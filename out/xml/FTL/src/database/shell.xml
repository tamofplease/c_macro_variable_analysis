<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/database/shell.c"><comment type="block">/* DO NOT EDIT!
** This file is automatically generated by the script in the canonical
** SQLite source tree at tool/mkshellc.tcl.  That script combines source
** code from various constituent source files of SQLite into this single
** "shell.c" file used to implement the SQLite command-line shell.
**
** Most of the code found below comes from the "src/shell.c.in" file in
** the canonical SQLite source tree.  That main file contains "INCLUDE"
** lines that specify other files in the canonical source tree that are
** inserted to getnerate this complete program source file.
**
** The code from multiple files is combined into this single "shell.c"
** source file to help make the command-line program easier to compile.
**
** To modify this program, get a copy of the canonical SQLite source tree,
** edit the src/shell.c.in" and/or some of the other files that are included
** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
*/</comment>
<comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "sqlite" command line
** utility for accessing SQLite databases.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_CRT_SECURE_NO_WARNINGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* This needs to come before any includes for MSVC compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_WARNINGS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>u16</name>;</typedef>

<comment type="block">/*
** Optionally #include a user-defined header, whereby compilation options
** may be set prior to where they take effect, but after platform setup. 
** If SQLITE_CUSTOM_INCLUDE=? is defined, its value names the #include
** file. Note that this macro has a like effect on sqlite3.c compilation.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_STRINGIFY_</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#f</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_STRINGIFY</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SHELL_STRINGIFY_(f)</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CUSTOM_INCLUDE</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> SHELL_STRINGIFY(SQLITE_CUSTOM_INCLUDE)</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Determine if we are dealing with WinRT, which provides only a subset of
** the full Win32 API.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_WINRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OS_WINRT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If SQLITE_SHELL_FIDDLE is defined then the shell is modified
** somewhat for use as a WASM module in a web browser. This flag
** should only be used when building the "fiddle" web application, as
** the browser-mode build has much different user input requirements
** and this build mode rewires the user input subsystem to account for
** that.
*/</comment>

<comment type="block">/*
** Warning pragmas copied from msvc.h in the core.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4054</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4055</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4100</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4127</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4130</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4152</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4189</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4206</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4210</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4232</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4244</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4305</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4306</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4702</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name> <name>:</name> <name>4706</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(_MSC_VER) */</comment>

<comment type="block">/*
** No support for loadable extensions in VxWorks.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>SQLITE_OMIT_LOAD_EXTENSION</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Enable large-file support for fopen() and friends on unix.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_LFS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_LARGE_FILE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>_FILE_OFFSET_BITS</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>_FILE_OFFSET_BITS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_LARGEFILE_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** emcc requires _POSIX_SOURCE (or one of several similar defines)
** to expose strdup().
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX_SOURCE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<typedef>typedef <type><name>sqlite3_int64</name></type> <name>i64</name>;</typedef>
<typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqlite3userauth.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<comment type="line">// print_FTL_version()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../log.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GETPID</name></cpp:macro> <cpp:value>getpid</cpp:value></cpp:define>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>DIRENT</name></cpp:macro> <cpp:value>dirent</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>S_ISLNK</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GETPID</name></cpp:macro> <cpp:value>(int)GetCurrentProcessId</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_READLINE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/history.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_EDITLINE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;editline/readline.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_EDITLINE</name> <operator>||</operator> <name>HAVE_READLINE</name></expr></cpp:if>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_add_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>add_history(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_read_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>read_history(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_write_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>write_history(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_stifle_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stifle_history(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_readline</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>readline(X)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_LINENOISE</name></expr></cpp:elif>

<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"linenoise.h"</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_add_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>linenoiseHistoryAdd(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_read_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>linenoiseHistoryLoad(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_write_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>linenoiseHistorySave(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_stifle_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>linenoiseHistorySetMaxLen(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_readline</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>linenoise(X)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_read_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_write_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>shell_stifle_history</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_USE_LOCAL_GETLINE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_POPEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>isatty</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_isatty(h)</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>access</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>access</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_access((f),(m))</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>unlink</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>unlink</name></cpp:macro> <cpp:value>_unlink</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>strdup</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>strdup</name></cpp:macro> <cpp:value>_strdup</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>popen</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>popen</name></cpp:macro> <cpp:value>_popen</cpp:value></cpp:define>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>pclose</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>pclose</name></cpp:macro> <cpp:value>_pclose</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
 <comment type="block">/* Make sure isatty() has a prototype. */</comment>
 <function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>isatty</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* popen and pclose are not C89 functions and so are
  ** sometimes omitted from the &lt;stdio.h&gt; header */</comment>
   <function_decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>popen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
   <function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>pclose</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_POPEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
 * thus we always assume that we have a console. That can be
 * overridden with the -batch command line option.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isatty</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ctype macros that work with signed characters */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsSpace</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>isspace((unsigned char)X)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsDigit</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>isdigit((unsigned char)X)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ToLower</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(char)tolower((unsigned char)X)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<comment type="block">/* string conversion routines only needed on Win32 */</comment>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_win32_unicode_to_utf8</name><parameter_list>(<parameter><decl><type><name>LPCWSTR</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_win32_mbcs_to_utf8_v2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_win32_utf8_to_mbcs_v2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>LPWSTR</name></type> <name>sqlite3_win32_utf8_to_unicode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* On Windows, we normally run with output mode of TEXT so that \n characters
** are automatically translated into \r\n.  However, this behavior needs
** to be disabled in some cases (ex: when generating CSV output and when
** rendering quoted strings that contain \n characters).  The following
** routines take care of that.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setBinaryMode</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isOutput</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>isOutput</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setTextMode</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isOutput</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>isOutput</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>setBinaryMode</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>setTextMode</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* True if the timer is enabled */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>enableTimer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* A version of strcmp() that works with NULL values */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cli_strcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>b</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cli_strncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>b</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current wall-clock time */</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>timeOfDay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name> <modifier>*</modifier></type><name>clockVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>t</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>clockVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>clockVfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>clockVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Never actually happens */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>clockVfs</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>clockVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>clockVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name><argument_list>(<argument><expr><name>clockVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>clockVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name>clockVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>r</name><operator>*</operator><literal type="number">86400000.0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__minux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<comment type="block">/* VxWorks does not support getrusage() as far as we can determine */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>rusage</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>ru_utime</name></decl>;</decl_stmt> <comment type="block">/* user CPU time used */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>ru_stime</name></decl>;</decl_stmt> <comment type="block">/* system CPU time used */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getrusage</name><parameter_list>(<parameter><type><name>A</name></type></parameter>,<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memset(B,0,sizeof(*B))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Saved resource information for the beginning of an operation */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type> <name>sBegin</name></decl>;</decl_stmt>  <comment type="block">/* CPU time at start */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>iBegin</name></decl>;</decl_stmt>  <comment type="block">/* Wall-clock time at start */</comment>

<comment type="block">/*
** Begin timing an operation
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beginTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>enableTimer</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iBegin</name> <operator>=</operator> <call><name>timeOfDay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the difference of two time_structs in seconds */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>timeDiff</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>pEnd</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>pStart</name><operator>-&gt;</operator><name>tv_usec</name></name><operator>)</operator><operator>*</operator><literal type="number">0.000001</literal> <operator>+</operator>
         <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>pEnd</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>pStart</name><operator>-&gt;</operator><name>tv_sec</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print the timing results.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>endTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>enableTimer</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iEnd</name> <init>= <expr><call><name>timeOfDay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>sEnd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Run Time: real %.3f user %f sys %f\n"</literal></expr></argument>,
       <argument><expr><operator>(</operator><name>iEnd</name> <operator>-</operator> <name>iBegin</name><operator>)</operator><operator>*</operator><literal type="number">0.001</literal></expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sBegin</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sEnd</name><operator>.</operator><name>ru_utime</name></name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sBegin</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sEnd</name><operator>.</operator><name>ru_stime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_TIMER</name></cpp:macro> <cpp:value>beginTimer()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_TIMER</name></cpp:macro> <cpp:value>endTimer()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_TIMER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<comment type="block">/* Saved resource information for the beginning of an operation */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>hProcess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILETIME</name></type> <name>ftKernelBegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILETIME</name></type> <name>ftUserBegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>ftWallBegin</name></decl>;</decl_stmt>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier><name>GETPROCTIMES</name>)<parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>LPFILETIME</name></type></decl></parameter>, <parameter><decl><type><name>LPFILETIME</name></type></decl></parameter>,
                                    <parameter><decl><type><name>LPFILETIME</name></type></decl></parameter>, <parameter><decl><type><name>LPFILETIME</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>GETPROCTIMES</name></type> <name>getProcessTimesAddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Check to see if we have timer support.  Return 1 if necessary
** support found (or found previously).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hasTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>getProcessTimesAddr</name></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <comment type="block">/* GetProcessTimes() isn't supported in WIN95 and some other Windows
    ** versions. See if the version we are running on has it, and if it
    ** does, save off a pointer to it and the current process handle.
    */</comment>
    <expr_stmt><expr><name>hProcess</name> <operator>=</operator> <call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>hProcess</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>HINSTANCE</name></type> <name>hinstLib</name> <init>= <expr><call><name>LoadLibrary</name><argument_list>(<argument><expr><call><name>TEXT</name><argument_list>(<argument><expr><literal type="string">"Kernel32.dll"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>NULL</name> <operator>!=</operator> <name>hinstLib</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>getProcessTimesAddr</name> <operator>=</operator>
            <operator>(</operator><name>GETPROCTIMES</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hinstLib</name></expr></argument>, <argument><expr><literal type="string">"GetProcessTimes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>NULL</name> <operator>!=</operator> <name>getProcessTimesAddr</name></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hinstLib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Begin timing an operation
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>beginTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>enableTimer</name> <operator>&amp;&amp;</operator> <name>getProcessTimesAddr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>ftCreation</name></decl>, <decl><type ref="prev"/><name>ftExit</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getProcessTimesAddr</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftCreation</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftExit</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>ftKernelBegin</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftUserBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ftWallBegin</name> <operator>=</operator> <call><name>timeOfDay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the difference of two FILETIME structs in seconds */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>timeDiff</name><parameter_list>(<parameter><decl><type><name>FILETIME</name> <modifier>*</modifier></type><name>pStart</name></decl></parameter>, <parameter><decl><type><name>FILETIME</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>i64Start</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>sqlite_int64</name> <operator>*</operator><operator>)</operator> <name>pStart</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>i64End</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>sqlite_int64</name> <operator>*</operator><operator>)</operator> <name>pEnd</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>i64End</name> <operator>-</operator> <name>i64Start</name><operator>)</operator> <operator>/</operator> <literal type="number">10000000.0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print the timing results.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>endTimer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>enableTimer</name> <operator>&amp;&amp;</operator> <name>getProcessTimesAddr</name></expr>)</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>ftCreation</name></decl>, <decl><type ref="prev"/><name>ftExit</name></decl>, <decl><type ref="prev"/><name>ftKernelEnd</name></decl>, <decl><type ref="prev"/><name>ftUserEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>ftWallEnd</name> <init>= <expr><call><name>timeOfDay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getProcessTimesAddr</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftCreation</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftExit</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftKernelEnd</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ftUserEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Run Time: real %.3f user %f sys %f\n"</literal></expr></argument>,
       <argument><expr><operator>(</operator><name>ftWallEnd</name> <operator>-</operator> <name>ftWallBegin</name><operator>)</operator><operator>*</operator><literal type="number">0.001</literal></expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ftUserBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ftUserEnd</name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ftKernelBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ftKernelEnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_TIMER</name></cpp:macro> <cpp:value>beginTimer()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_TIMER</name></cpp:macro> <cpp:value>endTimer()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_TIMER</name></cpp:macro> <cpp:value>hasTimer()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_TIMER</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_TIMER</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_TIMER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Used to prevent warnings about unused parameters
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>

<comment type="block">/*
** Number of elements in an array
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ArraySize</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(int)(sizeof(X)/sizeof(X[0]))</cpp:value></cpp:define>

<comment type="block">/*
** If the following flag is set, then command execution stops
** at an error if we are not interactive.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bail_on_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Threat stdin as an interactive input if the following variable
** is true.  Otherwise, assume stdin is connected to a file or pipe.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stdin_is_interactive</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** On Windows systems we have to know if standard output is a console
** in order to translate UTF-8 into MBCS.  The following variable is
** true if translation is required.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stdout_is_console</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The following is the open SQLite database.  We make a pointer
** to this database a static variable so that it can be accessed
** by the SIGINT handler to interrupt database processing.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3</name> <modifier>*</modifier></type><name>globalDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** True if an interrupt (Control-C) has been received.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>seenInterrupt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** This is the name of our program. It is set in main(), used
** in a number of other places, mostly for error messages.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>Argv0</name></decl>;</decl_stmt>

<comment type="block">/*
** Prompt strings. Initialized in main. Settable with
**   .prompt main continue
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>mainPrompt</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* First line prompt. default: "sqlite&gt; "*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>continuePrompt</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Continuation prompt. default: "   ...&gt; " */</comment>

<comment type="block">/*
** Render output like fprintf().  Except, if the output is going to the
** console and if this is running on a Windows machine, translate the
** output from UTF-8 into MBCS.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>utf8_printf</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>stdout_is_console</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>out</name><operator>==</operator><name>stdout</name> <operator>||</operator> <name>out</name><operator>==</operator><name>stderr</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z1</name> <init>= <expr><call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>sqlite3_win32_utf8_to_mbcs_v2</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>utf8_printf</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>utf8_printf</name></cpp:macro> <cpp:value>fprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Render output like fprintf().  This should not be used on anything that
** includes string formatting (e.g. "%s").
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>raw_printf</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>raw_printf</name></cpp:macro> <cpp:value>fprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Indicate out-of-memory and exit. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shell_out_of_memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check a pointer to see if it is NULL.  If it is NULL, exit with an
** out-of-memory error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shell_check_oom</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write I/O traces to the following stream.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>iotrace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine works like printf in that its first argument is a
** format string and subsequent arguments are values to be substituted
** in place of % fields.  The result of formatting this string
** is written to iotrace.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name> <name>SQLITE_CDECL</name></type> <name>iotracePrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iotrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>iotrace</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Output string zUtf to stream pOut as w characters.  If w is negative,
** then right-justify the text.  W is the width in UTF-8 characters, not
** in bytes.  This is different from the %*.*s specification in printf
** since with %*.*s the width is measured in bytes, not characters.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>utf8_width_print</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUtf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>aw</name> <init>= <expr><ternary><condition><expr><name>w</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>w</name></expr> </then><else>: <expr><name>w</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zUtf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zUtf</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zUtf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>zUtf</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>!=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><name>aw</name></expr> )</condition><block>{<block_content>
        <do>do<block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><operator>(</operator><name><name>zUtf</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition>;</do>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>aw</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zUtf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>w</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%*s%s"</literal></expr></argument>, <argument><expr><name>aw</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>zUtf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"%s%*s"</literal></expr></argument>, <argument><expr><name>zUtf</name></expr></argument>, <argument><expr><name>aw</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Determines if a string is a number of not.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>realnum</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>realnum</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>realnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>realnum</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>realnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><call><name>IsDigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>realnum</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>realnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>strlen30</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z2</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z2</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><literal type="number">0x3fffffff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>z2</name> <operator>-</operator> <name>z</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the length of a string in characters.  Multibyte UTF8 characters
** count as a single character.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>strlenChar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">0xc0</literal><operator>&amp;</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return open FILE * if zFile exists, can be opened for read
** and is an ordinary file or a character stream source.
** Otherwise return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type> <name>openChrSource</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
  <decl_stmt><decl><type><name><name>struct</name> <name>_stat</name></name></type> <name>x</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>STAT_CHR_SRC</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mode &amp; (_S_IFCHR|_S_IFIFO|_S_IFREG))!=0)</cpp:value></cpp:define>
  <comment type="block">/* On Windows, open first, then check the stream nature. This order
  ** is necessary because _stat() and sibs, when checking a named pipe,
  ** effectively break the pipe as its supplier sees it. */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rv</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>_fstat</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
      <operator>||</operator> <operator>!</operator><call><name>STAT_CHR_SRC</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>x</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>STAT_CHR_SRC</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(S_ISREG(mode)||S_ISFIFO(mode)||S_ISCHR(mode))</cpp:value></cpp:define>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>STAT_CHR_SRC</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STAT_CHR_SRC</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** If zLine is not NULL then it is a malloced buffer returned from
** a previous call to this routine that may be reused.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>local_getline</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name> <init>= <expr><ternary><condition><expr><name>zLine</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">100</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>+</operator><literal type="number">100</literal><operator>&gt;</operator><name>nLine</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nLine</name> <operator>=</operator> <name>nLine</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zLine</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>nLine</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zLine</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zLine</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* For interactive input on Windows systems, translate the
  ** multi-byte characterset characters into UTF-8. */</comment>
  <if_stmt><if>if<condition>( <expr><name>stdin_is_interactive</name> <operator>&amp;&amp;</operator> <name>in</name><operator>==</operator><name>stdin</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTrans</name> <init>= <expr><call><name>sqlite3_win32_mbcs_to_utf8_v2</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTrans</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>nTrans</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zTrans</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nTrans</name><operator>&gt;</operator><name>nLine</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zLine</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>zTrans</name></expr></argument>, <argument><expr><name>nTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(_WIN32) || defined(WIN32) */</comment>
  <return>return <expr><name>zLine</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Retrieve a single line of input text.
**
** If in==0 then read from standard input and prompt before each line.
** If isContinuation is true, then a continuation prompt is appropriate.
** If isContinuation is zero, then the main prompt should be used.
**
** If zPrior is not NULL then it is a buffer from a prior call to this
** routine that can be reused.
**
** The result is stored in space obtained from malloc() and must either
** be freed by the caller or else passed back into this routine via the
** zPrior argument for reuse.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>one_input_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrior</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isContinuation</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrompt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zResult</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zResult</name> <operator>=</operator> <call><name>local_getline</name><argument_list>(<argument><expr><name>zPrior</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zPrompt</name> <operator>=</operator> <ternary><condition><expr><name>isContinuation</name></expr> ?</condition><then> <expr><name>continuePrompt</name></expr> </then><else>: <expr><name>mainPrompt</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SHELL_USE_LOCAL_GETLINE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zPrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zResult</name> <operator>=</operator> <call><name>local_getline</name><argument_list>(<argument><expr><name>zPrior</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zResult</name> <operator>=</operator> <call><name>shell_readline</name><argument_list>(<argument><expr><name>zPrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zResult</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zResult</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>shell_add_history</name><argument_list>(<argument><expr><name>zResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>zResult</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_SHELL_FIDDLE */</comment>

<comment type="block">/*
** Return the value of a hexadecimal digit.  Return -1 if the input
** is not a hex digit.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hexDigitValue</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'f'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'F'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Interpret zArg as an integer value, possibly with suffixes.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>integerValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{ <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSuffix</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>iMult</name></decl>;</decl_stmt> }</block> <decl><name><name>aMult</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"KiB"</literal></expr>, <expr><literal type="number">1024</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"MiB"</literal></expr>, <expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"GiB"</literal></expr>, <expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"KB"</literal></expr>,  <expr><literal type="number">1000</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"MB"</literal></expr>,  <expr><literal type="number">1000000</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"GB"</literal></expr>,  <expr><literal type="number">1000000000</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"K"</literal></expr>,   <expr><literal type="number">1000</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"M"</literal></expr>,   <expr><literal type="number">1000000</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"G"</literal></expr>,   <expr><literal type="number">1000000000</literal></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>isNeg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zArg</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zArg</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zArg</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>hexDigitValue</name><argument_list>(<argument><expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zArg</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><call><name>IsDigit</name><argument_list>(<argument><expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zArg</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aMult</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>aMult</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zSuffix</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>*=</operator> <name><name>aMult</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iMult</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><ternary><condition><expr><name>isNeg</name></expr>?</condition><then> <expr><operator>-</operator><name>v</name></expr> </then><else>: <expr><name>v</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A variable length string to which one can append text.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ShellText</name></name></type> <name>ShellText</name>;</typedef>
<struct>struct <name>ShellText</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Initialize and destroy a ShellText object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>initText</name><parameter_list>(<parameter><decl><type><name>ShellText</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeText</name><parameter_list>(<parameter><decl><type><name>ShellText</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* zIn is either a pointer to a NULL-terminated string in memory obtained
** from malloc(), or a NULL pointer. The string pointed to by zAppend is
** added to zIn, and the result returned in memory obtained from malloc().
** zIn, if it was not NULL, is freed.
**
** If the third argument, quote, is not '\0', then it is used as a
** quote character for zAppend.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendText</name><parameter_list>(<parameter><decl><type><name>ShellText</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAppend</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>quote</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nAppend</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> <operator>=</operator> <name>nAppend</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>quote</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nAppend</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>len</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>quote</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCsr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nAppend</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <name>quote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>zCsr</name><operator>++</operator> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>zCsr</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>zCsr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>, <argument><expr><name>nAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <name>nAppend</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to determine if identifier zName needs to be quoted, either
** because it contains non-alphanumeric characters, or because it is an
** SQLite keyword.  Be conservative in this estimate:  When in doubt assume
** that quoting is required.
**
** Return '"' if quoting is required.  Return 0 if no quoting is required.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name></type> <name>quoteChar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'"'</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'_'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'"'</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><ternary><condition><expr><call><name>sqlite3_keyword_check</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'"'</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Construct a fake object name and column list to describe the structure
** of the view, virtual table, or table valued function zSchema.zName.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shellFakeSchema</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,            <comment type="block">/* The database connection containing the vtab */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl></parameter>,    <comment type="block">/* Schema of the database holding the vtab */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>       <comment type="block">/* The name of the virtual table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShellText</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cQuote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDiv</name> <init>= <expr><literal type="string">"("</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA \"%w\".table_info=%Q;"</literal></expr></argument>,
                         <argument><expr><ternary><condition><expr><name>zSchema</name></expr> ?</condition><then> <expr><name>zSchema</name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSchema</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cQuote</name> <operator>=</operator> <call><name>quoteChar</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>cQuote</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>,<argument><expr><literal type="string">"temp"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cQuote</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>cQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>cQuote</name> <operator>=</operator> <call><name>quoteChar</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>cQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nRow</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zDiv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDiv</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zCol</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cQuote</name> <operator>=</operator> <call><name>quoteChar</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>cQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRow</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>s</name><operator>.</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:  shell_module_schema(X)
**
** Return a fake schema for the table-valued function or eponymous virtual
** table X.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellModuleSchema</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFake</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFake</name> <operator>=</operator> <ternary><condition><expr><name>zName</name></expr> ?</condition><then> <expr><call><name>shellFakeSchema</name><argument_list>(<argument><expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFake</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"/* %s */"</literal></expr></argument>, <argument><expr><name>zFake</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zFake</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:  shell_add_schema(S,X)
**
** Add the schema name X to the CREATE statement in S and return the result.
** Examples:
**
**    CREATE TABLE t1(x)   -&gt;   CREATE TABLE xyz.t1(x);
**
** Also works on
**
**    CREATE INDEX
**    CREATE UNIQUE INDEX
**    CREATE VIEW
**    CREATE TRIGGER
**    CREATE VIRTUAL TABLE
**
** This UDF is used by the .schema command to insert the schema name of
** attached databases into the middle of the sqlite_schema.sql field.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellAddSchemaName</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>aPrefix</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="string">"TABLE"</literal></expr>,
     <expr><literal type="string">"INDEX"</literal></expr>,
     <expr><literal type="string">"UNIQUE INDEX"</literal></expr>,
     <expr><literal type="string">"VIEW"</literal></expr>,
     <expr><literal type="string">"TRIGGER"</literal></expr>,
     <expr><literal type="string">"VIRTUAL TABLE"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><literal type="string">"CREATE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aPrefix</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>aPrefix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zIn</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><name><name>aPrefix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFake</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zSchema</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>cQuote</name> <init>= <expr><call><name>quoteChar</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>cQuote</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>,<argument><expr><literal type="string">"temp"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s \"%w\".%s"</literal></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zIn</name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s %s.%s"</literal></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">7</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zIn</name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zName</name>
         <operator>&amp;&amp;</operator> <name><name>aPrefix</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'V'</literal>
         <operator>&amp;&amp;</operator> <operator>(</operator><name>zFake</name> <operator>=</operator> <call><name>shellFakeSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s\n/* %s */"</literal></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zFake</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z\n/* %s */"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zFake</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zFake</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The source code for several run-time loadable extensions is inserted
** below by the ../tool/mkshellc.tcl script.  Before processing that included
** code, we need to override some macros to make the included program code
** work here in the middle of this regular program.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_EXTENSION_INIT1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_EXTENSION_INIT2</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(X)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/************************* Begin test_windirent.h ******************/</comment>
<comment type="block">/*
** 2015 November 30
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains declarations for most of the opendir() family of
** POSIX functions on Win32 using the MSVCRT.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WINDIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WINDIRENT_H</name></cpp:macro></cpp:define>

<comment type="block">/*
** We need several data types from the Windows SDK header.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32_LEAN_AND_MEAN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>

<comment type="block">/*
** We need several support functions from the SQLite core.
*/</comment>

<comment type="block">/* #include "sqlite3.h" */</comment>

<comment type="block">/*
** We need several things from the ANSI and MSVCRT headers.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** We may need several defines that should have been in "sys/stat.h".
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_ISREG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISREG</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((mode) &amp; S_IFMT) == S_IFREG)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_ISDIR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((mode) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_ISLNK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We may need to provide the "mode_t" type.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MODE_T_DEFINED</name></cpp:ifndef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_T_DEFINED</name></cpp:macro></cpp:define>
  <typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>mode_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We may need to provide the "ino_t" type.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INO_T_DEFINED</name></cpp:ifndef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INO_T_DEFINED</name></cpp:macro></cpp:define>
  <typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>ino_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We need to define "NAME_MAX" if it was not present in "limits.h".
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NAME_MAX</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>FILENAME_MAX</name></cpp:ifdef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_MAX</name></cpp:macro> <cpp:value>(FILENAME_MAX)</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_MAX</name></cpp:macro> <cpp:value>(260)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We need to define "NULL_INTPTR_T" and "BAD_INTPTR_T".
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NULL_INTPTR_T</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NULL_INTPTR_T</name></cpp:macro> <cpp:value>((intptr_t)(0))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BAD_INTPTR_T</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>BAD_INTPTR_T</name></cpp:macro> <cpp:value>((intptr_t)(-1))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** We need to provide the necessary structures and related types.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DIRENT_DEFINED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRENT_DEFINED</name></cpp:macro></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>DIRENT</name></name></type> <name>DIRENT</name>;</typedef>
<typedef>typedef <type><name>DIRENT</name> <modifier>*</modifier></type><name>LPDIRENT</name>;</typedef>
<struct>struct <name>DIRENT</name> <block>{
  <decl_stmt><decl><type><name>ino_t</name></type> <name>d_ino</name></decl>;</decl_stmt>               <comment type="block">/* Sequence number, do not use. */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>d_attributes</name></decl>;</decl_stmt>     <comment type="block">/* Win32 file attributes. */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>d_name</name><index>[<expr><name>NAME_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Name within the directory. */</comment>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DIR_DEFINED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIR_DEFINED</name></cpp:macro></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>DIR</name></name></type> <name>DIR</name>;</typedef>
<typedef>typedef <type><name>DIR</name> <modifier>*</modifier></type><name>LPDIR</name>;</typedef>
<struct>struct <name>DIR</name> <block>{
  <decl_stmt><decl><type><name>intptr_t</name></type> <name>d_handle</name></decl>;</decl_stmt> <comment type="block">/* Value returned by "_findfirst". */</comment>
  <decl_stmt><decl><type><name>DIRENT</name></type> <name>d_first</name></decl>;</decl_stmt>    <comment type="block">/* DIRENT constructed based on "_findfirst". */</comment>
  <decl_stmt><decl><type><name>DIRENT</name></type> <name>d_next</name></decl>;</decl_stmt>     <comment type="block">/* DIRENT constructed based on "_findnext". */</comment>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Provide a macro, for use by the implementation, to determine if a
** particular directory entry should be skipped over when searching for
** the next directory entry that should be returned by the readdir() or
** readdir_r() functions.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>is_filtered</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>is_filtered</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((a).attrib)&amp;_A_HIDDEN) || (((a).attrib)&amp;_A_SYSTEM))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Provide the function prototype for the POSIX compatiable getenv()
** function.  This function is not thread-safe.
*/</comment>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>windirent_getenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Finally, we can provide the function prototypes for the opendir(),
** readdir(), readdir_r(), and closedir() POSIX functions.
*/</comment>

<function_decl><type><specifier>extern</specifier> <name>LPDIR</name></type> <name>opendir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>LPDIRENT</name></type> <name>readdir</name><parameter_list>(<parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>INT</name></type> <name>readdir_r</name><parameter_list>(<parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>, <parameter><decl><type><name>LPDIRENT</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>LPDIRENT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>INT</name></type> <name>closedir</name><parameter_list>(<parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(WIN32) &amp;&amp; defined(_MSC_VER) */</comment>

<comment type="block" format="doxygen">/************************* End test_windirent.h ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin test_windirent.c ******************/</comment>
<comment type="block">/*
** 2015 November 30
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement most of the opendir() family of
** POSIX functions on Win32 using the MSVCRT.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* #include "test_windirent.h" */</comment>

<comment type="block">/*
** Implementation of the POSIX getenv() function using the Win32 API.
** This function is not thread-safe.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>windirent_getenv</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>value</name><index>[<expr><literal type="number">32768</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Maximum length, per MSDN */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt> <comment type="block">/* Size in chars */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwRet</name></decl>;</decl_stmt> <comment type="block">/* Value returned by GetEnvironmentVariableA() */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dwRet</name> <operator>=</operator> <call><name>GetEnvironmentVariableA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>dwSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>dwRet</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>dwRet</name><operator>&gt;</operator><name>dwSize</name></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** The function call to GetEnvironmentVariableA() failed -OR-
    ** the buffer is not large enough.  Either way, return NULL.
    */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/*
    ** The function call to GetEnvironmentVariableA() succeeded
    ** -AND- the buffer contains the entire value.
    */</comment>
    <return>return <expr><name>value</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the POSIX opendir() function using the MSVCRT.
*/</comment>
<function><type><name>LPDIR</name></type> <name>opendir</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>_finddata_t</name></name></type> <name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPDIR</name></type> <name>dirp</name> <init>= <expr><operator>(</operator><name>LPDIR</name><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DIR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIZE_T</name></type> <name>namesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>dirp</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DIR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TODO: Remove this if Unix-style root paths are not used. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>windirent_getenv</name><argument_list>(<argument><expr><literal type="string">"SystemDrive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_finddata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_snprintf</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>namesize</name></expr></argument>, <argument><expr><literal type="string">"%s\\*"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name> <operator>=</operator> <call><name>_findfirst</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name><operator>==</operator><name>BAD_INTPTR_T</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* TODO: Remove this block to allow hidden and/or system files. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>is_filtered</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<label><name>next</name>:</label>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_finddata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>_findnext</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* TODO: Remove this block to allow hidden and/or system files. */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>is_filtered</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_attributes</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>attrib</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAME_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_name</name><index>[<expr><name>NAME_MAX</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <return>return <expr><name>dirp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the POSIX readdir() function using the MSVCRT.
*/</comment>
<function><type><name>LPDIRENT</name></type> <name>readdir</name><parameter_list>(
  <parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>_finddata_t</name></name></type> <name>data</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>dirp</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_ino</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_ino</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_ino</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><operator>&amp;</operator><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<label><name>next</name>:</label>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_finddata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>_findnext</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* TODO: Remove this block to allow hidden and/or system files. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>is_filtered</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_ino</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_attributes</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>attrib</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAME_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_name</name><index>[<expr><name>NAME_MAX</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <return>return <expr><operator>&amp;</operator><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the POSIX readdir_r() function using the MSVCRT.
*/</comment>
<function><type><name>INT</name></type> <name>readdir_r</name><parameter_list>(
  <parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>,
  <parameter><decl><type><name>LPDIRENT</name></type> <name>entry</name></decl></parameter>,
  <parameter><decl><type><name>LPDIRENT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>_finddata_t</name></name></type> <name>data</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>dirp</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EBADF</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_ino</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_ino</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_next</name><operator>.</operator><name>d_ino</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_ino</name></name> <operator>=</operator> <name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_ino</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_attributes</name></name> <operator>=</operator> <name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_attributes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_first</name><operator>.</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NAME_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>NAME_MAX</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<label><name>next</name>:</label>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_finddata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>_findnext</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>ENOENT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* TODO: Remove this block to allow hidden and/or system files. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>is_filtered</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_ino</name></name> <operator>=</operator> <operator>(</operator><name>ino_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* not available */</comment>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_attributes</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>attrib</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NAME_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>NAME_MAX</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the POSIX closedir() function using the MSVCRT.
*/</comment>
<function><type><name>INT</name></type> <name>closedir</name><parameter_list>(
  <parameter><decl><type><name>LPDIR</name></type> <name>dirp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>INT</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>dirp</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name><operator>!=</operator><name>NULL_INTPTR_T</name> <operator>&amp;&amp;</operator> <name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name><operator>!=</operator><name>BAD_INTPTR_T</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_findclose</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>d_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(WIN32) &amp;&amp; defined(_MSC_VER) */</comment>

<comment type="block" format="doxygen">/************************* End test_windirent.c ********************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>DIRENT</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/memtrace.c ******************/</comment>
<comment type="block">/*
** 2019-01-21
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements an extension that uses the SQLITE_CONFIG_MALLOC
** mechanism to add a tracing layer on top of SQLite.  If this extension
** is registered prior to sqlite3_initialize(), it will cause all memory
** allocation activities to be logged on standard output, or to some other
** FILE specified by the initializer.
**
** This file needs to be compiled into the application that uses it.
**
** This extension is used to implement the --memtrace option of the
** command-line shell.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<comment type="block">/* The original memory allocation routines */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_mem_methods</name></type> <name>memtraceBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>memtraceOut</name></decl>;</decl_stmt>

<comment type="block">/* Methods that trace memory allocations */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>memtraceMalloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>memtraceOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>memtraceOut</name></expr></argument>, <argument><expr><literal type="string">"MEMTRACE: allocate %d bytes\n"</literal></expr></argument>, 
            <argument><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xRoundup</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>memtraceBase</name><operator>.</operator><name>xMalloc</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memtraceFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>memtraceOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>memtraceOut</name></expr></argument>, <argument><expr><literal type="string">"MEMTRACE: free %d bytes\n"</literal></expr></argument>, <argument><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xSize</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xFree</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>memtraceRealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>memtraceMalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memtraceFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>memtraceOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>memtraceOut</name></expr></argument>, <argument><expr><literal type="string">"MEMTRACE: resize %d -&gt; %d bytes\n"</literal></expr></argument>,
            <argument><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xSize</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xRoundup</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>memtraceBase</name><operator>.</operator><name>xRealloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memtraceSize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>memtraceBase</name><operator>.</operator><name>xSize</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memtraceRoundup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>memtraceBase</name><operator>.</operator><name>xRoundup</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memtraceInit</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name><name>memtraceBase</name><operator>.</operator><name>xInit</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memtraceShutdown</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name><name>memtraceBase</name><operator>.</operator><name>xShutdown</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The substitute memory allocator */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_mem_methods</name></type> <name>ersaztMethods</name> <init>= <expr><block>{
  <expr><name>memtraceMalloc</name></expr>,
  <expr><name>memtraceFree</name></expr>,
  <expr><name>memtraceRealloc</name></expr>,
  <expr><name>memtraceSize</name></expr>,
  <expr><name>memtraceRoundup</name></expr>,
  <expr><name>memtraceInit</name></expr>,
  <expr><name>memtraceShutdown</name></expr>,
  <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Begin tracing memory allocations to out. */</comment>
<function><type><name>int</name></type> <name>sqlite3MemTraceActivate</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>memtraceBase</name><operator>.</operator><name>xMalloc</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_GETMALLOC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memtraceBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MALLOC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ersaztMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>memtraceOut</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Deactivate memory tracing */</comment>
<function><type><name>int</name></type> <name>sqlite3MemTraceDeactivate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>memtraceBase</name><operator>.</operator><name>xMalloc</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MALLOC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memtraceBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memtraceBase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>memtraceBase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>memtraceOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/memtrace.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/shathree.c ******************/</comment>
<comment type="block">/*
** 2017-03-08
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements functions that compute SHA3 hashes.
** Two SQL functions are implemented:
**
**     sha3(X,SIZE)
**     sha3_query(Y,SIZE)
**
** The sha3(X) function computes the SHA3 hash of the input X, or NULL if
** X is NULL.
**
** The sha3_query(Y) function evaluates all queries in the SQL statements of Y
** and returns a hash of their results.
**
** The SIZE argument is optional.  If omitted, the SHA3-256 hash algorithm
** is used.  If SIZE is included it must be one of the integers 224, 256,
** 384, or 512, to determine SHA3 hash variant that is computed.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<comment type="block">/* typedef sqlite3_uint64 u64; */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_AMALGAMATION */</comment>

<comment type="block" format="doxygen">/******************************************************************************
** The Hash Engine
*/</comment>
<comment type="block">/*
** Macros to determine whether the machine is big or little endian,
** and whether or not that determination is run-time or compile-time.
**
** For best performance, an attempt is made to guess at the byte-order
** using C-preprocessor macros.  If that is unsuccessful, or if
** -DSHA3_BYTEORDER=0 is set, then byte-order is determined
** at run-time.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SHA3_BYTEORDER</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>i386</name></expr></argument>)</argument_list></call>     <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call>   <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> <operator>||</operator>    \
     <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call>  <operator>||</operator>    \
     <call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_ARM</name></expr></argument>)</argument_list></call>     <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86</name></expr></argument>)</argument_list></call>   <operator>||</operator>    \
     <call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SHA3_BYTEORDER</name></cpp:macro>    <cpp:value>1234</cpp:value></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sparc</name></expr></argument>)</argument_list></call>    <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SHA3_BYTEORDER</name></cpp:macro>    <cpp:value>4321</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SHA3_BYTEORDER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** State structure for a SHA3 hash in progress
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SHA3Context</name></name></type> <name>SHA3Context</name>;</typedef>
<struct>struct <name>SHA3Context</name> <block>{
  <union>union <block>{
    <decl_stmt><decl><type><name>u64</name></type> <name><name>s</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Keccak state. 5x5 lines of 64 bits each */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[<expr><literal type="number">1600</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* ... or 1600 bytes */</comment>
  }</block> <decl><name>u</name></decl>;</union>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nRate</name></decl>;</decl_stmt>        <comment type="block">/* Bytes of input accepted per Keccak iteration */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nLoaded</name></decl>;</decl_stmt>      <comment type="block">/* Input bytes loaded into u.x[] so far this cycle */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>ixMask</name></decl>;</decl_stmt>       <comment type="block">/* Insert next input into u.x[nLoaded^ixMask]. */</comment>
}</block>;</struct>

<comment type="block">/*
** A single step of the Keccak mixing function for a 1600-bit state
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>KeccakF1600Step</name><parameter_list>(<parameter><decl><type><name>SHA3Context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>b0</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b3</name></decl>, <decl><type ref="prev"/><name>b4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>c0</name></decl>, <decl><type ref="prev"/><name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>c3</name></decl>, <decl><type ref="prev"/><name>c4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u64</name></type> <name>d0</name></decl>, <decl><type ref="prev"/><name>d1</name></decl>, <decl><type ref="prev"/><name>d2</name></decl>, <decl><type ref="prev"/><name>d3</name></decl>, <decl><type ref="prev"/><name>d4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u64</name></type> <name><name>RC</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0x0000000000000001ULL</literal></expr>,  <expr><literal type="number">0x0000000000008082ULL</literal></expr>,
    <expr><literal type="number">0x800000000000808aULL</literal></expr>,  <expr><literal type="number">0x8000000080008000ULL</literal></expr>,
    <expr><literal type="number">0x000000000000808bULL</literal></expr>,  <expr><literal type="number">0x0000000080000001ULL</literal></expr>,
    <expr><literal type="number">0x8000000080008081ULL</literal></expr>,  <expr><literal type="number">0x8000000000008009ULL</literal></expr>,
    <expr><literal type="number">0x000000000000008aULL</literal></expr>,  <expr><literal type="number">0x0000000000000088ULL</literal></expr>,
    <expr><literal type="number">0x0000000080008009ULL</literal></expr>,  <expr><literal type="number">0x000000008000000aULL</literal></expr>,
    <expr><literal type="number">0x000000008000808bULL</literal></expr>,  <expr><literal type="number">0x800000000000008bULL</literal></expr>,
    <expr><literal type="number">0x8000000000008089ULL</literal></expr>,  <expr><literal type="number">0x8000000000008003ULL</literal></expr>,
    <expr><literal type="number">0x8000000000008002ULL</literal></expr>,  <expr><literal type="number">0x8000000000000080ULL</literal></expr>,
    <expr><literal type="number">0x000000000000800aULL</literal></expr>,  <expr><literal type="number">0x800000008000000aULL</literal></expr>,
    <expr><literal type="number">0x8000000080008081ULL</literal></expr>,  <expr><literal type="number">0x8000000000008080ULL</literal></expr>,
    <expr><literal type="number">0x0000000080000001ULL</literal></expr>,  <expr><literal type="number">0x8000000080008008ULL</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a00</name></cpp:macro> <cpp:value>(p-&gt;u.s[0])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a01</name></cpp:macro> <cpp:value>(p-&gt;u.s[1])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a02</name></cpp:macro> <cpp:value>(p-&gt;u.s[2])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a03</name></cpp:macro> <cpp:value>(p-&gt;u.s[3])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a04</name></cpp:macro> <cpp:value>(p-&gt;u.s[4])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a10</name></cpp:macro> <cpp:value>(p-&gt;u.s[5])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a11</name></cpp:macro> <cpp:value>(p-&gt;u.s[6])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a12</name></cpp:macro> <cpp:value>(p-&gt;u.s[7])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a13</name></cpp:macro> <cpp:value>(p-&gt;u.s[8])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a14</name></cpp:macro> <cpp:value>(p-&gt;u.s[9])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a20</name></cpp:macro> <cpp:value>(p-&gt;u.s[10])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a21</name></cpp:macro> <cpp:value>(p-&gt;u.s[11])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a22</name></cpp:macro> <cpp:value>(p-&gt;u.s[12])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a23</name></cpp:macro> <cpp:value>(p-&gt;u.s[13])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a24</name></cpp:macro> <cpp:value>(p-&gt;u.s[14])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a30</name></cpp:macro> <cpp:value>(p-&gt;u.s[15])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a31</name></cpp:macro> <cpp:value>(p-&gt;u.s[16])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a32</name></cpp:macro> <cpp:value>(p-&gt;u.s[17])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a33</name></cpp:macro> <cpp:value>(p-&gt;u.s[18])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a34</name></cpp:macro> <cpp:value>(p-&gt;u.s[19])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a40</name></cpp:macro> <cpp:value>(p-&gt;u.s[20])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a41</name></cpp:macro> <cpp:value>(p-&gt;u.s[21])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a42</name></cpp:macro> <cpp:value>(p-&gt;u.s[22])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a43</name></cpp:macro> <cpp:value>(p-&gt;u.s[23])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>a44</name></cpp:macro> <cpp:value>(p-&gt;u.s[24])</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ROL64</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a&lt;&lt;x)|(a&gt;&gt;(64-x)))</cpp:value></cpp:define>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">24</literal></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">4</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c0</name> <operator>=</operator> <name>a00</name><operator>^</operator><name>a10</name><operator>^</operator><name>a20</name><operator>^</operator><name>a30</name><operator>^</operator><name>a40</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name>a01</name><operator>^</operator><name>a11</name><operator>^</operator><name>a21</name><operator>^</operator><name>a31</name><operator>^</operator><name>a41</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> <operator>=</operator> <name>a02</name><operator>^</operator><name>a12</name><operator>^</operator><name>a22</name><operator>^</operator><name>a32</name><operator>^</operator><name>a42</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c3</name> <operator>=</operator> <name>a03</name><operator>^</operator><name>a13</name><operator>^</operator><name>a23</name><operator>^</operator><name>a33</name><operator>^</operator><name>a43</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c4</name> <operator>=</operator> <name>a04</name><operator>^</operator><name>a14</name><operator>^</operator><name>a24</name><operator>^</operator><name>a34</name><operator>^</operator><name>a44</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d0</name> <operator>=</operator> <name>c4</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>c0</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <name>c1</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d3</name> <operator>=</operator> <name>c2</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c4</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d4</name> <operator>=</operator> <name>c3</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>b0</name> <operator>=</operator> <operator>(</operator><name>a00</name><operator>^</operator><name>d0</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a11</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a22</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">43</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a33</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a44</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>^=</operator> <name><name>RC</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a11</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a22</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a33</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a44</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a20</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a31</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a42</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a03</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a14</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a20</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a31</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a42</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a03</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a14</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a40</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a01</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a12</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a23</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a34</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a40</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a01</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a12</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a23</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a34</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a10</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a21</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a32</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a43</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a04</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a10</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a21</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a32</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a43</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a04</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a30</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a41</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a02</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">62</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a13</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">55</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a24</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a30</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a41</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a02</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a13</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a24</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>c0</name> <operator>=</operator> <name>a00</name><operator>^</operator><name>a20</name><operator>^</operator><name>a40</name><operator>^</operator><name>a10</name><operator>^</operator><name>a30</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name>a11</name><operator>^</operator><name>a31</name><operator>^</operator><name>a01</name><operator>^</operator><name>a21</name><operator>^</operator><name>a41</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> <operator>=</operator> <name>a22</name><operator>^</operator><name>a42</name><operator>^</operator><name>a12</name><operator>^</operator><name>a32</name><operator>^</operator><name>a02</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c3</name> <operator>=</operator> <name>a33</name><operator>^</operator><name>a03</name><operator>^</operator><name>a23</name><operator>^</operator><name>a43</name><operator>^</operator><name>a13</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c4</name> <operator>=</operator> <name>a44</name><operator>^</operator><name>a14</name><operator>^</operator><name>a34</name><operator>^</operator><name>a04</name><operator>^</operator><name>a24</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d0</name> <operator>=</operator> <name>c4</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>c0</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <name>c1</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d3</name> <operator>=</operator> <name>c2</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c4</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d4</name> <operator>=</operator> <name>c3</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>b0</name> <operator>=</operator> <operator>(</operator><name>a00</name><operator>^</operator><name>d0</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a31</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a12</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">43</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a43</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a24</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>^=</operator> <name><name>RC</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a31</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a12</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a43</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a24</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a40</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a21</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a02</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a33</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a14</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a40</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a21</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a02</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a33</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a14</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a30</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a11</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a42</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a23</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a04</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a30</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a11</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a42</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a23</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a04</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a20</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a01</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a32</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a13</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a44</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a20</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a01</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a32</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a13</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a44</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a10</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a41</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a22</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">62</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a03</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">55</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a34</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a10</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a41</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a22</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a03</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a34</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>c0</name> <operator>=</operator> <name>a00</name><operator>^</operator><name>a40</name><operator>^</operator><name>a30</name><operator>^</operator><name>a20</name><operator>^</operator><name>a10</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name>a31</name><operator>^</operator><name>a21</name><operator>^</operator><name>a11</name><operator>^</operator><name>a01</name><operator>^</operator><name>a41</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> <operator>=</operator> <name>a12</name><operator>^</operator><name>a02</name><operator>^</operator><name>a42</name><operator>^</operator><name>a32</name><operator>^</operator><name>a22</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c3</name> <operator>=</operator> <name>a43</name><operator>^</operator><name>a33</name><operator>^</operator><name>a23</name><operator>^</operator><name>a13</name><operator>^</operator><name>a03</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c4</name> <operator>=</operator> <name>a24</name><operator>^</operator><name>a14</name><operator>^</operator><name>a04</name><operator>^</operator><name>a44</name><operator>^</operator><name>a34</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d0</name> <operator>=</operator> <name>c4</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>c0</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <name>c1</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d3</name> <operator>=</operator> <name>c2</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c4</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d4</name> <operator>=</operator> <name>c3</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>b0</name> <operator>=</operator> <operator>(</operator><name>a00</name><operator>^</operator><name>d0</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a21</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a42</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">43</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a13</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a34</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>^=</operator> <name><name>RC</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a21</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a42</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a13</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a34</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a30</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a01</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a22</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a43</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a14</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a30</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a01</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a22</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a43</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a14</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a10</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a31</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a02</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a23</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a44</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a10</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a31</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a02</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a23</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a44</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a40</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a11</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a32</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a03</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a24</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a40</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a11</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a32</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a03</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a24</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a20</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a41</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a12</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">62</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a33</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">55</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a04</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a20</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a41</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a12</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a33</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a04</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>c0</name> <operator>=</operator> <name>a00</name><operator>^</operator><name>a30</name><operator>^</operator><name>a10</name><operator>^</operator><name>a40</name><operator>^</operator><name>a20</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name>a21</name><operator>^</operator><name>a01</name><operator>^</operator><name>a31</name><operator>^</operator><name>a11</name><operator>^</operator><name>a41</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> <operator>=</operator> <name>a42</name><operator>^</operator><name>a22</name><operator>^</operator><name>a02</name><operator>^</operator><name>a32</name><operator>^</operator><name>a12</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c3</name> <operator>=</operator> <name>a13</name><operator>^</operator><name>a43</name><operator>^</operator><name>a23</name><operator>^</operator><name>a03</name><operator>^</operator><name>a33</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c4</name> <operator>=</operator> <name>a34</name><operator>^</operator><name>a14</name><operator>^</operator><name>a44</name><operator>^</operator><name>a24</name><operator>^</operator><name>a04</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d0</name> <operator>=</operator> <name>c4</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>c0</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> <operator>=</operator> <name>c1</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d3</name> <operator>=</operator> <name>c2</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c4</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d4</name> <operator>=</operator> <name>c3</name><operator>^</operator><call><name>ROL64</name><argument_list>(<argument><expr><name>c0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>b0</name> <operator>=</operator> <operator>(</operator><name>a00</name><operator>^</operator><name>d0</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a01</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a02</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">43</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a03</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a04</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a00</name> <operator>^=</operator> <name><name>RC</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a01</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a02</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a03</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a04</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a10</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a11</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a12</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a13</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a14</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a10</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a11</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a12</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a13</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a14</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a20</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a21</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a22</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a23</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a24</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a20</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a21</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a22</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a23</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a24</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a30</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a31</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a32</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a33</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a34</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a30</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a31</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a32</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a33</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a34</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>b3</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a40</name><operator>^</operator><name>d0</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b4</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a41</name><operator>^</operator><name>d1</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a42</name><operator>^</operator><name>d2</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">62</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a43</name><operator>^</operator><name>d3</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">55</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>ROL64</name><argument_list>(<argument><expr><operator>(</operator><name>a44</name><operator>^</operator><name>d4</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a40</name> <operator>=</operator>   <name>b0</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b1</name><operator>)</operator><operator>&amp;</operator>  <name>b2</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a41</name> <operator>=</operator>   <name>b1</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b2</name><operator>)</operator><operator>&amp;</operator>  <name>b3</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a42</name> <operator>=</operator>   <name>b2</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b3</name><operator>)</operator><operator>&amp;</operator>  <name>b4</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a43</name> <operator>=</operator>   <name>b3</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b4</name><operator>)</operator><operator>&amp;</operator>  <name>b0</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a44</name> <operator>=</operator>   <name>b4</name> <operator>^</operator><operator>(</operator><operator>(</operator><operator>~</operator><name>b0</name><operator>)</operator><operator>&amp;</operator>  <name>b1</name> <operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a new hash.  iSize determines the size of the hash
** in bits and should be one of 224, 256, 384, or 512.  Or iSize
** can be zero to use the default hash size of 256 bits.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SHA3Init</name><parameter_list>(<parameter><decl><type><name>SHA3Context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iSize</name><operator>&gt;=</operator><literal type="number">128</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>&lt;=</operator><literal type="number">512</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1600</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name>iSize</name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">31</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1600</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">256</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SHA3_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal></expr></cpp:if>
  <comment type="block">/* Known to be little-endian at compile-time. No-op */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SHA3_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ixMask</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>  <comment type="block">/* Big-endian */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">1</literal><operator>==</operator><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>one</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Little endian.  No byte swapping. */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ixMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Big endian.  Byte swap. */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ixMask</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Make consecutive calls to the SHA3Update function to add new content
** to the hash
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>SHA3Update</name><parameter_list>(
  <parameter><decl><type><name>SHA3Context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aData</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SHA3_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>aData</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>+</operator><literal type="number">7</literal><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">8</literal></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>^=</operator> <operator>*</operator><operator>(</operator><name>u64</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>KeccakF1600Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SHA3_BYTEORDER</name><operator>==</operator><literal type="number">1234</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name></expr>]</index></name> <operator>^=</operator> <name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SHA3_BYTEORDER</name><operator>==</operator><literal type="number">4321</literal></expr></cpp:elif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>^</operator><literal type="number">0x07</literal></expr>]</index></name> <operator>^=</operator> <name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>^</operator><name><name>p</name><operator>-&gt;</operator><name>ixMask</name></name></expr>]</index></name> <operator>^=</operator> <name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>KeccakF1600Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** After all content has been added, invoke SHA3Final() to compute
** the final hash.  The function returns a pointer to the binary
** hash value.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>SHA3Final</name><parameter_list>(<parameter><decl><type><name>SHA3Context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c1</name> <init>= <expr><literal type="number">0x86</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c2</name> <init>= <expr><literal type="number">0x06</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c3</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLoaded</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nRate</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name>i</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name>i</name><operator>^</operator><name><name>p</name><operator>-&gt;</operator><name>ixMask</name></name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>x</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nRate</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* End of the hashing logic
*****************************************************************************/</comment>

<comment type="block">/*
** Implementation of the sha3(X,SIZE) function.
**
** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default
** size is 256.  If X is a BLOB, it is hashed as is.  
** For all other non-NULL types of input, X is converted into a UTF-8 string
** and the string is hashed without the trailing 0x00 terminator.  The hash
** of a NULL value is NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sha3Func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SHA3Context</name></type> <name>cx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSize</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSize</name><operator>!=</operator><literal type="number">224</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">384</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">512</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"SHA3 size should be one of: 224 256 "</literal>
                                    <literal type="string">"384 512"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>SHA3Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>SHA3Final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iSize</name><operator>/</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compute a string using sqlite3_vsnprintf() with a maximum length
** of 50 bytes and add it to the hash.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hash_step_vformat</name><parameter_list>(
  <parameter><decl><type><name>SHA3Context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Add content to this context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>,<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sha3_query(SQL,SIZE) function.
**
** This function compiles and runs the SQL statement(s) given in the
** argument. The results are hashed using a SIZE-bit SHA3.  The default
** size is 256.
**
** The format of the byte stream that is hashed is summarized as follows:
**
**       S&lt;n&gt;:&lt;sql&gt;
**       R
**       N
**       I&lt;int&gt;
**       F&lt;ieee-float&gt;
**       B&lt;size&gt;:&lt;bytes&gt;
**       T&lt;size&gt;:&lt;text&gt;
**
** &lt;sql&gt; is the original SQL text for each statement run and &lt;n&gt; is
** the size of that text.  The SQL text is UTF-8.  A single R character
** occurs before the start of each row.  N means a NULL value.
** I mean an 8-byte little-endian integer &lt;int&gt;.  F is a floating point
** number with an 8-byte little-endian IEEE floating point value &lt;ieee-float&gt;.
** B means blobs of &lt;size&gt; bytes.  T means text rendered as &lt;size&gt;
** bytes of UTF-8.  The &lt;n&gt; and &lt;size&gt; values are expressed as an ASCII
** text integers.
**
** For each SQL statement in the X input, there is one S segment.  Each
** S segment is followed by zero or more R segments, one for each row in the
** result set.  After each R, there are one or more N, I, F, B, or T segments,
** one for each column in the result set.  Segments are concatentated directly
** with no delimiters of any kind.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sha3QueryFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the result set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SHA3Context</name></type> <name>cx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSize</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iSize</name><operator>!=</operator><literal type="number">224</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">384</literal> <operator>&amp;&amp;</operator> <name>iSize</name><operator>!=</operator><literal type="number">512</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"SHA3 size should be one of: 224 256 "</literal>
                                    <literal type="string">"384 512"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>SHA3Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>zSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error SQL statement [%s]: %s"</literal></expr></argument>,
                                   <argument><expr><name>zSql</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3_stmt_readonly</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"non-query: [%s]"</literal></expr></argument>, <argument><expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>hash_step_vformat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><literal type="string">"S%d:"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Compute a hash over the result of the query */</comment>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"R"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <switch>switch<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"N"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">8</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>u</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'I'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>x</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>u</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">8</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>u</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'F'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>hash_step_vformat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><literal type="string">"T%d:"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>hash_step_vformat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>,<argument><expr><literal type="string">"B%d:"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SHA3Update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
        </block_content>}</block></switch>
      </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>SHA3Final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iSize</name><operator>/</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_shathree_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sha3"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                      <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_INNOCUOUS</name> <operator>|</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sha3Func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sha3"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                      <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_INNOCUOUS</name> <operator>|</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sha3Func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sha3_query"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                      <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_DIRECTONLY</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sha3QueryFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sha3_query"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                      <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_DIRECTONLY</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sha3QueryFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/shathree.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/uint.c ******************/</comment>
<comment type="block">/*
** 2020-04-14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements the UINT collating sequence.
**
** UINT works like BINARY for text, except that embedded strings
** of digits compare in numeric order.
**
**     *   Leading zeros are handled properly, in the sense that
**         they do not mess of the maginitude comparison of embedded
**         strings of digits.  "x00123y" is equal to "x123y".
**
**     *   Only unsigned integers are recognized.  Plus and minus
**         signs are ignored.  Decimal points and exponential notation
**         are ignored.
**
**     *   Embedded integers can be of arbitrary length.  Comparison
**         is *not* limited integers that can be expressed as a
**         64-bit machine integer.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<function><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Compare text in lexicographic order, except strings of digits
** compare in numeric order.
*/</comment>
<specifier>static</specifier> <name>int</name></type> <name>uintCollFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>notUsed</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zA</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zB</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>notUsed</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>nKey1</name> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>nKey2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zA</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>zB</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>zA</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>zB</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
      <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>nKey1</name> <operator>&amp;&amp;</operator> <name><name>zA</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><name>nKey2</name> <operator>&amp;&amp;</operator> <name><name>zB</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>i</name><operator>+</operator><name>k</name><operator>&lt;</operator><name>nKey1</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>zA</name><index>[<expr><name>i</name><operator>+</operator><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call>
             <operator>&amp;&amp;</operator> <name>j</name><operator>+</operator><name>k</name><operator>&lt;</operator><name>nKey2</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>zB</name><index>[<expr><name>j</name><operator>+</operator><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><name>k</name><operator>&lt;</operator><name>nKey1</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>zA</name><index>[<expr><name>i</name><operator>+</operator><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>j</name><operator>+</operator><name>k</name><operator>&lt;</operator><name>nKey2</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name><name>zB</name><index>[<expr><name>j</name><operator>+</operator><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zA</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>zB</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>x</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>x</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>(</operator><name>nKey1</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>nKey2</name> <operator>-</operator> <name>j</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_uint_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <return>return <expr><call><name>sqlite3_create_collation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"uint"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>uintCollFunc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/uint.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/decimal.c ******************/</comment>
<comment type="block">/*
** 2020-06-22
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** Routines to implement arbitrary-precision decimal math.
**
** The focus here is on simplicity and correctness, not performance.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Mark a function parameter as unused, to suppress nuisance compiler
** warnings. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNUSED_PARAMETER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(void)(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* A decimal object */</comment>
<typedef>typedef <type><name><name>struct</name> <name>Decimal</name></name></type> <name>Decimal</name>;</typedef>
<struct>struct <name>Decimal</name> <block>{
  <decl_stmt><decl><type><name>char</name></type> <name>sign</name></decl>;</decl_stmt>        <comment type="block">/* 0 for positive, 1 for negative */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>oom</name></decl>;</decl_stmt>         <comment type="block">/* True if an OOM is encountered */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>isNull</name></decl>;</decl_stmt>      <comment type="block">/* True if holds a NULL rather than a number */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>isInit</name></decl>;</decl_stmt>      <comment type="block">/* True upon initialization */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDigit</name></decl>;</decl_stmt>       <comment type="block">/* Total number of digits */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrac</name></decl>;</decl_stmt>        <comment type="block">/* Number of digits to the right of the decimal point */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>   <comment type="block">/* Array of digits.  Most significant first. */</comment>
}</block>;</struct>

<comment type="block">/*
** Release memory held by a Decimal, but do not free the object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimal_clear</name><parameter_list>(<parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destroy a Decimal object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimal_free</name><parameter_list>(<parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>decimal_clear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new Decimal object.  Initialize it to the number given
** by the input string.
*/</comment>
<function><type><specifier>static</specifier> <name>Decimal</name> <modifier>*</modifier></type><name>decimal_new</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nAlt</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zAlt</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iExp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>new_no_mem</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zAlt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nAlt</name></expr><operator>,</operator>
    <expr><name>zIn</name> <operator>=</operator> <name>zAlt</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>new_no_mem</name>;</goto></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zIn</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name>iExp</name><operator>&lt;</operator><literal type="number">1000000</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>j</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>j</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iExp</name> <operator>=</operator> <name>iExp</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zIn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>neg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iExp</name> <operator>=</operator> <operator>-</operator><name>iExp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iExp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iExp</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>-=</operator> <name>iExp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iExp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iExp</name> <operator>-=</operator> <name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iExp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>   
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <name>iExp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>new_no_mem</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+=</operator> <name>iExp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iExp</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iExp</name> <operator>=</operator> <operator>-</operator><name>iExp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nExtra</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nExtra</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nExtra</name><operator>&gt;=</operator><name>iExp</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>+=</operator> <name>iExp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iExp</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iExp</name> <operator>-=</operator> <name>nExtra</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iExp</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <name>iExp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>new_no_mem</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>iExp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+=</operator> <name>iExp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>+=</operator> <name>iExp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>

<label><name>new_no_mem</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make the given Decimal the result.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimal_result</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isNull</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name><operator>+</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sign</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>  )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>j</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL Function:   decimal(X)
**
** Convert input X into decimal and then back into text
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare to Decimal objects.  Return negative, 0, or positive if the
** first object is less than, equal to, or greater than the second.
**
** Preconditions for this routine:
**
**    pA!=0
**    pA-&gt;isNull==0
**    pB!=0
**    pB-&gt;isNull==0
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decimal_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decimal</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Decimal</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nASig</name></decl>, <decl><type ref="prev"/><name>nBSig</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name><operator>!=</operator><name><name>pB</name><operator>-&gt;</operator><name>sign</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Decimal</name> <modifier>*</modifier></type><name>pTemp</name> <init>= <expr><name>pA</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pA</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pB</name> <operator>=</operator> <name>pTemp</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nASig</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBSig</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nASig</name><operator>!=</operator><name>nBSig</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>nASig</name> <operator>-</operator> <name>nBSig</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQL Function:   decimal_cmp(X, Y)
**
** Return negative, zero, or positive if X is less then, equal to, or
** greater than Y.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalCmpFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pA</name> <operator>=</operator> <call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>isNull</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>cmp_done</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pB</name> <operator>=</operator> <call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>isNull</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>cmp_done</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>decimal_cmp</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if<condition>( <expr><name>rc</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cmp_done</name>:</label>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Expand the Decimal so that it has a least nDigit digits and nFrac
** digits to the right of the decimal point.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimal_expand</name><parameter_list>(<parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nDigit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFrac</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nAddSig</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAddFrac</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nAddFrac</name> <operator>=</operator> <name>nFrac</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nAddSig</name> <operator>=</operator> <operator>(</operator><name>nDigit</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name><operator>)</operator> <operator>-</operator> <name>nAddFrac</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nAddFrac</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nAddSig</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>nDigit</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nAddSig</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name>nAddSig</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nAddSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+=</operator> <name>nAddSig</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nAddFrac</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nAddFrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+=</operator> <name>nAddFrac</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>+=</operator> <name>nAddFrac</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add the value pB into pA.
**
** Both pA and pB might become denormalized by this routine.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimal_add</name><parameter_list>(<parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nSig</name></decl>, <decl><type ref="prev"/><name>nFrac</name></decl>, <decl><type ref="prev"/><name>nDigit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>oom</name></name> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>isNull</name></name> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>isNull</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nSig</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSig</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSig</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSig</name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name><operator>-</operator><name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nSig</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>-</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nFrac</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nFrac</name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nFrac</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nDigit</name> <operator>=</operator> <name>nSig</name> <operator>+</operator> <name>nFrac</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_expand</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>nDigit</name></expr></argument>, <argument><expr><name>nFrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_expand</name><argument_list>(<argument><expr><name>pB</name></expr></argument>, <argument><expr><name>nDigit</name></expr></argument>, <argument><expr><name>nFrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>oom</name></name> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name><operator>==</operator><name><name>pB</name><operator>-&gt;</operator><name>sign</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nDigit</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>signed</name> <name>char</name> <modifier>*</modifier></type><name>aA</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aB</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>borrow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>pB</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>nDigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aA</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>aB</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <operator>!</operator><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>aB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>a</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nDigit</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>aA</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>aB</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>borrow</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name><operator>+</operator><literal type="number">10</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compare text in decimal order.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decimalCollFunc</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>notUsed</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey1</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nKey2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pKey2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zA</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zB</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pKey2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nKey1</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nKey2</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>notUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>decimal_cmp</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** SQL Function:   decimal_add(X, Y)
**                 decimal_sub(X, Y)
**
** Return the sum or difference of X and Y.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalAddFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_add</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalSubFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pB</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <operator>!</operator><name><name>pB</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decimal_add</name><argument_list>(<argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Aggregate funcion:   decimal_sum(X)
**
** Works like sum() except that it uses decimal arithmetic for unlimited
** precision.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalSumStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>isInit</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>isInit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>a</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pArg</name> <operator>=</operator> <call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_add</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalSumInverse</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pArg</name> <operator>=</operator> <call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <operator>!</operator><name><name>pArg</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>decimal_add</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalSumValue</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalSumFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_clear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL Function:   decimal_mul(X, Y)
**
** Return the product of X and Y.
**
** All significant digits after the decimal point are retained.
** Trailing zeros after the decimal point are omitted as long as
** the number of digits after the decimal point is no less than
** either the number of digits in either input.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>decimalMulFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pA</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Decimal</name> <modifier>*</modifier></type><name>pB</name> <init>= <expr><call><name>decimal_new</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>signed</name> <name>char</name> <modifier>*</modifier></type><name>acc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minFrac</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pA</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>oom</name></name> <operator>||</operator> <name><name>pA</name><operator>-&gt;</operator><name>isNull</name></name>
   <operator>||</operator> <name>pB</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>oom</name></name> <operator>||</operator> <name><name>pB</name><operator>-&gt;</operator><name>isNull</name></name></expr> 
  )</condition><block>{<block_content>
    <goto>goto <name>mul_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>acc</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>acc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>mul_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>acc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>minFrac</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name><operator>&lt;</operator><name>minFrac</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minFrac</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>f</name> <init>= <expr><name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name><operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>k</name><operator>=</operator><name>i</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr><operator>,</operator> <expr><name>k</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>acc</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+</operator> <name>f</name><operator>*</operator><name><name>pB</name><operator>-&gt;</operator><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>acc</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>x</name><operator>%</operator><literal type="number">10</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>carry</name> <operator>=</operator> <name>x</name><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>acc</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>acc</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>x</name><operator>%</operator><literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>acc</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>x</name><operator>/</operator><literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>acc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>acc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nDigit</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name> <operator>+=</operator> <name><name>pB</name><operator>-&gt;</operator><name>nFrac</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>sign</name></name> <operator>^=</operator> <name><name>pB</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name><operator>&gt;</operator><name>minFrac</name> <operator>&amp;&amp;</operator> <name><name>pA</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>nFrac</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pA</name><operator>-&gt;</operator><name>nDigit</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>decimal_result</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>mul_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decimal_free</name><argument_list>(<argument><expr><name>pB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_decimal_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFuncName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"decimal"</literal></expr>,       <expr><literal type="number">1</literal></expr>,   <expr><name>decimalFunc</name></expr>        }</block></expr>,
    <expr><block>{ <expr><literal type="string">"decimal_cmp"</literal></expr>,   <expr><literal type="number">2</literal></expr>,   <expr><name>decimalCmpFunc</name></expr>     }</block></expr>,
    <expr><block>{ <expr><literal type="string">"decimal_add"</literal></expr>,   <expr><literal type="number">2</literal></expr>,   <expr><name>decimalAddFunc</name></expr>     }</block></expr>,
    <expr><block>{ <expr><literal type="string">"decimal_sub"</literal></expr>,   <expr><literal type="number">2</literal></expr>,   <expr><name>decimalSubFunc</name></expr>     }</block></expr>,
    <expr><block>{ <expr><literal type="string">"decimal_mul"</literal></expr>,   <expr><literal type="number">2</literal></expr>,   <expr><name>decimalMulFunc</name></expr>     }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>

  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFuncName</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
                   <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_window_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"decimal_sum"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                   <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>decimalSumStep</name></expr></argument>, <argument><expr><name>decimalSumFinalize</name></expr></argument>,
                   <argument><expr><name>decimalSumValue</name></expr></argument>, <argument><expr><name>decimalSumInverse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_collation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"decimal"</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>decimalCollFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/decimal.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/ieee754.c ******************/</comment>
<comment type="block">/*
** 2013-04-17
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements functions for the exact display
** and input of IEEE754 Binary64 floating-point numbers.
**
**   ieee754(X)
**   ieee754(Y,Z)
**
** In the first form, the value X should be a floating-point number.
** The function will return a string of the form 'ieee754(Y,Z)' where
** Y and Z are integers such that X==Y*pow(2,Z).
**
** In the second form, Y and Z are integers which are the mantissa and
** base-2 exponent of a new floating point number.  The function returns
** a floating-point value equal to Y*pow(2,Z).
**
** Examples:
**
**     ieee754(2.0)             -&gt;     'ieee754(2,0)'
**     ieee754(45.25)           -&gt;     'ieee754(181,-2)'
**     ieee754(2, 0)            -&gt;     2.0
**     ieee754(181, -2)         -&gt;     45.25
**
** Two additional functions break apart the one-argument ieee754()
** result into separate integer values:
**
**     ieee754_mantissa(45.25)  -&gt;     181
**     ieee754_exponent(45.25)  -&gt;     -2
**
** These functions convert binary64 numbers into blobs and back again.
**
**     ieee754_from_blob(x'3ff0000000000000')  -&gt;  1.0
**     ieee754_to_blob(1.0)                    -&gt;  x'3ff0000000000000'
**
** In all single-argument functions, if the argument is an 8-byte blob
** then that blob is interpreted as a big-endian binary64 value.
**
**
** EXACT DECIMAL REPRESENTATION OF BINARY64 VALUES
** -----------------------------------------------
**
** This extension in combination with the separate 'decimal' extension
** can be used to compute the exact decimal representation of binary64
** values.  To begin, first compute a table of exponent values:
**
**    CREATE TABLE pow2(x INTEGER PRIMARY KEY, v TEXT);
**    WITH RECURSIVE c(x,v) AS (
**      VALUES(0,'1')
**      UNION ALL
**      SELECT x+1, decimal_mul(v,'2') FROM c WHERE x+1&lt;=971
**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
**    WITH RECURSIVE c(x,v) AS (
**      VALUES(-1,'0.5')
**      UNION ALL
**      SELECT x-1, decimal_mul(v,'0.5') FROM c WHERE x-1&gt;=-1075
**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
**
** Then, to compute the exact decimal representation of a floating
** point value (the value 47.49 is used in the example) do:
**
**    WITH c(n) AS (VALUES(47.49))
**          ---------------^^^^^---- Replace with whatever you want
**    SELECT decimal_mul(ieee754_mantissa(c.n),pow2.v)
**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.n);
**
** Here is a query to show various boundry values for the binary64
** number format:
**
**    WITH c(name,bin) AS (VALUES
**       ('minimum positive value',        x'0000000000000001'),
**       ('maximum subnormal value',       x'000fffffffffffff'),
**       ('mininum positive nornal value', x'0010000000000000'),
**       ('maximum value',                 x'7fefffffffffffff'))
**    SELECT c.name, decimal_mul(ieee754_mantissa(c.bin),pow2.v)
**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.bin);
**
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<function><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Mark a function parameter as unused, to suppress nuisance compiler
** warnings. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNUSED_PARAMETER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAMETER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(void)(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Implementation of the ieee754() function
*/</comment>
<specifier>static</specifier> <name>void</name></type> <name>ieee754func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isNeg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zResult</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name>
     <operator>&amp;&amp;</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>isNeg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><name>r</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>isNeg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>a</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <name>a</name><operator>&gt;&gt;</operator><literal type="number">52</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <name>a</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">52</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>e</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">52</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <while>while<condition>( <expr><name><name>e</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1075</literal> <operator>&amp;&amp;</operator> <name>m</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>m</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>isNeg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><name>m</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <switch>switch<condition>( <expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zResult</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr><literal type="string">"ieee754(%lld,%d)"</literal></expr></argument>,
                         <argument><expr><name>m</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><literal type="number">1075</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><literal type="number">1075</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>e</name></decl>, <decl><type ref="prev"/><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isNeg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Limit the range of e.  Ticket 22dea1cfdb9151e4 2021-03-02 */</comment>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>e</name><operator>&lt;</operator><operator>-</operator><literal type="number">10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>-</operator><literal type="number">10000</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>m</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>isNeg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><name>m</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>m</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>e</name><operator>&gt;</operator><operator>-</operator><literal type="number">1000</literal> <operator>&amp;&amp;</operator> <name>e</name><operator>&lt;</operator><literal type="number">1000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>m</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xffe00000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while<condition>( <expr><name>m</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>m</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xfff00000</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>m</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>e</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">1075</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Subnormal */</comment>
      <if_stmt><if>if<condition>( <expr><literal type="number">1</literal><operator>-</operator><name>e</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal><operator>-</operator><name>e</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">0x7ff</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0x7ff</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>a</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">52</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>|=</operator> <name>e</name><operator>&lt;&lt;</operator><literal type="number">52</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isNeg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_uint64</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">63</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Functions to convert between blobs and floats.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ieee754func_from_blob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ieee754func_to_blob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_FLOAT</name>
   <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_INTEGER</name></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>a</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>a</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof><operator>-</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_ieee_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iAux</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"ieee754"</literal></expr>,           <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><name>ieee754func</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ieee754"</literal></expr>,           <expr><literal type="number">2</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><name>ieee754func</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ieee754_mantissa"</literal></expr>,  <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><name>ieee754func</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ieee754_exponent"</literal></expr>,  <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">2</literal></expr>, <expr><name>ieee754func</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ieee754_to_blob"</literal></expr>,   <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><name>ieee754func_to_blob</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"ieee754_from_blob"</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><name>ieee754func_from_blob</name></expr> }</block></expr>,

  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFName</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iAux</name></expr></argument>,
                               <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/ieee754.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/series.c ******************/</comment>
<comment type="block">/*
** 2015-08-18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file demonstrates how to create a table-valued-function using
** a virtual table.  This demo implements the generate_series() function
** which gives similar results to the eponymous function in PostgreSQL.
** Examples:
**
**      SELECT * FROM generate_series(0,100,5);
**
** The query above returns integers from 0 through 100 counting by steps
** of 5.
**
**      SELECT * FROM generate_series(0,100);
**
** Integers from 0 through 100 with a step size of 1.
**
**      SELECT * FROM generate_series(20) LIMIT 10;
**
** Integers 20 through 29.
**
** HOW IT WORKS
**
** The generate_series "function" is really a virtual table with the
** following schema:
**
**     CREATE TABLE generate_series(
**       value,
**       start HIDDEN,
**       stop HIDDEN,
**       step HIDDEN
**     );
**
** Function arguments in queries against this virtual table are translated
** into equality constraints against successive hidden columns.  In other
** words, the following pairs of queries are equivalent to each other:
**
**    SELECT * FROM generate_series(0,100,5);
**    SELECT * FROM generate_series WHERE start=0 AND stop=100 AND step=5;
**
**    SELECT * FROM generate_series(0,100);
**    SELECT * FROM generate_series WHERE start=0 AND stop=100;
**
**    SELECT * FROM generate_series(20) LIMIT 10;
**    SELECT * FROM generate_series WHERE start=20 LIMIT 10;
**
** The generate_series virtual table implementation leaves the xCreate method
** set to NULL.  This means that it is not possible to do a CREATE VIRTUAL
** TABLE command with "generate_series" as the USING argument.  Instead, there
** is a single generate_series virtual table that is always available without
** having to be created first.
**
** The xBestIndex method looks for equality constraints against the hidden
** start, stop, and step columns, and if present, it uses those constraints
** to bound the sequence of generated values.  If the equality constraints
** are missing, it uses 0 for start, 4294967295 for stop, and 1 for step.
** xBestIndex returns a small cost when both start and stop are available,
** and a very large cost if either start or stop are unavailable.  This
** encourages the query planner to order joins such that the bounds of the
** series are well-defined.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>


<comment type="block">/* series_cursor is a subclass of sqlite3_vtab_cursor which will
** serve as the underlying representation of a cursor that scans
** over rows of the result
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>series_cursor</name></name></type> <name>series_cursor</name>;</typedef>
<struct>struct <name>series_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isDesc</name></decl>;</decl_stmt>                <comment type="block">/* True to count down rather than up */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* The rowid */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iValue</name></decl>;</decl_stmt>      <comment type="block">/* Current value ("value") */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mnValue</name></decl>;</decl_stmt>     <comment type="block">/* Mimimum value ("start") */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mxValue</name></decl>;</decl_stmt>     <comment type="block">/* Maximum value ("stop") */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iStep</name></decl>;</decl_stmt>       <comment type="block">/* Increment ("step") */</comment>
}</block>;</struct>

<comment type="block">/*
** The seriesConnect() method is invoked to create a new
** series_vtab that describes the generate_series virtual table.
**
** Think of this routine as the constructor for series_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the series_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against generate_series will look like.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pUnused</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argcUnused</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argvUnused</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrUnused</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<comment type="block">/* Column numbers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIES_COLUMN_VALUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIES_COLUMN_START</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIES_COLUMN_STOP</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIES_COLUMN_STEP</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argcUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argvUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
     <argument><expr><literal type="string">"CREATE TABLE x(value,start hidden,stop hidden,step hidden)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>*</operator><name>ppVtab</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for series_cursor objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new series_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pUnused</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a series_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Advance a series_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>series_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>-=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>+=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>series_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SERIES_COLUMN_START</name></expr>:</case>  <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SERIES_COLUMN_STOP</name></expr>:</case>   <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SERIES_COLUMN_STEP</name></expr>:</case>   <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name></expr>;</expr_stmt>   <break>break;</break>
    <default>default:</default>                   <expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name></expr>;</expr_stmt>  <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row. In this implementation, the
** first row returned is assigned rowid value 1, and each subsequent
** row a value 1 more than that of the previous.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>series_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>series_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>&lt;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>&gt;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* True to cause run-time checking of the start=, stop=, and/or step= 
** parameters.  The only reason to do this is for testing the
** constraint checking logic for virtual tables in the SQLite core.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SERIES_CONSTRAINT_VERIFY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SERIES_CONSTRAINT_VERIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This method is called to "rewind" the series_cursor object back
** to the first row of output.  This method is always called at least
** once prior to any call to seriesColumn() or seriesRowid() or 
** seriesEof().
**
** The query plan selected by seriesBestIndex is passed in the idxNum
** parameter.  (idxStr is not used in this implementation.)  idxNum
** is a bitmask showing which constraints are available:
**
**    1:    start=VALUE
**    2:    stop=VALUE
**    4:    step=VALUE
**
** Also, if bit 8 is set, that means that the series should be output
** in descending order rather than in ascending order.  If bit 16 is
** set, then output must appear in ascending order.
**
** This routine should initialize the cursor and position it so that it
** is pointing at the first row, or pointing off the end of the table
** (so that seriesEof() will return true) if the table is empty.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStrUnused</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>series_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>series_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStrUnused</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name> <operator>=</operator> <operator>-</operator><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">16</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If any of the constraints have a NULL value, then return no rows.
      ** See ticket https://www.sqlite.org/src/info/fac496b61722daf2 */</comment>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>-=</operator> <operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>mxValue</name></name> <operator>-</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name><operator>)</operator><operator>%</operator><name><name>pCur</name><operator>-&gt;</operator><name>iStep</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>isDesc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iValue</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>mnValue</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the generate_series virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** The query plan is represented by bits in idxNum:
**
**  (1)  start = $value  -- constraint exists
**  (2)  stop = $value   -- constraint exists
**  (4)  step = $value   -- constraint exists
**  (8)  output in descending order
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>seriesBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>              <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The query plan bitmask */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bStartSeen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* EQ constraint seen on the START column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>unusableMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Mask of unusable constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of arguments that seriesFilter() expects */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aIdx</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>           <comment type="block">/* Constraints on start, stop, and step */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <comment type="block">/* This implementation assumes that the start, stop, and step columns
  ** are the last three columns in the virtual table. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SERIES_COLUMN_STOP</name> <operator>==</operator> <name>SERIES_COLUMN_START</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SERIES_COLUMN_STEP</name> <operator>==</operator> <name>SERIES_COLUMN_START</name><operator>+</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>aIdx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>    <comment type="block">/* 0 for start, 1 for stop, 2 for step */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iMask</name></decl>;</decl_stmt>   <comment type="block">/* bitmask for those column */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&lt;</operator><name>SERIES_COLUMN_START</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>-</operator> <name>SERIES_COLUMN_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;=</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>iCol</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bStartSeen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>unusableMask</name> <operator>|=</operator>  <name>iMask</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <name>iMask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aIdx</name><index>[<expr><name>iCol</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>j</name> <operator>=</operator> <name><name>aIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>nArg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <operator>!</operator><name>SQLITE_SERIES_CONSTRAINT_VERIFY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* The current generate_column() implementation requires at least one
  ** argument (the START value).  Legacy versions assumed START=0 if the
  ** first argument was omitted.  Compile with -DZERO_ARGUMENT_GENERATE_SERIES
  ** to obtain the legacy behavior */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZERO_ARGUMENT_GENERATE_SERIES</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bStartSeen</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"first argument to \"generate_series()\" missing or unusable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>unusableMask</name> <operator>&amp;</operator> <operator>~</operator><name>idxNum</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The start, stop, and step columns are inputs.  Therefore if there
    ** are unusable constraints on any of start, stop, or step then
    ** this plan is unusable */</comment>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Both start= and stop= boundaries are available.  This is the 
    ** the preferred case */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><literal type="number">2</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name>idxNum</name><operator>&amp;</operator><literal type="number">4</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If either boundary is missing, we have to generate a huge span
    ** of numbers.  Make this case very expensive so that the query
    ** planner will work hard to avoid it. */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">2147483647</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This following structure defines all the methods for the 
** generate_series virtual table.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>seriesModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>seriesConnect</name></expr>,             <comment type="block">/* xConnect */</comment>
  <expr><name>seriesBestIndex</name></expr>,           <comment type="block">/* xBestIndex */</comment>
  <expr><name>seriesDisconnect</name></expr>,          <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>seriesOpen</name></expr>,                <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>seriesClose</name></expr>,               <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>seriesFilter</name></expr>,              <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>seriesNext</name></expr>,                <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>seriesEof</name></expr>,                 <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>seriesColumn</name></expr>,              <comment type="block">/* xColumn - read data */</comment>
  <expr><name>seriesRowid</name></expr>,               <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_series_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_libversion_number</name><argument_list>()</argument_list></call><operator>&lt;</operator><literal type="number">3008012</literal> <operator>&amp;&amp;</operator> <name>pzErrMsg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"generate_series() requires SQLite 3.8.12 or later"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"generate_series"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>seriesModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/series.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/regexp.c ******************/</comment>
<comment type="block">/*
** 2012-11-13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** The code in this file implements a compact but reasonably
** efficient regular-expression matcher for posix extended regular
** expressions against UTF8 text.
**
** This file is an SQLite extension.  It registers a single function
** named "regexp(A,B)" where A is the regular expression and B is the
** string to be matched.  By registering this function, SQLite will also
** then implement the "B regexp A" operator.  Note that with the function
** the regular expression comes first, but with the operator it comes
** second.
**
**  The following regular expression syntax is supported:
**
**     X*      zero or more occurrences of X
**     X+      one or more occurrences of X
**     X?      zero or one occurrences of X
**     X{p,q}  between p and q occurrences of X
**     (X)     match X
**     X|Y     X or Y
**     ^X      X occurring at the beginning of the string
**     X$      X occurring at the end of the string
**     .       Match any single character
**     \c      Character c where c is one of \{}()[]|*+?.
**     \c      C-language escapes for c in afnrtv.  ex: \t or \n
**     \uXXXX  Where XXXX is exactly 4 hex digits, unicode value XXXX
**     \xXX    Where XX is exactly 2 hex digits, unicode value XX
**     [abc]   Any single character from the set abc
**     [^abc]  Any single character not in the set abc
**     [a-z]   Any single character in the range a-z
**     [^a-z]  Any single character not in the range a-z
**     \b      Word boundary
**     \w      Word character.  [A-Za-z0-9_]
**     \W      Non-word character
**     \d      Digit
**     \D      Non-digit
**     \s      Whitespace character
**     \S      Non-whitespace character
**
** A nondeterministic finite automaton (NFA) is used for matching, so the
** performance is bounded by O(N*M) where N is the size of the regular
** expression and M is the size of the input string.  The matcher never
** exhibits exponential behavior.  Note that the X{p,q} operator expands
** to p copies of X following by q-p copies of X? and that the size of the
** regular expression in the O(N*M) performance bound is computed after
** this expansion.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<decl_stmt><decl><type><name>SQLITE_EXTENSION_INIT1</name>

<comment type="block">/*
** The following #defines change the names of some functions implemented in
** this file to prevent name collisions with C-library functions of the
** same name.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_match</name></cpp:macro>   <cpp:value>sqlite3re_match</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_compile</name></cpp:macro> <cpp:value>sqlite3re_compile</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_free</name></cpp:macro>    <cpp:value>sqlite3re_free</cpp:value></cpp:define>

<comment type="block">/* The end-of-input character */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_EOF</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* End of input */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_START</name></cpp:macro>  <cpp:value>0xfffffff</cpp:value></cpp:define>    <comment type="block">/* Start of input - larger than an UTF-8 */</comment>

<comment type="block">/* The NFA is implemented as sequence of opcodes taken from the following
** set.  Each opcode has a single integer argument.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_MATCH</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Match the one character in the argument */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ANY</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* Match any one character.  (Implements ".") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ANYSTAR</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* Special optimized version of .* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_FORK</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* Continue to both next and opcode at iArg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_GOTO</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>    <comment type="block">/* Jump to opcode at iArg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ACCEPT</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>    <comment type="block">/* Halt and indicate a successful match */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_INC</name></cpp:macro>      <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* Beginning of a [...] character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_EXC</name></cpp:macro>      <cpp:value>8</cpp:value></cpp:define>    <comment type="block">/* Beginning of a [^...] character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_VALUE</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>    <comment type="block">/* Single value in a character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_RANGE</name></cpp:macro>   <cpp:value>10</cpp:value></cpp:define>    <comment type="block">/* Range of values in a character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_WORD</name></cpp:macro>       <cpp:value>11</cpp:value></cpp:define>    <comment type="block">/* Perl word character [A-Za-z0-9_] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTWORD</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define>    <comment type="block">/* Not a perl word character */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_DIGIT</name></cpp:macro>      <cpp:value>13</cpp:value></cpp:define>    <comment type="block">/* digit:  [0-9] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTDIGIT</name></cpp:macro>   <cpp:value>14</cpp:value></cpp:define>    <comment type="block">/* Not a digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_SPACE</name></cpp:macro>      <cpp:value>15</cpp:value></cpp:define>    <comment type="block">/* space:  [ \t\n\r\v\f] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTSPACE</name></cpp:macro>   <cpp:value>16</cpp:value></cpp:define>    <comment type="block">/* Not a digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_BOUNDARY</name></cpp:macro>   <cpp:value>17</cpp:value></cpp:define>    <comment type="block">/* Boundary between word and non-word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ATSTART</name></cpp:macro>    <cpp:value>18</cpp:value></cpp:define>    <comment type="block">/* Currently at the start of the string */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode names used for symbolic debugging */</comment>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>ReOpName</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"EOF"</literal></expr>,
  <expr><literal type="string">"MATCH"</literal></expr>,
  <expr><literal type="string">"ANY"</literal></expr>,
  <expr><literal type="string">"ANYSTAR"</literal></expr>,
  <expr><literal type="string">"FORK"</literal></expr>,
  <expr><literal type="string">"GOTO"</literal></expr>,
  <expr><literal type="string">"ACCEPT"</literal></expr>,
  <expr><literal type="string">"CC_INC"</literal></expr>,
  <expr><literal type="string">"CC_EXC"</literal></expr>,
  <expr><literal type="string">"CC_VALUE"</literal></expr>,
  <expr><literal type="string">"CC_RANGE"</literal></expr>,
  <expr><literal type="string">"WORD"</literal></expr>,
  <expr><literal type="string">"NOTWORD"</literal></expr>,
  <expr><literal type="string">"DIGIT"</literal></expr>,
  <expr><literal type="string">"NOTDIGIT"</literal></expr>,
  <expr><literal type="string">"SPACE"</literal></expr>,
  <expr><literal type="string">"NOTSPACE"</literal></expr>,
  <expr><literal type="string">"BOUNDARY"</literal></expr>,
  <expr><literal type="string">"ATSTART"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>


<comment type="block">/* Each opcode is a "state" in the NFA */</comment>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>ReStateNumber</name>;</typedef>

<comment type="block">/* Because this is an NFA and not a DFA, multiple states can be active at
** once.  An instance of the following object records all active states in
** the NFA.  The implementation is optimized for the common case where the
** number of actives states is small.
*/</comment>
<typedef>typedef <type><struct>struct <name>ReStateSet</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nState</name></decl>;</decl_stmt>            <comment type="block">/* Number of current states */</comment>
  <decl_stmt><decl><type><name>ReStateNumber</name> <modifier>*</modifier></type><name>aState</name></decl>;</decl_stmt>      <comment type="block">/* Current states */</comment>
}</block></struct></type> <name>ReStateSet</name>;</typedef>

<comment type="block">/* An input string read one character at a time.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ReInput</name></name></type> <name>ReInput</name>;</typedef>
<struct>struct <name>ReInput</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>  <comment type="block">/* All text */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                   <comment type="block">/* Next byte to read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name></decl>;</decl_stmt>                  <comment type="block">/* EOF when i&gt;=mx */</comment>
}</block>;</struct>

<comment type="block">/* A compiled NFA (or an NFA that is in the process of being compiled) is
** an instance of the following object.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ReCompiled</name></name></type> <name>ReCompiled</name>;</typedef>
<struct>struct <name>ReCompiled</name> <block>{
  <decl_stmt><decl><type><name>ReInput</name></type> <name>sIn</name></decl>;</decl_stmt>                <comment type="block">/* Regular expression text */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>           <comment type="block">/* Error message to return */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>                  <comment type="block">/* Operators for the virtual machine */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aArg</name></decl>;</decl_stmt>                  <comment type="block">/* Arguments to each operator */</comment>
  <function_decl><type><name>unsigned</name></type> (<modifier>*</modifier><name>xNextChar</name>)<parameter_list>(<parameter><decl><type><name>ReInput</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Next character function */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zInit</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Initial text to match */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInit</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in zInit */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nState</name></decl>;</decl_stmt>            <comment type="block">/* Number of entries in aOp[] and aArg[] */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nAlloc</name></decl>;</decl_stmt>            <comment type="block">/* Slots allocated for aOp[] and aArg[] */</comment>
}</block>;</struct>

<comment type="block">/* Add a state to the given state set if it is not already there */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_add_state</name><parameter_list>(<parameter><decl><type><name>ReStateSet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newState</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>newState</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>nState</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ReStateNumber</name><operator>)</operator><name>newState</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Extract the next unicode character from *pzIn and return it.  Advance
** *pzIn to the first byte past the end of the character returned.  To
** be clear:  this routine converts utf8 to unicode.  This routine is 
** optimized for the common case where the next character is a single byte.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_next_char</name><parameter_list>(<parameter><decl><type><name>ReInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xe0</literal><operator>)</operator><operator>==</operator><literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x1f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal> <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xf0</literal><operator>)</operator><operator>==</operator><literal type="number">0xe0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x0f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">12</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x7ff</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0xdfff</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xf8</literal><operator>)</operator><operator>==</operator><literal type="number">0xf0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">3</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x07</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">18</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator>
                       <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0xffff</literal> <operator>||</operator> <name>c</name><operator>&gt;</operator><literal type="number">0x10ffff</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_next_char_nocase</name><parameter_list>(<parameter><decl><type><name>ReInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name> <init>= <expr><call><name>re_next_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a perl "word" character:  [A-Za-z0-9_] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_word_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'_'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a "digit" character:  [0-9] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_digit_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a perl "space" character:  [ \t\r\n\v\f] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_space_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\v'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\f'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Run a compiled regular expression on the zero-terminated input
** string zIn[].  Return true on a match and false if there is no match.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_match</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReStateSet</name></type> <name><name>aStateSet</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pThis</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReStateNumber</name></type> <name><name>aSpace</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReStateNumber</name> <modifier>*</modifier></type><name>pToFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iSwap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name>RE_START</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReInput</name></type> <name>in</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>mx</name></name> <operator>=</operator> <ternary><condition><expr><name>nIn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>nIn</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>zIn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Look for the initial prefix match, if there is one. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>x</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name><operator>&lt;=</operator><name><name>in</name><operator>.</operator><name>mx</name></name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name><name>in</name><operator>.</operator><name>i</name></name></expr>]</index></name><operator>!=</operator><name>x</name> <operator>||</operator>
         <call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name><operator>+</operator><name><name>in</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name></name></expr></argument>, <argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name><operator>&gt;</operator><name><name>in</name><operator>.</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>RE_START</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name><operator>&lt;=</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSpace</name></expr></argument>)</argument_list></sizeof><operator>/</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSpace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pToFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <name>aSpace</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pToFree</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReStateNumber</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>*</operator><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pToFree</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <name>pToFree</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>aState</name><index>[<expr><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>c</name><operator>!=</operator><name>RE_EOF</name> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cPrev</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>pRe</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pThis</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><name>iSwap</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSwap</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>iSwap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pThis</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pThis</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <switch>switch<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>RE_OP_MATCH</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ATSTART</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>cPrev</name><operator>==</operator><name>RE_START</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ANY</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_WORD</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTWORD</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_DIGIT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_digit_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTDIGIT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_digit_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_SPACE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_space_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTSPACE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_space_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_BOUNDARY</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>re_word_char</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ANYSTAR</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_FORK</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_GOTO</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ACCEPT</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>re_match_end</name>;</goto>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_CC_EXC</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <comment type="block">/* fall-through */</comment> <goto>goto <name>re_op_cc_inc</name>;</goto>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_CC_INC</name></expr>:</case> <label><name>re_op_cc_inc</name>:</label> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>==</operator><name>RE_OP_CC_VALUE</name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>&lt;=</operator><name>c</name> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><name>c</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>RE_OP_CC_EXC</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><name>hit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>hit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></for>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pNext</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>RE_OP_GOTO</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>+=</operator> <name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>RE_OP_ACCEPT</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<label><name>re_match_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Resize the opcode and argument arrays for an RE under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_resize</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>aOp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aArg</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name></name> <operator>=</operator> <name>aArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new opcode and argument into an RE under construction.  The
** insertion point is just prior to existing opcode iBefore.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_insert</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>&amp;&amp;</operator> <call><name>re_resize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><name>iBefore</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>iBefore</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iBefore</name></expr>]</index></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
  <return>return <expr><name>iBefore</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a new opcode and argument to the end of the RE under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_append</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make a copy of N opcodes starting at iStart onto the end of the RE
** under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_copy</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name><operator>+</operator><name>N</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>re_resize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><name>N</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
** If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
** c is not a hex digit *pV is unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_hex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pV</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'F'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'A'</literal> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pV</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>pV</name><operator>)</operator><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A backslash character has been seen, read the next character and
** return its interpretation.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_esc_char</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zEsc</name><index>[]</index></name> <init>= <expr><literal type="string">"afnrtv\\()*.+?[$^{|}]"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zTrans</name><index>[]</index></name> <init>= <expr><literal type="string">"\a\f\n\r\t\v"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">4</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
      <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">6</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErr</name></name> <operator>=</operator> <literal type="string">"unknown \\ escape"</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_string</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Peek at the next byte of input */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>rePeek</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compile RE text into a sequence of opcodes.  Continue up to the
** first unmatched ")" character, then return.  If an error is found,
** return a pointer to the error message string.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_re</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iGoto</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iEnd</name> <operator>+</operator> <literal type="number">2</literal> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iGoto</name> <operator>=</operator> <call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_GOTO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iGoto</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iGoto</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compile an element of regular expression text (anything that can be
** an operand to the "|" operator).  Return NULL on success or a pointer
** to the error message if there is a problem.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_string</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrev</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'|'</literal></expr>:</case>
      <case>case <expr><literal type="char">')'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block>
      <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_re</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="char">')'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unmatched '('"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_ANYSTAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'*' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_GOTO</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iPrev</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'+'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'+' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iPrev</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'?'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'?' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'$'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>RE_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'^'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_ATSTART</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'{m,n}' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <name>m</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'}'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unmatched '{'"</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>m</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"n less than m in '{m,n}'"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"both m and n are zero in '{m,n}'"</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iPrev</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_copy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>m</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_copy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>m</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><operator>-</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_EXC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_INC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">':'</literal></expr> )</condition><block>{<block_content>
            <return>return <expr><literal type="string">"POSIX character classes not supported"</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_RANGE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_RANGE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_VALUE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unclosed '['"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iFirst</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iFirst</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'\\'</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>specialOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_BOUNDARY</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_DIGIT</name></expr>;</expr_stmt>      <break>break;</break>
          <case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTDIGIT</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'s'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_SPACE</name></expr>;</expr_stmt>      <break>break;</break>
          <case>case <expr><literal type="char">'S'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTSPACE</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'w'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_WORD</name></expr>;</expr_stmt>       <break>break;</break>
          <case>case <expr><literal type="char">'W'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTWORD</name></expr>;</expr_stmt>    <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if<condition>( <expr><name>specialOp</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>specialOp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free and reclaim all the memory used by a previously compiled
** regular expression.  Applications should invoke this routine once
** for every call to re_compile() to avoid memory leaks.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_free</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pRe</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compile a textual regular expression in zIn[] into a compiled regular
** expression suitable for us by re_match() and return a pointer to the
** compiled regular expression in *ppRe.  Return NULL on success or an
** error message if something goes wrong.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_compile</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRe</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noCase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRe</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRe</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="string">"out of memory"</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>xNextChar</name></name> <operator>=</operator> <ternary><condition><expr><name>noCase</name></expr> ?</condition><then> <expr><name>re_next_char_nocase</name></expr> </then><else>: <expr><name>re_next_char</name></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>re_resize</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="string">"out of memory"</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_ANYSTAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_re</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zErr</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_ACCEPT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppRe</name> <operator>=</operator> <name>pRe</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="string">"unrecognized character"</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The following is a performance optimization.  If the regex begins with
  ** ".*" (if the input regex lacks an initial "^") and afterwards there are
  ** one or more matching characters, enter those matching characters into
  ** zInit[].  The re_match() routine can then search ahead in the input 
  ** string looking for the initial match without having to run the whole
  ** regex engine over the string.  Do not worry able trying to match
  ** unicode characters beyond plane 0 - those are very rare and this is
  ** just an optimization. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>RE_OP_ANYSTAR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noCase</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>RE_OP_MATCH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name></type> <name>x</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">0xfff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><literal type="number">0xc0</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">0xffff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><literal type="number">0xe0</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pRe</name><operator>-&gt;</operator><name>zErr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the regexp() SQL function.  This function implements
** the build-in REGEXP operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A REGEXP B
**
** is implemented as regexp(B,A).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_sql_func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>          <comment type="block">/* Compiled regular expression */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>     <comment type="block">/* The regular expression */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl>;</decl_stmt><comment type="block">/* String being searched */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>         <comment type="block">/* Compile error message */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>setAux</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* True to invoke sqlite3_set_auxdata() */</comment>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>  <comment type="block">/* Unused */</comment>
  <expr_stmt><expr><name>pRe</name> <operator>=</operator> <call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRe</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>setAux</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zStr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>re_match</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>setAux</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRe</name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>re_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This function is used for testing and debugging only.  It is only available
** if the SQLITE_DEBUG compile-time option is used.
**
** Compile a regular expression and then convert the compiled expression into
** text and return that text.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_bytecode_func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRe</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>re_bytecode_func_err</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"INIT     "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>i</name><operator>&lt;</operator><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%-8s %4d\n"</literal></expr></argument>,
         <argument><expr><name><name>ReOpName</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_str_length</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>re_bytecode_func_err</name>:</label>
  <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>


<comment type="block">/*
** Invoke this routine to register the regexp() function with the
** SQLite database connection.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_regexp_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"regexp"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
                            <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>,
                            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>re_sql_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The regexpi(PATTERN,STRING) function is a case-insensitive version
    ** of regexp(PATTERN,STRING). */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"regexpi"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                            <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>,
                            <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>db</name></expr></argument>, <argument><expr><name>re_sql_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"regexp_bytecode"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name><operator>|</operator><name>SQLITE_DETERMINISTIC</name></expr></argument>,
                            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>re_bytecode_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/regexp.c ********************/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/fileio.c ******************/</comment>
<comment type="block">/*
** 2014-06-13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements SQL functions readfile() and
** writefile(), and eponymous virtual type "fsdir".
**
** WRITEFILE(FILE, DATA [, MODE [, MTIME]]):
**
**   If neither of the optional arguments is present, then this UDF
**   function writes blob DATA to file FILE. If successful, the number
**   of bytes written is returned. If an error occurs, NULL is returned.
**
**   If the first option argument - MODE - is present, then it must
**   be passed an integer value that corresponds to a POSIX mode
**   value (file type + permissions, as returned in the stat.st_mode
**   field by the stat() system call). Three types of files may
**   be written/created:
**
**     regular files:  (mode &amp; 0170000)==0100000
**     symbolic links: (mode &amp; 0170000)==0120000
**     directories:    (mode &amp; 0170000)==0040000
**
**   For a directory, the DATA is ignored. For a symbolic link, it is
**   interpreted as text and used as the target of the link. For a
**   regular file, it is interpreted as a blob and written into the
**   named file. Regardless of the type of file, its permissions are
**   set to (mode &amp; 0777) before returning.
**
**   If the optional MTIME argument is present, then it is interpreted
**   as an integer - the number of seconds since the unix epoch. The
**   modification-time of the target file is set to this value before
**   returning.
**
**   If three or more arguments are passed to this function and an
**   error is encountered, an exception is raised.
**
** READFILE(FILE):
**
**   Read and return the contents of file FILE (type blob) from disk.
**
** FSDIR:
**
**   Used as follows:
**
**     SELECT * FROM fsdir($path [, $dir]);
**
**   Parameter $path is an absolute or relative pathname. If the file that it
**   refers to does not exist, it is an error. If the path refers to a regular
**   file or symbolic link, it returns a single row. Or, if the path refers
**   to a directory, it returns one row for the directory, and one row for each
**   file within the hierarchy rooted at $path.
**
**   Each row has the following columns:
**
**     name:  Path to file or directory (text value).
**     mode:  Value of stat.st_mode for directory entry (an integer).
**     mtime: Value of stat.st_mtime for directory entry (an integer).
**     data:  For a regular file, a blob containing the file data. For a
**            symlink, a text value containing the text of the link. For a
**            directory, NULL.
**
**   If a non-NULL value is specified for the optional $dir parameter and
**   $path is a relative path, then $path is interpreted relative to $dir. 
**   And the paths returned in the "name" column of the table are also 
**   relative to directory $dir.
**
** Notes on building this extension for Windows:
**   Unless linked statically with the SQLite library, a preprocessor
**   symbol, FILEIO_WIN32_DLL, must be #define'd to create a stand-alone
**   DLL form of this extension for WIN32. See its use below for details.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<function><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"windows.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<comment type="block">/* #  include "test_windirent.h" */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>DIRENT</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>chmod</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>chmod</name></cpp:macro> <cpp:value>_chmod</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>stat</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>stat</name></cpp:macro> <cpp:value>_stat</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>mkdir</name><parameter_list>(<parameter><type><name>path</name></type></parameter>,<parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_mkdir(path)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>path</name></type></parameter>,<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat(path,buf)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>


<comment type="block">/*
** Structure of the fsdir() table-valued function
*/</comment>
                 <comment type="block">/*    0    1    2     3    4           5             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_SCHEMA</name></cpp:macro> <cpp:value>"(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_NAME</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>     <comment type="block">/* Name of the file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_MODE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>     <comment type="block">/* Access mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_MTIME</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>     <comment type="block">/* Last modification time */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_DATA</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>     <comment type="block">/* File content */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_PATH</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>     <comment type="block">/* Path to top of search */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSDIR_COLUMN_DIR</name></cpp:macro>      <cpp:value>5</cpp:value></cpp:define>     <comment type="block">/* Path is relative to this directory */</comment>


<comment type="block">/*
** Set the result stored by context ctx to a blob containing the 
** contents of file zName.  Or, leave the result unchanged (NULL)
** if the file does not exist or is unreadable.
**
** If the file exceeds the SQLite blob size limit, through an
** SQLITE_TOOBIG error.
**
** Throw an SQLITE_IOERR if there are difficulties pulling the file
** off of disk.
*/</comment>
<specifier>static</specifier> <name>void</name></type> <name>readFileContents</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxBlob</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* File does not exist or is unreadable. Leave the result set to NULL. */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxBlob</name> <operator>=</operator> <call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_LENGTH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>&gt;</operator><name>mxBlob</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>SQLITE_TOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><ternary><condition><expr><name>nIn</name></expr> ?</condition><then> <expr><name>nIn</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nIn</name><operator>==</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>nIn</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>SQLITE_IOERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the "readfile(X)" SQL function.  The entire content
** of the file named X is read and returned as a BLOB.  NULL is returned
** if the file does not exist or is unreadable.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>readfileFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argc</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>readFileContents</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ctxErrorMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This function is designed to convert a Win32 FILETIME structure into the
** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_uint64</name></type> <name>fileTimeToUnixTime</name><parameter_list>(
  <parameter><decl><type><name>LPFILETIME</name></type> <name>pFileTime</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>epochSystemTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>epochIntervals</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>epochFileTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>fileIntervals</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epochSystemTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SYSTEMTIME</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wYear</name></name> <operator>=</operator> <literal type="number">1970</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wMonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochSystemTime</name><operator>.</operator><name>wDay</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epochSystemTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epochFileTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochIntervals</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>epochFileTime</name><operator>.</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>epochIntervals</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>epochFileTime</name><operator>.</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>fileIntervals</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>pFileTime</name><operator>-&gt;</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fileIntervals</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>pFileTime</name><operator>-&gt;</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name><name>fileIntervals</name><operator>.</operator><name>QuadPart</name></name> <operator>-</operator> <name><name>epochIntervals</name><operator>.</operator><name>QuadPart</name></name><operator>)</operator> <operator>/</operator> <literal type="number">10000000</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILEIO_WIN32_DLL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:empty>#  <comment type="block">/* To allow a standalone DLL, use this next replacement function: */</comment></cpp:empty>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>sqlite3_win32_utf8_to_unicode</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_win32_utf8_to_unicode</name></cpp:macro> <cpp:value>utf8_to_utf16</cpp:value></cpp:define>
<cpp:empty>#</cpp:empty>
<function><type><name>LPWSTR</name></type> <name>utf8_to_utf16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nAllot</name> <init>= <expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>rv</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nAllot</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rv</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>nAllot</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
    <return>return <expr><name>rv</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function attempts to normalize the time values found in the stat()
** buffer to UTC.  This is necessary on Win32, where the runtime library
** appears to return these values as local times.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>statTimesToUtc</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFindFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zUnicodeName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>LPWSTR</name></type> <name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><name>zUnicodeName</name> <operator>=</operator> <call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zUnicodeName</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WIN32_FIND_DATAW</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hFindFile</name> <operator>=</operator> <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>hFindFile</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_ctime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftCreationTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_atime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftLastAccessTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStatBuf</name><operator>-&gt;</operator><name>st_mtime</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>fileTimeToUnixTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>.</operator><name>ftLastWriteTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>hFindFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function is used in place of stat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls stat().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fileStat</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>statTimesToUtc</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>stat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This function is used in place of lstat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls lstat().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fileLinkStat</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pStatBuf</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>lstat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>statTimesToUtc</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>lstat</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pStatBuf</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Argument zFile is the name of a file that will be created and/or written
** by SQL function writefile(). This function ensures that the directory
** zFile will be written to exists, creating it if required. The permissions
** for any path components created by this function are set in accordance
** with the current umask.
**
** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
** SQLITE_OK is returned if the directory is successfully created, or
** SQLITE_ERROR otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>makeDirectory</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zCopy</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

      <for>for<control>(<init>;</init> <condition><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nCopy</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nCopy</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>fileStat</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><literal type="number">0777</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work for the writefile() UDF. Refer to 
** header comments at the top of this file for details.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeFile</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Context to return bytes written in */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>,              <comment type="block">/* File to write */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,           <comment type="block">/* Data to write */</comment>
  <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>,                    <comment type="block">/* MODE parameter passed to writefile() */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>mtime</name></decl></parameter>             <comment type="block">/* MTIME parameter (or -1 to not set time) */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTo</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTo</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>symlink</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* The mkdir() call to create the directory failed. This might not
        ** be an error though - if there is already a directory at the same
        ** path and either the permissions already match or can be changed
        ** to do so using chmod(), it is not an error.  */</comment>
        <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>errno</name><operator>!=</operator><name>EEXIST</name>
         <operator>||</operator> <literal type="number">0</literal><operator>!=</operator><call><name>fileStat</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sStat</name></expr></argument>)</argument_list></call>
         <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call>
         <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>sStat</name><operator>.</operator><name>st_mode</name></name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator><operator>!=</operator><operator>(</operator><name>mode</name><operator>&amp;</operator><literal type="number">0777</literal><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>!=</operator><call><name>chmod</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name><operator>&amp;</operator><literal type="number">0777</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><call><name>fwrite</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nWrite</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>!=</operator><name>n</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>&amp;&amp;</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>mode</name> <operator>&amp;</operator> <literal type="number">0777</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>mtime</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <comment type="block">/* Windows */</comment>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>lastAccess</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILETIME</name></type> <name>lastWrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>currentTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LONGLONG</name></type> <name>intervals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zUnicodeName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>LPWSTR</name></type> <name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>intervals</name> <operator>=</operator> <call><name>Int32x32To64</name><argument_list>(<argument><expr><name>mtime</name></expr></argument>, <argument><expr><literal type="number">10000000</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">116444736000000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lastWrite</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>intervals</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lastWrite</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>=</operator> <name>intervals</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zUnicodeName</name> <operator>=</operator> <call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zUnicodeName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>hFile</name> <operator>=</operator> <call><name>CreateFileW</name><argument_list>(
      <argument><expr><name>zUnicodeName</name></expr></argument>, <argument><expr><name>FILE_WRITE_ATTRIBUTES</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
      <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUnicodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>hFile</name><operator>!=</operator><name>INVALID_HANDLE_VALUE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>bResult</name> <init>= <expr><call><name>SetFileTime</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastAccess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastWrite</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>!</operator><name>bResult</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal></expr></cpp:elif> <comment type="block">/* utimensat() is not universally available */</comment>
    <comment type="block">/* Recent unix */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name><name>times</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>=</operator> <name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>mtime</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>utimensat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>times</name></expr></argument>, <argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Legacy unix */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>times</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>mtime</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>utimes</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.  
** Refer to header comments at the top of this file for details.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>writefileFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mtime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>argc</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>argc</name></expr></argument>&gt;</argument_list></name><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, 
        <argument><expr><literal type="string">"wrong number of arguments to function writefile()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zFile</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>mode_t</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mtime</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>writeFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>ENOENT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>makeDirectory</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>writeFile</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>res</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to create symlink: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to create directory: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>ctxErrorMsg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"failed to write file: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:   lsmode(MODE)
**
** Given a numberic st_mode from stat(), convert it into a human-readable
** text string in the style of "ls -l".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lsModeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMode</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'l'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>iMode</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>iMode</name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>-</operator><name>i</name><operator>)</operator><operator>*</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>i</name><operator>*</operator><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'r'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'w'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>m</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'x'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/* 
** Cursor type for recursively iterating through a directory structure.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>fsdir_cursor</name></name></type> <name>fsdir_cursor</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>FsdirLevel</name></name></type> <name>FsdirLevel</name>;</typedef>

<struct>struct <name>FsdirLevel</name> <block>{
  <decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>pDir</name></decl>;</decl_stmt>                 <comment type="block">/* From opendir() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDir</name></decl>;</decl_stmt>                <comment type="block">/* Name of directory (nul-terminated) */</comment>
}</block>;</struct>

<struct>struct <name>fsdir_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nLvl</name></decl>;</decl_stmt>                  <comment type="block">/* Number of entries in aLvl[] array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLvl</name></decl>;</decl_stmt>                  <comment type="block">/* Index of current entry */</comment>
  <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>aLvl</name></decl>;</decl_stmt>          <comment type="block">/* Hierarchy of directories being traversed */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBase</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sStat</name></decl>;</decl_stmt>         <comment type="block">/* Current lstat() results */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>               <comment type="block">/* Path to current entry */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* Current rowid */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>fsdir_tab</name></name></type> <name>fsdir_tab</name>;</typedef>
<struct>struct <name>fsdir_tab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
}</block>;</struct>

<comment type="block">/*
** Construct a new fsdir virtual table object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_tab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x"</literal> <name>FSDIR_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>fsdir_tab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for fsdir vtab objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new fsdir_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset a cursor back to the state it was in when first returned
** by fsdirOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsdirResetCursor</name><parameter_list>(<parameter><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for an fsdir_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fsdirResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message for the virtual table associated with cursor
** pCur to the results of vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fsdirSetErrmsg</name><parameter_list>(<parameter><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Advance an fsdir_cursor to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mode_t</name></type> <name>m</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Descend into this directory */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iNew</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNew</name><operator>&gt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> <init>= <expr><name>iNew</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nByte</name> <init>= <expr><name>nNew</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>FsdirLevel</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>aNew</name> <init>= <expr><operator>(</operator><name>FsdirLevel</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aNew</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FsdirLevel</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nNew</name><operator>-</operator><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLvl</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name> <operator>=</operator> <name>iNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLvl</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name>iNew</name></expr>]</index></name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot read directory: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FsdirLevel</name> <modifier>*</modifier></type><name>pLvl</name> <init>= <expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>aLvl</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
       <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
       <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>fileLinkStat</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot stat file: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>pDir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLvl</name><operator>-&gt;</operator><name>zDir</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iLvl</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* EOF */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>FSDIR_COLUMN_NAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name><index>[<expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>FSDIR_COLUMN_MODE</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FSDIR_COLUMN_MTIME</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>FSDIR_COLUMN_DATA</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>mode_t</name></type> <name>m</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name><operator>.</operator><name>st_mode</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>aStatic</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><name>aStatic</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nBuf</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><name>nBuf</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>!=</operator><name>aStatic</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <name>nBuf</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>!=</operator><name>aStatic</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>readFileContents</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <case>case <expr><name>FSDIR_COLUMN_PATH</name></expr>:</case>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
      ** always return their values as NULL */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row. In this implementation, the
** first row returned is assigned rowid value 1, and each subsequent
** row a value 1 more than that of the previous.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xFilter callback.
**
** idxNum==1   PATH parameter only
** idxNum==2   Both PATH and DIR supplied
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fsdir_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>fsdir_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fsdirResetCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"table function fsdir requires an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><name>idxNum</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>argc</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>argc</name><operator>==</operator><literal type="number">2</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDir</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"table function fsdir requires a non-NULL argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nBase</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zBase</name></name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fileLinkStat</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>sStat</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fsdirSetErrmsg</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="string">"cannot stat file: %s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the generate_series virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** The query plan is represented by values of idxNum:
**
**  (1)  The path value is supplied by argv[0]
**  (2)  Path is in argv[0] and dir is in argv[1]
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxPath</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Index in pIdxInfo-&gt;aConstraint of PATH= */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxDir</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Index in pIdxInfo-&gt;aConstraint of DIR= */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* True if an unusable PATH= constraint is seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>seenDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* True if an unusable DIR= constraint is seen */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>tab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>FSDIR_COLUMN_PATH</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>idxPath</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>seenPath</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxPath</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>seenPath</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>FSDIR_COLUMN_DIR</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>idxDir</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>seenDir</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxDir</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>seenDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch> 
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>seenPath</name> <operator>||</operator> <name>seenDir</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If input parameters are unusable, disallow this plan */</comment>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxPath</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* The pIdxInfo-&gt;estimatedCost should have been initialized to a huge
    ** number.  Leave it unchanged. */</comment>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxPath</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxPath</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxDir</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxDir</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idxDir</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">10.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Register the "fsdir" virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsdirRegister</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>fsdirModule</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
    <expr><name>fsdirConnect</name></expr>,              <comment type="block">/* xConnect */</comment>
    <expr><name>fsdirBestIndex</name></expr>,            <comment type="block">/* xBestIndex */</comment>
    <expr><name>fsdirDisconnect</name></expr>,           <comment type="block">/* xDisconnect */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
    <expr><name>fsdirOpen</name></expr>,                 <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>fsdirClose</name></expr>,                <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>fsdirFilter</name></expr>,               <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>fsdirNext</name></expr>,                 <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>fsdirEof</name></expr>,                  <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>fsdirColumn</name></expr>,               <comment type="block">/* xColumn - read data */</comment>
    <expr><name>fsdirRowid</name></expr>,                <comment type="block">/* xRowid - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fsdir"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsdirModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>         <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>fsdirRegister</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fileio_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"readfile"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>readfileFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"writefile"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_DIRECTONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>writefileFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"lsmode"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>lsModeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fsdirRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILEIO_WIN32_DLL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<comment type="block">/* To allow a standalone DLL, make test_windirent.c use the same
 * redefined SQLite API calls as the above extension code does.
 * Just pull in this .c to accomplish this. As a beneficial side
 * effect, this extension becomes a single translation unit. */</comment>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"test_windirent.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/************************* End ../ext/misc/fileio.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/completion.c ******************/</comment>
<comment type="block">/*
** 2017-07-10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements an eponymous virtual table that returns suggested
** completions for a partial SQL input.
**
** Suggested usage:
**
**     SELECT DISTINCT candidate COLLATE nocase
**       FROM completion($prefix,$wholeline)
**      ORDER BY 1;
**
** The two query parameters are optional.  $prefix is the text of the
** current word being typed and that is to be completed.  $wholeline is
** the complete input line, used for context.
**
** The raw completion() table might return the same candidate multiple
** times, for example if the same column name is used to two or more
** tables.  And the candidates are returned in an arbitrary order.  Hence,
** the DISTINCT and ORDER BY are recommended.
**
** This virtual table operates at the speed of human typing, and so there
** is no attempt to make it fast.  Even a slow implementation will be much
** faster than any human can type.
**
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/* completion_vtab is a subclass of sqlite3_vtab which will
** serve as the underlying representation of a completion virtual table
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>completion_vtab</name></name></type> <name>completion_vtab</name>;</typedef>
<struct>struct <name>completion_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>        <comment type="block">/* Database connection for this completion vtab */</comment>
}</block>;</struct>

<comment type="block">/* completion_cursor is a subclass of sqlite3_vtab_cursor which will
** serve as the underlying representation of a cursor that scans
** over rows of the result
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>completion_cursor</name></name></type> <name>completion_cursor</name>;</typedef>
<struct>struct <name>completion_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Database connection for this cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPrefix</name></decl>, <decl><type ref="prev"/><name>nLine</name></decl>;</decl_stmt>        <comment type="block">/* Number of bytes in zPrefix and zLine */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrefix</name></decl>;</decl_stmt>             <comment type="block">/* The prefix for the word we want to complete */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name></decl>;</decl_stmt>               <comment type="block">/* The whole that we want to complete */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCurrentRow</name></decl>;</decl_stmt>   <comment type="block">/* Current output row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szRow</name></decl>;</decl_stmt>                 <comment type="block">/* Length of the zCurrentRow string */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>       <comment type="block">/* Current statement */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>      <comment type="block">/* The rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ePhase</name></decl>;</decl_stmt>                <comment type="block">/* Current phase */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                     <comment type="block">/* inter-phase counter */</comment>
}</block>;</struct>

<comment type="block">/* Values for ePhase:
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_FIRST_PHASE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_KEYWORDS</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_PRAGMAS</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_FUNCTIONS</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLLATIONS</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_INDEXES</name></cpp:macro>       <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_TRIGGERS</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_DATABASES</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_TABLES</name></cpp:macro>        <cpp:value>8</cpp:value></cpp:define>    <comment type="block">/* Also VIEWs and TRIGGERs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLUMNS</name></cpp:macro>       <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_MODULES</name></cpp:macro>       <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_EOF</name></cpp:macro>           <cpp:value>11</cpp:value></cpp:define>

<comment type="block">/*
** The completionConnect() method is invoked to create a new
** completion_vtab that describes the completion virtual table.
**
** Think of this routine as the constructor for completion_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the completion_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against completion will look like.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>pAux</name><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argc</name><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argv</name><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>pzErr</name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* Unused parameter */</comment>

<comment type="block">/* Column numbers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLUMN_CANDIDATE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>  <comment type="block">/* Suggested completion of the input */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLUMN_PREFIX</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* Prefix of the word to be completed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLUMN_WHOLELINE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* Entire line seen so far */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPLETION_COLUMN_PHASE</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>  <comment type="block">/* ePhase - used for debugging only */</comment>

  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_INNOCUOUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
      <argument><expr><literal type="string">"CREATE TABLE x("</literal>
      <literal type="string">"  candidate TEXT,"</literal>
      <literal type="string">"  prefix TEXT HIDDEN,"</literal>
      <literal type="string">"  wholeline TEXT HIDDEN,"</literal>
      <literal type="string">"  phase INT HIDDEN"</literal>        <comment type="block">/* Used for debugging only */</comment>
      <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for completion_cursor objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new completion_cursor object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>completion_vtab</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset the completion_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>completionCursorReset</name><parameter_list>(<parameter><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLine</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>j</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for a completion_cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>completionCursorReset</name><argument_list>(<argument><expr><operator>(</operator><name>completion_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance a completion_cursor to its next row of output.
**
** The -&gt;ePhase, -&gt;j, and -&gt;pStmt fields of the completion_cursor object
** record the current state of the scan.  This routine sets -&gt;zCurrentRow
** to the current row of output and then returns.  If no more rows remain,
** then -&gt;ePhase is set to COMPLETION_EOF which will signal the virtual
** table that has reached the end of its scan.
**
** The current implementation just lists potential identifiers and
** keywords and filters them by zPrefix.  Future enhancements should
** take zLine into account to try to restrict the set of identifiers and
** keywords based on what would be legal at the current point of input.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>completion_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eNextPhase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Next phase to try if current phase reaches end */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* If &gt;=0, step pCur-&gt;pStmt and use the i-th column */</comment>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name><operator>!=</operator><name>COMPLETION_EOF</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>COMPLETION_KEYWORDS</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>j</name></name> <operator>&gt;=</operator> <call><name>sqlite3_keyword_count</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name> <operator>=</operator> <name>COMPLETION_DATABASES</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_keyword_name</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>j</name></name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>szRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>COMPLETION_DATABASES</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA database_list"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>eNextPhase</name> <operator>=</operator> <name>COMPLETION_TABLES</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>COMPLETION_TABLES</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pS2</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA database_list"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pS2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
               <argument><expr><literal type="string">"%z%s"</literal>
               <literal type="string">"SELECT name FROM \"%w\".sqlite_schema"</literal></expr></argument>,
               <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" UNION "</literal></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>eNextPhase</name> <operator>=</operator> <name>COMPLETION_COLUMNS</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>COMPLETION_COLUMNS</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pS2</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA database_list"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pS2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
               <argument><expr><literal type="string">"%z%s"</literal>
               <literal type="string">"SELECT pti.name FROM \"%w\".sqlite_schema AS sm"</literal>
                       <literal type="string">" JOIN pragma_table_info(sm.name,%Q) AS pti"</literal>
               <literal type="string">" WHERE sm.type='table'"</literal></expr></argument>,
               <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" UNION "</literal></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pS2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>eNextPhase</name> <operator>=</operator> <name>COMPLETION_EOF</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* This case is when the phase presets zCurrentRow */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Extract the next row of content */</comment>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>szRow</name></name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* When all rows are finished, advance to the next phase */</comment>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name> <operator>=</operator> <name>eNextPhase</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name><operator>&lt;=</operator><name><name>pCur</name><operator>-&gt;</operator><name>szRow</name></name>
     <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return values of columns for the row at which the completion_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>completion_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>COMPLETION_COLUMN_CANDIDATE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zCurrentRow</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>szRow</name></name></expr></argument>,<argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>COMPLETION_COLUMN_PREFIX</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>COMPLETION_COLUMN_WHOLELINE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>COMPLETION_COLUMN_PHASE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the rowid for the current row.  In this implementation, the
** rowid is the same as the output value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>completion_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>completion_cursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name> <operator>&gt;=</operator> <name>COMPLETION_EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This method is called to "rewind" the completion_cursor object back
** to the first row of output.  This method is always called at least
** once prior to any call to completionColumn() or completionRowid() or 
** completionEof().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pVtabCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>completion_cursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>completion_cursor</name> <operator>*</operator><operator>)</operator><name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>idxStr</name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>argc</name><operator>)</operator></expr>;</expr_stmt>     <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><call><name>completionCursorReset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iArg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iArg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iArg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nLine</name></name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iArg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nLine</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iArg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pCur</name><operator>-&gt;</operator><name>nLine</name></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>isalnum</name><argument_list>(<argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pCur</name><operator>-&gt;</operator><name>zLine</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name> <operator>=</operator> <name><name>pCur</name><operator>-&gt;</operator><name>nLine</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>nPrefix</name></name></expr></argument>, <argument><expr><name><name>pCur</name><operator>-&gt;</operator><name>zLine</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCur</name><operator>-&gt;</operator><name>zPrefix</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>ePhase</name></name> <operator>=</operator> <name>COMPLETION_FIRST_PHASE</name></expr>;</expr_stmt>
  <return>return <expr><call><name>completionNext</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** SQLite will invoke this method one or more times while planning a query
** that uses the completion virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** There are two hidden parameters that act as arguments to the table-valued
** function:  "prefix" and "wholeline".  Bit 0 of idxNum is set if "prefix"
** is available and bit 1 is set if "wholeline" is available.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>completionBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop over constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idxNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* The query plan bitmask */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>prefixIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Index of the start= constraint, or -1 if none */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>wholelineIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Index of the stop= constraint, or -1 if none */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of arguments that completeFilter() expects */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>tab</name><operator>)</operator></expr>;</expr_stmt>    <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>COMPLETION_COLUMN_PREFIX</name></expr>:</case>
        <expr_stmt><expr><name>prefixIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>COMPLETION_COLUMN_WHOLELINE</name></expr>:</case>
        <expr_stmt><expr><name>wholelineIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxNum</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>prefixIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>prefixIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>nArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>prefixIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>wholelineIdx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>wholelineIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <operator>++</operator><name>nArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>wholelineIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><literal type="number">5000</literal> <operator>-</operator> <literal type="number">1000</literal><operator>*</operator><name>nArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">500</literal> <operator>-</operator> <literal type="number">100</literal><operator>*</operator><name>nArg</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This following structure defines all the methods for the 
** completion virtual table.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>completionModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>completionConnect</name></expr>,         <comment type="block">/* xConnect */</comment>
  <expr><name>completionBestIndex</name></expr>,       <comment type="block">/* xBestIndex */</comment>
  <expr><name>completionDisconnect</name></expr>,      <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>completionOpen</name></expr>,            <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>completionClose</name></expr>,           <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>completionFilter</name></expr>,          <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>completionNext</name></expr>,            <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>completionEof</name></expr>,             <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>completionColumn</name></expr>,          <comment type="block">/* xColumn - read data */</comment>
  <expr><name>completionRowid</name></expr>,           <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollbackTo */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<function><type><name>int</name></type> <name>sqlite3CompletionVtabInit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"completion"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>completionModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_completion_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>pzErrMsg</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3CompletionVtabInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/completion.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/appendvfs.c ******************/</comment>
<comment type="block">/*
** 2017-10-20
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements a VFS shim that allows an SQLite database to be
** appended onto the end of some other file, such as an executable.
**
** A special record must appear at the end of the file that identifies the
** file as an appended database and provides the offset to the first page
** of the exposed content. (Or, it is the length of the content prefix.)
** For best performance page 1 should be located at a disk page boundary,
** though that is not required.
**
** When opening a database using this VFS, the connection might treat
** the file as an ordinary SQLite database, or it might treat it as a
** database appended onto some other file.  The decision is made by
** applying the following rules in order:
**
**  (1)  An empty file is an ordinary database.
**
**  (2)  If the file ends with the appendvfs trailer string
**       "Start-Of-SQLite3-NNNNNNNN" that file is an appended database.
**
**  (3)  If the file begins with the standard SQLite prefix string
**       "SQLite format 3", that file is an ordinary database.
**
**  (4)  If none of the above apply and the SQLITE_OPEN_CREATE flag is
**       set, then a new database is appended to the already existing file.
**
**  (5)  Otherwise, SQLITE_CANTOPEN is returned.
**
** To avoid unnecessary complications with the PENDING_BYTE, the size of
** the file containing the database is limited to 1GiB. (1073741824 bytes)
** This VFS will not read or write past the 1GiB mark.  This restriction
** might be lifted in future versions.  For now, if you need a larger
** database, then keep it in a separate file.
**
** If the file being opened is a plain database (not an appended one), then
** this shim is a pass-through into the default underlying VFS. (rule 3)
**/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/* The append mark at the end of the database is:
**
**     Start-Of-SQLite3-NNNNNNNN
**     123456789 123456789 12345
**
** The NNNNNNNN represents a 64-bit big-endian unsigned integer which is
** the offset to page 1, and also the length of the prefix content.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_MARK_PREFIX</name></cpp:macro>     <cpp:value>"Start-Of-SQLite3-"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_MARK_PREFIX_SZ</name></cpp:macro>  <cpp:value>17</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_MARK_FOS_SZ</name></cpp:macro>      <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_MARK_SIZE</name></cpp:macro>       <cpp:value>(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)</cpp:value></cpp:define>

<comment type="block">/*
** Maximum size of the combined prefix + database + append-mark.  This
** must be less than 0x40000000 to avoid locking issues on Windows.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_MAX_SIZE</name></cpp:macro>  <cpp:value>(0x40000000)</cpp:value></cpp:define>

<comment type="block">/*
** Try to align the database to an even multiple of APND_ROUNDUP bytes.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APND_ROUNDUP</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_ROUNDUP</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_ALIGN_MASK</name></cpp:macro>         <cpp:value>((sqlite3_int64)(APND_ROUNDUP-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APND_START_ROUNDUP</name><parameter_list>(<parameter><type><name>fsz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((fsz)+APND_ALIGN_MASK) &amp; ~APND_ALIGN_MASK)</cpp:value></cpp:define>

<comment type="block">/*
** Forward declaration of objects used by this utility
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>sqlite3_vfs</name></name></type> <name>ApndVfs</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ApndFile</name></name></type> <name>ApndFile</name>;</typedef>

<comment type="block">/* Access to a lower-level VFS that (might) implement dynamic loading,
** access to randomness, etc.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ORIGVFS</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((sqlite3_vfs*)((p)-&gt;pAppData))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ORIGFILE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sqlite3_file*)(((ApndFile*)(p))+1))</cpp:value></cpp:define>

<comment type="block">/* An open appendvfs file
**
** An instance of this structure describes the appended database file.
** A separate sqlite3_file object is always appended. The appended
** sqlite3_file object (which can be accessed using ORIGFILE()) describes
** the entire file, including the prefix, the database, and the
** append-mark.
**
** The structure of an AppendVFS database is like this:
**
**   +-------------+---------+----------+-------------+
**   | prefix-file | padding | database | append-mark |
**   +-------------+---------+----------+-------------+
**                           ^          ^
**                           |          |
**                         iPgOne      iMark
**
**
** "prefix file" -  file onto which the database has been appended.
** "padding"     -  zero or more bytes inserted so that "database"
**                  starts on an APND_ROUNDUP boundary
** "database"    -  The SQLite database file
** "append-mark" -  The 25-byte "Start-Of-SQLite3-NNNNNNNN" that indicates
**                  the offset from the start of prefix-file to the start
**                  of "database".
**
** The size of the database is iMark - iPgOne.
**
** The NNNNNNNN in the "Start-Of-SQLite3-NNNNNNNN" suffix is the value
** of iPgOne stored as a big-ending 64-bit integer.
**
** iMark will be the size of the underlying file minus 25 (APND_MARKSIZE).
** Or, iMark is -1 to indicate that it has not yet been written.
*/</comment>
<struct>struct <name>ApndFile</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_file</name></type> <name>base</name></decl>;</decl_stmt>        <comment type="block">/* Subclass.  MUST BE FIRST! */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iPgOne</name></decl>;</decl_stmt>     <comment type="block">/* Offset to the start of the database */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMark</name></decl>;</decl_stmt>      <comment type="block">/* Offset of the append mark.  -1 if unwritten */</comment>
  <comment type="block">/* Always followed by another sqlite3_file that describes the whole file */</comment>
}</block>;</struct>

<comment type="block">/*
** Methods for ApndFile
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndWrite</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndShmMap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pgsz</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>volatile</specifier><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apndShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndFetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Methods for ApndVfs
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter> , <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndAccess</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndFullPathname</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>apndDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apndDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>static</specifier> <call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><call><name>apndDlSym</name><argument_list>(<argument><expr><name>sqlite3_vfs</name> <operator>*</operator><name>pVfs</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator><name>zSym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apndDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microseconds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>double</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>apndSetSystemCall</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_syscall_ptr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>sqlite3_syscall_ptr</name></type> <name>apndGetSystemCall</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>apndNextSystemCall</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name>apnd_vfs</name> <init>= <expr><block>{
  <expr><literal type="number">3</literal></expr>,                            <comment type="block">/* iVersion (set when registered) */</comment>
  <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* szOsFile (set when registered) */</comment>
  <expr><literal type="number">1024</literal></expr>,                         <comment type="block">/* mxPathname */</comment>
  <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* pNext */</comment>
  <expr><literal type="string">"apndvfs"</literal></expr>,                    <comment type="block">/* zName */</comment>
  <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* pAppData (set when registered) */</comment> 
  <expr><name>apndOpen</name></expr>,                     <comment type="block">/* xOpen */</comment>
  <expr><name>apndDelete</name></expr>,                   <comment type="block">/* xDelete */</comment>
  <expr><name>apndAccess</name></expr>,                   <comment type="block">/* xAccess */</comment>
  <expr><name>apndFullPathname</name></expr>,             <comment type="block">/* xFullPathname */</comment>
  <expr><name>apndDlOpen</name></expr>,                   <comment type="block">/* xDlOpen */</comment>
  <expr><name>apndDlError</name></expr>,                  <comment type="block">/* xDlError */</comment>
  <expr><name>apndDlSym</name></expr>,                    <comment type="block">/* xDlSym */</comment>
  <expr><name>apndDlClose</name></expr>,                  <comment type="block">/* xDlClose */</comment>
  <expr><name>apndRandomness</name></expr>,               <comment type="block">/* xRandomness */</comment>
  <expr><name>apndSleep</name></expr>,                    <comment type="block">/* xSleep */</comment>
  <expr><name>apndCurrentTime</name></expr>,              <comment type="block">/* xCurrentTime */</comment>
  <expr><name>apndGetLastError</name></expr>,             <comment type="block">/* xGetLastError */</comment>
  <expr><name>apndCurrentTimeInt64</name></expr>,         <comment type="block">/* xCurrentTimeInt64 */</comment>
  <expr><name>apndSetSystemCall</name></expr>,            <comment type="block">/* xSetSystemCall */</comment>
  <expr><name>apndGetSystemCall</name></expr>,            <comment type="block">/* xGetSystemCall */</comment>
  <expr><name>apndNextSystemCall</name></expr>            <comment type="block">/* xNextSystemCall */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name></type> <name>apnd_io_methods</name> <init>= <expr><block>{
  <expr><literal type="number">3</literal></expr>,                              <comment type="block">/* iVersion */</comment>
  <expr><name>apndClose</name></expr>,                      <comment type="block">/* xClose */</comment>
  <expr><name>apndRead</name></expr>,                       <comment type="block">/* xRead */</comment>
  <expr><name>apndWrite</name></expr>,                      <comment type="block">/* xWrite */</comment>
  <expr><name>apndTruncate</name></expr>,                   <comment type="block">/* xTruncate */</comment>
  <expr><name>apndSync</name></expr>,                       <comment type="block">/* xSync */</comment>
  <expr><name>apndFileSize</name></expr>,                   <comment type="block">/* xFileSize */</comment>
  <expr><name>apndLock</name></expr>,                       <comment type="block">/* xLock */</comment>
  <expr><name>apndUnlock</name></expr>,                     <comment type="block">/* xUnlock */</comment>
  <expr><name>apndCheckReservedLock</name></expr>,          <comment type="block">/* xCheckReservedLock */</comment>
  <expr><name>apndFileControl</name></expr>,                <comment type="block">/* xFileControl */</comment>
  <expr><name>apndSectorSize</name></expr>,                 <comment type="block">/* xSectorSize */</comment>
  <expr><name>apndDeviceCharacteristics</name></expr>,      <comment type="block">/* xDeviceCharacteristics */</comment>
  <expr><name>apndShmMap</name></expr>,                     <comment type="block">/* xShmMap */</comment>
  <expr><name>apndShmLock</name></expr>,                    <comment type="block">/* xShmLock */</comment>
  <expr><name>apndShmBarrier</name></expr>,                 <comment type="block">/* xShmBarrier */</comment>
  <expr><name>apndShmUnmap</name></expr>,                   <comment type="block">/* xShmUnmap */</comment>
  <expr><name>apndFetch</name></expr>,                      <comment type="block">/* xFetch */</comment>
  <expr><name>apndUnfetch</name></expr>                     <comment type="block">/* xUnfetch */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Close an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name><operator>+</operator><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add the append-mark onto what should become the end of the file.
*  If and only if this succeeds, internal ApndFile.iMark is updated.
*  Parameter iWriteEnd is the appendvfs-relative offset of the new mark.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndWriteMark</name><parameter_list>(
  <parameter><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iWriteEnd</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iPgOne</name> <init>= <expr><name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>a</name><index>[<expr><name>APND_MARK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>APND_MARK_FOS_SZ</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pFile</name> <operator>==</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>paf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>APND_MARK_PREFIX</name></expr></argument>, <argument><expr><name>APND_MARK_PREFIX_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>APND_MARK_PREFIX_SZ</name><operator>+</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>iPgOne</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPgOne</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>iWriteEnd</name> <operator>+=</operator> <name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name>
                  <argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>APND_MARK_SIZE</name></expr></argument>, <argument><expr><name>iWriteEnd</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name> <operator>=</operator> <name>iWriteEnd</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write data to an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iOfst</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iWriteEnd</name> <init>= <expr><name>iOfst</name> <operator>+</operator> <name>iAmt</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iWriteEnd</name><operator>&gt;=</operator><name>APND_MAX_SIZE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_FULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* If append-mark is absent or will be overwritten, write it. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name> <operator>+</operator> <name>iWriteEnd</name> <operator>&gt;</operator> <name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>apndWriteMark</name><argument_list>(<argument><expr><name>paf</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iWriteEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name><operator>+</operator><name>iOfst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Truncate an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The append mark goes out first so truncate failure does not lose it. */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>apndWriteMark</name><argument_list>(<argument><expr><name>paf</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Truncate underlying file just past append mark */</comment>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name><operator>+</operator><name>APND_MARK_SIZE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sync an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current file-size of an apnd-file.
** If the append mark is not yet there, the file-size is 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator> <name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name><name>paf</name><operator>-&gt;</operator><name>iMark</name></name> <operator>-</operator> <name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unlock an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check if another file-handle holds a RESERVED lock on an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** File control method. For custom operations on an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>paf</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>op</name><operator>==</operator><name>SQLITE_FCNTL_SIZE_HINT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>+=</operator> <name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>op</name><operator>==</operator><name>SQLITE_FCNTL_VFSNAME</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"apnd(%lld)/%z"</literal></expr></argument>, <argument><expr><name><name>paf</name><operator>-&gt;</operator><name>iPgOne</name></name></expr></argument>,<argument><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the sector-size in bytes for an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the device characteristic flags supported by an apnd-file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a shared memory file mapping */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>pgsz</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>,<argument><expr><name>iPg</name></expr></argument>,<argument><expr><name>pgsz</name></expr></argument>,<argument><expr><name>bExtend</name></expr></argument>,<argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Perform locking on a shared-memory segment */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Memory barrier operation on shared memory */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>apndShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Unmap a shared memory segment */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>,<argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fetch a page of a memory-mapped file */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndFetch</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iMark</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>iOfst</name><operator>+</operator><name>iAmt</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>iMark</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return> <comment type="block">/* Cannot read what is not yet there. */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFetch</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iOfst</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>iPgOne</name></name></expr></argument>, <argument><expr><name>iAmt</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release a memory-mapped page */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ApndFile</name> <operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pFile</name> <operator>=</operator> <call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnfetch</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iOfst</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>iPgOne</name></name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to read the append-mark off the end of a file.  Return the
** start of the appended database if the append-mark is present.
** If there is no valid append-mark, return -1;
**
** An append-mark is only valid if the NNNNNNNN start-of-database offset
** indicates that the appended database contains at least one page.  The
** start-of-database value must be a multiple of 512.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_int64</name></type> <name>apndReadMark</name><parameter_list>(<parameter><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMark</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>msbs</name> <init>= <expr><literal type="number">8</literal> <operator>*</operator> <operator>(</operator><name>APND_MARK_FOS_SZ</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>a</name><index>[<expr><name>APND_MARK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>APND_MARK_SIZE</name><operator>!=</operator><operator>(</operator><name>sz</name> <operator>&amp;</operator> <literal type="number">0x1ff</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>APND_MARK_SIZE</name></expr></argument>, <argument><expr><name>sz</name><operator>-</operator><name>APND_MARK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>APND_MARK_PREFIX</name></expr></argument>, <argument><expr><name>APND_MARK_PREFIX_SZ</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iMark</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name><name>a</name><index>[<expr><name>APND_MARK_PREFIX_SZ</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name>msbs</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>msbs</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMark</name> <operator>|=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><name>APND_MARK_PREFIX_SZ</name><operator>+</operator><name>i</name></expr>]</index></name><operator>&lt;&lt;</operator><name>msbs</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iMark</name> <operator>&gt;</operator> <operator>(</operator><name>sz</name> <operator>-</operator> <name>APND_MARK_SIZE</name> <operator>-</operator> <literal type="number">512</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMark</name> <operator>&amp;</operator> <literal type="number">0x1ff</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>iMark</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>apvfsSqliteHdr</name><index>[]</index></name> <init>= <expr><literal type="string">"SQLite format 3"</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/*
** Check to see if the file is an appendvfs SQLite database file.
** Return true iff it is such. Parameter sz is the file's size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndIsAppendvfsDatabase</name><parameter_list>(<parameter><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zHdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iMark</name> <init>= <expr><call><name>apndReadMark</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iMark</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If file has the correct end-marker, the expected odd size, and the
    ** SQLite DB type marker where the end-marker puts it, then it
    ** is an appendvfs database.
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name>
     <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><name>apvfsSqliteHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>&amp;&amp;</operator> <operator>(</operator><name>sz</name> <operator>&amp;</operator> <literal type="number">0x1ff</literal><operator>)</operator> <operator>==</operator> <name>APND_MARK_SIZE</name>
     <operator>&amp;&amp;</operator> <name>sz</name><operator>&gt;=</operator><literal type="number">512</literal><operator>+</operator><name>APND_MARK_SIZE</name></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* It's an appendvfs database */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the file is an ordinary SQLite database file.
** Return true iff so. Parameter sz is the file's size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndIsOrdinaryDatabaseFile</name><parameter_list>(<parameter><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zHdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>apndIsAppendvfsDatabase</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call> <comment type="block">/* rule 2 */</comment>
   <operator>||</operator> <operator>(</operator><name>sz</name> <operator>&amp;</operator> <literal type="number">0x1ff</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
   <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
   <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zHdr</name></expr></argument>, <argument><expr><name>apvfsSqliteHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Open an apnd file handle.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pApndVfs</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ApndFile</name> <modifier>*</modifier></type><name>pApndFile</name> <init>= <expr><operator>(</operator><name>ApndFile</name><operator>*</operator><operator>)</operator><name>pFile</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pBaseFile</name> <init>= <expr><call><name>ORIGFILE</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pBaseVfs</name> <init>= <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pApndVfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The appendvfs is not to be used for transient or temporary databases.
    ** Just use the base VFS open to initialize the given file object and
    ** open the underlying file. (Appendvfs is then unused for this file.)
    */</comment>
    <return>return <expr><call><name><name>pBaseVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pBaseVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pApndFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ApndFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>apnd_io_methods</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pApndFile</name><operator>-&gt;</operator><name>iMark</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* Append mark not yet written */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBaseVfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pBaseVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pBaseFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pBaseFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pBaseFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pBaseFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pBaseFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>apndIsOrdinaryDatabaseFile</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pBaseFile</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* The file being opened appears to be just an ordinary DB. Copy
    ** the base dispatch-table so this instance mimics the base VFS. 
    */</comment>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pApndFile</name></expr></argument>, <argument><expr><name>pBaseFile</name></expr></argument>, <argument><expr><name><name>pBaseVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pApndFile</name><operator>-&gt;</operator><name>iPgOne</name></name> <operator>=</operator> <call><name>apndReadMark</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pApndFile</name><operator>-&gt;</operator><name>iPgOne</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pApndFile</name><operator>-&gt;</operator><name>iMark</name></name> <operator>=</operator> <name>sz</name> <operator>-</operator> <name>APND_MARK_SIZE</name></expr>;</expr_stmt> <comment type="block">/* Append mark found */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_CREATE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pBaseFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pBaseFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Round newly added appendvfs location to #define'd page boundary. 
    ** Note that nothing has yet been written to the underlying file.
    ** The append mark will be written along with first content write.
    ** Until then, paf-&gt;iMark value indicates it is not yet written.
    */</comment>
    <expr_stmt><expr><name><name>pApndFile</name><operator>-&gt;</operator><name>iPgOne</name></name> <operator>=</operator> <call><name>APND_START_ROUNDUP</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete an apnd file.
** For an appendvfs, this could mean delete the appendvfs portion,
** leaving the appendee as it was before it gained an appendvfs.
** For now, this code deletes the underlying file too.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dirSync</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xDelete</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>dirSync</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** All other VFS methods are pass-thrus.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndAccess</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xAccess</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndFullPathname</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xFullPathname</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zPath</name></expr></argument>,<argument><expr><name>nOut</name></expr></argument>,<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>apndDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xDlOpen</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>apndDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xDlError</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*apndDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xDlSym</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSym</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>apndDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xDlClose</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBufOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xRandomness</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zBufOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nMicro</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xSleep</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nMicro</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pTimeOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xCurrentTime</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pTimeOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xGetLastError</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xCurrentTimeInt64</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apndSetSystemCall</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_syscall_ptr</name></type> <name>pCall</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xSetSystemCall</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><name>pCall</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sqlite3_syscall_ptr</name></type> <name>apndGetSystemCall</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xGetSystemCall</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>apndNextSystemCall</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>xNextSystemCall</name><argument_list>(<argument><expr><call><name>ORIGVFS</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* 
** This routine is called when the extension is loaded.
** Register the new VFS.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_appendvfs_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pOrig</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrig</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrig</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>apnd_vfs</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>iVersion</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apnd_vfs</name><operator>.</operator><name>pAppData</name></name> <operator>=</operator> <name>pOrig</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apnd_vfs</name><operator>.</operator><name>szOsFile</name></name> <operator>=</operator> <name><name>pOrig</name><operator>-&gt;</operator><name>szOsFile</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ApndFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>apnd_vfs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APPENDVFS_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>apndvfsRegister</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK_LOAD_PERMANENTLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/appendvfs.c ********************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/zipfile.c ******************/</comment>
<comment type="block">/*
** 2017-12-26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements a virtual table for reading and writing ZIP archive
** files.
**
** Usage example:
**
**     SELECT name, sz, datetime(mtime,'unixepoch') FROM zipfile($filename);
**
** Current limitations:
**
**    *  No support for encryption
**    *  No support for ZIP archives spanning multiple files
**    *  No support for zip64 extensions
**    *  Only the "inflate/deflate" (zlib) compression method is supported
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<decl_stmt><decl><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT32_TYPE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_UINT32_T</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_TYPE</name></cpp:macro> <cpp:value>uint32_t</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_TYPE</name></cpp:macro> <cpp:value>unsigned int</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT16_TYPE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_UINT16_T</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_TYPE</name></cpp:macro> <cpp:value>uint16_t</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_TYPE</name></cpp:macro> <cpp:value>unsigned short int</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* typedef sqlite3_int64 i64; */</comment>
<comment type="block">/* typedef unsigned char u8; */</comment>
<comment type="block">/* typedef UINT32_TYPE u32;           // 4-byte unsigned integer // */</comment>
<comment type="block">/* typedef UINT16_TYPE u16;           // 2-byte unsigned integer // */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a)&lt;(b) ? (a) : (b))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SQLITE_AMALGAMATION */</comment>

<comment type="block">/*
** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
**
** In some ways it would be better to obtain these values from system 
** header files. But, the dependency is undesirable and (a) these
** have been stable for decades, (b) the values are part of POSIX and
** are also made explicit in [man stat], and (c) are part of the 
** file format for zip archives.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFDIR</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFDIR</name></cpp:macro> <cpp:value>0040000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFREG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFREG</name></cpp:macro> <cpp:value>0100000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IFLNK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFLNK</name></cpp:macro> <cpp:value>0120000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ZIPFILE_SCHEMA</name><index>[]</index></name> <init>= 
  <expr><literal type="string">"CREATE TABLE y("</literal>
    <literal type="string">"name PRIMARY KEY,"</literal>  <comment type="block">/* 0: Name of file in zip archive */</comment>
    <literal type="string">"mode,"</literal>              <comment type="block">/* 1: POSIX mode for file */</comment>
    <literal type="string">"mtime,"</literal>             <comment type="block">/* 2: Last modification time (secs since 1970)*/</comment>
    <literal type="string">"sz,"</literal>                <comment type="block">/* 3: Size of object */</comment>
    <literal type="string">"rawdata,"</literal>           <comment type="block">/* 4: Raw data */</comment>
    <literal type="string">"data,"</literal>              <comment type="block">/* 5: Uncompressed data */</comment>
    <literal type="string">"method,"</literal>            <comment type="block">/* 6: Compression method (integer) */</comment>
    <literal type="string">"z HIDDEN"</literal>           <comment type="block">/* 7: Name of zip file */</comment>
  <literal type="string">") WITHOUT ROWID;"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_F_COLUMN_IDX</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* Index of column "file" in the above */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_BUFFER_SIZE</name></cpp:macro> <cpp:value>(64*1024)</cpp:value></cpp:define>


<comment type="block">/*
** Magic numbers used to read and write zip files.
**
** ZIPFILE_NEWENTRY_MADEBY:
**   Use this value for the "version-made-by" field in new zip file
**   entries. The upper byte indicates "unix", and the lower byte 
**   indicates that the zip file matches pkzip specification 3.0. 
**   This is what info-zip seems to do.
**
** ZIPFILE_NEWENTRY_REQUIRED:
**   Value for "version-required-to-extract" field of new entries.
**   Version 2.0 is required to support folders and deflate compression.
**
** ZIPFILE_NEWENTRY_FLAGS:
**   Value for "general-purpose-bit-flags" field of new entries. Bit
**   11 means "utf-8 filename and comment".
**
** ZIPFILE_SIGNATURE_CDS:
**   First 4 bytes of a valid CDS record.
**
** ZIPFILE_SIGNATURE_LFH:
**   First 4 bytes of a valid LFH record.
**
** ZIPFILE_SIGNATURE_EOCD
**   First 4 bytes of a valid EOCD record.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_EXTRA_TIMESTAMP</name></cpp:macro>   <cpp:value>0x5455</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_MADEBY</name></cpp:macro>   <cpp:value>((3&lt;&lt;8) + 30)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_REQUIRED</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_NEWENTRY_FLAGS</name></cpp:macro>    <cpp:value>0x800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_CDS</name></cpp:macro>     <cpp:value>0x02014b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_LFH</name></cpp:macro>     <cpp:value>0x04034b50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_SIGNATURE_EOCD</name></cpp:macro>    <cpp:value>0x06054b50</cpp:value></cpp:define>

<comment type="block">/*
** The sizes of the fixed-size part of each of the three main data 
** structures in a zip archive.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_LFH_FIXED_SZ</name></cpp:macro>      <cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_EOCD_FIXED_SZ</name></cpp:macro>     <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_FIXED_SZ</name></cpp:macro>      <cpp:value>46</cpp:value></cpp:define>

<comment type="block">/*
*** 4.3.16  End of central directory record:
***
***   end of central dir signature    4 bytes  (0x06054b50)
***   number of this disk             2 bytes
***   number of the disk with the
***   start of the central directory  2 bytes
***   total number of entries in the
***   central directory on this disk  2 bytes
***   total number of entries in
***   the central directory           2 bytes
***   size of the central directory   4 bytes
***   offset of start of central
***   directory with respect to
***   the starting disk number        4 bytes
***   .ZIP file comment length        2 bytes
***   .ZIP file comment       (variable size)
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileEOCD</name></name></type> <name>ZipfileEOCD</name>;</typedef>
<struct>struct <name>ZipfileEOCD</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iDisk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iFirstDisk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nEntryTotal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iOffset</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
*** 4.3.12  Central directory structure:
***
*** ...
***
***   central file header signature   4 bytes  (0x02014b50)
***   version made by                 2 bytes
***   version needed to extract       2 bytes
***   general purpose bit flag        2 bytes
***   compression method              2 bytes
***   last mod file time              2 bytes
***   last mod file date              2 bytes
***   crc-32                          4 bytes
***   compressed size                 4 bytes
***   uncompressed size               4 bytes
***   file name length                2 bytes
***   extra field length              2 bytes
***   file comment length             2 bytes
***   disk number start               2 bytes
***   internal file attributes        2 bytes
***   external file attributes        4 bytes
***   relative offset of local header 4 bytes
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileCDS</name></name></type> <name>ZipfileCDS</name>;</typedef>
<struct>struct <name>ZipfileCDS</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionMadeBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionExtract</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iCompression</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mDate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>crc32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szCompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szUncompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nExtra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nComment</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iDiskStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iInternalAttr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iExternalAttr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>                    <comment type="block">/* Filename (sqlite3_malloc()) */</comment>
}</block>;</struct>

<comment type="block">/*
*** 4.3.7  Local file header:
***
***   local file header signature     4 bytes  (0x04034b50)
***   version needed to extract       2 bytes
***   general purpose bit flag        2 bytes
***   compression method              2 bytes
***   last mod file time              2 bytes
***   last mod file date              2 bytes
***   crc-32                          4 bytes
***   compressed size                 4 bytes
***   uncompressed size               4 bytes
***   file name length                2 bytes
***   extra field length              2 bytes
***   
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileLFH</name></name></type> <name>ZipfileLFH</name>;</typedef>
<struct>struct <name>ZipfileLFH</name> <block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>iVersionExtract</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>iCompression</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>mDate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>crc32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szCompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szUncompressed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>nExtra</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileEntry</name></name></type> <name>ZipfileEntry</name>;</typedef>
<struct>struct <name>ZipfileEntry</name> <block>{
  <decl_stmt><decl><type><name>ZipfileCDS</name></type> <name>cds</name></decl>;</decl_stmt>            <comment type="block">/* Parsed CDS record */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mUnixTime</name></decl>;</decl_stmt>             <comment type="block">/* Modification time, in UNIX format */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aExtra</name></decl>;</decl_stmt>                <comment type="block">/* cds.nExtra+cds.nComment bytes of extra data */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iDataOff</name></decl>;</decl_stmt>              <comment type="block">/* Offset to data in file (if aData==0) */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>                 <comment type="block">/* cds.szCompressed bytes of compressed data */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>       <comment type="block">/* Next element in in-memory CDS */</comment>
}</block>;</struct>

<comment type="block">/* 
** Cursor type for zipfile tables.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ZipfileCsr</name></name></type> <name>ZipfileCsr</name>;</typedef>
<struct>struct <name>ZipfileCsr</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iId</name></decl>;</decl_stmt>                   <comment type="block">/* Cursor ID */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bEof</name></decl>;</decl_stmt>                   <comment type="block">/* True when at EOF */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bNoop</name></decl>;</decl_stmt>                  <comment type="block">/* If next xNext() call is no-op */</comment>

  <comment type="block">/* Used outside of write transactions */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl>;</decl_stmt>               <comment type="block">/* Zip file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iNextOff</name></decl>;</decl_stmt>              <comment type="block">/* Offset of next record in central directory */</comment>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>          <comment type="block">/* Parse of central directory record */</comment>

  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pFreeEntry</name></decl>;</decl_stmt>  <comment type="block">/* Free this list when cursor is closed or reset */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pCurrent</name></decl>;</decl_stmt>    <comment type="block">/* Current entry */</comment>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsrNext</name></decl>;</decl_stmt>      <comment type="block">/* Next cursor on same virtual table */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileTab</name></name></type> <name>ZipfileTab</name>;</typedef>
<struct>struct <name>ZipfileTab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>         <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>               <comment type="block">/* Zip file this table accesses (may be NULL) */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Host database connection */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl>;</decl_stmt>               <comment type="block">/* Temporary buffer used for various tasks */</comment>

  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsrList</name></decl>;</decl_stmt>      <comment type="block">/* List of cursors */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iNextCsrid</name></decl>;</decl_stmt>

  <comment type="block">/* The following are used by write transactions only */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pFirstEntry</name></decl>;</decl_stmt> <comment type="block">/* Linked list of all files (if pWriteFd!=0) */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pLastEntry</name></decl>;</decl_stmt>  <comment type="block">/* Last element in pFirstEntry list */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pWriteFd</name></decl>;</decl_stmt>            <comment type="block">/* File handle open on zip archive */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>szCurrent</name></decl>;</decl_stmt>             <comment type="block">/* Current size of zip archive */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>szOrig</name></decl>;</decl_stmt>                <comment type="block">/* Size of archive at start of transaction */</comment>
}</block>;</struct>

<comment type="block">/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCtxErrorMsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If string zIn is quoted, dequote it in place. Otherwise, if the string
** is not quoted, do nothing.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileDequote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>q</name> <init>= <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'`'</literal> <operator>||</operator> <name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>q</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>q</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>zIn</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>q</name> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>iIn</name><operator>++</operator></expr>]</index></name><operator>!=</operator><name>q</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Construct a new ZipfileTab virtual table object.
** 
**   argv[0]   -&gt; module name  ("zipfile")
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; "column name" and other module argument fields.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileTab</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>ZIPFILE_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* If the table name is not "zipfile", require that the argument be
  ** specified. This stops zipfile tables from being created as:
  **
  **   CREATE VIRTUAL TABLE zzz USING zipfile();
  **
  ** It does not prevent:
  **
  **   CREATE VIRTUAL TABLE zipfile USING zipfile();
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">0</literal><operator>!=</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name><operator>&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>||</operator> <name>argc</name><operator>&gt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile constructor requires one argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFile</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>ZIPFILE_SCHEMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>nByte</name><operator>+</operator><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name><operator>+</operator><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aBuffer</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zFile</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aBuffer</name><index>[<expr><name>ZIPFILE_BUFFER_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>nFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>zipfileDequote</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_vtab_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_VTAB_DIRECTONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the ZipfileEntry structure indicated by the only argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileEntryFree</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Release resources that should be freed at the end of a write 
** transaction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCleanupTransaction</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szOrig</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This method is the destructor for zipfile vtab objects.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Constructor for a new ZipfileCsr object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCsr</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name><operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name> <operator>=</operator> <operator>++</operator><name><name>pTab</name><operator>-&gt;</operator><name>iNextCsrid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset a cursor back to the state it was in when first returned
** by zipfileOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileResetCursor</name><parameter_list>(<parameter><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Destructor for an ZipfileCsr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>zipfileResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove this cursor from the ZipfileTab.pCsrList list. */</comment>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pCsr</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pCsrNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error message for the virtual table associated with cursor
** pCsr to the results of vprintf(zFmt, ...).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileTableErr</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileCursorErr</name><parameter_list>(<parameter><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Read nRead bytes of data from offset iOff of file pFile into buffer
** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
** otherwise. 
**
** If an error does occur, output variable (*pzErrmsg) may be set to point
** to an English language error message. It is the responsibility of the
** caller to eventually free this buffer using
** sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadData</name><parameter_list>(
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* Read from this file */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name></decl></parameter>,                      <comment type="block">/* Read into this buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>nRead</name></decl></parameter>,                      <comment type="block">/* Number of bytes to read */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* Offset to read from */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (from sqlite3_malloc) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>iOff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>!=</operator><name>nRead</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrmsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error in fread()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendData</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aWrite</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nWrite</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>nWrite</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>aWrite</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>!=</operator><name>nWrite</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"error in fwrite()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>u16</name></type> <name>zipfileGetU16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileGetU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator>
       <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write a 16-bit little endiate integer into buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfilePutU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>u16</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write a 32-bit little endiate integer into buffer aBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfilePutU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRead32</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( aBuf+=4, zipfileGetU32(aBuf-4) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRead16</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( aBuf+=2, zipfileGetU16(aBuf-2) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileWrite32</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ zipfilePutU32(aBuf,val); aBuf+=4; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileWrite16</name><parameter_list>(<parameter><type><name>aBuf</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ zipfilePutU16(aBuf,val); aBuf+=2; }</cpp:value></cpp:define>

<comment type="block">/*
** Magic numbers used to read CDS records.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_NFILE_OFF</name></cpp:macro>        <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPFILE_CDS_SZCOMPRESSED_OFF</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<comment type="block">/*
** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadCDS</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>sig</name> <init>= <expr><call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sig</name><operator>!=</operator><name>ZIPFILE_SIGNATURE_CDS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionExtract</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aRead</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iDiskStart</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iInternalAttr</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aRead</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_FIXED_SZ</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadLFH</name><parameter_list>(
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuffer</name></decl></parameter>,
  <parameter><decl><type><name>ZipfileLFH</name> <modifier>*</modifier></type><name>pLFH</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name>aBuffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>u32</name></type> <name>sig</name> <init>= <expr><call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>sig</name><operator>!=</operator><name>ZIPFILE_SIGNATURE_LFH</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>iVersionExtract</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>iCompression</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>szCompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>szUncompressed</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>nFile</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLFH</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
** Scan through this buffer to find an "extra-timestamp" field. If one
** exists, extract the 32-bit modification-timestamp from it and store
** the value in output parameter *pmTime.
**
** Zero is returned if no extra-timestamp record could be found (and so
** *pmTime is left unchanged), or non-zero otherwise.
**
** The general format of an extra field is:
**
**   Header ID    2 bytes
**   Data Size    2 bytes
**   Data         N bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileScanExtra</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aExtra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nExtra</name></decl></parameter>, <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pmTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>aExtra</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aExtra</name><index>[<expr><name>nExtra</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>p</name><operator>&lt;</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>id</name> <init>= <expr><call><name>zipfileRead16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u16</name></type> <name>nByte</name> <init>= <expr><call><name>zipfileRead16</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch<condition>( <expr><name>id</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>u8</name></type> <name>b</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>b</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr> )</condition><block>{<block_content>     <comment type="block">/* 0x01 -&gt; modtime is present */</comment>
          <expr_stmt><expr><operator>*</operator><name>pmTime</name> <operator>=</operator> <call><name>zipfileGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the standard MS-DOS timestamp stored in the mTime and mDate
** fields of the CDS structure passed as the only argument to a 32-bit
** UNIX seconds-since-the-epoch timestamp. Return the result.
**
** "Standard" MS-DOS time format:
**
**   File modification time:
**     Bits 00-04: seconds divided by 2
**     Bits 05-10: minute
**     Bits 11-15: hour
**   File modification date:
**     Bits 00-04: day
**     Bits 05-08: month (1-12)
**     Bits 09-15: years from 1980 
**
** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileMtime</name><parameter_list>(<parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>Y</name></decl>,<decl><type ref="prev"/><name>M</name></decl>,<decl><type ref="prev"/><name>D</name></decl>,<decl><type ref="prev"/><name>X1</name></decl>,<decl><type ref="prev"/><name>X2</name></decl>,<decl><type ref="prev"/><name>A</name></decl>,<decl><type ref="prev"/><name>B</name></decl>,<decl><type ref="prev"/><name>sec</name></decl>,<decl><type ref="prev"/><name>min</name></decl>,<decl><type ref="prev"/><name>hr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>JDsec</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>Y</name> <operator>=</operator> <operator>(</operator><literal type="number">1980</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>M</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>D</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>hr</name> <operator>=</operator> <operator>(</operator><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name> <operator>&gt;&gt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>M</name><operator>&lt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>Y</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>M</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>X1</name> <operator>=</operator> <literal type="number">36525</literal><operator>*</operator><operator>(</operator><name>Y</name><operator>+</operator><literal type="number">4716</literal><operator>)</operator><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>X2</name> <operator>=</operator> <literal type="number">306001</literal><operator>*</operator><operator>(</operator><name>M</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">10000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>A</name> <operator>=</operator> <name>Y</name><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>B</name> <operator>=</operator> <literal type="number">2</literal> <operator>-</operator> <name>A</name> <operator>+</operator> <operator>(</operator><name>A</name><operator>/</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>JDsec</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>X1</name> <operator>+</operator> <name>X2</name> <operator>+</operator> <name>D</name> <operator>+</operator> <name>B</name> <operator>-</operator> <literal type="number">1524.5</literal><operator>)</operator><operator>*</operator><literal type="number">86400</literal><operator>)</operator> <operator>+</operator> <name>hr</name><operator>*</operator><literal type="number">3600</literal> <operator>+</operator> <name>min</name><operator>*</operator><literal type="number">60</literal> <operator>+</operator> <name>sec</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name>JDsec</name> <operator>-</operator> <operator>(</operator><name>i64</name><operator>)</operator><literal type="number">24405875</literal><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">8640</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The opposite of zipfileMtime(). This function populates the mTime and
** mDate fields of the CDS structure passed as the first argument according
** to the UNIX timestamp value passed as the second.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileMtimeToDos</name><parameter_list>(<parameter><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCds</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>mUnixTime</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>JD</name> <init>= <expr><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">2440588</literal> <operator>+</operator> <name>mUnixTime</name> <operator>/</operator> <operator>(</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>A</name></decl>, <decl><type ref="prev"/><name>B</name></decl>, <decl><type ref="prev"/><name>C</name></decl>, <decl><type ref="prev"/><name>D</name></decl>, <decl><type ref="prev"/><name>E</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yr</name></decl>, <decl><type ref="prev"/><name>mon</name></decl>, <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hr</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>sec</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>A</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>JD</name> <operator>-</operator> <literal type="number">1867216.25</literal><operator>)</operator><operator>/</operator><literal type="number">36524.25</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>A</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>JD</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>A</name> <operator>-</operator> <operator>(</operator><name>A</name><operator>/</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>B</name> <operator>=</operator> <name>A</name> <operator>+</operator> <literal type="number">1524</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>C</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>B</name> <operator>-</operator> <literal type="number">122.1</literal><operator>)</operator><operator>/</operator><literal type="number">365.25</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>D</name> <operator>=</operator> <operator>(</operator><literal type="number">36525</literal><operator>*</operator><operator>(</operator><name>C</name><operator>&amp;</operator><literal type="number">32767</literal><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>E</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>B</name><operator>-</operator><name>D</name><operator>)</operator><operator>/</operator><literal type="number">30.6001</literal><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>day</name> <operator>=</operator> <name>B</name> <operator>-</operator> <name>D</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">30.6001</literal><operator>*</operator><name>E</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>mon</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>E</name><operator>&lt;</operator><literal type="number">14</literal></expr> ?</condition><then> <expr><name>E</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>E</name><operator>-</operator><literal type="number">13</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>yr</name> <operator>=</operator> <ternary><condition><expr><name>mon</name><operator>&gt;</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name>C</name><operator>-</operator><literal type="number">4716</literal></expr> </then><else>: <expr><name>C</name><operator>-</operator><literal type="number">4715</literal></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name>hr</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <operator>(</operator><literal type="number">24</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <operator>(</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">60</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>sec</name> <operator>=</operator> <operator>(</operator><name>mUnixTime</name> <operator>%</operator> <literal type="number">60</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>yr</name><operator>&gt;=</operator><literal type="number">1980</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>day</name> <operator>+</operator> <operator>(</operator><name>mon</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>yr</name><operator>-</operator><literal type="number">1980</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><name>sec</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>min</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>hr</name><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name> <operator>=</operator> <name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mUnixTime</name><operator>&lt;</operator><literal type="number">315507600</literal> 
       <operator>||</operator> <name>mUnixTime</name><operator>==</operator><call><name>zipfileMtime</name><argument_list>(<argument><expr><name>pCds</name></expr></argument>)</argument_list></call> 
       <operator>||</operator> <operator>(</operator><operator>(</operator><name>mUnixTime</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>mUnixTime</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><call><name>zipfileMtime</name><argument_list>(<argument><expr><name>pCds</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument> 
       <comment type="block">/* || (mUnixTime % 2) */</comment>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
** size) containing an entire zip archive image. Or, if aBlob is NULL,
** then pFile is a file-handle open on a zip file. In either case, this
** function creates a ZipfileEntry object based on the zip archive entry
** for which the CDS record is at offset iOff.
**
** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
** the new object. Otherwise, an SQLite error code is returned and the
** final value of (*ppEntry) undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileGetEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,               <comment type="block">/* Store any error message here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>,                <comment type="block">/* Pointer to in-memory file image */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>,                      <comment type="block">/* Size of aBlob[] in bytes */</comment>
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* If aBlob==0, read from this file */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>,                       <comment type="block">/* Offset of CDS record */</comment>
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppEntry</name></decl></parameter>          <comment type="block">/* OUT: Pointer to new object */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>ZIPFILE_CDS_FIXED_SZ</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>iOff</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>nFile</name> <init>= <expr><call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> <init>= <expr><call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nExtra</name> <operator>+=</operator> <call><name>zipfileGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nExtra</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBlob</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <call><name>zipfileGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>ZIPFILE_CDS_SZCOMPRESSED_OFF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>ZipfileEntry</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadCDS</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"failed to read CDS at offset %lld"</literal></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(
            <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>nExtra</name><operator>+</operator><name>nFile</name></expr></argument>, <argument><expr><name>iOff</name><operator>+</operator><name>ZIPFILE_CDS_FIXED_SZ</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>iOff</name> <operator>+</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>nFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>nFile</name></expr>]</index></name></expr></argument>, <argument><expr><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>zipfileScanExtra</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aRead</name><index>[<expr><name>nFile</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name> <operator>=</operator> <call><name>zipfileMtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>szFix</name> <init>= <expr><name>ZIPFILE_LFH_FIXED_SZ</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ZipfileLFH</name></type> <name>lfh</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pFile</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>szFix</name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadLFH</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>=</operator>  <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>+</operator> <name>ZIPFILE_LFH_FIXED_SZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>+=</operator> <name><name>lfh</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>lfh</name><operator>.</operator><name>nExtra</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aBlob</name> <operator>&amp;&amp;</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aExtra</name><index>[<expr><name>nExtra</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>aData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name><name>pNew</name><operator>-&gt;</operator><name>iDataOff</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"failed to read LFH at offset %d"</literal></expr></argument>, 
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppEntry</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Advance an ZipfileCsr to its next row of output.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iEof</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>nSize</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name><operator>&gt;=</operator><name>iEof</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>+=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nComment</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content> 
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<comment type="block">/*
** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
** size is nOut bytes. This function uncompresses the data and sets the
** return value in context pCtx to the result (a blob).
**
** If an error occurs, an error code is left in pCtx instead.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileInflate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,          <comment type="block">/* Store result here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>,                  <comment type="block">/* Compressed data */</comment>
  <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>,                        <comment type="block">/* Size of buffer aIn[] in bytes */</comment>
  <parameter><decl><type><name>int</name></type> <name>nOut</name></decl></parameter>                        <comment type="block">/* Expected output size */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRes</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>aRes</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_stream</name></type> <name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><name>aIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><name>aRes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>err</name><operator>!=</operator><name>Z_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileCtxErrorMsg</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"inflateInit2() failed (%d)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>err</name><operator>!=</operator><name>Z_STREAM_END</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>zipfileCtxErrorMsg</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"inflate() failed (%d)"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aRes</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>zipfileFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aRes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Buffer aIn (size nIn bytes) contains uncompressed data. This function
** compresses it and sets (*ppOut) to point to a buffer containing the
** compressed data. The caller is responsible for eventually calling
** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut) 
** is set to the size of buffer (*ppOut) in bytes.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
** code is returned and an error message left in virtual-table handle
** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
** case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileDeflate</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>,         <comment type="block">/* Input */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnOut</name></decl></parameter>,         <comment type="block">/* Output */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>z_stream</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><name>aIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>deflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <call><name>deflateBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aOut</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>nAlloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>Z_STREAM_END</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>aOut</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pnOut</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>str</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: deflate() error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>deflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>   <comment type="block">/* name */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">1</literal></expr>:</case>   <comment type="block">/* mode */</comment>
      <comment type="block">/* TODO: Whether or not the following is correct surely depends on
      ** the platform on which the archive was created.  */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content> <comment type="block">/* mtime */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">3</literal></expr>:</case> <block>{<block_content> <comment type="block">/* sz */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_nochange</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">4</literal></expr>:</case>   <comment type="block">/* rawdata */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_vtab_nochange</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <case>case <expr><literal type="number">5</literal></expr>:</case> <block>{<block_content> <comment type="block">/* data */</comment>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">4</literal> <operator>||</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>szFinal</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>szFinal</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>aData</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>aData</name></name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>aBuf</name> <operator>=</operator> <name>aFree</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>aBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if<condition>( <expr><name>pFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>pFile</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>pWriteFd</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>iDataOff</name></name></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>
              )</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>zipfileInflate</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>szFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* Figure out if this is a directory or a zero-sized file. Consider
          ** it to be a directory either if the mode suggests so, or if
          ** the final character in the name is '/'.  */</comment>
          <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>S_IFDIR</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name><index>[<expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">6</literal></expr>:</case>   <comment type="block">/* method */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>  <comment type="block">/* z */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><literal type="number">7</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the cursor is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
** is guaranteed to be a file-handle open on a zip file.
**
** This function attempts to locate the EOCD record within the zip archive
** and populate *pEOCD with the results of decoding it. SQLITE_OK is
** returned if successful. Otherwise, an SQLite error code is returned and
** an English language error message may be left in virtual-table pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileReadEOCD</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,               <comment type="block">/* Return errors here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>,                <comment type="block">/* Pointer to in-memory file image */</comment>
  <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>,                      <comment type="block">/* Size of aBlob[] in bytes */</comment>
  <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,                    <comment type="block">/* Read from this file if aBlob==0 */</comment>
  <parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>pEOCD</name></decl></parameter>              <comment type="block">/* Object to populate */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRead</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Temporary buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name></decl>;</decl_stmt>                      <comment type="block">/* Bytes to read from file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pEOCD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEOCD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>                     <comment type="block">/* Offset to read from */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>szFile</name></decl>;</decl_stmt>                   <comment type="block">/* Total size of file in bytes */</comment>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szFile</name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>ftell</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>szFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>szFile</name></expr></argument>, <argument><expr><name>ZIPFILE_BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name>szFile</name> <operator>-</operator> <name>nRead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadData</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>aRead</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nRead</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name>ZIPFILE_BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>aRead</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aBlob</name><index>[<expr><name>nBlob</name><operator>-</operator><name>nRead</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Scan backwards looking for the signature bytes */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nRead</name><operator>-</operator><literal type="number">20</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aRead</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0x50</literal> <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0x4b</literal> 
       <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0x05</literal> <operator>&amp;&amp;</operator> <name><name>aRead</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="number">0x06</literal></expr> 
      )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"cannot find end of central directory record"</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>aRead</name> <operator>+=</operator> <name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iDisk</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iFirstDisk</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nEntryTotal</name></name> <operator>=</operator> <call><name>zipfileRead16</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>nSize</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pEOCD</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <call><name>zipfileRead32</name><argument_list>(<argument><expr><name>aRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry 
** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
** to the end of the list. Otherwise, it is added to the list immediately
** before pBefore (which is guaranteed to be a part of said list).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileAddEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, 
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pBefore</name></decl></parameter>, 
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBefore</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name><operator>!=</operator><name>pBefore</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pBefore</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileLoadDirectory</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iOff</name> <operator>=</operator> <name><name>eocd</name><operator>.</operator><name>iOffset</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>eocd</name><operator>.</operator><name>nEntry</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileAddEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nExtra</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nComment</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xFilter callback.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ZipfileCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Zip file to scan */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bInMemory</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* True for an in-memory zipfile */</comment>

  <expr_stmt><expr><call><name>zipfileResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>zipfileCursorErr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"zipfile() function requires an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name>aEmptyBlob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aBlob</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aBlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>aBlob</name> <operator>=</operator> <operator>&amp;</operator><name>aEmptyBlob</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileLoadDirectory</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pLastEntry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bInMemory</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><name>bInMemory</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileCursorErr</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="string">"cannot open file: %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileReadEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>nEntry</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bEof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iNextOff</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>eocd</name><operator>.</operator><name>iOffset</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr> ?</condition><then> <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pFreeEntry</name></name></expr> </then><else>: <expr><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xBestIndex callback.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>unusable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>!=</operator><name>ZIPFILE_F_COLUMN_IDX</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>unusable</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>unusable</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZipfileEntry</name> <modifier>*</modifier></type><name>zipfileNewEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeLFH</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCds</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCds</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>

  <comment type="block">/* Write the LFH itself */</comment>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_LFH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_LFH_FIXED_SZ</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the file name */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCds</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCds</name><operator>-&gt;</operator><name>nFile</name></name></expr>;</expr_stmt>

  <comment type="block">/* The "extra" data */</comment>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>a</name><operator>++</operator> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendEntry</name><parameter_list>(
  <parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <call><name>zipfileSerializeLFH</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>iDataOff</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileGetMode</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>bIsDir</name></decl></parameter>,                     <comment type="block">/* If true, default to directory */</comment>
  <parameter><decl><type><name>u32</name> <modifier>*</modifier></type><name>pMode</name></decl></parameter>,                     <comment type="block">/* OUT: Mode value */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bIsDir</name></expr> ?</condition><then> <expr><operator>(</operator><name>S_IFDIR</name> <operator>+</operator> <literal type="number">0755</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>S_IFREG</name> <operator>+</operator> <literal type="number">0644</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>zTemplate</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <init>= <expr><literal type="string">"-rwxrwxrwx"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFREG</name></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFDIR</name></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'l'</literal></expr>:</case> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <name>S_IFLNK</name></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default> <goto>goto <name>parse_error</name>;</goto>
    </block_content>}</block></switch>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>zTemplate</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">9</literal><operator>-</operator><name>i</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parse_error</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>S_IFDIR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><name>bIsDir</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The "mode" attribute is a directory, but data has been specified.
    ** Or vice-versa - no data but "mode" is a file or symlink.  */</comment>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: mode does not match data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pMode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

 <label><name>parse_error</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: parse error in mode: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Both (const char*) arguments point to nul-terminated strings. Argument
** nB is the value of strlen(zB). This function returns 0 if the strings are
** identical, ignoring any trailing '/' character in either path.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileComparePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nA</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zA</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nA</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zA</name><index>[<expr><name>nA</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nA</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nB</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zB</name><index>[<expr><name>nB</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nB</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nA</name><operator>==</operator><name>nB</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zA</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>, <argument><expr><name>nA</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBegin</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pTab</name><operator>-&gt;</operator><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile: missing filename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Open a write fd on the file. Also load the entire central directory
  ** structure into memory. During the transaction any new file data is 
  ** appended to the archive file, but the central directory is accumulated
  ** in main-memory until the transaction is committed.  */</comment>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><literal type="string">"ab+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"zipfile: failed to open file %s for writing"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>szOrig</name></name> <operator>=</operator> <operator>(</operator><name>i64</name><operator>)</operator><call><name>ftell</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileLoadDirectory</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current time as a 32-bit timestamp in UNIX epoch format (like
** time(2)).
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>ret</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVfs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVfs</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>ms</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ms</name><operator>/</operator><literal type="number">1000</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><literal type="number">24405875</literal> <operator>*</operator> <literal type="number">8640</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>day</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pVfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>day</name> <operator>-</operator> <literal type="number">2440587.5</literal><operator>)</operator> <operator>*</operator> <literal type="number">86400</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a 32-bit timestamp in UNIX epoch format.
**
** If the value passed as the only argument is either NULL or an SQL NULL,
** return the current time. Otherwise, return the value stored in (*pVal)
** cast to a 32-bit unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>zipfileGetTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pVal</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>zipfileTime</name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Unless it is NULL, entry pOld is currently part of the pTab-&gt;pFirstEntry
** linked list.  Remove it from the list and free the object.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileRemoveEntryFromList</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pOld</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>pOld</name></expr>;</condition> <incr><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileEntryFree</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xUpdate method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* New in-memory CDS entry */</comment>

  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Mode for new entry */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>mTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Modification time for new entry */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* Uncompressed size */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Path for new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* strlen(zPath) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Pointer to buffer containing content */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of pData buffer in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Compression method for new entry */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Free this */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Also free this */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pOld2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bUpdate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* True for an update that modifies "name" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIsDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iCrc32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileBegin</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If this is a DELETE or UPDATE, find the archive entry to delete. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDelete</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDelete</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zDelete</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUpdate</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zUpdate</name> <operator>&amp;&amp;</operator> <call><name>zipfileComparePath</name><argument_list>(<argument><expr><name>zUpdate</name></expr></argument>, <argument><expr><name>zDelete</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bUpdate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pOld</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><literal type="number">1</literal></expr>;</condition> <incr><expr><name>pOld</name><operator>=</operator><name><name>pOld</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>zipfileComparePath</name><argument_list>(<argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zDelete</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOld</name><operator>-&gt;</operator><name>pNext</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Check that "sz" and "rawdata" are both NULL: */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"sz must be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"rawdata must be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* data=NULL. A directory */</comment>
        <expr_stmt><expr><name>bIsDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Value specified for "data", and possibly "method". This must be
        ** a regular file or a symlink. */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aIn</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bAuto</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <name>aIn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMethod</name><operator>!=</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"unknown compression method: %d"</literal></expr></argument>, <argument><expr><name>iMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>bAuto</name> <operator>||</operator> <name>iMethod</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nCmp</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileDeflate</name><argument_list>(<argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nCmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>iMethod</name> <operator>||</operator> <name>nCmp</name><operator>&lt;</operator><name>nIn</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>pData</name> <operator>=</operator> <name>pFree</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nCmp</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>iCrc32</name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetMode</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bIsDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zPath</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nPath</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mTime</name> <operator>=</operator> <call><name>zipfileGetTime</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bIsDir</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For a directory, check that the last character in the path is a
      ** '/'. This appears to be required for compatibility with info-zip
      ** (the unzip command on unix). It does not create directories
      ** otherwise.  */</comment>
      <if_stmt><if>if<condition>( <expr><name>nPath</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zPath</name><index>[<expr><name>nPath</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFree</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zFree</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zFree</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nPath</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>nPath</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check that we're not inserting a duplicate entry -OR- updating an
    ** entry with a path, thereby making it into a duplicate. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pOld</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>bUpdate</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>zipfileComparePath</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>nPath</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <switch>switch<condition>( <expr><call><name>sqlite3_vtab_on_conflict</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <case>case <expr><name>SQLITE_IGNORE</name></expr>:</case> <block>{<block_content>
              <goto>goto <name>zipfile_update_done</name>;</goto>
            </block_content>}</block>
            <case>case <expr><name>SQLITE_REPLACE</name></expr>:</case> <block>{<block_content>
              <expr_stmt><expr><name>pOld2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block>
            <default>default:</default> <block>{<block_content>
              <expr_stmt><expr><call><name>zipfileTableErr</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="string">"duplicate name: \"%s\""</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CONSTRAINT</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block>
          </block_content>}</block></switch>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Create the new CDS record. */</comment>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>zipfileNewEntry</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_MADEBY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iVersionExtract</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_REQUIRED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_FLAGS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iCompression</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iMethod</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zipfileMtimeToDos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>, <argument><expr><name>mTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <name>iCrc32</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>szUncompressed</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iExternalAttr</name></name> <operator>=</operator> <operator>(</operator><name>mode</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nPath</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>mUnixTime</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>mTime</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zipfileAddEntry</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pOld</name> <operator>||</operator> <name>pOld2</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><name>pOld</name> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name><operator>==</operator><name>pOld2</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bNoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>zipfileRemoveEntryFromList</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileRemoveEntryFromList</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pOld2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>zipfile_update_done</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeEOCD</name><parameter_list>(<parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_EOCD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iFirstDisk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nEntryTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Size of trailing comment in bytes*/</comment>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileAppendEOCD</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>ZipfileEOCD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><call><name>zipfileSerializeEOCD</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nBuf</name><operator>==</operator><name>ZIPFILE_EOCD_FIXED_SZ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Serialize the CDS structure into buffer aBuf[]. Return the number
** of bytes written.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileSerializeCDS</name><parameter_list>(<parameter><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>aBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>pCDS</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_SIGNATURE_CDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name><operator>==</operator><operator>&amp;</operator><name><name>aBuf</name><index>[<expr><name>ZIPFILE_CDS_NFILE_OFF</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iDiskStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iInternalAttr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iExternalAttr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>pCDS</name><operator>-&gt;</operator><name>nFile</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pCDS</name><operator>-&gt;</operator><name>nComment</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>aExtra</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCDS</name><operator>-&gt;</operator><name>nExtra</name></name><operator>==</operator><literal type="number">9</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ZIPFILE_EXTRA_TIMESTAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite16</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>a</name><operator>++</operator> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipfileWrite32</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>a</name><operator>-</operator><name>aBuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pWriteFd</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Write out all entries */</comment>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pFirstEntry</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>zipfileSerializeCDS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendData</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aBuffer</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nEntry</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Write out the EOCD record */</comment>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iDisk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iFirstDisk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntry</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntryTotal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>szCurrent</name></name> <operator>-</operator> <name>iOffset</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileAppendEOCD</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zipfileCleanupTransaction</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileRollback</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>zipfileCommit</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZipfileCsr</name> <modifier>*</modifier></type><name>zipfileFindCursor</name><parameter_list>(<parameter><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCsr</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pCsrList</name></name></expr>;</init> <condition><expr><name>pCsr</name></expr>;</condition> <incr><expr><name>pCsr</name><operator>=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCsrNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iId</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iId</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>pCsr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFunctionCds</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileTab</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>ZipfileTab</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>zipfileFindCursor</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ZipfileCDS</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pCurrent</name><operator>-&gt;</operator><name>cds</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRes</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"{"</literal>
        <literal type="string">"\"version-made-by\" : %u, "</literal>
        <literal type="string">"\"version-to-extract\" : %u, "</literal>
        <literal type="string">"\"flags\" : %u, "</literal>
        <literal type="string">"\"compression\" : %u, "</literal>
        <literal type="string">"\"time\" : %u, "</literal>
        <literal type="string">"\"date\" : %u, "</literal>
        <literal type="string">"\"crc32\" : %u, "</literal>
        <literal type="string">"\"compressed-size\" : %u, "</literal>
        <literal type="string">"\"uncompressed-size\" : %u, "</literal>
        <literal type="string">"\"file-name-length\" : %u, "</literal>
        <literal type="string">"\"extra-field-length\" : %u, "</literal>
        <literal type="string">"\"file-comment-length\" : %u, "</literal>
        <literal type="string">"\"disk-number-start\" : %u, "</literal>
        <literal type="string">"\"internal-attr\" : %u, "</literal>
        <literal type="string">"\"external-attr\" : %u, "</literal>
        <literal type="string">"\"offset\" : %u }"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iVersionMadeBy</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iVersionExtract</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iCompression</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>mTime</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>mDate</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>szCompressed</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>szUncompressed</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nFile</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nExtra</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nComment</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iDiskStart</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iInternalAttr</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iExternalAttr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zRes</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRes</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xFindFunction method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileFindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,            <comment type="block">/* Virtual table handle */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Number of SQL function arguments */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name of SQL function */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <comment type="block">/* OUT: Result */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>                    <comment type="block">/* OUT: User data for *pxFunc */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"zipfile_cds"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>zipfileFunctionCds</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppArg</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileBuffer</name></name></type> <name>ZipfileBuffer</name>;</typedef>
<struct>struct <name>ZipfileBuffer</name> <block>{
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>                          <comment type="block">/* Pointer to buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                          <comment type="block">/* Size of buffer in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>                     <comment type="block">/* Byte allocated at a[] */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ZipfileCtx</name></name></type> <name>ZipfileCtx</name>;</typedef>
<struct>struct <name>ZipfileCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileBuffer</name></type> <name>body</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileBuffer</name></type> <name>cds</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileBufferGrow</name><parameter_list>(<parameter><decl><type><name>ZipfileBuffer</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name><name>pBuf</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNew</name> <init>= <expr><ternary><condition><expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">512</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nReq</name> <init>= <expr><name><name>pBuf</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <name>nByte</name></expr></init></decl>;</decl_stmt>

    <while>while<condition>( <expr><name>nNew</name><operator>&lt;</operator><name>nReq</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name>nNew</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>aNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pBuf</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>a</name></name> <operator>=</operator> <name>aNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuf</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nNew</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** xStep() callback for the zipfile() aggregate. This can be called in
** any of the following ways:
**
**   SELECT zipfile(name,data) ...
**   SELECT zipfile(name,mode,mtime,data) ...
**   SELECT zipfile(name,mode,mtime,data,method) ...
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Aggregate function context */</comment>
  <decl_stmt><decl><type><name>ZipfileEntry</name></type> <name>e</name></decl>;</decl_stmt>                 <comment type="block">/* New entry to add to zip archive */</comment>

  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMtime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>bIsDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>iMethod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Compression method to use (0 or 8) */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Possibly compressed data for new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of aData[] in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szUncompressed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Size of data before compression */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Free this before returning */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iCrc32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* crc32 of uncompressed data */</comment>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Path (name) of new entry */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Size of zName in bytes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Free this before returning */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>ZipfileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Martial the arguments into stack variables */</comment>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>!=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>nVal</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments to function zipfile()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>zipfile_step_out</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pName</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pMode</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMtime</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nVal</name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pMethod</name> <operator>=</operator> <name><name>apVal</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Check that the 'name' parameter looks ok. */</comment>
  <expr_stmt><expr><name>zName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"first argument to zipfile() must be non-NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>zipfile_step_out</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
  ** deflate compression) or NULL (choose automatically).  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pMethod</name> <operator>&amp;&amp;</operator> <name>SQLITE_NULL</name><operator>!=</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pMethod</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iMethod</name><operator>!=</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"illegal method value: %d"</literal></expr></argument>, <argument><expr><name>iMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>zipfile_step_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now inspect the data. If this is NULL, then the new entry must be a
  ** directory.  Otherwise, figure out whether or not the data should
  ** be deflated or simply stored in the zip archive. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bIsDir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>szUncompressed</name> <operator>=</operator> <name>nData</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCrc32</name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iMethod</name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileDeflate</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aFree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <goto>goto <name>zipfile_step_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iMethod</name><operator>==</operator><literal type="number">8</literal> <operator>||</operator> <name>nOut</name><operator>&lt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <name>aFree</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nData</name> <operator>=</operator> <name>nOut</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iMethod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Decode the "mode" argument. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zipfileGetMode</name><argument_list>(<argument><expr><name>pMode</name></expr></argument>, <argument><expr><name>bIsDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Decode the "mtime" argument. */</comment>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>mUnixTime</name></name> <operator>=</operator> <call><name>zipfileGetTime</name><argument_list>(<argument><expr><name>pMtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a directory entry, ensure that there is exactly one '/'
  ** at the end of the path. Or, if this is not a directory and the path
  ** ends in '/' it is an error. */</comment>
  <if_stmt><if>if<condition>( <expr><name>bIsDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nName</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"non-directory name must not end with /"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>zipfile_step_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'/'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <name>zFree</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>zipfile_step_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nName</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><name>nName</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zName</name><index>[<expr><name>nName</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nName</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Assemble the ZipfileEntry object for the new zip archive entry */</comment>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iVersionMadeBy</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_MADEBY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iVersionExtract</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_REQUIRED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>ZIPFILE_NEWENTRY_FLAGS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iCompression</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>iMethod</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zipfileMtimeToDos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>.</operator><name>cds</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u32</name><operator>)</operator><name><name>e</name><operator>.</operator><name>mUnixTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>crc32</name></name> <operator>=</operator> <name>iCrc32</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>szCompressed</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>szUncompressed</name></name> <operator>=</operator> <name>szUncompressed</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iExternalAttr</name></name> <operator>=</operator> <operator>(</operator><name>mode</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name>nName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>

  <comment type="block">/* Append the LFH to the body of the new archive */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>ZIPFILE_LFH_FIXED_SZ</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <call><name>zipfileSerializeLFH</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append the data to the body of the new archive */</comment>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Append the CDS record to the directory of the new archive */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name>ZIPFILE_CDS_FIXED_SZ</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>cds</name><operator>.</operator><name>nFile</name></name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zipfileBufferGrow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>zipfile_step_out</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name> <operator>+=</operator> <call><name>zipfileSerializeCDS</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Increment the count of entries in the archive */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>++</operator></expr>;</expr_stmt>

 <label><name>zipfile_step_out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** xFinalize() callback for zipfile aggregate function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipfileFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ZipfileCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ZipfileEOCD</name></type> <name>eocd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nZip</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aZip</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>ZipfileCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZipfileCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>eocd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntry</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nEntryTotal</name></name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>nSize</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>eocd</name><operator>.</operator><name>iOffset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>nZip</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name>ZIPFILE_EOCD_FIXED_SZ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aZip</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nZip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>aZip</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aZip</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aZip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>zipfileSerializeEOCD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eocd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aZip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>n</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>n</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aZip</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nZip</name></expr></argument>, <argument><expr><name>zipfileFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>cds</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Register the "zipfile" virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zipfileRegister</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>zipfileModule</name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,                         <comment type="block">/* iVersion */</comment>
    <expr><name>zipfileConnect</name></expr>,            <comment type="block">/* xCreate */</comment>
    <expr><name>zipfileConnect</name></expr>,            <comment type="block">/* xConnect */</comment>
    <expr><name>zipfileBestIndex</name></expr>,          <comment type="block">/* xBestIndex */</comment>
    <expr><name>zipfileDisconnect</name></expr>,         <comment type="block">/* xDisconnect */</comment>
    <expr><name>zipfileDisconnect</name></expr>,         <comment type="block">/* xDestroy */</comment>
    <expr><name>zipfileOpen</name></expr>,               <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>zipfileClose</name></expr>,              <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>zipfileFilter</name></expr>,             <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>zipfileNext</name></expr>,               <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>zipfileEof</name></expr>,                <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>zipfileColumn</name></expr>,             <comment type="block">/* xColumn - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRowid - read data */</comment>
    <expr><name>zipfileUpdate</name></expr>,             <comment type="block">/* xUpdate */</comment>
    <expr><name>zipfileBegin</name></expr>,              <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
    <expr><name>zipfileCommit</name></expr>,             <comment type="block">/* xCommit */</comment>
    <expr><name>zipfileRollback</name></expr>,           <comment type="block">/* xRollback */</comment>
    <expr><name>zipfileFindFunction</name></expr>,       <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>  , <argument><expr><operator>&amp;</operator><name>zipfileModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile_cds"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"zipfile"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
        <argument><expr><name>zipfileStep</name></expr></argument>, <argument><expr><name>zipfileFinal</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">8</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>         <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>zipfileRegister</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SQLITE_OK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_zipfile_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <return>return <expr><call><name>zipfileRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/zipfile.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/misc/sqlar.c ******************/</comment>
<comment type="block">/*
** 2017-12-17
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** Utility functions sqlar_compress() and sqlar_uncompress(). Useful
** for working with sqlar archives and used by the shell tool's built-in
** sqlar support.
*/</comment>
<comment type="block">/* #include "sqlite3ext.h" */</comment>
<function><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Implementation of the "sqlar_compress(X)" SQL function.
**
** If the type of X is SQLITE_BLOB, and compressing that blob using
** zlib utility function compress() yields a smaller blob, return the
** compressed blob. Otherwise, return a copy of X.
**
** SQLar uses the "zlib format" for compressed content.  The zlib format
** contains a two-byte identification header and a four-byte checksum at
** the end.  This is different from ZIP which uses the raw deflate format.
**
** Future enhancements to SQLar might add support for new compression formats.
** If so, those new formats will be identified by alternative headers in the
** compressed data.
*/</comment>
<specifier>static</specifier> <name>void</name></type> <name>sqlarCompressFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>nData</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLongf</name></type> <name>nOut</name> <init>= <expr><call><name>compressBound</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>(</operator><name>Bytef</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>Z_OK</name><operator>!=</operator><call><name>compress</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOut</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"error in compress()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nOut</name><operator>&lt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the "sqlar_uncompress(X,SZ)" SQL function
**
** Parameter SZ is interpreted as an integer. If it is less than or
** equal to zero, then this function returns a copy of X. Or, if
** SZ is equal to the size of X when interpreted as a blob, also
** return a copy of X. Otherwise, decompress blob X using zlib
** utility function uncompress() and return the results (another
** blob).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlarUncompressFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>uLong</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uLongf</name></type> <name>sz</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>sz</name><operator>==</operator><operator>(</operator><name>nData</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>pData</name><init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>Z_OK</name><operator>!=</operator><call><name>uncompress</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"error in uncompress()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_sqlar_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlar_compress"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, 
                               <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>sqlarCompressFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlar_uncompress"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name><operator>|</operator><name>SQLITE_INNOCUOUS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>sqlarUncompressFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************* End ../ext/misc/sqlar.c ********************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/************************* Begin ../ext/expert/sqlite3expert.h ******************/</comment>
<comment type="block">/*
** 2017 April 07
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITEEXPERT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITEEXPERT_H</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/* #include "sqlite3.h" */</comment>

<typedef>typedef <type><name><name>struct</name> <name>sqlite3expert</name></name></type> <name>sqlite3expert</name>;</typedef>

<comment type="block">/*
** Create a new sqlite3expert object.
**
** If successful, a pointer to the new object is returned and (*pzErr) set
** to NULL. Or, if an error occurs, NULL is returned and (*pzErr) set to
** an English-language error message. In this case it is the responsibility
** of the caller to eventually free the error message buffer using
** sqlite3_free().
*/</comment>
<function_decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>sqlite3_expert_new</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Configure an sqlite3expert object.
**
** EXPERT_CONFIG_SAMPLE:
**   By default, sqlite3_expert_analyze() generates sqlite_stat1 data for
**   each candidate index. This involves scanning and sorting the entire
**   contents of each user database table once for each candidate index
**   associated with the table. For large databases, this can be 
**   prohibitively slow. This option allows the sqlite3expert object to
**   be configured so that sqlite_stat1 data is instead generated based on a
**   subset of each table, or so that no sqlite_stat1 data is used at all.
**
**   A single integer argument is passed to this option. If the value is less
**   than or equal to zero, then no sqlite_stat1 data is generated or used by
**   the analysis - indexes are recommended based on the database schema only.
**   Or, if the value is 100 or greater, complete sqlite_stat1 data is
**   generated for each candidate index (this is the default). Finally, if the
**   value falls between 0 and 100, then it represents the percentage of user
**   table rows that should be considered when generating sqlite_stat1 data.
**
**   Examples:
**
**     // Do not generate any sqlite_stat1 data
**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 0);
**
**     // Generate sqlite_stat1 data based on 10% of the rows in each table.
**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 10);
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_expert_config</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPERT_CONFIG_SAMPLE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* int */</comment>

<comment type="block">/*
** Specify zero or more SQL statements to be included in the analysis.
**
** Buffer zSql must contain zero or more complete SQL statements. This
** function parses all statements contained in the buffer and adds them
** to the internal list of statements to analyze. If successful, SQLITE_OK
** is returned and (*pzErr) set to NULL. Or, if an error occurs - for example
** due to a error in the SQL - an SQLite error code is returned and (*pzErr)
** may be set to point to an English language error message. In this case
** the caller is responsible for eventually freeing the error message buffer
** using sqlite3_free().
**
** If an error does occur while processing one of the statements in the
** buffer passed as the second argument, none of the statements in the
** buffer are added to the analysis.
**
** This function must be called before sqlite3_expert_analyze(). If a call
** to this function is made on an sqlite3expert object that has already
** been passed to sqlite3_expert_analyze() SQLITE_MISUSE is returned
** immediately and no statements are added to the analysis.
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_expert_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* From a successful sqlite3_expert_new() */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL statement(s) to add */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message (if any) */</comment>
)</parameter_list>;</function_decl>


<comment type="block">/*
** This function is called after the sqlite3expert object has been configured
** with all SQL statements using sqlite3_expert_sql() to actually perform
** the analysis. Once this function has been called, it is not possible to
** add further SQL statements to the analysis.
**
** If successful, SQLITE_OK is returned and (*pzErr) is set to NULL. Or, if
** an error occurs, an SQLite error code is returned and (*pzErr) set to 
** point to a buffer containing an English language error message. In this
** case it is the responsibility of the caller to eventually free the buffer
** using sqlite3_free().
**
** If an error does occur within this function, the sqlite3expert object
** is no longer useful for any purpose. At that point it is no longer
** possible to add further SQL statements to the object or to re-attempt
** the analysis. The sqlite3expert object must still be freed using a call
** sqlite3_expert_destroy().
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_expert_analyze</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Return the total number of statements loaded using sqlite3_expert_sql().
** The total number of SQL statements may be different from the total number
** to calls to sqlite3_expert_sql().
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_expert_count</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Return a component of the report.
**
** This function is called after sqlite3_expert_analyze() to extract the
** results of the analysis. Each call to this function returns either a
** NULL pointer or a pointer to a buffer containing a nul-terminated string.
** The value passed as the third argument must be one of the EXPERT_REPORT_*
** #define constants defined below.
**
** For some EXPERT_REPORT_* parameters, the buffer returned contains 
** information relating to a specific SQL statement. In these cases that
** SQL statement is identified by the value passed as the second argument.
** SQL statements are numbered from 0 in the order in which they are parsed.
** If an out-of-range value (less than zero or equal to or greater than the
** value returned by sqlite3_expert_count()) is passed as the second argument
** along with such an EXPERT_REPORT_* parameter, NULL is always returned.
**
** EXPERT_REPORT_SQL:
**   Return the text of SQL statement iStmt.
**
** EXPERT_REPORT_INDEXES:
**   Return a buffer containing the CREATE INDEX statements for all recommended
**   indexes for statement iStmt. If there are no new recommeded indexes, NULL 
**   is returned.
**
** EXPERT_REPORT_PLAN:
**   Return a buffer containing the EXPLAIN QUERY PLAN output for SQL query
**   iStmt after the proposed indexes have been added to the database schema.
**
** EXPERT_REPORT_CANDIDATES:
**   Return a pointer to a buffer containing the CREATE INDEX statements 
**   for all indexes that were tested (for all SQL statements). The iStmt
**   parameter is ignored for EXPERT_REPORT_CANDIDATES calls.
*/</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_expert_report</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eReport</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Values for the third argument passed to sqlite3_expert_report().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPERT_REPORT_SQL</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPERT_REPORT_INDEXES</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPERT_REPORT_PLAN</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPERT_REPORT_CANDIDATES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** Free an (sqlite3expert*) handle and all associated resources. There 
** should be one call to this function for each successful call to 
** sqlite3-expert_new().
*/</comment>
<function_decl><type><name>void</name></type> <name>sqlite3_expert_destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !defined(SQLITEEXPERT_H) */</comment>

<comment type="block" format="doxygen">/************************* End ../ext/expert/sqlite3expert.h ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/expert/sqlite3expert.c ******************/</comment>
<comment type="block">/*
** 2017 April 09
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/</comment>
<comment type="block">/* #include "sqlite3expert.h" */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_AMALGAMATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MUTATION_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((X)?1:(assert(0),0))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>((X)?(assert(0),1):0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ALWAYS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(X)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>NEVER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_AMALGAMATION) */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef> 

<comment type="block">/* typedef sqlite3_int64 i64; */</comment>
<comment type="block">/* typedef sqlite3_uint64 u64; */</comment>

<typedef>typedef <type><name><name>struct</name> <name>IdxColumn</name></name></type> <name>IdxColumn</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxConstraint</name></name></type> <name>IdxConstraint</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxScan</name></name></type> <name>IdxScan</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxStatement</name></name></type> <name>IdxStatement</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxTable</name></name></type> <name>IdxTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxWrite</name></name></type> <name>IdxWrite</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name></cpp:macro>  <cpp:value>(int)strlen</cpp:value></cpp:define>

<comment type="block">/*
** A temp table name that we assume no user database will actually use.
** If this assumption proves incorrect triggers on the table with the
** conflicting name will be ignored.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIQUE_TABLE_NAME</name></cpp:macro> <cpp:value>"t592690916721053953805701627921227776"</cpp:value></cpp:define>

<comment type="block">/*
** A single constraint. Equivalent to either "col = ?" or "col &lt; ?" (or
** any other type of single-ended range constraint on a column).
**
** pLink:
**   Used to temporarily link IdxConstraint objects into lists while
**   creating candidate indexes.
*/</comment>
<struct>struct <name>IdxConstraint</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>                    <comment type="block">/* Collation sequence */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRange</name></decl>;</decl_stmt>                     <comment type="block">/* True for range, false for eq */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>                       <comment type="block">/* Constrained table column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFlag</name></decl>;</decl_stmt>                      <comment type="block">/* Used by idxFindCompatible() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDesc</name></decl>;</decl_stmt>                      <comment type="block">/* True if ORDER BY &lt;expr&gt; DESC */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>           <comment type="block">/* Next constraint in pEq or pRange list */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pLink</name></decl>;</decl_stmt>           <comment type="block">/* See above */</comment>
}</block>;</struct>

<comment type="block">/*
** A single scan of a single table.
*/</comment>
<struct>struct <name>IdxScan</name> <block>{
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>                 <comment type="block">/* Associated table object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                        <comment type="block">/* Database containing table zTable */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>covering</name></decl>;</decl_stmt>                   <comment type="block">/* Mask of columns required for cov. index */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pOrder</name></decl>;</decl_stmt>          <comment type="block">/* ORDER BY columns */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl>;</decl_stmt>             <comment type="block">/* List of == constraints */</comment>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pRange</name></decl>;</decl_stmt>          <comment type="block">/* List of &lt; constraints */</comment>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pNextScan</name></decl>;</decl_stmt>             <comment type="block">/* Next IdxScan object for same analysis */</comment>
}</block>;</struct>

<comment type="block">/*
** Information regarding a single database table. Extracted from 
** "PRAGMA table_info" by function idxGetTableInfo().
*/</comment>
<struct>struct <name>IdxColumn</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPk</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>IdxTable</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>                    <comment type="block">/* Table name */</comment>
  <decl_stmt><decl><type><name>IdxColumn</name> <modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>                <comment type="block">/* Next table in linked list of all tables */</comment>
}</block>;</struct>

<comment type="block">/*
** An object of the following type is created for each unique table/write-op
** seen. The objects are stored in a singly-linked list beginning at
** sqlite3expert.pWrite.
*/</comment>
<struct>struct <name>IdxWrite</name> <block>{
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eOp</name></decl>;</decl_stmt>                        <comment type="block">/* SQLITE_UPDATE, DELETE or INSERT */</comment>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Each statement being analyzed is represented by an instance of this
** structure.
*/</comment>
<struct>struct <name>IdxStatement</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iId</name></decl>;</decl_stmt>                        <comment type="block">/* Statement number */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                     <comment type="block">/* SQL statement */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl>;</decl_stmt>                     <comment type="block">/* Indexes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEQP</name></decl>;</decl_stmt>                     <comment type="block">/* Plan */</comment>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
** A hash table for storing strings. With space for a payload string
** with each entry. Methods are:
**
**   idxHashInit()
**   idxHashClear()
**   idxHashAdd()
**   idxHashSearch()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDX_HASH_SIZE</name></cpp:macro> <cpp:value>1023</cpp:value></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>IdxHashEntry</name></name></type> <name>IdxHashEntry</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>IdxHash</name></name></type> <name>IdxHash</name>;</typedef>
<struct>struct <name>IdxHashEntry</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>                     <comment type="block">/* nul-terminated key */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>                     <comment type="block">/* nul-terminated value string */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVal2</name></decl>;</decl_stmt>                    <comment type="block">/* nul-terminated value string 2 */</comment>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pHashNext</name></decl>;</decl_stmt>        <comment type="block">/* Next entry in same hash bucket */</comment>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>            <comment type="block">/* Next entry in hash */</comment>
}</block>;</struct>
<struct>struct <name>IdxHash</name> <block>{
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name><name>aHash</name><index>[<expr><name>IDX_HASH_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** sqlite3expert object.
*/</comment>
<struct>struct <name>sqlite3expert</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iSample</name></decl>;</decl_stmt>                    <comment type="block">/* Percentage of tables to sample for stat1 */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* User database */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name></decl>;</decl_stmt>                   <comment type="block">/* In-memory db for this analysis */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbv</name></decl>;</decl_stmt>                   <comment type="block">/* Vtab schema for this analysis */</comment>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>               <comment type="block">/* List of all IdxTable objects */</comment>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl>;</decl_stmt>                 <comment type="block">/* List of scan objects */</comment>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>               <comment type="block">/* List of write objects */</comment>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStatement</name></decl>;</decl_stmt>       <comment type="block">/* List of IdxStatement objects */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRun</name></decl>;</decl_stmt>                       <comment type="block">/* True once analysis has run */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Error code from whereinfo hook */</comment>
  <decl_stmt><decl><type><name>IdxHash</name></type> <name>hIdx</name></decl>;</decl_stmt>                   <comment type="block">/* Hash containing all candidate indexes */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCandidates</name></decl>;</decl_stmt>              <comment type="block">/* For EXPERT_REPORT_CANDIDATES */</comment>
}</block>;</struct>


<comment type="block">/*
** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc(). 
** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>idxMalloc</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize an IdxHash hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxHashInit</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Reset an IdxHash hash table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxHashClear</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>IDX_HASH_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the index of the hash bucket that the string specified by the
** arguments to this function belongs.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxHashString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>(</operator><name>ret</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ret</name> <operator>%</operator> <name>IDX_HASH_SIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If zKey is already present in the hash table, return non-zero and do
** nothing. Otherwise, add an entry with key zKey and payload string zVal to
** the hash table passed as the second argument. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxHashAdd</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name> <init>= <expr><call><name>idxHashString</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>zVal</name></expr> ?</condition><then> <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHash</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nKey</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxHashEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nKey</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <name>nVal</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pEntry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name><index>[<expr><name>nKey</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pHash</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pHash</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>pEntry</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If zKey/nKey is present in the hash table, return a pointer to the 
** hash-entry object.
*/</comment>
<function><type><specifier>static</specifier> <name>IdxHashEntry</name> <modifier>*</modifier></type><name>idxHashFind</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iHash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nKey</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iHash</name> <operator>=</operator> <call><name>idxHashString</name><argument_list>(<argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHash</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>pHash</name><operator>-&gt;</operator><name>aHash</name><index>[<expr><name>iHash</name></expr>]</index></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pHashNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>nKey</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>pEntry</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the hash table contains an entry with a key equal to the string
** passed as the final two arguments to this function, return a pointer
** to the payload string. Otherwise, if zKey/nKey is not present in the
** hash table, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxHashSearch</name><parameter_list>(<parameter><decl><type><name>IdxHash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>idxHashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
** variable to point to a copy of nul-terminated string zColl.
*/</comment>
<function><type><specifier>static</specifier> <name>IdxConstraint</name> <modifier>*</modifier></type><name>idxNewConstraint</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nColl</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>IdxConstraint</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxConstraint</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nColl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zColl</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>nColl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An error associated with database handle db has just occurred. Pass
** the error message to callback function xOut.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxDatabaseError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* Write error here */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pzErrmsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Prepare an SQL statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPrepareStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle to compile against */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,          <comment type="block">/* OUT: Compiled SQL statement */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>,                <comment type="block">/* OUT: sqlite3_malloc()ed error message */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>                <comment type="block">/* SQL statement to compile */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Prepare an SQL statement using the results of a printf() formatting.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPrintfPrepareStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database handle to compile against */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,          <comment type="block">/* OUT: Compiled SQL statement */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>,                <comment type="block">/* OUT: sqlite3_malloc()ed error message */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>,               <comment type="block">/* printf() format of SQL statement */</comment>
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>                             <comment type="block">/* Trailing printf() arguments */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************************************
** Beginning of virtual table implementation.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ExpertVtab</name></name></type> <name>ExpertVtab</name>;</typedef>
<struct>struct <name>ExpertVtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>ExpertCsr</name></name></type> <name>ExpertCsr</name>;</typedef>
<struct>struct <name>ExpertCsr</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>expertDequote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iIn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iIn</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iIn</name><operator>&lt;</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>iIn</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zIn</name><index>[<expr><name>iIn</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iIn</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>iOut</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zIn</name><index>[<expr><name>iIn</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** This function is the implementation of both the xConnect and xCreate
** methods of the r-tree virtual table.
**
**   argv[0]   -&gt; module name
**   argv[1]   -&gt; database name
**   argv[2]   -&gt; table name
**   argv[...] -&gt; column names...
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name> <init>= <expr><operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><name>pAux</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"internal error!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCreateTable</name> <init>= <expr><call><name>expertDequote</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCreateTable</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCreateTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpertVtab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExpert</name></name> <operator>=</operator> <name>pExpert</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>pExpert</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreateTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opmask</name> <init>= 
    <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name> <operator>|</operator> <name>SQLITE_INDEX_CONSTRAINT_GT</name> <operator>|</operator>
    <name>SQLITE_INDEX_CONSTRAINT_LT</name> <operator>|</operator> <name>SQLITE_INDEX_CONSTRAINT_GE</name> <operator>|</operator>
    <name>SQLITE_INDEX_CONSTRAINT_LE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pScan</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxScan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pScan</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Link the new scan object into the list */</comment>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pNextScan</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pExpert</name><operator>-&gt;</operator><name>pScan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pExpert</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <name>pScan</name></expr>;</expr_stmt>

    <comment type="block">/* Add the constraints to the IdxScan object */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pCons</name> <init>= <expr><operator>&amp;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>usable</name></name> 
       <operator>&amp;&amp;</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> 
       <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name></expr>]</index></name><operator>.</operator><name>iPk</name><operator>==</operator><literal type="number">0</literal>
       <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;</operator> <name>opmask</name><operator>)</operator></expr> 
      )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><call><name>sqlite3_vtab_collation</name><argument_list>(<argument><expr><name>pIdxInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>idxNewConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name><name>pCons</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bRange</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Add the ORDER BY to the IdxScan object */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><call><name>idxNewConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zColl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bDesc</name></name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pLink</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pOrder</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1000000.0</literal> <operator>/</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expertUpdate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>azData</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>azData</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pRowid</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xOpen method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pVTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpertCsr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name><operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xClose method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Virtual table module xEof method.
**
** Return non-zero if the cursor does not currently point to a valid 
** record (i.e if the scan has finished), or zero otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xNext method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xRowid method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cur</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xColumn method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVal</name> <operator>=</operator> <call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVal</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Virtual table module xFilter method.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ExpertCsr</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>ExpertCsr</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpertVtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><operator>(</operator><name>ExpertVtab</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name> <init>= <expr><name><name>pVtab</name><operator>-&gt;</operator><name>pExpert</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>idxStr</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>pExpert</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pVtab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name></expr></argument>,
        <argument><expr><literal type="string">"SELECT * FROM main.%Q WHERE sample()"</literal></expr></argument>, <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expertNext</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxRegisterVtab</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>expertModule</name> <init>= <expr><block>{
    <expr><literal type="number">2</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><name>expertConnect</name></expr>,                <comment type="block">/* xCreate - create a table */</comment>
    <expr><name>expertConnect</name></expr>,                <comment type="block">/* xConnect - connect to an existing table */</comment>
    <expr><name>expertBestIndex</name></expr>,              <comment type="block">/* xBestIndex - Determine search strategy */</comment>
    <expr><name>expertDisconnect</name></expr>,             <comment type="block">/* xDisconnect - Disconnect from a table */</comment>
    <expr><name>expertDisconnect</name></expr>,             <comment type="block">/* xDestroy - Drop a table */</comment>
    <expr><name>expertOpen</name></expr>,                   <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>expertClose</name></expr>,                  <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>expertFilter</name></expr>,                 <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>expertNext</name></expr>,                   <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>expertEof</name></expr>,                    <comment type="block">/* xEof */</comment>
    <expr><name>expertColumn</name></expr>,                 <comment type="block">/* xColumn - read data */</comment>
    <expr><name>expertRowid</name></expr>,                  <comment type="block">/* xRowid - read data */</comment>
    <expr><name>expertUpdate</name></expr>,                 <comment type="block">/* xUpdate - write data */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xBegin - begin transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSync - sync transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCommit - commit transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollback - rollback transaction */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xFindFunction - function overloading */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRename - rename the table */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><literal type="string">"expert"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expertModule</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** End of virtual table implementation.
*************************************************************************/</comment>
<comment type="block">/*
** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
** is called, set it to the return value of sqlite3_finalize() before
** returning. Otherwise, discard the sqlite3_finalize() return value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxFinalize</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to allocate an IdxTable structure corresponding to table zTab
** in the main database of connection db. If successful, set (*ppOut) to
** point to the new object and return SQLITE_OK. Otherwise, return an
** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
** set to point to an error string.
**
** It is the responsibility of the caller to eventually free either the
** IdxTable object or error message using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxGetTableInfo</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database connection to read details from */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,               <comment type="block">/* Table name */</comment>
  <parameter><decl><type><name>IdxTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>,               <comment type="block">/* OUT: New object (if successful) */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>                 <comment type="block">/* OUT: Error message (if not) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nTab</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IdxTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nTab</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA table_xinfo=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zColSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zColSeq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColSeq</name> <operator>=</operator> <literal type="string">"binary"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zColSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPk</name> <operator>+=</operator> <operator>(</operator><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IdxColumn</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nCol</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>IdxColumn</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nCol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zCol</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>zName</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>iPk</name> <operator>=</operator> <operator>(</operator><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nPk</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zColSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zColSeq</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zColSeq</name> <operator>=</operator> <literal type="string">"binary"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zColSeq</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name><operator>.</operator><name>zColl</name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zColSeq</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCsr</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pNew</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>pCsr</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>nTab</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if *pRc is set to anything other than 
** SQLITE_OK when it is called.
**
** If *pRc is initially set to SQLITE_OK, then the text specified by
** the printf() style arguments is appended to zIn and the result returned
** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
** zIn before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>idxAppendText</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zAppend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> <init>= <expr><ternary><condition><expr><name>zIn</name></expr> ?</condition><then> <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAppend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zAppend</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zAppend</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAppend</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nIn</name> <operator>+</operator> <name>nAppend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zAppend</name> <operator>&amp;&amp;</operator> <name>zRet</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nIn</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zRet</name><index>[<expr><name>nIn</name></expr>]</index></name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>, <argument><expr><name>nAppend</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if zId must be quoted in order to use it as an SQL
** identifier, or false otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxIdentifierRequiresQuotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nId</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_keyword_check</name><argument_list>(<argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>zId</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function appends an index column definition suitable for constraint
** pCons to the string passed as zIn and returns the result.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>idxAppendColDefn</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* IN/OUT: Error code */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>,                      <comment type="block">/* Column defn accumulated so far */</comment>
  <parameter><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,                 <comment type="block">/* Table index will be created on */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCons</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxColumn</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name><name>pCons</name><operator>-&gt;</operator><name>iCol</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zRet</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"%Q"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %Q"</literal></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><name><name>pCons</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pCons</name><operator>-&gt;</operator><name>bDesc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Search database dbm for an index compatible with the one idxCreateFromCons()
** would create from arguments pScan, pEq and pTail. If no error occurs and 
** such an index is found, return non-zero. Or, if no such index is found,
** return zero.
**
** If an error occurs, set *pRc to an SQLite error code and return zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindCompatible</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>,                       <comment type="block">/* OUT: Error code */</comment>
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>dbm</name></decl></parameter>,                   <comment type="block">/* Database to search */</comment>
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,                 <comment type="block">/* Scan for table to search for index on */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl></parameter>,             <comment type="block">/* List of == constraints */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>            <comment type="block">/* List of range constraints */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIdxList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Number of elements in pEq */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Count the elements in list pEq */</comment>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nEq</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIdxList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_list=%Q"</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bMatch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pT</name> <init>= <expr><name>pTail</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* Zero the IdxConstraint.bFlag values in the pEq list */</comment>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_xInfo=%Q"</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>iIdx</name><operator>&lt;</operator><name>nEq</name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pIter</name><operator>-&gt;</operator><name>iCol</name></name><operator>!=</operator><name>iCol</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>pIter</name><operator>-&gt;</operator><name>bFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pIter</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pT</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pT</name><operator>-&gt;</operator><name>iCol</name></name><operator>!=</operator><name>iCol</name> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>pT</name><operator>-&gt;</operator><name>zColl</name></name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pT</name> <operator>=</operator> <name><name>pT</name><operator>-&gt;</operator><name>pLink</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bMatch</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pIdxList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Callback for sqlite3_exec() with query with leading count(*) column.
 * The first argument is expected to be an int*, referent to be incremented
 * if that leading column is not exactly '0'.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>countNonzeros</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nc</name></decl></parameter>,
                         <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>azResults</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>azColumns</name><index>[]</index></name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>azColumns</name></expr>;</expr_stmt>  <comment type="block">/* Suppress unused parameter warning */</comment>
  <if_stmt><if>if<condition>( <expr><name>nc</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>azResults</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'0'</literal> <operator>||</operator> <name><name>azResults</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pCount</name><operator>)</operator> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateFromCons</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pEq</name></decl></parameter>, 
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pEq</name> <operator>||</operator> <name>pTail</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>idxFindCompatible</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pEq</name></expr></argument>, <argument><expr><name>pTail</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCons</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>pCons</name><operator>=</operator><name>pEq</name></expr>;</init> <condition><expr><name>pCons</name></expr>;</condition> <incr><expr><name>pCons</name><operator>=</operator><name><name>pCons</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendColDefn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for<control>(<init><expr><name>pCons</name><operator>=</operator><name>pTail</name></expr>;</init> <condition><expr><name>pCons</name></expr>;</condition> <incr><expr><name>pCons</name><operator>=</operator><name><name>pCons</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendColDefn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Hash the list of columns to come up with a name for the index */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>quoteTable</name> <init>= <expr><call><name>idxIdentifierRequiresQuotes</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Index name */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>collisions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <do>do<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFind</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zCols</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>h</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>h</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name><name>zCols</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s_idx_%08x"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* Is is unique among table, view and index names? */</comment>
        <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"SELECT count(*) FROM sqlite_schema WHERE name=%Q"</literal>
          <literal type="string">" AND type in ('index','table','view')"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zFind</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>zFind</name></expr></argument>, <argument><expr><name>countNonzeros</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>collisions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>collisions</name></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><name>collisions</name><operator>&lt;</operator><literal type="number">50</literal> <operator>&amp;&amp;</operator> <name>zName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
      <if_stmt><if>if<condition>( <expr><name>collisions</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* This return means "Gave up trying to find a unique index name." */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_TIMEOUT</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>quoteTable</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"CREATE INDEX \"%w\" ON \"%w\"(%s)"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zFmt</name> <operator>=</operator> <literal type="string">"CREATE INDEX %s ON %s(%s)"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zIdx</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pzErrmsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY_TIMEOUT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>idxHashAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if list pList (linked by IdxConstraint.pLink) contains
** a constraint compatible with *p. Otherwise return false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindConstraint</name><parameter_list>(<parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pList</name></decl></parameter>, <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCmp</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pCmp</name><operator>=</operator><name>pList</name></expr>;</init> <condition><expr><name>pCmp</name></expr>;</condition> <incr><expr><name>pCmp</name><operator>=</operator><name><name>pCmp</name><operator>-&gt;</operator><name>pLink</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iCol</name></name><operator>==</operator><name><name>pCmp</name><operator>-&gt;</operator><name>iCol</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateFromWhere</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>,                 <comment type="block">/* Create indexes for this scan */</comment>
  <parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pTail</name></decl></parameter>            <comment type="block">/* range/ORDER BY constraints for inclusion */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pCon</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Gather up all the == constraints. */</comment>
  <for>for<control>(<init><expr><name>pCon</name><operator>=</operator><name><name>pScan</name><operator>-&gt;</operator><name>pEq</name></name></expr>;</init> <condition><expr><name>pCon</name></expr>;</condition> <incr><expr><name>pCon</name><operator>=</operator><name><name>pCon</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>pTail</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCon</name><operator>-&gt;</operator><name>pLink</name></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>pCon</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Create an index using the == constraints collected above. And the
  ** range constraint/ORDER BY terms passed in by the caller, if any. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromCons</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no range/ORDER BY passed by the caller, create a version of the
  ** index for each range constraint.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>pCon</name><operator>=</operator><name><name>pScan</name><operator>-&gt;</operator><name>pRange</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pCon</name></expr>;</condition> <incr><expr><name>pCon</name><operator>=</operator><name><name>pCon</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCon</name><operator>-&gt;</operator><name>pLink</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>idxFindConstraint</name><argument_list>(<argument><expr><name>pTail</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromCons</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>pCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create candidate indexes in database [dbm] based on the data in 
** linked-list pScan.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateCandidates</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr>;</init> <condition><expr><name>pIter</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNextScan</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromWhere</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pOrder</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateFromWhere</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name><name>pIter</name><operator>-&gt;</operator><name>pOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting at pConstraint.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxConstraintFree</name><parameter_list>(<parameter><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pConstraint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxConstraint</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pConstraint</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting from pScan up until pLast
** (pLast is not freed).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxScanFree</name><parameter_list>(<parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScan</name></decl></parameter>, <parameter><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pScan</name></expr>;</init> <condition><expr><name>p</name><operator>!=</operator><name>pLast</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNextScan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pEq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxConstraintFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free all elements of the linked list starting from pStatement up 
** until pLast (pLast is not freed).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxStatementFree</name><parameter_list>(<parameter><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStatement</name></decl></parameter>, <parameter><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pLast</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name>pStatement</name></expr>;</init> <condition><expr><name>p</name><operator>!=</operator><name>pLast</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zEQP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free the linked list of IdxTable objects starting at pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxTableFree</name><parameter_list>(<parameter><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pTab</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Free the linked list of IdxWrite objects starting at pTab.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxWriteFree</name><parameter_list>(<parameter><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pTab</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block">/*
** This function is called after candidate indexes have been created. It
** runs all the queries to see which indexes they prefer, and populates
** IdxStatement.zIdx and IdxStatement.zEQP with the results.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxFindIndexes</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                         <comment type="block">/* OUT: Error message (sqlite3_malloc) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbm</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>IdxHash</name></type> <name>hIdx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>idxHashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pStmt</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pStmt</name></expr>;</condition> <incr><expr><name>pStmt</name><operator>=</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pExplain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name>dbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExplain</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>,
        <argument><expr><literal type="string">"EXPLAIN QUERY PLAN %s"</literal></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* int iId = sqlite3_column_int(pExplain, 0); */</comment>
      <comment type="block">/* int iParent = sqlite3_column_int(pExplain, 1); */</comment>
      <comment type="block">/* int iNotUsed = sqlite3_column_int(pExplain, 2); */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDetail</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nDetail</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zDetail</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nDetail</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>zDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nDetail</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">13</literal><operator>&lt;</operator><name>nDetail</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">" USING INDEX "</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">13</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">22</literal><operator>&lt;</operator><name>nDetail</name> 
            <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">" USING COVERING INDEX "</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> 
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <operator>&amp;</operator><name><name>zDetail</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">22</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zIdx</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><name><name>zIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIdx</name><index>[<expr><name>nIdx</name></expr>]</index></name><operator>!=</operator><literal type="char">' '</literal> <operator>||</operator> <name><name>zIdx</name><index>[<expr><name>nIdx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'('</literal><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nIdx</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>idxHashSearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><name>nIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>idxHashAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>find_indexes_out</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name><name>zDetail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>hIdx</name><operator>.</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

 <label><name>find_indexes_out</name>:</label>
  <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxAuthCallback</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eOp</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z3</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z4</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTrigger</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>z4</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>zTrigger</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eOp</name><operator>==</operator><name>SQLITE_INSERT</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_UPDATE</name> <operator>||</operator> <name>eOp</name><operator>==</operator><name>SQLITE_DELETE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pWrite</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</init> <condition><expr><name>pWrite</name></expr>;</condition> <incr><expr><name>pWrite</name><operator>=</operator><name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name>pTab</name> <operator>&amp;&amp;</operator> <name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>eOp</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pWrite</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pWrite</name> <operator>=</operator> <call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxWrite</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name> <operator>=</operator> <name>eOp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pWrite</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name> <operator>=</operator> <name>pWrite</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxProcessOneTrigger</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pWrite</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInt</name> <init>= <expr><name>UNIQUE_TABLE_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDrop</name> <init>= <expr><literal type="string">"DROP TABLE "</literal> <name>UNIQUE_TABLE_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pWrite</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= 
    <expr><literal type="string">"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema "</literal>
    <literal type="string">"WHERE tbl_name = %Q AND type IN ('table', 'trigger') "</literal>
    <literal type="string">"ORDER BY type;"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Create the table and its triggers in the temp schema */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCreate</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCreate</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Rename the table in the temp schema to zInt */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE temp.%Q RENAME TO %Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>( <expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_INSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %Q VALUES("</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"%s?"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_UPDATE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %Q SET "</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><literal type="string">"%s%Q=?"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>, 
            <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWrite</name><operator>-&gt;</operator><name>eOp</name></name><operator>==</operator><name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zWrite</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"DELETE FROM %Q"</literal></expr></argument>, <argument><expr><name>zInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zWrite</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pX</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zDrop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxProcessTriggers</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pFirst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pFirst</name><operator>!=</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxWrite</name> <modifier>*</modifier></type><name>pIter</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>pIter</name><operator>=</operator><name>pFirst</name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>pIter</name><operator>!=</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pIter</name><operator>=</operator><name><name>pIter</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxProcessOneTrigger</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pEnd</name> <operator>=</operator> <name>pFirst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFirst</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>idxCreateVtabSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>idxRegisterVtab</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* For each table in the main db schema:
  **
  **   1) Add an entry to the p-&gt;pTable list, and
  **   2) Create the equivalent virtual table in dbv.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSchema</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>,
      <argument><expr><literal type="string">"SELECT type, name, sql, 1 FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%' "</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT type, name, sql, 2 FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type = 'trigger'"</literal>
      <literal type="string">"  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') "</literal>
      <literal type="string">"ORDER BY 4, 1"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSchema</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>zType</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'v'</literal> <operator>||</operator> <name><name>zType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>IdxTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxGetTableInfo</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTab</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zInner</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOuter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>

        <comment type="block">/* The statement the vtab will pass to sqlite3_declare_vtab() */</comment>
        <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE x("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>, <argument><expr><literal type="string">"%s%Q COLLATE %s"</literal></expr></argument>, 
              <argument><expr><operator>(</operator><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zColl</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>zInner</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The CVT statement to create the vtab */</comment>
        <expr_stmt><expr><name>zOuter</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
            <argument><expr><literal type="string">"CREATE VIRTUAL TABLE %Q USING expert(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zInner</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zOuter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>IdxSampleCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iTarget</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>target</name></decl>;</decl_stmt>                  <comment type="block">/* Target nRet/nRow value */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRow</name></decl>;</decl_stmt>                    <comment type="block">/* Number of rows seen */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRet</name></decl>;</decl_stmt>                    <comment type="block">/* Number of rows returned */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>idxSampleFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxSampleCtx</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>IdxSampleCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bRet</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argv</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name><operator>==</operator><literal type="number">0.0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>bRet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>bRet</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nRet</name></name> <operator>/</operator> <name><name>p</name><operator>-&gt;</operator><name>nRow</name></name><operator>)</operator> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bRet</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>rnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bRet</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>rnd</name> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>iTarget</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>bRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRow</name></name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRet</name></name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>bRet</name></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>IdxRemCtx</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nSlot</name></decl>;</decl_stmt>
  <struct>struct <name>IdxRemSlot</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>                    <comment type="block">/* SQLITE_NULL, INTEGER, REAL, TEXT, BLOB */</comment>
    <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name></decl>;</decl_stmt>                     <comment type="block">/* SQLITE_INTEGER value */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>                  <comment type="block">/* SQLITE_FLOAT value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                    <comment type="block">/* Bytes of space allocated at z */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                        <comment type="block">/* Size of buffer z */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                      <comment type="block">/* SQLITE_TEXT/BLOB value */</comment>
  }</block> <decl><name><name>aSlot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</struct>
}</block>;</struct>

<comment type="block">/*
** Implementation of scalar function rem().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>idxRemFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemCtx</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>IdxRemCtx</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemSlot</name></name> <modifier>*</modifier></type><name>pSlot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSlot</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iSlot</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSlot</name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nSlot</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSlot</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aSlot</name><index>[<expr><name>iSlot</name></expr>]</index></name></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>

    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>iVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>rVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>

    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>iVal</name></name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>rVal</name></name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name><name>pSlot</name><operator>-&gt;</operator><name>nByte</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>nByte</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSlot</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSlot</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pData</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pSlot</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxLargestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnMax</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMax</name> <init>= 
    <expr><literal type="string">"SELECT max(i.seqno) FROM "</literal>
    <literal type="string">"  sqlite_schema AS s, "</literal>
    <literal type="string">"  pragma_index_list(s.name) AS l, "</literal>
    <literal type="string">"  pragma_index_info(l.name) AS i "</literal>
    <literal type="string">"WHERE s.type = 'table'"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMax</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pMax</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnMax</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pMax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPopulateOneStat1</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIndexXInfo</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWriteStat</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOrder</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aStat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Formulate the query text */</comment>
  <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zComma</name> <init>= <expr><ternary><condition><expr><name>zCols</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zCols</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, 
        <argument><expr><literal type="string">"%sx.%Q IS rem(%d, x.%Q) COLLATE %s"</literal></expr></argument>, <argument><expr><name>zComma</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOrder</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>zComma</name></expr></argument>, <argument><expr><operator>++</operator><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT %s FROM %Q x ORDER BY %s"</literal></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"SELECT %s FROM temp."</literal><name>UNIQUE_TABLE_NAME</name><literal type="string">" x ORDER BY %s"</literal></expr></argument>, <argument><expr><name>zCols</name></expr></argument>, <argument><expr><name>zOrder</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Formulate the query text */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbrem</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name>dbrem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>aStat</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCol</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <for>for<control>(<comment type="block">/*no-op*/</comment><init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>aStat</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>s0</name> <init>= <expr><name><name>aStat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zStat</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStat</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>zStat</name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>zStat</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>s0</name><operator>+</operator><name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name><operator>/</operator><literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>aStat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>zStat</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pWriteStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>idxHashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pEntry</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name> <operator>=</operator> <name>zStat</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aStat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>idxBuildSampleTable</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>,<argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal><name>UNIQUE_TABLE_NAME</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"CREATE TABLE temp."</literal> <name>UNIQUE_TABLE_NAME</name> <literal type="string">" AS SELECT * FROM %Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called as part of sqlite3_expert_analyze(). Candidate
** indexes have already been created in database sqlite3expert.dbm, this
** function populates sqlite_stat1 table in the same database.
**
** The stat1 data is generated by querying the 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>idxPopulateStat1</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name> <init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxRemCtx</name></name> <modifier>*</modifier></type><name>pCtx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>IdxSampleCtx</name></name></type> <name>samplectx</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPrev</name> <init>= <expr><operator>-</operator><literal type="number">100000</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pIndexXInfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pWrite</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAllIndex</name> <init>=
    <expr><literal type="string">"SELECT s.rowid, s.name, l.name FROM "</literal>
    <literal type="string">"  sqlite_schema AS s, "</literal>
    <literal type="string">"  pragma_index_list(s.name) AS l "</literal>
    <literal type="string">"WHERE s.type = 'table'"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIndexXInfo</name> <init>= 
    <expr><literal type="string">"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWrite</name> <init>= <expr><literal type="string">"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)"</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If iSample==0, no sqlite_stat1 data is required. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxLargestIndex</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMax</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMax</name><operator>&lt;=</operator><literal type="number">0</literal> <operator>||</operator> <name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE; PRAGMA writable_schema=1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>IdxRemCtx</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>IdxRemSlot</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nMax</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <operator>(</operator>struct <name>IdxRemCtx</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbrem</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>==</operator><literal type="number">100</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(
        <argument><expr><name>dbrem</name></expr></argument>, <argument><expr><literal type="string">"rem"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></argument>, <argument><expr><name>idxRemFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(
        <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"sample"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>samplectx</name></expr></argument>, <argument><expr><name>idxSampleFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>nSlot</name></name> <operator>=</operator> <name>nMax</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAllIndex</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zAllIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pIndexXInfo</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrepareStmt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pWrite</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>, <argument><expr><name>zWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pAllIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&lt;</operator><literal type="number">100</literal> <operator>&amp;&amp;</operator> <name>iPrev</name><operator>!=</operator><name>iRowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>target</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>iTarget</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iSample</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>nRow</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>samplectx</name><operator>.</operator><name>nRet</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxBuildSampleTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPopulateOneStat1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pIndexXInfo</name></expr></argument>, <argument><expr><name>pWrite</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iRowid</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iSample</name></name><operator>&lt;</operator><literal type="number">100</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, 
        <argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal> <name>UNIQUE_TABLE_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pAllIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pIndexXInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>nSlot</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>aSlot</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE IF EXISTS temp."</literal><name>UNIQUE_TABLE_NAME</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate a new sqlite3expert object.
*/</comment>
<function><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>sqlite3_expert_new</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrmsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>sqlite3expert</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3expert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open two in-memory databases to work with. The "vtab database" (dbv)
  ** will contain a virtual table corresponding to each real table in
  ** the user database schema, and a copy of each view. It is used to
  ** collect information regarding the WHERE, ORDER BY and other clauses
  ** of the user's query.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iSample</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  

  <comment type="block">/* Copy the entire schema of database [db] into [dbm]. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPrintfPrepareStmt</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSql</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>, 
        <argument><expr><literal type="string">"SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%'"</literal>
        <literal type="string">" AND sql NOT LIKE 'CREATE VIRTUAL %%'"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>idxFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create the vtab schema */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateVtabSchema</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the auth callback with dbv */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>idxAuthCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If an error has occurred, free the new object and reutrn NULL. Otherwise,
  ** return the new sqlite3expert handle.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_expert_destroy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure an sqlite3expert object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_config</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>EXPERT_CONFIG_SAMPLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iVal</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&gt;</operator><literal type="number">100</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iVal</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iSample</name></name> <operator>=</operator> <name>iVal</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add an SQL statement to the analysis.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* From sqlite3_expert_new() */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,               <comment type="block">/* SQL statement to add */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>                    <comment type="block">/* OUT: Error message (if any) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>IdxScan</name> <modifier>*</modifier></type><name>pScanOrig</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmtOrig</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStmt</name> <init>= <expr><name>zSql</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></block_content></block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>zStmt</name> <operator>&amp;&amp;</operator> <name><name>zStmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>(</operator><name>IdxStatement</name><operator>*</operator><operator>)</operator><call><name>idxMalloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdxStatement</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSql</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iId</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name><operator>-&gt;</operator><name>iId</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>idxDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>idxScanFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><name>pScanOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxStatementFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></argument>, <argument><expr><name>pStmtOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <name>pScanOrig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name> <operator>=</operator> <name>pStmtOrig</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3_expert_analyze</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxHashEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>

  <comment type="block">/* Do trigger processing to collect any extra IdxScan structures */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxProcessTriggers</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create candidate indexes within the in-memory database file */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxCreateCandidates</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if <condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY_TIMEOUT</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pzErr</name></expr> )</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"Cannot find a unique index name to propose."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate the stat1 data */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxPopulateStat1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Formulate the EXPERT_REPORT_CANDIDATES text */</comment>
  <for>for<control>(<init><expr><name>pEntry</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name><operator>.</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pEntry</name></expr>;</condition> <incr><expr><name>pEntry</name><operator>=</operator><name><name>pEntry</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name> <operator>=</operator> <call><name>idxAppendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr></argument>, 
        <argument><expr><literal type="string">"%s;%s%s\n"</literal></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal</name></name></expr></argument>, 
        <argument><expr><ternary><condition><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr> ?</condition><then> <expr><literal type="string">" -- stat1: "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>zVal2</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Figure out which of the candidate indexes are preferred by the query
  ** planner and report the results to the user.  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>idxFindIndexes</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the total number of statements that have been added to this
** sqlite3expert using sqlite3_expert_sql().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expert_count</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nRet</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pStatement</name><operator>-&gt;</operator><name>iId</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a component of the report.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_expert_report</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eReport</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IdxStatement</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRun</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>pStmt</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr>;</init> <condition><expr><name>pStmt</name> <operator>&amp;&amp;</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>iId</name></name><operator>!=</operator><name>iStmt</name></expr>;</condition> <incr><expr><name>pStmt</name><operator>=</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <switch>switch<condition>( <expr><name>eReport</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>EXPERT_REPORT_SQL</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zSql</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_INDEXES</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zIdx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_PLAN</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>pStmt</name><operator>-&gt;</operator><name>zEQP</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>EXPERT_REPORT_CANDIDATES</name></expr>:</case>
      <expr_stmt><expr><name>zRet</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an sqlite3expert object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_expert_destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxScanFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxStatementFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStatement</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxTableFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxWriteFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>idxHashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zCandidates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block" format="doxygen">/************************* End ../ext/expert/sqlite3expert.c ********************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_DBPAGE_VTAB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SHELL_HAVE_RECOVER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SHELL_HAVE_RECOVER</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>
<comment type="block" format="doxygen">/************************* Begin ../ext/recover/dbdata.c ******************/</comment>
<comment type="block">/*
** 2019-04-17
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains an implementation of two eponymous virtual tables,
** "sqlite_dbdata" and "sqlite_dbptr". Both modules require that the
** "sqlite_dbpage" eponymous virtual table be available.
**
** SQLITE_DBDATA:
**   sqlite_dbdata is used to extract data directly from a database b-tree
**   page and its associated overflow pages, bypassing the b-tree layer.
**   The table schema is equivalent to:
**
**     CREATE TABLE sqlite_dbdata(
**       pgno INTEGER,
**       cell INTEGER,
**       field INTEGER,
**       value ANY,
**       schema TEXT HIDDEN
**     );
**
**   IMPORTANT: THE VIRTUAL TABLE SCHEMA ABOVE IS SUBJECT TO CHANGE. IN THE
**   FUTURE NEW NON-HIDDEN COLUMNS MAY BE ADDED BETWEEN "value" AND
**   "schema".
**
**   Each page of the database is inspected. If it cannot be interpreted as
**   a b-tree page, or if it is a b-tree page containing 0 entries, the
**   sqlite_dbdata table contains no rows for that page.  Otherwise, the
**   table contains one row for each field in the record associated with
**   each cell on the page. For intkey b-trees, the key value is stored in
**   field -1.
**
**   For example, for the database:
**
**     CREATE TABLE t1(a, b);     -- root page is page 2
**     INSERT INTO t1(rowid, a, b) VALUES(5, 'v', 'five');
**     INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');
**
**   the sqlite_dbdata table contains, as well as from entries related to 
**   page 1, content equivalent to:
**
**     INSERT INTO sqlite_dbdata(pgno, cell, field, value) VALUES
**         (2, 0, -1, 5     ),
**         (2, 0,  0, 'v'   ),
**         (2, 0,  1, 'five'),
**         (2, 1, -1, 10    ),
**         (2, 1,  0, 'x'   ),
**         (2, 1,  1, 'ten' );
**
**   If database corruption is encountered, this module does not report an
**   error. Instead, it attempts to extract as much data as possible and
**   ignores the corruption.
**
** SQLITE_DBPTR:
**   The sqlite_dbptr table has the following schema:
**
**     CREATE TABLE sqlite_dbptr(
**       pgno INTEGER,
**       child INTEGER,
**       schema TEXT HIDDEN
**     );
**
**   It contains one entry for each b-tree pointer between a parent and
**   child page in the database.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITEINT_H</name></expr></argument>)</argument_list></call></expr></cpp:if> 
<comment type="block">/* #include "sqlite3ext.h" */</comment>

<comment type="block">/* typedef unsigned char u8; */</comment>
<comment type="block">/* typedef unsigned int u32; */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_PADDING_BYTES</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define> 

<typedef>typedef <type><name><name>struct</name> <name>DbdataTable</name></name></type> <name>DbdataTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>DbdataCursor</name></name></type> <name>DbdataCursor</name>;</typedef>

<comment type="block">/* Cursor object */</comment>
<struct>struct <name>DbdataCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>       <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>            <comment type="block">/* For fetching database pages */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>iPgno</name></decl>;</decl_stmt>                      <comment type="block">/* Current page number */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aPage</name></decl>;</decl_stmt>                      <comment type="block">/* Buffer containing page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                      <comment type="block">/* Size of aPage[] in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                      <comment type="block">/* Number of cells on aPage[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCell</name></decl>;</decl_stmt>                      <comment type="block">/* Current cell number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bOnePage</name></decl>;</decl_stmt>                   <comment type="block">/* True to stop after one page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRowid</name></decl>;</decl_stmt>

  <comment type="block">/* Only for the sqlite_dbdata table */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pRec</name></decl>;</decl_stmt>                       <comment type="block">/* Buffer containing current record */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRec</name></decl>;</decl_stmt>             <comment type="block">/* Size of pRec[] in bytes */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nHdr</name></decl>;</decl_stmt>             <comment type="block">/* Size of header in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iField</name></decl>;</decl_stmt>                     <comment type="block">/* Current field number */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pHdrPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>enc</name></decl>;</decl_stmt>                        <comment type="block">/* Text encoding */</comment>
  
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iIntkey</name></decl>;</decl_stmt>          <comment type="block">/* Integer key value */</comment>
}</block>;</struct>

<comment type="block">/* Table object */</comment>
<struct>struct <name>DbdataTable</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>              <comment type="block">/* Base class.  Must be first */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>            <comment type="block">/* For fetching database pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPtr</name></decl>;</decl_stmt>                       <comment type="block">/* True for sqlite3_dbptr table */</comment>
}</block>;</struct>

<comment type="block">/* Column and schema definitions for sqlite_dbdata */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_COLUMN_PGNO</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_COLUMN_CELL</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_COLUMN_FIELD</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_COLUMN_VALUE</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_COLUMN_SCHEMA</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBDATA_SCHEMA</name></cpp:macro>             \
      <cpp:value>"CREATE TABLE x("           \
      "  pgno INTEGER,"           \
      "  cell INTEGER,"           \
      "  field INTEGER,"          \
      "  value ANY,"              \
      "  schema TEXT HIDDEN"      \
      ")"</cpp:value></cpp:define>

<comment type="block">/* Column and schema definitions for sqlite_dbptr */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBPTR_COLUMN_PGNO</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBPTR_COLUMN_CHILD</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBPTR_COLUMN_SCHEMA</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBPTR_SCHEMA</name></cpp:macro>              \
      <cpp:value>"CREATE TABLE x("           \
      "  pgno INTEGER,"           \
      "  child INTEGER,"          \
      "  schema TEXT HIDDEN"      \
      ")"</cpp:value></cpp:define>

<comment type="block">/*
** Connect to an sqlite_dbdata (pAux==0) or sqlite_dbptr (pAux!=0) virtual 
** table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pAux</name></expr> ?</condition><then> <expr><name>DBPTR_SCHEMA</name></expr> </then><else>: <expr><name>DBDATA_SCHEMA</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pTab</name> <operator>=</operator> <operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbdataTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbdataTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name> <operator>=</operator> <operator>(</operator><name>pAux</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVtab</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab</name><operator>*</operator><operator>)</operator><name>pTab</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Disconnect from or destroy a sqlite_dbdata or sqlite_dbptr virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function interprets two types of constraints:
**
**       schema=?
**       pgno=?
**
** If neither are present, idxNum is set to 0. If schema=? is present,
** the 0x01 bit in idxNum is set. If pgno=? is present, the 0x02 bit
** in idxNum is set.
**
** If both parameters are present, schema is in position 0 and pgno in
** position 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSchema</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPgno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>colSchema</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name></expr> ?</condition><then> <expr><name>DBPTR_COLUMN_SCHEMA</name></expr> </then><else>: <expr><name>DBDATA_COLUMN_SCHEMA</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>colSchema</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>iSchema</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><name>DBDATA_COLUMN_PGNO</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iPgno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>iSchema</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iSchema</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iSchema</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPgno</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iPgno</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>iSchema</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>iPgno</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator>  <literal type="number">50</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>nOrderBy</name></name> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><name><name>pIdx</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <operator>(</operator><name>iCol</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>iCol</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pIdx</name><operator>-&gt;</operator><name>nOrderBy</name></name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pIdx</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>desc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>orderByConsumed</name></name> <operator>=</operator> <operator>(</operator><name><name>pIdx</name><operator>-&gt;</operator><name>aOrderBy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iColumn</name><operator>==</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">100000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>estimatedRows</name></name> <operator>=</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pIdx</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iSchema</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0x01</literal></expr> </then><else>: <expr><literal type="number">0x00</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>iPgno</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0x02</literal></expr> </then><else>: <expr><literal type="number">0x00</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a new sqlite_dbdata or sqlite_dbptr cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCsr</name> <operator>=</operator> <operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbdataCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCsr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbdataCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name> <operator>=</operator> <name>pVTab</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_vtab_cursor</name> <operator>*</operator><operator>)</operator><name>pCsr</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Restore a cursor object to the state it was in when first allocated 
** by dbdataOpen().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbdataResetCursor</name><parameter_list>(<parameter><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close an sqlite_dbdata or sqlite_dbptr cursor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>dbdataResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Utility methods to decode 16 and 32-bit big-endian unsigned integers. 
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>get_uint16</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>get_uint32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator>
       <operator>|</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator>
       <operator>|</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator>
       <operator>|</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Load page pgno from the database via the sqlite_dbpage virtual table.
** If successful, set (*ppPage) to point to a buffer containing the page
** data, (*pnPage) to the size of that buffer in bytes and return
** SQLITE_OK. In this case it is the responsibility of the caller to
** eventually free the buffer using sqlite3_free().
**
** Or, if an error occurs, set both (*ppPage) and (*pnPage) to 0 and
** return an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataLoadPage</name><parameter_list>(
  <parameter><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>,             <comment type="block">/* Cursor object */</comment>
  <parameter><decl><type><name>u32</name></type> <name>pgno</name></decl></parameter>,                       <comment type="block">/* Page number of page to load */</comment>
  <parameter><decl><type><name>u8</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>,                    <comment type="block">/* OUT: pointer to page buffer */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnPage</name></decl></parameter>                     <comment type="block">/* OUT: Size of (*ppPage) in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPage</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pPage</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nCopy</name> <operator>+</operator> <name>DBDATA_PADDING_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pPage</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>pCopy</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCopy</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPage</name><index>[<expr><name>nCopy</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DBDATA_PADDING_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pnPage</name> <operator>=</operator> <name>nCopy</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read a varint.  Put the value in *pVal and return the number of bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataGetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt> <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Like dbdataGetVarint(), but set the output to 0 if it is less than 0
** or greater than 0xFFFFFFFF. This can be used for all varints in an
** SQLite database except for key values in intkey tables.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataGetVarintU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> <init>= <expr><call><name>dbdataGetVarint</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>val</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>val</name></expr></argument>&gt;</argument_list></name><literal type="number">0xFFFFFFFF</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of bytes of space used by an SQLite value of type
** eType.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataValueBytes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">8</literal></expr>:</case> <case>case <expr><literal type="number">9</literal></expr>:</case>
    <case>case <expr><literal type="number">10</literal></expr>:</case> <case>case <expr><literal type="number">11</literal></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    <case>case <expr><literal type="number">3</literal></expr>:</case>
      <return>return <expr><literal type="number">3</literal></expr>;</return>
    <case>case <expr><literal type="number">4</literal></expr>:</case>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    <case>case <expr><literal type="number">5</literal></expr>:</case>
      <return>return <expr><literal type="number">6</literal></expr>;</return>
    <case>case <expr><literal type="number">6</literal></expr>:</case>
    <case>case <expr><literal type="number">7</literal></expr>:</case>
      <return>return <expr><literal type="number">8</literal></expr>;</return>
    <default>default:</default>
      <if_stmt><if>if<condition>( <expr><name>eType</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><operator>(</operator><operator>(</operator><name>eType</name><operator>-</operator><literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Load a value of type eType from buffer pData and use it to set the
** result of context object pCtx.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbdataValue</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>u32</name></type> <name>enc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>eType</name></decl></parameter>, 
  <parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>nData</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>dbdataValueBytes</name><argument_list>(<argument><expr><name>eType</name></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>nData</name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case> 
      <case>case <expr><literal type="number">10</literal></expr>:</case> 
      <case>case <expr><literal type="number">11</literal></expr>:</case> 
        <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      
      <case>case <expr><literal type="number">8</literal></expr>:</case> 
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="number">9</literal></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
  
      <case>case <expr><literal type="number">1</literal></expr>:</case> <case>case <expr><literal type="number">2</literal></expr>:</case> <case>case <expr><literal type="number">3</literal></expr>:</case> <case>case <expr><literal type="number">4</literal></expr>:</case> <case>case <expr><literal type="number">5</literal></expr>:</case> <case>case <expr><literal type="number">6</literal></expr>:</case> <case>case <expr><literal type="number">7</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>signed</name> <name>char</name><operator>)</operator><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pData</name><operator>++</operator></expr>;</expr_stmt>
        <switch>switch<condition>( <expr><name>eType</name></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="number">7</literal></expr>:</case>
          <case>case <expr><literal type="number">6</literal></expr>:</case>  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <case>case <expr><literal type="number">5</literal></expr>:</case>  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <case>case <expr><literal type="number">4</literal></expr>:</case>  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>pData</name><operator>++</operator></expr>;</expr_stmt>
          <case>case <expr><literal type="number">3</literal></expr>:</case>  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>pData</name><operator>++</operator></expr>;</expr_stmt>
          <case>case <expr><literal type="number">2</literal></expr>:</case>  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>pData</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></switch>
  
        <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
  
      <default>default:</default> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><operator>(</operator><name>eType</name><operator>-</operator><literal type="number">12</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>eType</name> <operator>%</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
          <switch>switch<condition>( <expr><name>enc</name></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
            <case>case <expr><name>SQLITE_UTF16BE</name></expr>:</case>
              <expr_stmt><expr><call><name>sqlite3_result_text16be</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            <case>case <expr><name>SQLITE_UTF16LE</name></expr>:</case>
              <expr_stmt><expr><call><name>sqlite3_result_text16le</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
              <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Move an sqlite_dbdata or sqlite_dbptr cursor to the next entry.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bNextPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>szDb</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataLoadPage</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nCell</name></name> <operator>=</operator> <call><name>get_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name><operator>!=</operator><literal type="number">0x02</literal> <operator>&amp;&amp;</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name><operator>!=</operator><literal type="number">0x05</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>&gt;=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* If there is no record loaded, load it now. */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>bHasRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nPointer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nPayload</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nHdr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iHdr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>U</name></decl>, <decl><type ref="prev"/><name>X</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nLocal</name></decl>;</decl_stmt>
  
        <switch>switch<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="number">0x02</literal></expr>:</case>
            <expr_stmt><expr><name>nPointer</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><literal type="number">0x0a</literal></expr>:</case>
            <break>break;</break>
          <case>case <expr><literal type="number">0x0d</literal></expr>:</case>
            <expr_stmt><expr><name>bHasRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
          <default>default:</default>
            <comment type="block">/* This is not a b-tree page with records on it. Continue. */</comment>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nCell</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>&gt;=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nCell</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bNextPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
  
          <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <literal type="number">8</literal> <operator>+</operator> <name>nPointer</name> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bNextPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>get_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
    
          <comment type="block">/* For an interior node cell, skip past the child-page number */</comment>
          <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name>nPointer</name></expr>;</expr_stmt>
    
          <comment type="block">/* Load the "byte of payload including overflow" field */</comment>
          <if_stmt><if>if<condition>( <expr><name>bNextPage</name> <operator>||</operator> <name>iOff</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bNextPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>dbdataGetVarintU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
    
          <comment type="block">/* If this is a leaf intkey cell, load the rowid */</comment>
          <if_stmt><if>if<condition>( <expr><name>bHasRowid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bNextPage</name> <operator>&amp;&amp;</operator> <name>iOff</name><operator>&lt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <call><name>dbdataGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>iIntkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
    
          <comment type="block">/* Figure out how much data to read from the local page */</comment>
          <expr_stmt><expr><name>U</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bHasRowid</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <name>U</name><operator>-</operator><literal type="number">35</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>X</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>U</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">64</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;=</operator><name>X</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nLocal</name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>M</name></decl>, <decl><type ref="prev"/><name>K</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>M</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>U</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">32</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>K</name> <operator>=</operator> <name>M</name><operator>+</operator><operator>(</operator><operator>(</operator><name>nPayload</name><operator>-</operator><name>M</name><operator>)</operator><operator>%</operator><operator>(</operator><name>U</name><operator>-</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>K</name><operator>&lt;=</operator><name>X</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>nLocal</name> <operator>=</operator> <name>K</name></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>nLocal</name> <operator>=</operator> <name>M</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>bNextPage</name> <operator>||</operator> <name>nLocal</name><operator>+</operator><name>iOff</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bNextPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>

            <comment type="block">/* Allocate space for payload. And a bit more to catch small buffer
            ** overruns caused by attempting to read a varint or similar from 
            ** near the end of a corrupt record.  */</comment>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nPayload</name><operator>+</operator><name>DBDATA_PADDING_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nPayload</name><operator>+</operator><name>DBDATA_PADDING_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRec</name></name> <operator>=</operator> <name>nPayload</name></expr>;</expr_stmt>

            <comment type="block">/* Load the nLocal bytes of payload */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>nLocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <name>nLocal</name></expr>;</expr_stmt>

            <comment type="block">/* Load content from overflow pages */</comment>
            <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&gt;</operator><name>nLocal</name></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRem</name> <init>= <expr><name>nPayload</name> <operator>-</operator> <name>nLocal</name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>u32</name></type> <name>pgnoOvfl</name> <init>= <expr><call><name>get_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
                <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataLoadPage</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aOvfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>aOvfl</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nOvfl</name><operator>==</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if<condition>( <expr><name>aOvfl</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>U</name><operator>-</operator><literal type="number">4</literal></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>nCopy</name><operator>&gt;</operator><name>nRem</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nCopy</name> <operator>=</operator> <name>nRem</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name>nPayload</name><operator>-</operator><name>nRem</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aOvfl</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>pgnoOvfl</name> <operator>=</operator> <call><name>get_uint32</name><argument_list>(<argument><expr><name>aOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
    
            <expr_stmt><expr><name>iHdr</name> <operator>=</operator> <call><name>dbdataGetVarintU32</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>nHdr</name><operator>&gt;</operator><name>nPayload</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nHdr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>nHdr</name></name> <operator>=</operator> <name>nHdr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name>iHdr</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nHdr</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>bHasRowid</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iType</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name><operator>&gt;</operator><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRec</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>bNextPage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name> <operator>+=</operator> <call><name>dbdataGetVarintU32</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPtr</name></name> <operator>+=</operator> <call><name>dbdataValueBytes</name><argument_list>(<argument><expr><name>iType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>bNextPage</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name><operator>&lt;</operator><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nHdr</name></name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Advance to the next cell. The next iteration of the loop will load
        ** the record and so on. */</comment>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><literal type="string">"can't get here"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return true if the cursor is at EOF.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return true if nul-terminated string zSchema ends in "()". Or false
** otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataIsFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>zSchema</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name><name>zSchema</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">')'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>-</operator><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Determine the size in pages of database zSchema (where zSchema is
** "main", "temp" or the name of an attached database) and set 
** pCsr-&gt;szDb accordingly. If successful, return SQLITE_OK. Otherwise,
** an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataDbsize</name><parameter_list>(<parameter><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name><name>pCsr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFunc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nFunc</name> <operator>=</operator> <call><name>dbdataIsFunction</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %.*s(0)"</literal></expr></argument>, <argument><expr><name>nFunc</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA %Q.page_count"</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>szDb</name></name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to figure out the encoding of the database by retrieving page 1
** and inspecting the header field. If successful, set the pCsr-&gt;enc variable
** and return SQLITE_OK. Otherwise, return an SQLite error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataGetEncoding</name><parameter_list>(<parameter><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPg1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aPg1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataLoadPage</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>aPg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name>nPg1</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nPg1</name><operator>&gt;=</operator><literal type="number">512</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nPg1</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <call><name>get_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aPg1</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 
** xFilter method for sqlite_dbdata and sqlite_dbptr.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name> <init>= <expr><literal type="string">"main"</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>dbdataResetCursor</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSchema</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>(</operator><name>idxNum</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>bOnePage</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataDbsize</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nFunc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>nFunc</name> <operator>=</operator> <call><name>dbdataIsFunction</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT %.*s(?2)"</literal></expr></argument>, <argument><expr><name>nFunc</name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, 
          <argument><expr><literal type="string">"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
          <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Try to determine the encoding of the db by inspecting the header
  ** field on page 1. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataGetEncoding</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dbdataNext</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a column for the sqlite_dbdata or sqlite_dbptr table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbdataTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><operator>(</operator><name>DbdataTable</name><operator>*</operator><operator>)</operator><name><name>pCursor</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>bPtr</name></name></expr> )</condition><block>{<block_content>
    <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>DBPTR_COLUMN_PGNO</name></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DBPTR_COLUMN_CHILD</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><ternary><condition><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iOff</name> <operator>+=</operator> <literal type="number">12</literal> <operator>+</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>&gt;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iOff</name> <operator>=</operator> <call><name>get_uint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>&lt;=</operator><name><name>pCsr</name><operator>-&gt;</operator><name>nPage</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>get_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>aPage</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></if><else>else<block>{<block_content>
    <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>DBDATA_COLUMN_PGNO</name></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iPgno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DBDATA_COLUMN_CELL</name></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DBDATA_COLUMN_FIELD</name></expr>:</case>
        <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>DBDATA_COLUMN_VALUE</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pCsr</name><operator>-&gt;</operator><name>iField</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>iIntkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRec</name></name></expr>]</index></name> <operator>&gt;=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pPtr</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iType</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>dbdataGetVarintU32</name><argument_list>(<argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pHdrPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>dbdataValue</name><argument_list>(
              <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><name><name>pCsr</name><operator>-&gt;</operator><name>pPtr</name></name></expr></argument>, 
              <argument><expr><operator>&amp;</operator><name><name>pCsr</name><operator>-&gt;</operator><name>pRec</name><index>[<expr><name><name>pCsr</name><operator>-&gt;</operator><name>nRec</name></name></expr>]</index></name> <operator>-</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>pPtr</name></name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the rowid for an sqlite_dbdata or sqlite_dptr table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dbdataRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DbdataCursor</name> <modifier>*</modifier></type><name>pCsr</name> <init>= <expr><operator>(</operator><name>DbdataCursor</name><operator>*</operator><operator>)</operator><name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>pCsr</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Invoke this routine to register the "sqlite_dbdata" virtual table module
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3DbdataRegister</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>dbdata_module</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* iVersion */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCreate */</comment>
    <expr><name>dbdataConnect</name></expr>,                <comment type="block">/* xConnect */</comment>
    <expr><name>dbdataBestIndex</name></expr>,              <comment type="block">/* xBestIndex */</comment>
    <expr><name>dbdataDisconnect</name></expr>,             <comment type="block">/* xDisconnect */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xDestroy */</comment>
    <expr><name>dbdataOpen</name></expr>,                   <comment type="block">/* xOpen - open a cursor */</comment>
    <expr><name>dbdataClose</name></expr>,                  <comment type="block">/* xClose - close a cursor */</comment>
    <expr><name>dbdataFilter</name></expr>,                 <comment type="block">/* xFilter - configure scan constraints */</comment>
    <expr><name>dbdataNext</name></expr>,                   <comment type="block">/* xNext - advance a cursor */</comment>
    <expr><name>dbdataEof</name></expr>,                    <comment type="block">/* xEof - check for end of scan */</comment>
    <expr><name>dbdataColumn</name></expr>,                 <comment type="block">/* xColumn - read data */</comment>
    <expr><name>dbdataRowid</name></expr>,                  <comment type="block">/* xRowid - read data */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xUpdate */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xBegin */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSync */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xCommit */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollback */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xFindMethod */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRename */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xSavepoint */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRelease */</comment>
    <expr><literal type="number">0</literal></expr>,                            <comment type="block">/* xRollbackTo */</comment>
    <expr><literal type="number">0</literal></expr>                             <comment type="block">/* xShadowName */</comment>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_dbdata"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbdata_module</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"sqlite_dbptr"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbdata_module</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_dbdata_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3DbdataRegister</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block" format="doxygen">/************************* End ../ext/recover/dbdata.c ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/recover/sqlite3recover.h ******************/</comment>
<comment type="block">/*
** 2022-08-27
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains the public interface to the "recover" extension -
** an SQLite extension designed to recover data from corrupted database
** files.
*/</comment>

<comment type="block">/*
** OVERVIEW:
**
** To use the API to recover data from a corrupted database, an
** application:
**
**   1) Creates an sqlite3_recover handle by calling either
**      sqlite3_recover_init() or sqlite3_recover_init_sql().
**
**   2) Configures the new handle using one or more calls to
**      sqlite3_recover_config().
**
**   3) Executes the recovery by repeatedly calling sqlite3_recover_step() on
**      the handle until it returns something other than SQLITE_OK. If it
**      returns SQLITE_DONE, then the recovery operation completed without 
**      error. If it returns some other non-SQLITE_OK value, then an error 
**      has occurred.
**
**   4) Retrieves any error code and English language error message using the
**      sqlite3_recover_errcode() and sqlite3_recover_errmsg() APIs,
**      respectively.
**
**   5) Destroys the sqlite3_recover handle and frees all resources
**      using sqlite3_recover_finish().
**
** The application may abandon the recovery operation at any point 
** before it is finished by passing the sqlite3_recover handle to
** sqlite3_recover_finish(). This is not an error, but the final state
** of the output database, or the results of running the partial script
** delivered to the SQL callback, are undefined.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_SQLITE_RECOVER_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SQLITE_RECOVER_H</name></cpp:macro></cpp:define>

<comment type="block">/* #include "sqlite3.h" */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** An instance of the sqlite3_recover object represents a recovery
** operation in progress.
**
** Constructors:
**
**    sqlite3_recover_init()
**    sqlite3_recover_init_sql()
**
** Destructor:
**
**    sqlite3_recover_finish()
**
** Methods:
**
**    sqlite3_recover_config()
**    sqlite3_recover_errcode()
**    sqlite3_recover_errmsg()
**    sqlite3_recover_run()
**    sqlite3_recover_step()
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>sqlite3_recover</name></name></type> <name>sqlite3_recover</name>;</typedef>

<comment type="block">/* 
** These two APIs attempt to create and return a new sqlite3_recover object.
** In both cases the first two arguments identify the (possibly
** corrupt) database to recover data from. The first argument is an open
** database handle and the second the name of a database attached to that
** handle (i.e. "main", "temp" or the name of an attached database).
**
** If sqlite3_recover_init() is used to create the new sqlite3_recover
** handle, then data is recovered into a new database, identified by
** string parameter zUri. zUri may be an absolute or relative file path,
** or may be an SQLite URI. If the identified database file already exists,
** it is overwritten.
**
** If sqlite3_recover_init_sql() is invoked, then any recovered data will
** be returned to the user as a series of SQL statements. Executing these
** SQL statements results in the same database as would have been created
** had sqlite3_recover_init() been used. For each SQL statement in the
** output, the callback function passed as the third argument (xSql) is 
** invoked once. The first parameter is a passed a copy of the fourth argument
** to this function (pCtx) as its first parameter, and a pointer to a
** nul-terminated buffer containing the SQL statement formated as UTF-8 as 
** the second. If the xSql callback returns any value other than SQLITE_OK,
** then processing is immediately abandoned and the value returned used as
** the recover handle error code (see below).
**
** If an out-of-memory error occurs, NULL may be returned instead of
** a valid handle. In all other cases, it is the responsibility of the
** application to avoid resource leaks by ensuring that
** sqlite3_recover_finish() is called on all allocated handles.
*/</comment>
<function_decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>
)</parameter_list>;</function_decl>
<function_decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>
)</parameter_list>;</function_decl>

<comment type="block">/*
** Configure an sqlite3_recover object that has just been created using
** sqlite3_recover_init() or sqlite3_recover_init_sql(). This function
** may only be called before the first call to sqlite3_recover_step()
** or sqlite3_recover_run() on the object.
**
** The second argument passed to this function must be one of the
** SQLITE_RECOVER_* symbols defined below. Valid values for the third argument
** depend on the specific SQLITE_RECOVER_* symbol in use.
**
** SQLITE_OK is returned if the configuration operation was successful,
** or an SQLite error code otherwise.
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_recover_config</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** SQLITE_RECOVER_LOST_AND_FOUND:
**   The pArg argument points to a string buffer containing the name
**   of a "lost-and-found" table in the output database, or NULL. If
**   the argument is non-NULL and the database contains seemingly
**   valid pages that cannot be associated with any table in the
**   recovered part of the schema, data is extracted from these
**   pages to add to the lost-and-found table.
**
** SQLITE_RECOVER_FREELIST_CORRUPT:
**   The pArg value must actually be a pointer to a value of type
**   int containing value 0 or 1 cast as a (void*). If this option is set
**   (argument is 1) and a lost-and-found table has been configured using
**   SQLITE_RECOVER_LOST_AND_FOUND, then is assumed that the freelist is 
**   corrupt and an attempt is made to recover records from pages that
**   appear to be linked into the freelist. Otherwise, pages on the freelist
**   are ignored. Setting this option can recover more data from the
**   database, but often ends up "recovering" deleted records. The default 
**   value is 0 (clear).
**
** SQLITE_RECOVER_ROWIDS:
**   The pArg value must actually be a pointer to a value of type
**   int containing value 0 or 1 cast as a (void*). If this option is set
**   (argument is 1), then an attempt is made to recover rowid values
**   that are not also INTEGER PRIMARY KEY values. If this option is
**   clear, then new rowids are assigned to all recovered rows. The
**   default value is 1 (set).
**
** SQLITE_RECOVER_SLOWINDEXES:
**   The pArg value must actually be a pointer to a value of type
**   int containing value 0 or 1 cast as a (void*). If this option is clear
**   (argument is 0), then when creating an output database, the recover 
**   module creates and populates non-UNIQUE indexes right at the end of the
**   recovery operation - after all recoverable data has been inserted
**   into the new database. This is faster overall, but means that the
**   final call to sqlite3_recover_step() for a recovery operation may
**   be need to create a large number of indexes, which may be very slow.
**
**   Or, if this option is set (argument is 1), then non-UNIQUE indexes
**   are created in the output database before it is populated with 
**   recovered data. This is slower overall, but avoids the slow call
**   to sqlite3_recover_step() at the end of the recovery operation.
**
**   The default option value is 0.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_RECOVER_LOST_AND_FOUND</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_RECOVER_FREELIST_CORRUPT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_RECOVER_ROWIDS</name></cpp:macro>           <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_RECOVER_SLOWINDEXES</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
** Perform a unit of work towards the recovery operation. This function 
** must normally be called multiple times to complete database recovery.
**
** If no error occurs but the recovery operation is not completed, this
** function returns SQLITE_OK. If recovery has been completed successfully
** then SQLITE_DONE is returned. If an error has occurred, then an SQLite
** error code (e.g. SQLITE_IOERR or SQLITE_NOMEM) is returned. It is not
** considered an error if some or all of the data cannot be recovered
** due to database corruption.
**
** Once sqlite3_recover_step() has returned a value other than SQLITE_OK,
** all further such calls on the same recover handle are no-ops that return
** the same non-SQLITE_OK value.
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_recover_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* 
** Run the recovery operation to completion. Return SQLITE_OK if successful,
** or an SQLite error code otherwise. Calling this function is the same
** as executing:
**
**     while( SQLITE_OK==sqlite3_recover_step(p) );
**     return sqlite3_recover_errcode(p);
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_recover_run</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** If an error has been encountered during a prior call to
** sqlite3_recover_step(), then this function attempts to return a 
** pointer to a buffer containing an English language explanation of 
** the error. If no error message is available, or if an out-of memory 
** error occurs while attempting to allocate a buffer in which to format
** the error message, NULL is returned.
**
** The returned buffer remains valid until the sqlite3_recover handle is
** destroyed using sqlite3_recover_finish().
*/</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_recover_errmsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** If this function is called on an sqlite3_recover handle after
** an error occurs, an SQLite error code is returned. Otherwise, SQLITE_OK.
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_recover_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* 
** Clean up a recovery object created by a call to sqlite3_recover_init().
** The results of using a recovery object with any API after it has been
** passed to this function are undefined.
**
** This function returns the same value as sqlite3_recover_errcode().
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3_recover_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
</block_content>}</block></extern>  <comment type="block">/* end of the 'extern "C"' block */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef _SQLITE_RECOVER_H */</comment>

<comment type="block" format="doxygen">/************************* End ../ext/recover/sqlite3recover.h ********************/</comment>
<comment type="block" format="doxygen">/************************* Begin ../ext/recover/sqlite3recover.c ******************/</comment>
<comment type="block">/*
** 2022-08-27
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
*/</comment>


<comment type="block">/* #include "sqlite3recover.h" */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<comment type="block">/*
** Declaration for public API function in file dbdata.c. This may be called
** with NULL as the final two arguments to register the sqlite_dbptr and
** sqlite_dbdata virtual tables with a database handle.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>sqlite3_dbdata_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* typedef unsigned int u32; */</comment>
<comment type="block">/* typedef unsigned char u8; */</comment>
<comment type="block">/* typedef sqlite3_int64 i64; */</comment>

<typedef>typedef <type><name><name>struct</name> <name>RecoverTable</name></name></type> <name>RecoverTable</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RecoverColumn</name></name></type> <name>RecoverColumn</name>;</typedef>

<comment type="block">/*
** When recovering rows of data that can be associated with table
** definitions recovered from the sqlite_schema table, each table is
** represented by an instance of the following object.
**
** iRoot:
**   The root page in the original database. Not necessarily (and usually
**   not) the same in the recovered database.
**
** zTab:
**   Name of the table.
**
** nCol/aCol[]:
**   aCol[] is an array of nCol columns. In the order in which they appear 
**   in the table.
**
** bIntkey:
**   Set to true for intkey tables, false for WITHOUT ROWID.
**
** iRowidBind:
**   Each column in the aCol[] array has associated with it the index of
**   the bind parameter its values will be bound to in the INSERT statement
**   used to construct the output database. If the table does has a rowid
**   but not an INTEGER PRIMARY KEY column, then iRowidBind contains the
**   index of the bind paramater to which the rowid value should be bound.
**   Otherwise, it contains -1. If the table does contain an INTEGER PRIMARY 
**   KEY column, then the rowid value should be bound to the index associated
**   with the column.
**
** pNext:
**   All RecoverTable objects used by the recovery operation are allocated
**   and populated as part of creating the recovered database schema in
**   the output database, before any non-schema data are recovered. They
**   are then stored in a singly-linked list linked by this variable beginning
**   at sqlite3_recover.pTblList.
*/</comment>
<struct>struct <name>RecoverTable</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>iRoot</name></decl>;</decl_stmt>                      <comment type="block">/* Root page in original database */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name></decl>;</decl_stmt>                     <comment type="block">/* Name of table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                       <comment type="block">/* Number of columns in table */</comment>
  <decl_stmt><decl><type><name>RecoverColumn</name> <modifier>*</modifier></type><name>aCol</name></decl>;</decl_stmt>            <comment type="block">/* Array of columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIntkey</name></decl>;</decl_stmt>                    <comment type="block">/* True for intkey, false for without rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iRowidBind</name></decl>;</decl_stmt>                 <comment type="block">/* If &gt;0, bind rowid to INSERT here */</comment>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Each database column is represented by an instance of the following object
** stored in the RecoverTable.aCol[] array of the associated table.
**
** iField:
**   The index of the associated field within database records. Or -1 if
**   there is no associated field (e.g. for virtual generated columns).
**
** iBind:
**   The bind index of the INSERT statement to bind this columns values
**   to. Or 0 if there is no such index (iff (iField&lt;0)).
**
** bIPK:
**   True if this is the INTEGER PRIMARY KEY column.
**
** zCol:
**   Name of column.
**
** eHidden:
**   A RECOVER_EHIDDEN_* constant value (see below for interpretation of each).
*/</comment>
<struct>struct <name>RecoverColumn</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iField</name></decl>;</decl_stmt>                     <comment type="block">/* Field in record on disk */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBind</name></decl>;</decl_stmt>                      <comment type="block">/* Binding to use in INSERT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bIPK</name></decl>;</decl_stmt>                       <comment type="block">/* True for IPK column */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_NONE</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>      <comment type="block">/* Normal database column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_HIDDEN</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/* Column is __HIDDEN__ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_VIRTUAL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/* Virtual generated column */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_EHIDDEN_STORED</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>      <comment type="block">/* Stored generated column */</comment>

<comment type="block">/*
** Bitmap object used to track pages in the input database. Allocated
** and manipulated only by the following functions:
**
**     recoverBitmapAlloc()
**     recoverBitmapFree()
**     recoverBitmapSet()
**     recoverBitmapQuery()
**
** nPg:
**   Largest page number that may be stored in the bitmap. The range
**   of valid keys is 1 to nPg, inclusive.
**
** aElem[]:
**   Array large enough to contain a bit for each key. For key value
**   iKey, the associated bit is the bit (iKey%32) of aElem[iKey/32].
**   In other words, the following is true if bit iKey is set, or 
**   false if it is clear:
**
**       (aElem[iKey/32] &amp; (1 &lt;&lt; (iKey%32))) ? 1 : 0
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverBitmap</name></name></type> <name>RecoverBitmap</name>;</typedef>
<struct>struct <name>RecoverBitmap</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name></decl>;</decl_stmt>                        <comment type="block">/* Size of bitmap */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name><name>aElem</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* Array of 32-bit bitmasks */</comment>
}</block>;</struct>

<comment type="block">/*
** State variables (part of the sqlite3_recover structure) used while
** recovering data for tables identified in the recovered schema (state
** RECOVER_STATE_WRITING).
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverStateW1</name></name></type> <name>RecoverStateW1</name>;</typedef>
<struct>struct <name>RecoverStateW1</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pTbls</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nInsert</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>             <comment type="block">/* Table currently being written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>                       <comment type="block">/* Max column count in any schema table */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl>;</decl_stmt>          <comment type="block">/* Array of nMax values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>                       <comment type="block">/* Number of valid entries in apVal[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iPrevPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrevCell</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** State variables (part of the sqlite3_recover structure) used while
** recovering data destined for the lost and found table (states
** RECOVER_STATE_LOSTANDFOUND[123]).
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverStateLAF</name></name></type> <name>RecoverStateLAF</name>;</typedef>
<struct>struct <name>RecoverStateLAF</name> <block>{
  <decl_stmt><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name></decl>;</decl_stmt>                        <comment type="block">/* Size of db in pages */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllAndParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMapInsert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pMaxField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pUsedPages</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pFindRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name></decl>;</decl_stmt>          <comment type="block">/* INSERT INTO lost_and_found ... */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pAllPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pPageData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxField</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Main recover handle structure.
*/</comment>
<struct>struct <name>sqlite3_recover</name> <block>{
  <comment type="block">/* Copies of sqlite3_recover_init[_sql]() parameters */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbIn</name></decl>;</decl_stmt>                  <comment type="block">/* Input database */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                      <comment type="block">/* Name of input db ("main" etc.) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUri</name></decl>;</decl_stmt>                     <comment type="block">/* URI for output database */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl>;</decl_stmt>                  <comment type="block">/* SQL callback context */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Pointer to SQL callback function */</comment>

  <comment type="block">/* Values configured by sqlite3_recover_config() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStateDb</name></decl>;</decl_stmt>                 <comment type="block">/* State database to use (or NULL) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLostAndFound</name></decl>;</decl_stmt>            <comment type="block">/* Name of lost-and-found table (or NULL) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bFreelistCorrupt</name></decl>;</decl_stmt>           <comment type="block">/* SQLITE_RECOVER_FREELIST_CORRUPT setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRecoverRowid</name></decl>;</decl_stmt>              <comment type="block">/* SQLITE_RECOVER_ROWIDS setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bSlowIndexes</name></decl>;</decl_stmt>               <comment type="block">/* SQLITE_RECOVER_SLOWINDEXES setting */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>detected_pgsz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReserve</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPage1Disk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>pPage1Cache</name></decl>;</decl_stmt>

  <comment type="block">/* Error code and error message */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>                    <comment type="block">/* For sqlite3_recover_errcode() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl>;</decl_stmt>                  <comment type="block">/* For sqlite3_recover_errmsg() */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>eState</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bCloseTransaction</name></decl>;</decl_stmt>

  <comment type="block">/* Variables used with eState==RECOVER_STATE_WRITING */</comment>
  <decl_stmt><decl><type><name>RecoverStateW1</name></type> <name>w1</name></decl>;</decl_stmt>

  <comment type="block">/* Variables used with states RECOVER_STATE_LOSTANDFOUND[123] */</comment>
  <decl_stmt><decl><type><name>RecoverStateLAF</name></type> <name>laf</name></decl>;</decl_stmt>

  <comment type="block">/* Fields used within sqlite3_recover_run() */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbOut</name></decl>;</decl_stmt>                 <comment type="block">/* Output database */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pGetPage</name></decl>;</decl_stmt>         <comment type="block">/* SELECT against input db sqlite_dbdata */</comment>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTblList</name></decl>;</decl_stmt>         <comment type="block">/* List of tables recovered from schema */</comment>
}</block>;</struct>

<comment type="block">/*
** The various states in which an sqlite3_recover object may exist:
**
**   RECOVER_STATE_INIT:
**    The object is initially created in this state. sqlite3_recover_step()
**    has yet to be called. This is the only state in which it is permitted
**    to call sqlite3_recover_config().
**
**   RECOVER_STATE_WRITING:
**
**   RECOVER_STATE_LOSTANDFOUND1:
**    State to populate the bitmap of pages used by other tables or the
**    database freelist.
**
**   RECOVER_STATE_LOSTANDFOUND2:
**    Populate the recovery.map table - used to figure out a "root" page
**    for each lost page from in the database from which records are
**    extracted.
**
**   RECOVER_STATE_LOSTANDFOUND3:
**    Populate the lost-and-found table itself.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_INIT</name></cpp:macro>           <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_WRITING</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND1</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND2</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_LOSTANDFOUND3</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_SCHEMA2</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_STATE_DONE</name></cpp:macro>           <cpp:value>6</cpp:value></cpp:define>


<comment type="block">/*
** Global variables used by this extension.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>RecoverGlobal</name></name></type> <name>RecoverGlobal</name>;</typedef>
<struct>struct <name>RecoverGlobal</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_io_methods</name> <modifier>*</modifier></type><name>pMethods</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>RecoverGlobal</name></type> <name>recover_g</name></decl>;</decl_stmt>

<comment type="block">/*
** Use this static SQLite mutex to protect the globals during the
** first call to sqlite3_recover_step().
*/</comment> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_MUTEX_ID</name></cpp:macro> <cpp:value>SQLITE_MUTEX_STATIC_APP2</cpp:value></cpp:define>


<comment type="block">/* 
** Default value for SQLITE_RECOVER_ROWIDS (sqlite3_recover.bRecoverRowid).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_ROWID_DEFAULT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
** Mutex handling:
**
**    recoverEnterMutex()       -   Enter the recovery mutex
**    recoverLeaveMutex()       -   Leave the recovery mutex
**    recoverAssertMutexHeld()  -   Assert that the recovery mutex is held
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_THREADSAFE</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverEnterMutex</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverLeaveMutex</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverEnterMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLeaveMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name><operator>+</operator><literal type="number">0</literal><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverAssertMutexHeld</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>RECOVER_MUTEX_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>recoverAssertMutexHeld</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Like strlen(). But handles NULL pointer arguments.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverStrlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if the recover handle passed as the first 
** argument already contains an error (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, an attempt is made to allocate, zero and return a buffer nByte
** bytes in size. If successful, a pointer to the new buffer is returned. Or,
** if an OOM error occurs, NULL is returned and the handle error code
** (p-&gt;errCode) set to SQLITE_NOMEM.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>recoverMalloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the error code and error message for the recover handle passed as
** the first argument. The error code is set to the value of parameter
** errCode.
**
** Parameter zFmt must be a printf() style formatting string. The handle 
** error message is set to the result of using any trailing arguments for 
** parameter substitutions in the formatting string.
**
** For example:
**
**   recoverError(p, SQLITE_ERROR, "no such table: %s", zTablename);
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFmt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt>
  <return>return <expr><name>errCode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** This function is a no-op if p-&gt;errCode is initially other than SQLITE_OK.
** In this case it returns NULL.
**
** Otherwise, an attempt is made to allocate and return a bitmap object
** large enough to store a bit for all page numbers between 1 and nPg,
** inclusive. The bitmap is initially zeroed.
*/</comment>
<function><type><specifier>static</specifier> <name>RecoverBitmap</name> <modifier>*</modifier></type><name>recoverBitmapAlloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nElem</name> <init>= <expr><operator>(</operator><name>nPg</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">31</literal><operator>)</operator> <operator>/</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecoverBitmap</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nElem</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><operator>(</operator><name>RecoverBitmap</name><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>nPg</name></name> <operator>=</operator> <name>nPg</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free a bitmap object allocated by recoverBitmapAlloc().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBitmapFree</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the bit associated with page iPg in bitvec pMap.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBitmapSet</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;=</operator><name><name>pMap</name><operator>-&gt;</operator><name>nPg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iElem</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBit</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pMap</name><operator>-&gt;</operator><name>aElem</name><index>[<expr><name>iElem</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>iBit</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Query bitmap object pMap for the state of the bit associated with page
** iPg. Return 1 if it is set, or 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverBitmapQuery</name><parameter_list>(<parameter><decl><type><name>RecoverBitmap</name> <modifier>*</modifier></type><name>pMap</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iPg</name><operator>&lt;=</operator><name><name>pMap</name><operator>-&gt;</operator><name>nPg</name></name> <operator>&amp;&amp;</operator> <name>iPg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iElem</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>/</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBit</name> <init>= <expr><operator>(</operator><name>iPg</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pMap</name><operator>-&gt;</operator><name>aElem</name><index>[<expr><name>iElem</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>iBit</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the recover handle error to the error code and message returned by
** calling sqlite3_errcode() and sqlite3_errmsg(), respectively, on database
** handle db.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverDbError</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, it attempts to prepare the SQL statement in zSql against
** database handle db. If successful, the statement handle is returned.
** Or, if an error occurs, NULL is returned and an error left in the
** recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverPrepare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). 
**
** Otherwise, argument zFmt is used as a printf() style format string,
** along with any trailing arguments, to create an SQL statement. This
** SQL statement is prepared against database handle db and, if successful,
** the statment handle returned. Or, if an error occurs - either during
** the printf() formatting or when preparing the resulting SQL - an
** error code and message are left in the recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverPreparePrintf</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reset SQLite statement handle pStmt. If the call to sqlite3_reset() 
** indicates that an error occurred, and there is not already an error
** in the recover handle passed as the first argument, set the error
** code and error message appropriately.
**
** This function returns a copy of the statement handle pointer passed
** as the second argument.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverReset</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_CONSTRAINT</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Finalize SQLite statement handle pStmt. If the call to sqlite3_reset() 
** indicates that an error occurred, and there is not already an error
** in the recover handle passed as the first argument, set the error
** code and error message appropriately.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of p-&gt;errCode is returned in this 
** case.
**
** Otherwise, execute SQL script zSql. If successful, return SQLITE_OK.
** Or, if an error occurs, leave an error code and message in the recover
** handle and return a copy of the error code.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverExec</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Bind the value pVal to parameter iBind of statement pStmt. Leave an
** error in the recover handle passed as the first argument if an error
** (e.g. an OOM) occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverBindValue</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iBind</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). NULL is returned in this case.
**
** Otherwise, an attempt is made to interpret zFmt as a printf() style
** formatting string and the result of using the trailing arguments for
** parameter substitution with it written into a buffer obtained from
** sqlite3_malloc(). If successful, a pointer to the buffer is returned.
** It is the responsibility of the caller to eventually free the buffer
** using sqlite3_free().
**
** Or, if an error occurs, an error code and message is left in the recover
** handle and NULL returned.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverMPrintf</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). Zero is returned in this case.
**
** Otherwise, execute "PRAGMA page_count" against the input database. If
** successful, return the integer result. Or, if an error occurs, leave an
** error code and error message in the sqlite3_recover handle and return
** zero.
*/</comment>
<function><type><specifier>static</specifier> <name>i64</name></type> <name>recoverPageCount</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %Q.page_count"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nPg</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nPg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of SQL scalar function "read_i32". The first argument to 
** this function must be a blob. The second a non-negative integer. This 
** function reads and returns a 32-bit big-endian integer from byte
** offset (4*&lt;arg2&gt;) of the blob.
**
**     SELECT read_i32(&lt;blob&gt;, &lt;idx&gt;)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverReadI32</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iInt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iInt</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iInt</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal><operator>&lt;=</operator><name>nBlob</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>pBlob</name><index>[<expr><name>iInt</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator>
             <operator>+</operator> <operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of SQL scalar function "page_is_used". This function
** is used as part of the procedure for locating orphan rows for the
** lost-and-found table, and it depends on those routines having populated
** the sqlite3_recover.laf.pUsed variable.
**
** The only argument to this function is a page-number. It returns true 
** if the page has already been used somehow during data recovery, or false
** otherwise.
**
**     SELECT page_is_used(&lt;pgno&gt;);
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPageIsUsed</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>pgno</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The implementation of a user-defined SQL function invoked by the 
** sqlite_dbdata and sqlite_dbptr virtual table modules to access pages
** of the database being recovered.
**
** This function always takes a single integer argument. If the argument
** is zero, then the value returned is the number of pages in the db being
** recovered. If the argument is greater than zero, it is a page number. 
** The value returned in this case is an SQL blob containing the data for 
** the identified page of the db being recovered. e.g.
**
**     SELECT getpage(0);       -- return number of pages in db
**     SELECT getpage(4);       -- return page 4 of db as a blob of data 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverGetPage</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>pgno</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nPg</name> <init>= <expr><call><name>recoverPageCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
          <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT data FROM sqlite_dbpage(%Q) WHERE pgno=?"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>aPg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nPg</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aPg</name> <operator>=</operator> <call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nPg</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nPg</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pgsz</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>aPg</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nPg</name><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find a string that is not found anywhere in z[].  Return a pointer
** to that string.
**
** Try to use zA and zB first.  If both of those are already found in z[]
** then make up some string and store it in the buffer zBuf.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverUnusedString</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,                    <comment type="block">/* Result must not appear anywhere in z */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>,   <comment type="block">/* Try these first */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>                        <comment type="block">/* Space to store a generated string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zA</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zB</name></expr>;</return></block_content></block></if></if_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><literal type="string">"(%s%u)"</literal></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>zBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of scalar SQL function "escape_crnl".  The argument passed to
** this function is the output of built-in function quote(). If the first
** character of the input is "'", indicating that the value passed to quote()
** was a text value, then this function searches the input for "\n" and "\r"
** characters and adds a wrapper similar to the following:
**
**   replace(replace(&lt;input&gt;, '\n', char(10), '\r', char(13));
**
** Or, if the first character of the input is not "'", then a copy of the input
** is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverEscapeCrnl</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nText</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf2</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zNL</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zNL</name> <operator>=</operator> <call><name>recoverUnusedString</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><literal type="string">"\\012"</literal></expr></argument>, <argument><expr><name>zBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNL</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zCR</name> <operator>=</operator> <call><name>recoverUnusedString</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>, <argument><expr><literal type="string">"\\015"</literal></expr></argument>, <argument><expr><name>zBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCR</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>||</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nMax</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nNL</name> <operator>&gt;</operator> <name>nCR</name><operator>)</operator></expr> ?</condition><then> <expr><name>nNL</name></expr> </then><else>: <expr><name>nCR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><name>nMax</name> <operator>*</operator> <name>nText</name> <operator>+</operator> <operator>(</operator><name>nMax</name><operator>+</operator><literal type="number">64</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>&amp;&amp;</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace(replace("</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace("</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>zNL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(10))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(13))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of the error code is returned in
** this case. 
**
** Otherwise, attempt to populate temporary table "recovery.schema" with the
** parts of the database schema that can be extracted from the input database.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an error code
** and error message are left in the recover handle and a copy of the
** error code returned. It is not considered an error if part of all of
** the database schema cannot be recovered due to corruption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverCacheSchema</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
    <argument><expr><literal type="string">"WITH RECURSIVE pages(p) AS ("</literal>
    <literal type="string">"  SELECT 1"</literal>
    <literal type="string">"    UNION"</literal>
    <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), pages WHERE pgno=p"</literal>
    <literal type="string">")"</literal>
    <literal type="string">"INSERT INTO recovery.schema SELECT"</literal>
    <literal type="string">"  max(CASE WHEN field=0 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=1 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=2 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=3 THEN value ELSE NULL END),"</literal>
    <literal type="string">"  max(CASE WHEN field=4 THEN value ELSE NULL END)"</literal>
    <literal type="string">"FROM sqlite_dbdata('getpage()') WHERE pgno IN ("</literal>
    <literal type="string">"  SELECT p FROM pages"</literal>
    <literal type="string">") GROUP BY pgno, cell"</literal></expr></argument>
  )</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If this recover handle is not in SQL callback mode (i.e. was not created 
** using sqlite3_recover_init_sql()) of if an error has already occurred, 
** this function is a no-op. Otherwise, issue a callback with SQL statement
** zSql as the parameter. 
**
** If the callback returns non-zero, set the recover handle error code to
** the value returned (so that the caller will abandon processing).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverSqlCallback</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>xSql</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSqlCtx</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"callback returned an error - %d"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Transfer the following settings from the input database to the output
** database:
**
**   + page-size,
**   + auto-vacuum settings,
**   + database encoding,
**   + user-version (PRAGMA user_version), and
**   + application-id (PRAGMA application_id), and
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverTransferSettings</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>aPragma</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"encoding"</literal></expr>,
    <expr><literal type="string">"page_size"</literal></expr>,
    <expr><literal type="string">"auto_vacuum"</literal></expr>,
    <expr><literal type="string">"user_version"</literal></expr>,
    <expr><literal type="string">"application_id"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <comment type="block">/* Truncate the output database to 0 pages in size. This is done by 
  ** opening a new, empty, temp db, then using the backup API to clobber 
  ** any existing output db with a copy of it. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>db2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aPragma</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aPragma</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPrag</name> <init>= <expr><name><name>aPragma</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %Q.%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zPrag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z2</name> <init>= <expr><call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA %s = %Q"</literal></expr></argument>, <argument><expr><name>zPrag</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE t1(a); DROP TABLE t1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_backup</name> <modifier>*</modifier></type><name>pBackup</name> <init>= <expr><call><name>sqlite3_backup_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>pBackup</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_backup_step</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_backup_finish</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). A copy of the error code is returned in
** this case. 
**
** Otherwise, an attempt is made to open the output database, attach
** and create the schema of the temporary database used to store
** intermediate data, and to register all required user functions and
** virtual table modules with the output handle.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an error code
** and error message are left in the recover handle and a copy of the
** error code returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverOpenOutput</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct>struct <name>Func</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"getpage"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverGetPage</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"page_is_used"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverPageIsUsed</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"read_i32"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>recoverReadI32</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"escape_crnl"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>recoverEscapeCrnl</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>

  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><name>SQLITE_OPEN_URI</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_READWRITE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* New database handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                         <comment type="block">/* For iterating through aFunc[] */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zUri</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the sqlite_dbdata and sqlite_dbptr virtual table modules.
  ** These two are registered with the output database handle - this
  ** module depends on the input handle supporting the sqlite_dbpage
  ** virtual table only.  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_dbdata_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Register the custom user-functions with the output handle. */</comment>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, 
        <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Attach the auxiliary database 'recovery' to the output database handle.
** This temporary database is used during the recovery process and then 
** discarded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverOpenRecovery</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"ATTACH %Q AS recovery;"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"PRAGMA writable_schema = 1;"</literal>
      <literal type="string">"CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, parent INT);"</literal> 
      <literal type="string">"CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK).
**
** Otherwise, argument zName must be the name of a table that has just been
** created in the output database. This function queries the output db
** for the schema of said table, and creates a RecoverTable object to
** store the schema in memory. The new RecoverTable object is linked into
** the list at sqlite3_recover.pTblList.
**
** Parameter iRoot must be the root page of table zName in the INPUT 
** database.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverAddTable</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name of table created in output db */</comment>
  <parameter><decl><type><name>i64</name></type> <name>iRoot</name></decl></parameter>                       <comment type="block">/* Root page of same table in INPUT db */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, 
      <argument><expr><literal type="string">"PRAGMA table_xinfo(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iPk</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iBind</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nCol</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <operator>(</operator><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecoverTable</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nCol</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RecoverColumn</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>csr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <operator>(</operator><name>RecoverColumn</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zTab</name></name> <operator>=</operator> <name>csr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name>nCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iRoot</name></name> <operator>=</operator> <name>iRoot</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>csr</name> <operator>+=</operator> <name>nName</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iPKF</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>iPk</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iPKF</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"integer"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPk</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iPKF</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iPk</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCol</name> <operator>=</operator> <name>csr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eHidden</name> <operator>=</operator> <name>eHidden</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>==</operator><name>RECOVER_EHIDDEN_VIRTUAL</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <name>iField</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_VIRTUAL</name>
         <operator>&amp;&amp;</operator> <name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_STORED</name></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iBind</name> <operator>=</operator> <name>iBind</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>csr</name> <operator>+=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA index_xinfo(%Q)"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pStmt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iField</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name><name>pNew</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>iField</name> <operator>=</operator> <name>iField</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iPk</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iPk</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iPk</name></expr>]</index></name><operator>.</operator><name>bIPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>bIntkey</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iRowidBind</name></name> <operator>=</operator> <name>iBind</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after recoverCacheSchema() has cached those parts
** of the input database schema that could be recovered in temporary table
** "recovery.schema". This function creates in the output database copies
** of all parts of that schema that must be created before the tables can
** be populated. Specifically, this means:
**
**     * all tables that are not VIRTUAL, and
**     * UNIQUE indexes.
**
** If the recovery handle uses SQL callbacks, then callbacks containing
** the associated "CREATE TABLE" and "CREATE INDEX" statements are made.
**
** Additionally, records are added to the sqlite_schema table of the
** output database for any VIRTUAL tables. The CREATE VIRTUAL TABLE
** records are written directly to sqlite_schema, not actually executed.
** If the handle is in SQL callback mode, then callbacks are invoked 
** with equivalent SQL statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteSchema1</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pTblname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH dbschema(rootpage, name, sql, tbl, isVirtual, isIndex) AS ("</literal>
      <literal type="string">"  SELECT rootpage, name, sql, "</literal>
      <literal type="string">"    type='table', "</literal>
      <literal type="string">"    sql LIKE 'create virtual%',"</literal>
      <literal type="string">"    (type='index' AND (sql LIKE '%unique%' OR ?1))"</literal>
      <literal type="string">"  FROM recovery.schema"</literal>
      <literal type="string">")"</literal>
      <literal type="string">"SELECT rootpage, tbl, isVirtual, name, sql"</literal>
      <literal type="string">" FROM dbschema "</literal>
      <literal type="string">"  WHERE tbl OR isIndex"</literal>
      <literal type="string">"  ORDER BY tbl DESC, name=='sqlite_sequence' DESC"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTblname</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT name FROM sqlite_schema "</literal>
      <literal type="string">"WHERE type='table' ORDER BY rowid DESC LIMIT 1"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bTable</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bVirtual</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>bVirtual</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>zFree</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
            <argument><expr><literal type="string">"INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)"</literal></expr></argument>,
            <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>
        )</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bVirtual</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pTblname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>recoverAddTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after the output database has been populated. It
** adds all recovered schema elements that were not created in the output
** database by recoverWriteSchema1() - everything except for tables and
** UNIQUE indexes. Specifically:
**
**     * views,
**     * triggers,
**     * non-UNIQUE indexes.
**
** If the recover handle is in SQL callback mode, then equivalent callbacks
** are issued to create the schema elements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteSchema2</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pSelect</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name></expr> ?</condition><then>
      <expr><literal type="string">"SELECT rootpage, sql FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type!='table' AND type!='index'"</literal></expr>
      </then><else>:
      <expr><literal type="string">"SELECT rootpage, sql FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type!='table' AND (type!='index' OR sql NOT LIKE '%unique%')"</literal></expr></else></ternary></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pSelect</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverDbError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is a no-op if recover handle p already contains an error
** (if p-&gt;errCode!=SQLITE_OK). In this case it returns NULL.
**
** Otherwise, if the recover handle is configured to create an output
** database (was created by sqlite3_recover_init()), then this function
** prepares and returns an SQL statement to INSERT a new record into table
** pTab, assuming the first nField fields of a record extracted from disk
** are valid.
**
** For example, if table pTab is:
**
**     CREATE TABLE name(a, b GENERATED ALWAYS AS (a+1) STORED, c, d, e);
**
** And nField is 4, then the SQL statement prepared and returned is:
**
**     INSERT INTO (a, c, d) VALUES (?1, ?2, ?3);
**
** In this case even though 4 values were extracted from the input db,
** only 3 are written to the output, as the generated STORED column 
** cannot be written.
**
** If the recover handle is in SQL callback mode, then the SQL statement
** prepared is such that evaluating it returns a single row containing
** a single text value - itself an SQL statement similar to the above,
** except with SQL literals in place of the variables. For example:
**
**     SELECT 'INSERT INTO (a, c, d) VALUES (' 
**          || quote(?1) || ', '
**          || quote(?2) || ', '
**          || quote(?3) || ')';
**
** In either case, it is the responsibility of the caller to eventually
** free the statement handle using sqlite3_finalize().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverInsertStmt</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSqlSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFinal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bSql</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nField</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name><operator>&lt;=</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"INSERT OR IGNORE INTO %Q("</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>bIntkey</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z_rowid_"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%zquote(?%d)"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z?%d"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zSqlSep</name> <operator>=</operator> <literal type="string">"||', '||"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eHidden</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>eHidden</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_VIRTUAL</name>
     <operator>&amp;&amp;</operator> <name>eHidden</name><operator>!=</operator><name>RECOVER_EHIDDEN_STORED</name></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iField</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s%Q"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
            <argument><expr><literal type="string">"%z%sescape_crnl(quote(?%d))"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSqlSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSqlSep</name> <operator>=</operator> <literal type="string">"||', '||"</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s?%d"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>iBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>bSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zFinal</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"SELECT %Q || ') VALUES (' || %s || ')'"</literal></expr></argument>, 
        <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zFinal</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s) VALUES (%s)"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Search the list of RecoverTable objects at p-&gt;pTblList for one that
** has root page iRoot in the input database. If such an object is found,
** return a pointer to it. Otherwise, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>RecoverTable</name> <modifier>*</modifier></type><name>recoverFindTable</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iRoot</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pRet</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pRet</name> <operator>&amp;&amp;</operator> <name><name>pRet</name><operator>-&gt;</operator><name>iRoot</name></name><operator>!=</operator><name>iRoot</name></expr>;</condition> <incr><expr><name>pRet</name><operator>=</operator><name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function attempts to create a lost and found table within the 
** output db. If successful, it returns a pointer to a buffer containing
** the name of the new table. It is the responsibility of the caller to
** eventually free this buffer using sqlite3_free().
**
** If an error occurs, NULL is returned and an error code and error 
** message left in the recover handle.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recoverLostAndFoundCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Recover object */</comment>
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>                      <comment type="block">/* Number of column fields in new table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pProbe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pProbe</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
    <argument><expr><literal type="string">"SELECT 1 FROM sqlite_schema WHERE name=?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>zTbl</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><literal type="number">1000</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bFail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>ii</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bFail</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>bFail</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zTbl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>zTbl</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zField</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER, "</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ii</name><operator>&lt;</operator><name>nField</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zField</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%sc%d"</literal></expr></argument>, <argument><expr><name>zField</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE %s(%s)"</literal></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>zField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>recoverError</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create %s output table"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>zTbl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Synthesize and prepare an INSERT statement to write to the lost_and_found
** table in the output database. The name of the table is zTab, and it has
** nField c* fields.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>recoverLostAndFoundInsert</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nField</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nTotal</name> <init>= <expr><name>nField</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>xSql</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%s?"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zBind</name></expr>?</condition><then><expr><literal type="string">", "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s VALUES(%s)"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zBind</name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%z%squote(?)"</literal></expr></argument>, <argument><expr><name>zBind</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"|| ', ' ||"</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>pRet</name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(
        <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 'INSERT INTO %s VALUES(' || %s || ')'"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zBind</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Input database page iPg contains data that will be written to the
** lost-and-found table of the output database. This function attempts
** to identify the root page of the tree that page iPg belonged to.
** If successful, it sets output variable (*piRoot) to the page number
** of the root page and returns SQLITE_OK. Otherwise, if an error occurs,
** an SQLite error code is returned and the final value of *piRoot 
** undefined.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFoundFindRoot</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 
  <parameter><decl><type><name>i64</name></type> <name>iPg</name></decl></parameter>,
  <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>piRoot</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"WITH RECURSIVE p(pgno) AS ("</literal>
        <literal type="string">"  SELECT ?"</literal>
        <literal type="string">"    UNION"</literal>
        <literal type="string">"  SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno"</literal>
        <literal type="string">") "</literal>
        <literal type="string">"SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno "</literal>
        <literal type="string">"    AND m.parent IS NULL"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piRoot</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>piRoot</name> <operator>=</operator> <name>iPg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Recover data from page iPage of the input database and write it to
** the lost-and-found table in the output database.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFoundOnePage</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>apVal</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pPageData</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pPageData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name> <init>= <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrevCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bHaveRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iRowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>recoverLostAndFoundFindRoot</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRoot</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>iPrevCell</name><operator>!=</operator><name>iCell</name> <operator>&amp;&amp;</operator> <name>nVal</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Insert the new row */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* rootpgno */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* pgno */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* nfield */</comment>
      <if_stmt><if>if<condition>( <expr><name>bHaveRowid</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* id */</comment>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>recoverBindValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">5</literal><operator>+</operator><name>ii</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Discard the accumulated row data */</comment>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bHaveRowid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iCell</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bHaveRowid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iField</name><operator>&lt;</operator><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pPageData</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iField</name><operator>==</operator><name>nVal</name> <operator>||</operator> <operator>(</operator><name>nVal</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iField</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> <operator>=</operator> <name>iField</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>iPrevCell</name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pPageData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nVal</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND3 state - during which the lost-and-found 
** table of the output database is populated with recovered data that can 
** not be assigned to any recovered schema object.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound3Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>i64</name></type> <name>iPage</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>recoverLostAndFoundOnePage</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required in RECOVER_STATE_LOSTANDFOUND3 
** state - during which the lost-and-found table of the output database 
** is populated with recovered data that can not be assigned to any 
** recovered schema object.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound3Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Name of lost_and_found table */</comment>

    <expr_stmt><expr><name>zTab</name> <operator>=</operator> <call><name>recoverLostAndFoundCreate</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <call><name>recoverLostAndFoundInsert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllPage</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"WITH RECURSIVE seq(ii) AS ("</literal>
        <literal type="string">"  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii&lt;%lld"</literal>
        <literal type="string">")"</literal>
        <literal type="string">"SELECT ii FROM seq"</literal></expr></argument> , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nPg</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pPageData</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
        <argument><expr><literal type="string">"SELECT cell, field, value "</literal>
        <literal type="string">"FROM sqlite_dbdata('getpage()') d WHERE d.pgno=? "</literal>
        <literal type="string">"UNION ALL "</literal>
        <literal type="string">"SELECT -1, -1, -1"</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>apVal</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
        <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required in RECOVER_STATE_WRITING state - during which
** tables recovered from the schema of the input database are populated with
** recovered data.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteDataInit</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Figure out the maximum number of columns for any table in the schema */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pTbl</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pTbl</name></expr>;</condition> <incr><expr><name>pTbl</name><operator>=</operator><name><name>pTbl</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pTbl</name><operator>-&gt;</operator><name>nCol</name></name><operator>&gt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name> <operator>=</operator> <name><name>pTbl</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Allocate an array of (sqlite3_value*) in which to accumulate the values
  ** that will be written to the output database in a single row. */</comment>
  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_value</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>nMax</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Prepare the SELECT to loop through schema tables (pTbls) and the SELECT
  ** to loop through cells that appear to belong to a single table (pSel). */</comment>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT rootpage FROM recovery.schema "</literal>
      <literal type="string">"  WHERE type='table' AND (sql NOT LIKE 'create virtual%')"</literal>
      <literal type="string">"  ORDER BY (tbl_name='sqlite_sequence') ASC"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, 
      <argument><expr><literal type="string">"WITH RECURSIVE pages(page) AS ("</literal>
      <literal type="string">"  SELECT ?1"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), pages "</literal>
      <literal type="string">"    WHERE pgno=page"</literal>
      <literal type="string">") "</literal>
      <literal type="string">"SELECT page, cell, field, value "</literal>
      <literal type="string">"FROM sqlite_dbdata('getpage()') d, pages p WHERE p.page=d.pgno "</literal>
      <literal type="string">"UNION ALL "</literal>
      <literal type="string">"SELECT 0, 0, 0, 0"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Clean up resources allocated by recoverWriteDataInit() (stuff in 
** sqlite3_recover.w1).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverWriteDataCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_WRITING state - during which tables recovered from the
** schema of the input database are populated with recovered data.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverWriteDataStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateW1</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>w1</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSel</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pSel</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>apVal</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iRoot</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTbls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <call><name>recoverFindTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* If this table is unknown, return early. The caller will invoke this
      ** function again and it will move on to the next table.  */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* If this is the sqlite_sequence table, delete any rows added by
      ** earlier INSERT statements on tables with AUTOINCREMENT primary
      ** keys before recovering its contents. The p1-&gt;pTbls SELECT statement
      ** is rigged to deliver "sqlite_sequence" last of all, so we don't
      ** worry about it being modified after it is recovered. */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>zTab</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM sqlite_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM sqlite_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Bind the root page of this table within the original database to 
      ** SELECT statement p1-&gt;pSel. The SELECT statement will then iterate
      ** through cells that look like they belong to table pTab.  */</comment>
      <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>i64</name></type> <name>iPage</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCell</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iField</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bNewCell</name> <init>= <expr><operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name><operator>!=</operator><name>iPage</name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name><operator>!=</operator><name>iCell</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bNewCell</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>iField</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>iField</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bNewCell</name> <operator>||</operator> <name>iField</name><operator>==</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>==</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>bNewCell</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>!=</operator><name><name>p1</name><operator>-&gt;</operator><name>nInsert</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name> <operator>=</operator> <call><name>recoverInsertStmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nInsert</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>pInsert</name></name></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>RecoverColumn</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><operator>&amp;</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>iBind</name> <init>= <expr><name><name>pCol</name><operator>-&gt;</operator><name>iBind</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>iBind</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>bIPK</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pCol</name><operator>-&gt;</operator><name>iField</name></name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><call><name>recoverBindValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>iBind</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><name><name>pCol</name><operator>-&gt;</operator><name>iField</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>iRowidBind</name></name></expr></argument>, <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>||</operator> <name>pInsert</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pInsert</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_clear_bindings</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_value_free</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iPage</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iField</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pSel</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>bHaveRowid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iField</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_value_dup</name><argument_list>( <argument><expr><name>pVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>apVal</name><index>[<expr><name>iField</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>recoverError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <name>iField</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevCell</name></name> <operator>=</operator> <name>iCell</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>iPrevPage</name></name> <operator>=</operator> <name>iPage</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p1</name><operator>-&gt;</operator><name>pTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required by sqlite3_recover_step() in
** RECOVER_STATE_LOSTANDFOUND1 state - during which the set of pages not
** already allocated to a recovered schema element is determined.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nPg</name></name> <operator>=</operator> <call><name>recoverPageCount</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name> <operator>=</operator> <call><name>recoverBitmapAlloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nPg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Prepare a statement to iterate through all pages that are part of any tree
  ** in the recoverable part of the input database schema to the bitmap. And,
  ** if !p-&gt;bFreelistCorrupt, add all pages that appear to be part of the
  ** freelist.  */</comment>
  <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(
      <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH trunk(pgno) AS ("</literal>
      <literal type="string">"  SELECT read_i32(getpage(1), 8) AS x WHERE x&gt;0"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT read_i32(getpage(trunk.pgno), 0) AS x FROM trunk WHERE x&gt;0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"trunkdata(pgno, data) AS ("</literal>
      <literal type="string">"  SELECT pgno, getpage(pgno) FROM trunk"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"freelist(data, n, freepgno) AS ("</literal>
      <literal type="string">"  SELECT data, min(16384, read_i32(data, 1)-1), pgno FROM trunkdata"</literal>
      <literal type="string">"    UNION ALL"</literal>
      <literal type="string">"  SELECT data, n-1, read_i32(data, 2+n) FROM freelist WHERE n&gt;=0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">""</literal>
      <literal type="string">"roots(r) AS ("</literal>
      <literal type="string">"  SELECT 1 UNION ALL"</literal>
      <literal type="string">"  SELECT rootpage FROM recovery.schema WHERE rootpage&gt;0"</literal>
      <literal type="string">"),"</literal>
      <literal type="string">"used(page) AS ("</literal>
      <literal type="string">"  SELECT r FROM roots"</literal>
      <literal type="string">"    UNION"</literal>
      <literal type="string">"  SELECT child FROM sqlite_dbptr('getpage()'), used "</literal>
      <literal type="string">"    WHERE pgno=page"</literal>
      <literal type="string">") "</literal>
      <literal type="string">"SELECT page FROM used"</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT freepgno FROM freelist WHERE NOT ?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bFreelistCorrupt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND1 state - during which the set of pages not
** already allocated to a recovered schema element is determined.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound1Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iPg</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>recoverBitmapSet</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsedPages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize resources required by RECOVER_STATE_LOSTANDFOUND2 
** state - during which the pages identified in RECOVER_STATE_LOSTANDFOUND1
** are sorted into sets that likely belonged to the same database tree.
*/</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFound2Init</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nMaxField</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name> <operator>=</operator> <call><name>recoverPrepare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"INSERT OR IGNORE INTO recovery.map(pgno, parent) VALUES(?, ?)"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"WITH RECURSIVE seq(ii) AS ("</literal>
      <literal type="string">"  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii&lt;%lld"</literal>
      <literal type="string">")"</literal>
      <literal type="string">"SELECT pgno, child FROM sqlite_dbptr('getpage()') "</literal>
      <literal type="string">" UNION ALL "</literal>
      <literal type="string">"SELECT NULL, ii FROM seq"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>nPg</name></name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name> <operator>=</operator> <call><name>recoverPreparePrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>,
      <argument><expr><literal type="string">"SELECT max(field)+1 FROM sqlite_dbdata('getpage') WHERE pgno = ?"</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Perform one step (sqlite3_recover_step()) of work for the connection 
** passed as the only argument, which is guaranteed to be in
** RECOVER_STATE_LOSTANDFOUND2 state - during which the pages identified 
** in RECOVER_STATE_LOSTANDFOUND1 are sorted into sets that likely belonged 
** to the same database tree.
*/</comment> 
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverLostAndFound2Step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverStateLAF</name> <modifier>*</modifier></type><name>pLaf</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>laf</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iChild</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>recoverBitmapQuery</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pUsed</name></name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, 
            <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>nMax</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nMax</name><operator>&gt;</operator><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>nMaxField</name></name> <operator>=</operator> <name>nMax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>recoverReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>recoverFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pLaf</name><operator>-&gt;</operator><name>pAllAndParent</name></name> <operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources allocated as part of sqlite3_recover_step() calls
** in one of the RECOVER_STATE_LOSTANDFOUND[123] states.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverLostAndFoundCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>recoverBitmapFree</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsedPages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pFindRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pPageData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsedPages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMapInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pMaxField</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pFindRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pPageData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>apVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>apVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free all resources allocated as part of sqlite3_recover_step() calls.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverFinalCleanup</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RecoverTable</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>recoverWriteDataCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverLostAndFoundCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>pTab</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name></expr>;</init> <condition><expr><name>pTab</name></expr>;</condition> <incr><expr><name>pTab</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pTblList</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pGetPage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>res</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Decode and return an unsigned 16-bit big-endian integer value from 
** buffer a[].
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>recoverGetU16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode and return an unsigned 32-bit big-endian integer value from 
** buffer a[].
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>recoverGetU32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decode an SQLite varint from buffer a[]. Write the decoded value to (*pVal)
** and return the number of bytes consumed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverGetVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>i64</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">7</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt> <return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>u</name> <operator>=</operator> <operator>(</operator><name>u</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">9</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The second argument points to a buffer n bytes in size. If this buffer
** or a prefix thereof appears to contain a well-formed SQLite b-tree page, 
** return the page-size in bytes. Otherwise, if the buffer does not 
** appear to contain a well-formed b-tree page, return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverIsValidPage</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>aTmp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aUsed</name> <init>= <expr><name>aTmp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nActual</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Number of cells on page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCellOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* Offset of cell array in page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iContent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>eType</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><literal type="number">0x02</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x05</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x0A</literal> <operator>&amp;&amp;</operator> <name>eType</name><operator>!=</operator><literal type="number">0x0D</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>iFree</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iContent</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iContent</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iContent</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nFrag</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iContent</name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aUsed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aUsed</name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>iContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Follow the free-list. This is the same format for all b-tree pages. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iFree</name> <operator>&amp;&amp;</operator> <name>iFree</name><operator>&lt;=</operator><name>iContent</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>iFree</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iNext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>&gt;</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">4</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iFree</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iFree</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iFree</name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name>n</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iNext</name> <operator>&amp;&amp;</operator> <name>iNext</name><operator>&lt;</operator><name>iFree</name><operator>+</operator><name>nByte</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aUsed</name><index>[<expr><name>iFree</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iFree</name> <operator>=</operator> <name>iNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Run through the cells */</comment>
  <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x02</literal> <operator>||</operator> <name>eType</name><operator>==</operator><literal type="number">0x05</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iCellOff</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iCellOff</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iCellOff</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>nCell</name><operator>)</operator><operator>&gt;</operator><name>iContent</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCell</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iByte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nPayload</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOff</name> <init>= <expr><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iCellOff</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>iOff</name><argument_list type="generic">&lt;<argument><expr><name>iContent</name> <operator>||</operator> <name>iOff</name></expr></argument>&gt;</argument_list></name><name>n</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x05</literal> <operator>||</operator> <name>eType</name><operator>==</operator><literal type="number">0x02</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>recoverGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iOff</name><operator>+</operator><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>==</operator><literal type="number">0x0D</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <call><name>recoverGetVarint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>iOff</name><operator>+</operator><name>nByte</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eType</name><operator>!=</operator><literal type="number">0x05</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>X</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>eType</name><operator>==</operator><literal type="number">0x0D</literal><operator>)</operator></expr> ?</condition><then> <expr><name>n</name><operator>-</operator><literal type="number">35</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">64</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>M</name> <init>= <expr><operator>(</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">12</literal><operator>)</operator><operator>*</operator><literal type="number">32</literal><operator>/</operator><literal type="number">255</literal><operator>)</operator><operator>-</operator><literal type="number">23</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>K</name> <init>= <expr><name>M</name><operator>+</operator><operator>(</operator><operator>(</operator><name>nPayload</name><operator>-</operator><name>M</name><operator>)</operator><operator>%</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>nPayload</name><operator>&lt;</operator><name>X</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>nPayload</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>K</name><operator>&lt;=</operator><name>X</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>K</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <name>M</name><operator>+</operator><literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>iOff</name><operator>+</operator><name>nByte</name><operator>&gt;</operator><name>n</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>iByte</name><operator>=</operator><name>iOff</name></expr>;</init> <condition><expr><name>iByte</name><operator>&lt;</operator><operator>(</operator><name>iOff</name><operator>+</operator><name>nByte</name><operator>)</operator></expr>;</condition> <incr><expr><name>iByte</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aUsed</name><index>[<expr><name>iByte</name></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>aUsed</name><index>[<expr><name>iByte</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><name>nActual</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aUsed</name><index>[<expr><name>ii</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nActual</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>nActual</name><operator>==</operator><name>nFrag</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOfst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsWrite</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmMap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>volatile</specifier><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recoverVfsShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_io_methods</name></type> <name>recover_methods</name> <init>= <expr><block>{
  <expr><literal type="number">2</literal></expr>, <comment type="block">/* iVersion */</comment>
  <expr><name>recoverVfsClose</name></expr>,
  <expr><name>recoverVfsRead</name></expr>,
  <expr><name>recoverVfsWrite</name></expr>,
  <expr><name>recoverVfsTruncate</name></expr>,
  <expr><name>recoverVfsSync</name></expr>,
  <expr><name>recoverVfsFileSize</name></expr>,
  <expr><name>recoverVfsLock</name></expr>,
  <expr><name>recoverVfsUnlock</name></expr>,
  <expr><name>recoverVfsCheckReservedLock</name></expr>,
  <expr><name>recoverVfsFileControl</name></expr>,
  <expr><name>recoverVfsSectorSize</name></expr>,
  <expr><name>recoverVfsDeviceCharacteristics</name></expr>,
  <expr><name>recoverVfsShmMap</name></expr>,
  <expr><name>recoverVfsShmLock</name></expr>,
  <expr><name>recoverVfsShmBarrier</name></expr>,
  <expr><name>recoverVfsShmUnmap</name></expr>,
  <expr><name>recoverVfsFetch</name></expr>,
  <expr><name>recoverVfsUnfetch</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>!=</operator><operator>&amp;</operator><name>recover_methods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Write value v to buffer a[] as a 16-bit big-endian unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPutU16</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Write value v to buffer a[] as a 32-bit big-endian unsigned integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverPutU32</name><parameter_list>(<parameter><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00FF</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Detect the page-size of the database opened by file-handle pFd by 
** searching the first part of the file for a well-formed SQLite b-tree 
** page. If parameter nReserve is non-zero, then as well as searching for
** a b-tree page with zero reserved bytes, this function searches for one
** with nReserve reserved bytes at the end of it.
**
** If successful, set variable p-&gt;detected_pgsz to the detected page-size
** in bytes and return SQLITE_OK. Or, if no error occurs but no valid page
** can be found, return SQLITE_OK but leave p-&gt;detected_pgsz set to 0. Or,
** if an error occurs (e.g. an IO or OOM error), then an SQLite error code
** is returned. The final value of p-&gt;detected_pgsz is undefined in this
** case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDetectPagesize</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Recover handle */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>,              <comment type="block">/* File-handle open on input database */</comment>
  <parameter><decl><type><name>u32</name></type> <name>nReserve</name></decl></parameter>,                   <comment type="block">/* Possible nReserve value */</comment>
  <parameter><decl><type><name>i64</name></type> <name>nSz</name></decl></parameter>                         <comment type="block">/* Size of database file in bytes */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMin</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMax</name> <init>= <expr><literal type="number">65536</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nMaxBlk</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>pgsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aPg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aTmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aPg</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>*</operator><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aPg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>aTmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aPg</name><index>[<expr><name>nMax</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nBlk</name> <operator>=</operator> <operator>(</operator><name>nSz</name><operator>+</operator><name>nMax</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>nMax</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBlk</name><operator>&gt;</operator><name>nMaxBlk</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBlk</name> <operator>=</operator> <name>nMaxBlk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <do>do <block>{<block_content>
    <for>for<control>(<init><expr><name>iBlk</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iBlk</name><operator>&lt;</operator><name>nBlk</name></expr>;</condition> <incr><expr><name>iBlk</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nSz</name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>iBlk</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nMax</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name>nMax</name></expr> </then><else>: <expr><operator>(</operator><name>nSz</name> <operator>%</operator> <name>nMax</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aPg</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iBlk</name><operator>*</operator><name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>pgsz2</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pgsz2</name><operator>=</operator><operator>(</operator><ternary><condition><expr><name>pgsz</name></expr> ?</condition><then> <expr><name>pgsz</name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>nMin</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>pgsz2</name><operator>&lt;=</operator><name>nMax</name></expr>;</condition> <incr><expr><name>pgsz2</name><operator>=</operator><name>pgsz2</name><operator>*</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>iOff</name></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>iOff</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iOff</name><operator>&lt;</operator><name>nMax</name></expr>;</condition> <incr><expr><name>iOff</name><operator>+=</operator><name>pgsz2</name></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><call><name>recoverIsValidPage</name><argument_list>(<argument><expr><name>aTmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aPg</name><index>[<expr><name>iOff</name></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz2</name><operator>-</operator><name>nReserve</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <name>pgsz2</name></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>&gt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name> <operator>=</operator> <name>nReserve</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReserve</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><literal type="number">1</literal></expr> )</condition>;</do>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name> <operator>=</operator> <name>pgsz</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The xRead() method of the wrapper VFS. This is used to intercept calls
** to read page 1 of the input database.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>recover_methods</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">16</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>iOff</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&gt;=</operator><literal type="number">108</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Ensure that the database has a valid header file. The only fields
      ** that really matter to recovery are:
      **
      **   + Database page size (16-bits at offset 16)
      **   + Size of db in pages (32-bits at offset 28)
      **   + Database encoding (32-bits at offset 56)
      **
      ** Also preserved are:
      **
      **   + first freelist page (32-bits at offset 32)
      **   + size of freelist (32-bits at offset 36)
      **
      ** We also try to preserve the auto-vacuum, incr-value, user-version
      ** and application-id fields - all 32 bit quantities at offsets 
      ** 52, 60, 64 and 68. All other fields are set to known good values.
      **
      ** Byte offset 105 should also contain the page-size as a 16-bit 
      ** integer.
      */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>aPreserve</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><literal type="number">68</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name><name>aHdr</name><index>[<expr><literal type="number">108</literal></expr>]</index></name> <init>= <expr><block>{
        <expr><literal type="number">0x53</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0x4c</literal></expr>, <expr><literal type="number">0x69</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x65</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x66</literal></expr>, 
        <expr><literal type="number">0x6f</literal></expr>, <expr><literal type="number">0x72</literal></expr>, <expr><literal type="number">0x6d</literal></expr>, <expr><literal type="number">0x61</literal></expr>, <expr><literal type="number">0x74</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x01</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x20</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x04</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x10</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
        <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x2e</literal></expr>, <expr><literal type="number">0x5b</literal></expr>, <expr><literal type="number">0x30</literal></expr>,

        <expr><literal type="number">0x0D</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x00</literal></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aBuf</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>u32</name></type> <name>pgsz</name> <init>= <expr><call><name>recoverGetU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>nReserve</name> <init>= <expr><name><name>a</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>enc</name> <init>= <expr><call><name>recoverGetU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>dbsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>dbFileSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>recover_g</name><operator>.</operator><name>p</name></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>==</operator><literal type="number">0x01</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbFileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>recoverVfsDetectPagesize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>nReserve</name></expr></argument>, <argument><expr><name>dbFileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>detected_pgsz</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nReserve</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nReserve</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pgsz</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>dbsz</name> <operator>=</operator> <name>dbFileSize</name> <operator>/</operator> <name>pgsz</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>enc</name><operator>!=</operator><name>SQLITE_UTF8</name> <operator>&amp;&amp;</operator> <name>enc</name><operator>!=</operator><name>SQLITE_UTF16BE</name> <operator>&amp;&amp;</operator> <name>enc</name><operator>!=</operator><name>SQLITE_UTF16LE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pgsz</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>recoverMalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Disk</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>recoverPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>dbsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverPutU32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>recoverPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">105</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz</name><operator>-</operator><name>nReserve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>pgsz</name><operator>==</operator><literal type="number">65536</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pgsz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>recoverPutU16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aHdr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <operator>=</operator> <name>nReserve</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aPreserve</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aPreserve</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aHdr</name><index>[<expr><name><name>aPreserve</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name><name>aPreserve</name><index>[<expr><name>ii</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>aHdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>aBuf</name><operator>)</operator><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Used to make sqlite3_io_methods wrapper methods less verbose.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVER_VFS_WRAPPER</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro>                         \
  <cpp:value>int rc = SQLITE_OK;                                     \
  if( pFd-&gt;pMethods==&amp;recover_methods ){                  \
    pFd-&gt;pMethods = recover_g.pMethods;                   \
    rc = code;                                            \
    pFd-&gt;pMethods = &amp;recover_methods;                     \
  }else{                                                  \
    rc = code;                                            \
  }                                                       \
  return rc;</cpp:value></cpp:define>                                              

<comment type="block">/*
** Methods of the wrapper VFS. All methods except for xRead() and xClose()
** simply uninstall the sqlite3_io_methods wrapper, invoke the equivalent
** method on the lower level VFS, then reinstall the wrapper before returning.
** Those that return an integer value use the RECOVER_VFS_WRAPPER macro.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aBuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>pSize</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eLock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xCheckReservedLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
    <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> ?</condition><then>  <expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>SQLITE_NOTFOUND</name></expr></else></ternary><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pgsz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bExtend</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>iPg</name></expr></argument>, <argument><expr><name>pgsz</name></expr></argument>, <argument><expr><name>bExtend</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverVfsShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>==</operator><operator>&amp;</operator><name>recover_methods</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmBarrier</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>RECOVER_VFS_WRAPPER</name> <argument_list>(
      <argument><expr><call><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsFetch</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iAmt</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverVfsUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Install the VFS wrapper around the file-descriptor open on the input
** database for recover handle p. Mutex RECOVER_MUTEX_ID must be held
** when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverInstallWrapper</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>recoverAssertMutexHeld</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFd</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name><operator>!=</operator><operator>&amp;</operator><name>recover_methods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFd</name> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iVersion</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_methods</name><operator>.</operator><name>iVersion</name></name> <operator>=</operator> <name>iVersion</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>recover_methods</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Uninstall the VFS wrapper that was installed around the file-descriptor open
** on the input database for recover handle p. Mutex RECOVER_MUTEX_ID must be
** held when this function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverUninstallWrapper</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>recoverAssertMutexHeld</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>,<argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pFd</name> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMethods</name></name> <operator>=</operator> <name><name>recover_g</name><operator>.</operator><name>pMethods</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>recover_g</name><operator>.</operator><name>p</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function does the work of a single sqlite3_recover_step() call. It
** is guaranteed that the handle is not in an error state when this
** function is called.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recoverStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>RECOVER_STATE_INIT</name></expr>:</case>
      <comment type="block">/* This is the very first call to sqlite3_recover_step() on this object.
      */</comment>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverInstallWrapper</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Open the output database. And register required virtual tables and 
      ** user functions with the new handle. */</comment>
      <expr_stmt><expr><call><name>recoverOpenOutput</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Open transactions on both the input and output databases. */</comment>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bCloseTransaction</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM sqlite_schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverTransferSettings</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverOpenRecovery</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverCacheSchema</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverUninstallWrapper</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>recoverWriteSchema1</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_WRITING</name></expr>;</expr_stmt>
      <break>break;</break>
      
    <case>case <expr><name>RECOVER_STATE_WRITING</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>w1</name><operator>.</operator><name>pTbls</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverWriteDataInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverWriteDataStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverWriteDataCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND1</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_SCHEMA2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND1</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pUsed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound1Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound1Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND2</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pAllAndParent</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound2Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound2Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_LOSTANDFOUND3</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_LOSTANDFOUND3</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>laf</name><operator>.</operator><name>pInsert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>recoverLostAndFound3Init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name><operator>==</operator><call><name>recoverLostAndFound3Step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_SCHEMA2</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>RECOVER_STATE_SCHEMA2</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>recoverWriteSchema2</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_DONE</name></expr>;</expr_stmt>

      <comment type="block">/* If no error has occurred, commit the write transaction on the output
      ** database. Regardless of whether or not an error has occurred, make
      ** an attempt to end the read transaction on the input database.  */</comment>
      <expr_stmt><expr><call><name>recoverExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbOut</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverSqlCallback</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name> <operator>=</operator> <name>RECOVER_STATE_DONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>recoverFinalCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block><empty_stmt>;</empty_stmt>

    <case>case <expr><name>RECOVER_STATE_DONE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* no-op */</comment>
      <break>break;</break>
    </block_content>}</block><empty_stmt>;</empty_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** This is a worker function that does the heavy lifting for both init
** functions:
**
**     sqlite3_recover_init()
**     sqlite3_recover_init_sql()
**
** All this function does is allocate space for the recover handle and
** take copies of the input parameters. All the real work is done within
** sqlite3_recover_run().
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>recoverInit</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>,               <comment type="block">/* Output URI for _recover_init() */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<comment type="block">/* SQL callback for _recover_init_sql() */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl></parameter>                   <comment type="block">/* Context arg for _recover_init_sql() */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nUri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>nDb</name> <operator>=</operator> <call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nUri</name> <operator>=</operator> <call><name>recoverStrlen</name><argument_list>(<argument><expr><name>zUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_recover</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nDb</name><operator>+</operator><literal type="number">1</literal> <operator>+</operator> <name>nUri</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> <operator>=</operator> <operator>(</operator><name>sqlite3_recover</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRet</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>dbIn</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pRet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>zUri</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name><index>[<expr><name>nDb</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nUri</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zUri</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pRet</name><operator>-&gt;</operator><name>zUri</name></name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><name>nUri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>xSql</name></name> <operator>=</operator> <name>xSql</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pSqlCtx</name></name> <operator>=</operator> <name>pSqlCtx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>=</operator> <name>RECOVER_ROWID_DEFAULT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a recovery handle that creates a new database containing
** the recovered data.
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUri</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zUri</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize a recovery handle that returns recovered data in the
** form of SQL statements via a callback.
*/</comment>
<function><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>sqlite3_recover_init_sql</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type> <name>db</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, 
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xSql</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pSqlCtx</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>recoverInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xSql</name></expr></argument>, <argument><expr><name>pSqlCtx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the handle error message, if any.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_recover_errmsg</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>!=</operator><name>SQLITE_NOMEM</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> </then><else>: <expr><literal type="string">"out of memory"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the handle error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_errcode</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Configure the handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_config</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>!=</operator><name>RECOVER_STATE_INIT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">789</literal></expr>:</case>
        <comment type="block">/* This undocumented magic configuration option is used to set the
        ** name of the auxiliary database that is ATTACH-ed to the database
        ** connection and used to hold state information during the
        ** recovery process.  This option is for debugging use only and
        ** is subject to change or removal at any time. */</comment>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_LOST_AND_FOUND</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zArg</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name> <operator>=</operator> <call><name>recoverMPrintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>

      <case>case <expr><name>SQLITE_RECOVER_FREELIST_CORRUPT</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bFreelistCorrupt</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_ROWIDS</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bRecoverRowid</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>SQLITE_RECOVER_SLOWINDEXES</name></expr>:</case>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bSlowIndexes</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a unit of work towards the recovery job. Return SQLITE_OK if
** no error has occurred but database recovery is not finished, SQLITE_DONE
** if database recovery has been successfully completed, or an SQLite
** error code if an error has occurred.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>recoverStep</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eState</name></name><operator>==</operator><name>RECOVER_STATE_DONE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do the configured recovery operation. Return SQLITE_OK if successful, or
** else an SQLite error code.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_run</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3_recover_step</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
  <return>return <expr><call><name>sqlite3_recover_errcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Free all resources associated with the recover handle passed as the only
** argument. The results of using a handle with any sqlite3_recover_**
** API function after it has been passed to this function are undefined.
**
** A copy of the value returned by the first call made to sqlite3_recover_run()
** on this handle is returned, or SQLITE_OK if sqlite3_recover_run() has
** not been called on this handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_recover_finish</name><parameter_list>(<parameter><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>recoverFinalCleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bCloseTransaction</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3_get_autocommit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dbIn</name></name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>errCode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zStateDb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zLostAndFound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage1Cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block" format="doxygen">/************************* End ../ext/recover/sqlite3recover.c ********************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** State information for a single open session
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>OpenSession</name></name></type> <name>OpenSession</name>;</typedef>
<struct>struct <name>OpenSession</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>             <comment type="block">/* Symbolic name for this session */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFilter</name></decl>;</decl_stmt>             <comment type="block">/* Number of xFilter rejection GLOB patterns */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azFilter</name></decl>;</decl_stmt>         <comment type="block">/* Array of xFilter rejection GLOB patterns */</comment>
  <decl_stmt><decl><type><name>sqlite3_session</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>      <comment type="block">/* The open session */</comment>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>ExpertInfo</name></name></type> <name>ExpertInfo</name>;</typedef>
<struct>struct <name>ExpertInfo</name> <block>{
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>pExpert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bVerbose</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* A single line in the EQP output */</comment>
<typedef>typedef <type><name><name>struct</name> <name>EQPGraphRow</name></name></type> <name>EQPGraphRow</name>;</typedef>
<struct>struct <name>EQPGraphRow</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iEqpId</name></decl>;</decl_stmt>           <comment type="block">/* ID for this row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParentId</name></decl>;</decl_stmt>        <comment type="block">/* ID of the parent row */</comment>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>   <comment type="block">/* Next row in sequence */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zText</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Text to display for this row */</comment>
}</block>;</struct>

<comment type="block">/* All EQP output is collected into an instance of the following */</comment>
<typedef>typedef <type><name><name>struct</name> <name>EQPGraph</name></name></type> <name>EQPGraph</name>;</typedef>
<struct>struct <name>EQPGraph</name> <block>{
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pRow</name></decl>;</decl_stmt>    <comment type="block">/* Linked list of all rows of the EQP output */</comment>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pLast</name></decl>;</decl_stmt>   <comment type="block">/* Last element of the pRow list */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zPrefix</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Graph prefix */</comment>
}</block>;</struct>

<comment type="block">/* Parameters affecting columnar mode result display (defaulting together) */</comment>
<typedef>typedef <type><struct>struct <name>ColModeOpts</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iWrap</name></decl>;</decl_stmt>            <comment type="block">/* In columnar modes, wrap lines reaching this limit */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bQuote</name></decl>;</decl_stmt>            <comment type="block">/* Quote results for .mode box and table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bWordWrap</name></decl>;</decl_stmt>         <comment type="block">/* In columnar modes, wrap at word boundaries  */</comment>
}</block></struct></type> <name>ColModeOpts</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ColModeOpts_default</name></cpp:macro> <cpp:value>{ 60, 0, 0 }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ColModeOpts_default_qbox</name></cpp:macro> <cpp:value>{ 60, 1, 0 }</cpp:value></cpp:define>

<comment type="block">/*
** State information about the database connection is contained in an
** instance of the following structure.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ShellState</name></name></type> <name>ShellState</name>;</typedef>
<struct>struct <name>ShellState</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>autoExplain</name></decl>;</decl_stmt>        <comment type="block">/* Automatically turn on .explain mode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>autoEQP</name></decl>;</decl_stmt>            <comment type="block">/* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>autoEQPtest</name></decl>;</decl_stmt>        <comment type="block">/* autoEQP is in test mode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>autoEQPtrace</name></decl>;</decl_stmt>       <comment type="block">/* autoEQP is in trace mode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>scanstatsOn</name></decl>;</decl_stmt>        <comment type="block">/* True to display scan stats before each finalize */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>openMode</name></decl>;</decl_stmt>           <comment type="block">/* SHELL_OPEN_NORMAL, _APPENDVFS, or _ZIPFILE */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>doXdgOpen</name></decl>;</decl_stmt>          <comment type="block">/* Invoke start/open/xdg-open in output_reset() */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nEqpLevel</name></decl>;</decl_stmt>          <comment type="block">/* Depth of the EQP output graph */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eTraceType</name></decl>;</decl_stmt>         <comment type="block">/* SHELL_TRACE_* value for type of trace */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bSafeMode</name></decl>;</decl_stmt>          <comment type="block">/* True to prohibit unsafe operations */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bSafeModePersist</name></decl>;</decl_stmt>   <comment type="block">/* The long-term value of bSafeMode */</comment>
  <decl_stmt><decl><type><name>ColModeOpts</name></type> <name>cmOpts</name></decl>;</decl_stmt>    <comment type="block">/* Option values affecting columnar mode output */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>statsOn</name></decl>;</decl_stmt>      <comment type="block">/* True to display memory stats before each finalize */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>mEqpLines</name></decl>;</decl_stmt>    <comment type="block">/* Mask of veritical lines in the EQP output graph */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>inputNesting</name></decl>;</decl_stmt>      <comment type="block">/* Track nesting level of .read and other redirects */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>outCount</name></decl>;</decl_stmt>          <comment type="block">/* Revert to stdout when reaching zero */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>               <comment type="block">/* Number of records displayed so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>            <comment type="block">/* Line number of last line read from in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name></decl>;</decl_stmt>         <comment type="block">/* Additional flags to open.  (SQLITE_OPEN_NOFOLLOW) */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>              <comment type="block">/* Read commands from this stream */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>             <comment type="block">/* Write results here */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>traceOut</name></decl>;</decl_stmt>        <comment type="block">/* Output for sqlite3_trace() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>              <comment type="block">/* Number of errors seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>              <comment type="block">/* An output mode setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>modePrior</name></decl>;</decl_stmt>         <comment type="block">/* Saved mode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cMode</name></decl>;</decl_stmt>             <comment type="block">/* temporary output mode for the current query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>normalMode</name></decl>;</decl_stmt>        <comment type="block">/* Output mode before ".explain on" */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>writableSchema</name></decl>;</decl_stmt>    <comment type="block">/* True if PRAGMA writable_schema=ON */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>showHeader</name></decl>;</decl_stmt>        <comment type="block">/* True to show column names in List or Column mode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCheck</name></decl>;</decl_stmt>            <comment type="block">/* Number of ".check" commands run */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nProgress</name></decl>;</decl_stmt>    <comment type="block">/* Number of progress callbacks encountered */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>mxProgress</name></decl>;</decl_stmt>   <comment type="block">/* Maximum progress callbacks before failing */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>flgProgress</name></decl>;</decl_stmt>  <comment type="block">/* Flags for the progress callback */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>shellFlgs</name></decl>;</decl_stmt>    <comment type="block">/* Various flags */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>priorShFlgs</name></decl>;</decl_stmt>  <comment type="block">/* Saved copy of flags */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szMax</name></decl>;</decl_stmt>   <comment type="block">/* --maxsize argument to .open */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDestTable</name></decl>;</decl_stmt>      <comment type="block">/* Name of destination table when MODE_Insert */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTempFile</name></decl>;</decl_stmt>       <comment type="block">/* Temporary file that might need deleting */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTestcase</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Name of current test case */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>colSeparator</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Column separator character for several modes */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>rowSeparator</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Row separator character for MODE_Ascii */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>colSepPrior</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Saved column separator */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>rowSepPrior</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Saved row separator */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>colWidth</name></decl>;</decl_stmt>         <comment type="block">/* Requested width of each column in columnar modes */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>actualWidth</name></decl>;</decl_stmt>      <comment type="block">/* Actual width of each column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nWidth</name></decl>;</decl_stmt>            <comment type="block">/* Number of slots in colWidth[] and actualWidth[] */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>nullValue</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The text to print when a NULL comes back from
                         ** the database */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>outfile</name><index>[<expr><name>FILENAME_MAX</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Filename for *out */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>   <comment type="block">/* Current statement if any. */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>pLog</name></decl>;</decl_stmt>            <comment type="block">/* Write log output here */</comment>
  <struct>struct <name>AuxDb</name> <block>{         <comment type="block">/* Storage space for auxiliary database connections */</comment>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Connection pointer */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbFilename</name></decl>;</decl_stmt>   <comment type="block">/* Filename used to open the connection */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFreeOnClose</name></decl>;</decl_stmt>        <comment type="block">/* Free this memory allocation on close */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>nSession</name></decl>;</decl_stmt>              <comment type="block">/* Number of active sessions */</comment>
    <decl_stmt><decl><type><name>OpenSession</name></type> <name><name>aSession</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Array of sessions.  [0] is in focus. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block> <decl><name><name>aAuxDb</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>,           <comment type="block">/* Array of all database connections */</comment>
    <decl><type ref="prev"><modifier>*</modifier></type><name>pAuxDb</name></decl>;</struct>             <comment type="block">/* Currently active database connection */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiIndent</name></decl>;</decl_stmt>         <comment type="block">/* Array of indents used in MODE_Explain */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIndent</name></decl>;</decl_stmt>           <comment type="block">/* Size of array aiIndent[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIndent</name></decl>;</decl_stmt>           <comment type="block">/* Index of current op in aiIndent[] */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNonce</name></decl>;</decl_stmt>          <comment type="block">/* Nonce for temporary safe-mode excapes */</comment>
  <decl_stmt><decl><type><name>EQPGraph</name></type> <name>sGraph</name></decl>;</decl_stmt>       <comment type="block">/* Information for the graphical EXPLAIN QUERY PLAN */</comment>
  <decl_stmt><decl><type><name>ExpertInfo</name></type> <name>expert</name></decl>;</decl_stmt>     <comment type="block">/* Valid if previous command was ".expert OPT..." */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
  <struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zInput</name></decl>;</decl_stmt> <comment type="block">/* Input string from wasm/JS proxy */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zPos</name></decl>;</decl_stmt>   <comment type="block">/* Cursor pos into zInput */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zDefaultDbName</name></decl>;</decl_stmt> <comment type="block">/* Default name for db file */</comment>
  }</block> <decl><name>wasm</name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShellState</name></type> <name>shellState</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Allowed values for ShellState.autoEQP
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOEQP_off</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>           <comment type="block">/* Automatic EXPLAIN QUERY PLAN is off */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOEQP_on</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>           <comment type="block">/* Automatic EQP is on */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOEQP_trigger</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>           <comment type="block">/* On and also show plans for triggers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOEQP_full</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>           <comment type="block">/* Show full EXPLAIN */</comment>

<comment type="block">/* Allowed values for ShellState.openMode
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_UNSPEC</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>      <comment type="block">/* No open-mode specified */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_NORMAL</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/* Normal database file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_APPENDVFS</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/* Use appendvfs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_ZIPFILE</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>      <comment type="block">/* Use the zipfile virtual table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_READONLY</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>      <comment type="block">/* Open a normal database read-only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_DESERIALIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>      <comment type="block">/* Open using sqlite3_deserialize() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_OPEN_HEXDB</name></cpp:macro>       <cpp:value>6</cpp:value></cpp:define>      <comment type="block">/* Use "dbtotxt" output as data source */</comment>

<comment type="block">/* Allowed values for ShellState.eTraceType
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_TRACE_PLAIN</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>      <comment type="block">/* Show input SQL text */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_TRACE_EXPANDED</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>      <comment type="block">/* Show expanded SQL text */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_TRACE_NORMALIZED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>      <comment type="block">/* Show normalized SQL text */</comment>

<comment type="block">/* Bits in the ShellState.flgProgress variable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_PROGRESS_QUIET</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>  <comment type="block">/* Omit announcing every progress callback */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_PROGRESS_RESET</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>  <comment type="block">/* Reset the count when the progres
                                   ** callback limit is reached, and for each
                                   ** top-level SQL statement */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_PROGRESS_ONCE</name></cpp:macro>  <cpp:value>0x04</cpp:value></cpp:define>  <comment type="block">/* Cancel the --limit after firing once */</comment>

<comment type="block">/*
** These are the allowed shellFlgs values
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_Pagecache</name></cpp:macro>      <cpp:value>0x00000001</cpp:value></cpp:define> <comment type="block">/* The --pagecache option is used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_Lookaside</name></cpp:macro>      <cpp:value>0x00000002</cpp:value></cpp:define> <comment type="block">/* Lookaside memory is used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_Backslash</name></cpp:macro>      <cpp:value>0x00000004</cpp:value></cpp:define> <comment type="block">/* The --backslash option is used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_PreserveRowid</name></cpp:macro>  <cpp:value>0x00000008</cpp:value></cpp:define> <comment type="block">/* .dump preserves rowid values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_Newlines</name></cpp:macro>       <cpp:value>0x00000010</cpp:value></cpp:define> <comment type="block">/* .dump --newline flag */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_CountChanges</name></cpp:macro>   <cpp:value>0x00000020</cpp:value></cpp:define> <comment type="block">/* .changes setting */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_Echo</name></cpp:macro>           <cpp:value>0x00000040</cpp:value></cpp:define> <comment type="block">/* .echo on/off, or --echo setting */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_HeaderSet</name></cpp:macro>      <cpp:value>0x00000080</cpp:value></cpp:define> <comment type="block">/* showHeader has been specified */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_DumpDataOnly</name></cpp:macro>   <cpp:value>0x00000100</cpp:value></cpp:define> <comment type="block">/* .dump show data only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHFLG_DumpNoSys</name></cpp:macro>      <cpp:value>0x00000200</cpp:value></cpp:define> <comment type="block">/* .dump omits system tables */</comment>

<comment type="block">/*
** Macros for testing and setting shellFlgs
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ShellHasFlag</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>(((P)-&gt;shellFlgs &amp; (X))!=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ShellSetFlag</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>((P)-&gt;shellFlgs|=(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ShellClearFlag</name><parameter_list>(<parameter><type><name>P</name></type></parameter>,<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((P)-&gt;shellFlgs&amp;=(~(X)))</cpp:value></cpp:define>

<comment type="block">/*
** These are the allowed modes.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Line</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>  <comment type="block">/* One column per line.  Blank line between records */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Column</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* One record per line in neat columns */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_List</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* One record per line with a separator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Semi</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>  <comment type="block">/* Same as MODE_List but append ";" to each line */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Html</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>  <comment type="block">/* Generate an XHTML table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Insert</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>  <comment type="block">/* Generate SQL "insert" statements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Quote</name></cpp:macro>    <cpp:value>6</cpp:value></cpp:define>  <comment type="block">/* Quote values as for SQL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Tcl</name></cpp:macro>      <cpp:value>7</cpp:value></cpp:define>  <comment type="block">/* Generate ANSI-C or TCL quoted elements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Csv</name></cpp:macro>      <cpp:value>8</cpp:value></cpp:define>  <comment type="block">/* Quote strings, numbers are plain */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Explain</name></cpp:macro>  <cpp:value>9</cpp:value></cpp:define>  <comment type="block">/* Like MODE_Column, but do not truncate data */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Ascii</name></cpp:macro>   <cpp:value>10</cpp:value></cpp:define>  <comment type="block">/* Use ASCII unit and record separators (0x1F/0x1E) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Pretty</name></cpp:macro>  <cpp:value>11</cpp:value></cpp:define>  <comment type="block">/* Pretty-print schemas */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_EQP</name></cpp:macro>     <cpp:value>12</cpp:value></cpp:define>  <comment type="block">/* Converts EXPLAIN QUERY PLAN output into a graph */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Json</name></cpp:macro>    <cpp:value>13</cpp:value></cpp:define>  <comment type="block">/* Output JSON */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Markdown</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> <comment type="block">/* Markdown formatting */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Table</name></cpp:macro>   <cpp:value>15</cpp:value></cpp:define>  <comment type="block">/* MySQL-style table formatting */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Box</name></cpp:macro>     <cpp:value>16</cpp:value></cpp:define>  <comment type="block">/* Unicode box-drawing characters */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Count</name></cpp:macro>   <cpp:value>17</cpp:value></cpp:define>  <comment type="block">/* Output only a count of the rows of output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_Off</name></cpp:macro>     <cpp:value>18</cpp:value></cpp:define>  <comment type="block">/* No query output shown */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>modeDescr</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"line"</literal></expr>,
  <expr><literal type="string">"column"</literal></expr>,
  <expr><literal type="string">"list"</literal></expr>,
  <expr><literal type="string">"semi"</literal></expr>,
  <expr><literal type="string">"html"</literal></expr>,
  <expr><literal type="string">"insert"</literal></expr>,
  <expr><literal type="string">"quote"</literal></expr>,
  <expr><literal type="string">"tcl"</literal></expr>,
  <expr><literal type="string">"csv"</literal></expr>,
  <expr><literal type="string">"explain"</literal></expr>,
  <expr><literal type="string">"ascii"</literal></expr>,
  <expr><literal type="string">"prettyprint"</literal></expr>,
  <expr><literal type="string">"eqp"</literal></expr>,
  <expr><literal type="string">"json"</literal></expr>,
  <expr><literal type="string">"markdown"</literal></expr>,
  <expr><literal type="string">"table"</literal></expr>,
  <expr><literal type="string">"box"</literal></expr>,
  <expr><literal type="string">"count"</literal></expr>,
  <expr><literal type="string">"off"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** These are the column/row/line separators used by the various
** import/export modes.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Column</name></cpp:macro>    <cpp:value>"|"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Row</name></cpp:macro>       <cpp:value>"\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Tab</name></cpp:macro>       <cpp:value>"\t"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Space</name></cpp:macro>     <cpp:value>" "</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Comma</name></cpp:macro>     <cpp:value>","</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_CrLf</name></cpp:macro>      <cpp:value>"\r\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Unit</name></cpp:macro>      <cpp:value>"\x1F"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEP_Record</name></cpp:macro>    <cpp:value>"\x1E"</cpp:value></cpp:define>

<comment type="block">/*
** Limit input nesting via .read or any other input redirect.
** It's not too expensive, so a generous allowance can be made.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INPUT_NESTING</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>

<comment type="block">/*
** A callback for the sqlite3_log() interface.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellLog</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iErrCode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pLog</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLog</name></name></expr></argument>, <argument><expr><literal type="string">"(%d) %s\n"</literal></expr></argument>, <argument><expr><name>iErrCode</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:  shell_putsnl(X)
**
** Write the text X to the screen (or whatever output is being directed)
** adding a newline at the end, and then return X.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellPutsFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If in safe mode, print an error message described by the arguments
** and exit immediately.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>failIfSafeMode</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>,
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"line %d: "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** SQL function:   edit(VALUE)
**                 edit(VALUE,EDITOR)
**
** These steps:
**
**     (1) Write VALUE into a temporary file.
**     (2) Run program EDITOR on that temporary file.
**     (3) Read the temporary file back and return its content as the result.
**     (4) Delete the temporary file
**
** If the EDITOR argument is omitted, use the value in the VISUAL
** environment variable.  If still there is no EDITOR, through an error.
**
** Also throw an error if the EDITOR program returns a non-zero exit code.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_NOHAVE_SYSTEM</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>editFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEditor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTempFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCmd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bBin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasCRNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zEditor</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zEditor</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"VISUAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zEditor</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"no editor for edit()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"NULL input to edit()"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTempFile</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zTempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTempFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTempFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"temp%llx"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTempFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>bBin</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr>;</expr_stmt>
  <comment type="block">/* When writing the file to be edited, do \n to \r\n conversions on systems
  ** that want \r\n line endings */</comment>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zTempFile</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bBin</name></expr> ?</condition><then> <expr><literal type="string">"wb"</literal></expr> </then><else>: <expr><literal type="string">"w"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"edit() cannot open temp file"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bBin</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Remember whether or not the value originally contained \r\n */</comment>
    <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasCRNL</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>!=</operator><name>sz</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"edit() could not write the whole file"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s \"%s\""</literal></expr></argument>, <argument><expr><name>zEditor</name></expr></argument>, <argument><expr><name>zTempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zCmd</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"EDITOR returned non-zero"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zTempFile</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
      <argument><expr><literal type="string">"edit() cannot reopen temp file after edit"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>!=</operator><name>sz</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"could not read back the whole file"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>edit_func_end</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bBin</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_blob64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>hasCRNL</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If the original contains \r\n then do no conversions back to \n */</comment>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* If the file did not originally contain \r\n then convert any new
      ** \r\n back into \n */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt> 
    <expr_stmt><expr><call><name>sqlite3_result_text64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
                          <argument><expr><name>sqlite3_free</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>edit_func_end</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>f</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zTempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_NOHAVE_SYSTEM */</comment>

<comment type="block">/*
** Save or restore the current output mode
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>outputModePush</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>modePrior</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>priorShFlgs</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSepPrior</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSepPrior</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>outputModePop</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>modePrior</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>priorShFlgs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSepPrior</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSepPrior</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_hex_blob</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBlob</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBlob</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aBlob</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>pBlob</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStr</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nBlob</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlob</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aHex</name><index>[]</index></name> <init>= <expr><block>{
        <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,
        <expr><literal type="char">'8'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'f'</literal></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zStr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>aHex</name><index>[ <expr><operator>(</operator><name><name>aBlob</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr> ]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zStr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aHex</name><index>[ <expr><operator>(</operator><name><name>aBlob</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr> ]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>zStr</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"X'%s'"</literal></expr></argument>, <argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Find a string that is not found anywhere in z[].  Return a pointer
** to that string.
**
** Try to use zA and zB first.  If both of those are already found in z[]
** then make up some string and store it in the buffer zBuf.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unused_string</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,                    <comment type="block">/* Result must not appear anywhere in z */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zB</name></decl></parameter>,   <comment type="block">/* Try these first */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>                        <comment type="block">/* Space to store a generated string */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zA</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zB</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zB</name></expr>;</return></block_content></block></if></if_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><literal type="string">"(%s%u)"</literal></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <return>return <expr><name>zBuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string as a quoted string using SQL quoting conventions.
**
** See also: output_quoted_escaped_string()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_quoted_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setBinaryMode</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\''</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"'%s'"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\''</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setTextMode</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string as a quoted string using SQL quoting conventions.
** Additionallly , escape the "\n" and "\r" characters so that they do not
** get corrupted by end-of-line translation facilities in some operating
** systems.
**
** This is like output_quoted_string() but with the addition of the \r\n
** escape mechanism.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_quoted_escaped_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setBinaryMode</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\r'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"'%s'"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>zBuf2</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nNL</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nCR</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nNL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"replace("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zNL</name> <operator>=</operator> <call><name>unused_string</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><literal type="string">"\\012"</literal></expr></argument>, <argument><expr><name>zBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"replace("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCR</name> <operator>=</operator> <call><name>unused_string</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>, <argument><expr><literal type="string">"\\015"</literal></expr></argument>, <argument><expr><name>zBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\''</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCR</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">",'%s',char(13))"</literal></expr></argument>, <argument><expr><name>zCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nNL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">",'%s',char(10))"</literal></expr></argument>, <argument><expr><name>zNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setTextMode</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string as a quoted according to C or TCL quoting rules.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_c_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\t'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\\%03o"</literal></expr></argument>, <argument><expr><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string as a quoted according to JSON quoting rules.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_json_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>--</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x1f</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\b'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\f'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\t'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
         <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"u%04x"</literal></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output the given string with characters that are special to
** HTML escaped.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_html_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init>   <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>
            <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'&lt;'</literal>
            <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'&amp;'</literal>
            <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'&gt;'</literal>
            <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'\"'</literal>
            <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'\''</literal></expr>;</condition>
        <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%.*s"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'&lt;'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'&amp;'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'&gt;'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"&amp;#39;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>needCsvQuote</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Output a single term of CSV.  Actually, p-&gt;colSeparator is used for
** the separator, which may or may not be a comma.  p-&gt;nullValue is
** the null value.  Strings are quoted if necessary.  The separator
** is only issued if bSep is true.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_csv</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bSep</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>needCsvQuote</name><index>[<expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>z</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuoted</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bSep</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine runs when the user presses Ctrl-C
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interrupt_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>seenInterrupt</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>seenInterrupt</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>globalDb</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This routine runs for console events (e.g. Ctrl-C) on Win32
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type> <name>ConsoleCtrlHandler</name><parameter_list>(
  <parameter><decl><type><name>DWORD</name></type> <name>dwCtrlType</name></decl></parameter> <comment type="block">/* One of the CTRL_*_EVENT constants */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>dwCtrlType</name><operator>==</operator><name>CTRL_C_EVENT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>interrupt_handler</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
<comment type="block">/*
** This authorizer runs in safe mode.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safeModeAuth</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pClientData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA2</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA3</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA4</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pClientData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azProhibitedFunctions</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"edit"</literal></expr>,
    <expr><literal type="string">"fts3_tokenizer"</literal></expr>,
    <expr><literal type="string">"load_extension"</literal></expr>,
    <expr><literal type="string">"readfile"</literal></expr>,
    <expr><literal type="string">"writefile"</literal></expr>,
    <expr><literal type="string">"zipfile"</literal></expr>,
    <expr><literal type="string">"zipfile_cds"</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>zA2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>zA3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>zA4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_ATTACH</name></expr>:</case> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
      <comment type="block">/* In WASM builds the filesystem is a virtual sandbox, so
      ** there's no harm in using ATTACH. */</comment>
      <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run ATTACH in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FUNCTION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azProhibitedFunctions</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zA1</name></expr></argument>, <argument><expr><name><name>azProhibitedFunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot use the %s() function in safe mode"</literal></expr></argument>,
                         <argument><expr><name><name>azProhibitedFunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** When the ".auth ON" is set, the following authorizer callback is
** invoked.  It always returns SQLITE_OK.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>shellAuth</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pClientData</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA2</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA3</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zA4</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pClientData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azAction</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>,
     <expr><literal type="string">"CREATE_INDEX"</literal></expr>,         <expr><literal type="string">"CREATE_TABLE"</literal></expr>,         <expr><literal type="string">"CREATE_TEMP_INDEX"</literal></expr>,
     <expr><literal type="string">"CREATE_TEMP_TABLE"</literal></expr>,    <expr><literal type="string">"CREATE_TEMP_TRIGGER"</literal></expr>,  <expr><literal type="string">"CREATE_TEMP_VIEW"</literal></expr>,
     <expr><literal type="string">"CREATE_TRIGGER"</literal></expr>,       <expr><literal type="string">"CREATE_VIEW"</literal></expr>,          <expr><literal type="string">"DELETE"</literal></expr>,
     <expr><literal type="string">"DROP_INDEX"</literal></expr>,           <expr><literal type="string">"DROP_TABLE"</literal></expr>,           <expr><literal type="string">"DROP_TEMP_INDEX"</literal></expr>,
     <expr><literal type="string">"DROP_TEMP_TABLE"</literal></expr>,      <expr><literal type="string">"DROP_TEMP_TRIGGER"</literal></expr>,    <expr><literal type="string">"DROP_TEMP_VIEW"</literal></expr>,
     <expr><literal type="string">"DROP_TRIGGER"</literal></expr>,         <expr><literal type="string">"DROP_VIEW"</literal></expr>,            <expr><literal type="string">"INSERT"</literal></expr>,
     <expr><literal type="string">"PRAGMA"</literal></expr>,               <expr><literal type="string">"READ"</literal></expr>,                 <expr><literal type="string">"SELECT"</literal></expr>,
     <expr><literal type="string">"TRANSACTION"</literal></expr>,          <expr><literal type="string">"UPDATE"</literal></expr>,               <expr><literal type="string">"ATTACH"</literal></expr>,
     <expr><literal type="string">"DETACH"</literal></expr>,               <expr><literal type="string">"ALTER_TABLE"</literal></expr>,          <expr><literal type="string">"REINDEX"</literal></expr>,
     <expr><literal type="string">"ANALYZE"</literal></expr>,              <expr><literal type="string">"CREATE_VTABLE"</literal></expr>,        <expr><literal type="string">"DROP_VTABLE"</literal></expr>,
     <expr><literal type="string">"FUNCTION"</literal></expr>,             <expr><literal type="string">"SAVEPOINT"</literal></expr>,            <expr><literal type="string">"RECURSIVE"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>az</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>zA1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>zA2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>zA3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>az</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>zA4</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"authorizer: %s"</literal></expr></argument>, <argument><expr><name><name>azAction</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>safeModeAuth</name><argument_list>(<argument><expr><name>pClientData</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>zA1</name></expr></argument>, <argument><expr><name>zA2</name></expr></argument>, <argument><expr><name>zA3</name></expr></argument>, <argument><expr><name>zA4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.
**
** This routine converts some CREATE TABLE statements for shadow tables
** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
**
** If the schema statement in z[] contains a start-of-comment and if
** sqlite3_complete() returns false, try to terminate the comment before
** printing the result.  https://sqlite.org/forum/forumpost/d7be961c5c
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printSchemaLine</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zToFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTail</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zTail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">';'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"/*"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOrig</name> <init>= <expr><name>z</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azTerm</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"*/"</literal></expr>, <expr><literal type="string">"\n"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azTerm</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s;"</literal></expr></argument>, <argument><expr><name>zOrig</name></expr></argument>, <argument><expr><name><name>azTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zToFree</name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><literal type="string">"CREATE TABLE ['\"]*"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS %s%s"</literal></expr></argument>, <argument><expr><name>z</name><operator>+</operator><literal type="number">13</literal></expr></argument>, <argument><expr><name>zTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printSchemaLineN</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printSchemaLine</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return true if string z[] has nothing but whitespace and comments to the
** end of the first line.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>wsToEol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a new entry to the EXPLAIN QUERY PLAN data
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>eqp_append</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEqpId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nText</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nText</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtest</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d,%d,%s\n"</literal></expr></argument>, <argument><expr><name>iEqpId</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nText</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iEqpId</name></name> <operator>=</operator> <name>iEqpId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>iParentId</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zText</name></name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><name>nText</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pLast</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pLast</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pRow</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pLast</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free and reset the EXPLAIN QUERY PLAN data that has been collected
** in p-&gt;sGraph.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>eqp_reset</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pRow</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pRow</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pRow</name></name></expr>;</init> <condition><expr><name>pRow</name></expr>;</condition> <incr><expr><name>pRow</name> <operator>=</operator> <name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sGraph</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the next EXPLAIN QUERY PLAN line with iEqpId that occurs after
** pOld, or return the first such line if pOld is NULL
*/</comment>
<function><type><specifier>static</specifier> <name>EQPGraphRow</name> <modifier>*</modifier></type><name>eqp_next_row</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEqpId</name></decl></parameter>, <parameter><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pRow</name> <init>= <expr><ternary><condition><expr><name>pOld</name></expr> ?</condition><then> <expr><name><name>pOld</name><operator>-&gt;</operator><name>pNext</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pRow</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pRow</name> <operator>&amp;&amp;</operator> <name><name>pRow</name><operator>-&gt;</operator><name>iParentId</name></name><operator>!=</operator><name>iEqpId</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pRow</name> <operator>=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>pRow</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Render a single level of the graph that has iEqpId as its parent.  Called
** recursively to render sublevels.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>eqp_render_level</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEqpId</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pRow</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pRow</name> <operator>=</operator> <call><name>eqp_next_row</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iEqpId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pRow</name></expr>;</condition> <incr><expr><name>pRow</name> <operator>=</operator> <name>pNext</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <call><name>eqp_next_row</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iEqpId</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>zText</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s%s%s\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name>pNext</name></expr> ?</condition><then> <expr><literal type="string">"|--"</literal></expr> </then><else>: <expr><literal type="string">"`--"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><operator>(</operator><name>i64</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">7</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>pNext</name></expr> ?</condition><then> <expr><literal type="string">"|  "</literal></expr> </then><else>: <expr><literal type="string">"   "</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>eqp_render_level</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pRow</name><operator>-&gt;</operator><name>iEqpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Display and reset the EXPLAIN QUERY PLAN data
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>eqp_render</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>EQPGraphRow</name> <modifier>*</modifier></type><name>pRow</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pRow</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRow</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRow</name><operator>-&gt;</operator><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pRow</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>eqp_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>pRow</name><operator>-&gt;</operator><name>zText</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>pRow</name></name> <operator>=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"QUERY PLAN\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sGraph</name><operator>.</operator><name>zPrefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>eqp_render_level</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>eqp_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
<comment type="block">/*
** Progress handler callback.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>progress_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pClientData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pClientData</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>mxProgress</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>mxProgress</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Progress limit reached (%u)\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>&amp;</operator> <name>SHELL_PROGRESS_RESET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>&amp;</operator> <name>SHELL_PROGRESS_ONCE</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>&amp;</operator> <name>SHELL_PROGRESS_QUIET</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Progress %u\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_PROGRESS_CALLBACK */</comment>

<comment type="block">/*
** Print N dashes
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_dashes</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>zDash</name><index>[]</index></name> <init>= <expr><literal type="string">"--------------------------------------------------"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nDash</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDash</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><name>nDash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>zDash</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name> <operator>-=</operator> <name>nDash</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>zDash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Print a markdown or table-style row separator using ascii-art
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_row_separator</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_dashes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_dashes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is the callback routine that the shell
** invokes for each row of a query result.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>shell_callback</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,        <comment type="block">/* Number of result columns */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,    <comment type="block">/* Text of each result column */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>,    <comment type="block">/* Column names */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>aiType</name></decl></parameter>      <comment type="block">/* Column types.  Might be NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>MODE_Count</name></expr>:</case>
    <case>case <expr><name>MODE_Off</name></expr>:</case> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Line</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>w</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>w</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%*s = %s%s"</literal></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Explain</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>aExplainWidth</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">13</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aExplainWidth</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nArg</name> <operator>=</operator> <call><name>ArraySize</name><argument_list>(<argument><expr><name>aExplainWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>aExplainWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>utf8_width_print</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">"  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>aExplainWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>print_dashes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">"  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><name><name>aExplainWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&gt;</operator><name>w</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iIndent</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndent</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%*.s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>iIndent</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIndent</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>utf8_width_print</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">"  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Semi</name></expr>:</case> <block>{<block_content>   <comment type="block">/* .schema and .fullschema output */</comment>
      <expr_stmt><expr><call><name>printSchemaLine</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Pretty</name></expr>:</case> <block>{<block_content>  <comment type="block">/* .schema and .fullschema with --indent */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nParen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>cEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"CREATE VIEW%"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"CREATE TRIG%"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <for>for<control>(<init>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'('</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'('</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">')'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <while>while<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">79</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <comment type="block">/* Copy from z[i] back to z[j] */</comment>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>cEnd</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>cEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'`'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>cEnd</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>cEnd</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>cEnd</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'('</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nParen</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">')'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nParen</name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>nLine</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nParen</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>printSchemaLineN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>nParen</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>cEnd</name><operator>==</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'('</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>wsToEol</name><argument_list>(<argument><expr><name>z</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>printSchemaLineN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>nLine</name><operator>++</operator></expr>;</expr_stmt>
            <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>printSchemaLine</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_List</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s%s"</literal></expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Html</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;TR&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;TH&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>output_html_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;/TH&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;/TR&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;TR&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;TD&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>output_html_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;/TD&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;/TR&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Tcl</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>(<expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Csv</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setBinaryMode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>output_csv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>output_csv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>setTextMode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Insert</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"INSERT INTO %s"</literal></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>quoteChar</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">" VALUES("</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_NULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Newlines</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>output_quoted_escaped_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>ur</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ur</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>ur</name><operator>==</operator><literal type="number">0x7ff0000000000000LL</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"1e999"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ur</name><operator>==</operator><literal type="number">0xfff0000000000000LL</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-1e999"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>ir</name> <init>= <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>r</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>r</name><operator>==</operator><operator>(</operator><name>double</name><operator>)</operator><name>ir</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"%lld.0"</literal></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"%!.20g"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_BLOB</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBlob</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>output_hex_blob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>isNumber</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Newlines</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>output_quoted_escaped_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Json</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"[{"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">",\n{"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>output_json_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_NULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>ur</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ur</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>ur</name><operator>==</operator><literal type="number">0x7ff0000000000000LL</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"1e999"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ur</name><operator>==</operator><literal type="number">0xfff0000000000000LL</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-1e999"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"%!.20g"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_BLOB</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBlob</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>output_json_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>output_json_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Quote</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_NULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_FLOAT</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>r</name> <init>= <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"%!.20g"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>aiType</name> <operator>&amp;&amp;</operator> <name><name>aiType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>SQLITE_BLOB</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBlob</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>output_hex_blob</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>pBlob</name></expr></argument>, <argument><expr><name>nBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>isNumber</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Ascii</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><ternary><condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><ternary><condition><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_EQP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>eqp_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the callback routine that the SQLite library
** invokes for each row of a query result.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* since we don't have type info, call the shell_callback with a NULL value */</comment>
  <return>return <expr><call><name>shell_callback</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the callback routine from sqlite3_exec() that appends all
** output onto the end of a ShellText object.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>captureOutputCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>az</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellText</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellText</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>az</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate an appropriate SELFTEST table in the main database.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createSelftestTable</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
    <argument><expr><literal type="string">"SAVEPOINT selftest_init;\n"</literal>
    <literal type="string">"CREATE TABLE IF NOT EXISTS selftest(\n"</literal>
    <literal type="string">"  tno INTEGER PRIMARY KEY,\n"</literal>   <comment type="block">/* Test number */</comment>
    <literal type="string">"  op TEXT,\n"</literal>                   <comment type="block">/* Operator:  memo run */</comment>
    <literal type="string">"  cmd TEXT,\n"</literal>                  <comment type="block">/* Command text */</comment>
    <literal type="string">"  ans TEXT\n"</literal>                   <comment type="block">/* Desired answer */</comment>
    <literal type="string">");"</literal>
    <literal type="string">"CREATE TEMP TABLE [_shell$self](op,cmd,ans);\n"</literal>
    <literal type="string">"INSERT INTO [_shell$self](rowid,op,cmd)\n"</literal>
    <literal type="string">"  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n"</literal>
    <literal type="string">"         'memo','Tests generated by --init');\n"</literal>
    <literal type="string">"INSERT INTO [_shell$self]\n"</literal>
    <literal type="string">"  SELECT 'run',\n"</literal>
    <literal type="string">"    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql "</literal>
                                 <literal type="string">"FROM sqlite_schema ORDER BY 2'',224))',\n"</literal>
    <literal type="string">"    hex(sha3_query('SELECT type,name,tbl_name,sql "</literal>
                          <literal type="string">"FROM sqlite_schema ORDER BY 2',224));\n"</literal>
    <literal type="string">"INSERT INTO [_shell$self]\n"</literal>
    <literal type="string">"  SELECT 'run',"</literal>
    <literal type="string">"    'SELECT hex(sha3_query(''SELECT * FROM \"' ||"</literal>
    <literal type="string">"        printf('%w',name) || '\" NOT INDEXED'',224))',\n"</literal>
    <literal type="string">"    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n"</literal>
    <literal type="string">"  FROM (\n"</literal>
    <literal type="string">"    SELECT name FROM sqlite_schema\n"</literal>
    <literal type="string">"     WHERE type='table'\n"</literal>
    <literal type="string">"       AND name&lt;&gt;'selftest'\n"</literal>
    <literal type="string">"       AND coalesce(rootpage,0)&gt;0\n"</literal>
    <literal type="string">"  )\n"</literal>
    <literal type="string">" ORDER BY name;\n"</literal>
    <literal type="string">"INSERT INTO [_shell$self]\n"</literal>
    <literal type="string">"  VALUES('run','PRAGMA integrity_check','ok');\n"</literal>
    <literal type="string">"INSERT INTO selftest(tno,op,cmd,ans)"</literal>
    <literal type="string">"  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\n"</literal>
    <literal type="string">"DROP TABLE [_shell$self];"</literal></expr></argument>
    ,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SELFTEST initialization failure: %s\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"RELEASE selftest_init"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Set the destination table field of the ShellState structure to
** the name of the table given.  Escape any quote characters in the
** table name.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_table_name</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cQuote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>cQuote</name> <operator>=</operator> <call><name>quoteChar</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cQuote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cQuote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>cQuote</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cQuote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Maybe construct two lines of text that point out the position of a
** syntax error.  Return a pointer to the text, in memory obtained from
** sqlite3_malloc().  Or, if the most recent error does not involve a
** specific token that we can point to, return an empty string.
**
** In all cases, the memory returned is obtained from sqlite3_malloc64()
** and should be released by the caller invoking sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shell_error_context</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>db</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name>zSql</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <operator>(</operator><name>iOffset</name> <operator>=</operator> <call><name>sqlite3_error_offset</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>iOffset</name><operator>&gt;</operator><literal type="number">50</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iOffset</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name><operator>++</operator></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name><name>zSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zSql</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>iOffset</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  </block_content>}</block></while>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><literal type="number">78</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">78</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name><name>zSql</name><index>[<expr><name>len</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zCode</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zCode</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zSql</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zCode</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iOffset</name><operator>&lt;</operator><literal type="number">25</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\n  %z\n  %*s^--- error here"</literal></expr></argument>, <argument><expr><name>zCode</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\n  %z\n  %*serror here ---^"</literal></expr></argument>, <argument><expr><name>zCode</name></expr></argument>, <argument><expr><name>iOffset</name><operator>-</operator><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>zMsg</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Execute a query statement that will generate SQL output.  Print
** the result columns, comma-separated, on a line and then add a
** semicolon terminator to the end of that line.
**
** If the number of columns is 1 and that column contains text "--"
** then write the semicolon on a separate line.  That way, if a
** "--" comment occurs at the end of the statement, the comment
** won't consume the semicolon terminator.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>run_table_dump_query</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,           <comment type="block">/* Query context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSelect</name></decl></parameter>      <comment type="block">/* SELECT statement to extract content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nResult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSelect</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>||</operator> <operator>!</operator><name>pSelect</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zContext</name> <init>= <expr><call><name>shell_error_context</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/**** ERROR: (%d) %s *****/\n%s"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>,
                <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>!=</operator><name>SQLITE_CORRUPT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nResult</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nResult</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/**** ERROR: (%d) %s *****/\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>,
                <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>!=</operator><name>SQLITE_CORRUPT</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate space and save off string indicating current error.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>save_err_msg</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,           <comment type="block">/* Database to query */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPhase</name></decl></parameter>,    <comment type="block">/* When the error occcurs */</comment>
  <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>,                <comment type="block">/* Error code returned from API */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>       <comment type="block">/* SQL string, or NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zContext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%s, %s"</literal></expr></argument>, <argument><expr><name>zPhase</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zContext</name> <operator>=</operator> <call><name>shell_error_context</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zContext</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_str_appendall</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zErr</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<comment type="block">/*
** Attempt to display I/O stats on Linux using /proc/PID/io
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>displayLinuxIoStats</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"/proc/%d/io"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDesc</name></decl>;</decl_stmt>
    }</block> <decl><name><name>aTrans</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"rchar: "</literal></expr>,                  <expr><literal type="string">"Bytes received by read():"</literal></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="string">"wchar: "</literal></expr>,                  <expr><literal type="string">"Bytes sent to write():"</literal></expr>    }</block></expr>,
      <expr><block>{ <expr><literal type="string">"syscr: "</literal></expr>,                  <expr><literal type="string">"Read() system calls:"</literal></expr>      }</block></expr>,
      <expr><block>{ <expr><literal type="string">"syscw: "</literal></expr>,                  <expr><literal type="string">"Write() system calls:"</literal></expr>     }</block></expr>,
      <expr><block>{ <expr><literal type="string">"read_bytes: "</literal></expr>,             <expr><literal type="string">"Bytes read from storage:"</literal></expr>  }</block></expr>,
      <expr><block>{ <expr><literal type="string">"write_bytes: "</literal></expr>,            <expr><literal type="string">"Bytes written to storage:"</literal></expr> }</block></expr>,
      <expr><block>{ <expr><literal type="string">"cancelled_write_bytes: "</literal></expr>,  <expr><literal type="string">"Cancelled write bytes:"</literal></expr>    }</block></expr>,
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aTrans</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>aTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>aTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zPattern</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s"</literal></expr></argument>, <argument><expr><name><name>aTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Display a single line of status using 64-bit values.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>displayStatLine</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,            <comment type="block">/* The shell context */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zLabel</name></decl></parameter>,             <comment type="block">/* Label for this one line */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,            <comment type="block">/* Format for the result */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStatusCtrl</name></decl></parameter>,          <comment type="block">/* Which status to display */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReset</name></decl></parameter>                <comment type="block">/* True to reset the stats */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iCur</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iHiwtr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nPercent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zLine</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_status64</name><argument_list>(<argument><expr><name>iStatusCtrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>nPercent</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zFormat</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPercent</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>nPercent</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>zLabel</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Display memory stats.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>display_stats</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                <comment type="block">/* Database to query */</comment>
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,           <comment type="block">/* Pointer to ShellState */</comment>
  <parameter><decl><type><name>int</name></type> <name>bReset</name></decl></parameter>                  <comment type="block">/* True to reset the stats */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iHiwtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pArg</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pArg</name><operator>-&gt;</operator><name>out</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>out</name> <operator>=</operator> <name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>statsOn</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"Number of output columns:"</literal></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"Column %d %nname:"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DECLTYPE</name></cpp:ifndef>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>z</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"declared type:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_column_decltype</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>z</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"database name:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_column_database_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>z</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"table name:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_column_table_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>z</name><operator>+</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"origin name:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%-36s %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_column_origin_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>statsOn</name></name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"VM-steps: %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Memory Used:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld (max %lld) bytes"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Number of Outstanding Allocations:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld (max %lld)"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_MALLOC_COUNT</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_Pagecache</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Number of Pcache Pages Used:"</literal></expr></argument>,
       <argument><expr><literal type="string">"%lld (max %lld) pages"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_PAGECACHE_USED</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Number of Pcache Overflow Bytes:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld (max %lld) bytes"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_PAGECACHE_OVERFLOW</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Largest Allocation:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld bytes"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_MALLOC_SIZE</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Largest Pcache Allocation:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld bytes"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_PAGECACHE_SIZE</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <expr_stmt><expr><call><name>displayStatLine</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="string">"Deepest Parser Stack:"</literal></expr></argument>,
     <argument><expr><literal type="string">"%lld (max %lld)"</literal></expr></argument>, <argument><expr><name>SQLITE_STATUS_PARSER_STACK</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>db</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_Lookaside</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_LOOKASIDE_USED</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
              <argument><expr><literal type="string">"Lookaside Slots Used:                %d (max %d)\n"</literal></expr></argument>,
              <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_LOOKASIDE_HIT</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Successful lookaside attempts:       %d\n"</literal></expr></argument>,
              <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Lookaside failures due to size:      %d\n"</literal></expr></argument>,
              <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Lookaside failures due to OOM:       %d\n"</literal></expr></argument>,
              <argument><expr><name>iHiwtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_CACHE_USED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Pager Heap Usage:                    %d bytes\n"</literal></expr></argument>,
            <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_CACHE_HIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Page cache hits:                     %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_CACHE_MISS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Page cache misses:                   %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_CACHE_WRITE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Page cache writes:                   %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_CACHE_SPILL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Page cache spills:                   %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_SCHEMA_USED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Schema Heap Usage:                   %d bytes\n"</literal></expr></argument>,
            <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHiwtr</name> <operator>=</operator> <name>iCur</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_status</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBSTATUS_STMT_USED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iHiwtr</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Statement Heap/Lookaside Usage:      %d bytes\n"</literal></expr></argument>,
            <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iHit</name></decl>, <decl><type ref="prev"/><name>iMiss</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr></argument>,
                               <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Fullscan Steps:                      %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_SORT</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Sort Operations:                     %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_AUTOINDEX</name></expr></argument>,<argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Autoindex Inserts:                   %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iHit</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_FILTER_HIT</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMiss</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_FILTER_MISS</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iHit</name> <operator>||</operator> <name>iMiss</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Bloom filter bypass taken:           %d/%d\n"</literal></expr></argument>,
            <argument><expr><name>iHit</name></expr></argument>, <argument><expr><name>iHit</name><operator>+</operator><name>iMiss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_VM_STEP</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Virtual Machine Steps:               %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_REPREPARE</name></expr></argument>,<argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Reprepare operations:                %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_RUN</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Number of times run:                 %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCur</name> <operator>=</operator> <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>SQLITE_STMTSTATUS_MEMUSED</name></expr></argument>, <argument><expr><name>bReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Memory used by prepared stmt:        %d\n"</literal></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
  <expr_stmt><expr><call><name>displayLinuxIoStats</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do not remove this machine readable comment: extra-stats-output-here */</comment>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Display scan stats.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>display_scanstats</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database to query */</comment>
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>                <comment type="block">/* Pointer to ShellState */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifndef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>mx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-------- scanstats --------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;=</operator><name>mx</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>rEstLoop</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nLoop</name></decl>, <decl><type ref="prev"/><name>nVisit</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>rEst</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iSid</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zExplain</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stmt_scanstatus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SQLITE_SCANSTAT_NLOOP</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nLoop</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_stmt_scanstatus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SQLITE_SCANSTAT_SELECTID</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iSid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iSid</name><operator>&gt;</operator><name>mx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mx</name> <operator>=</operator> <name>iSid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>iSid</name><operator>!=</operator><name>k</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rEstLoop</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>nLoop</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>k</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-------- subquery %d -------\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_stmt_scanstatus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SQLITE_SCANSTAT_NVISIT</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nVisit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_stmt_scanstatus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SQLITE_SCANSTAT_EST</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_stmt_scanstatus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SQLITE_SCANSTAT_EXPLAIN</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>zExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Loop %2d: %s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rEstLoop</name> <operator>*=</operator> <name>rEst</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
          <argument><expr><literal type="string">"         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\n"</literal></expr></argument>,
          <argument><expr><name>nLoop</name></expr></argument>, <argument><expr><name>nVisit</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name>rEstLoop</name><operator>+</operator><literal type="number">0.5</literal><operator>)</operator></expr></argument>, <argument><expr><name>rEst</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"---------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Parameter azArray points to a zero-terminated array of strings. zStr
** points to a single nul-terminated string. Return non-zero if zStr
** is equal, according to strcmp(), to any of the strings in the array.
** Otherwise, return zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_in_array</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArray</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>azArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>, <argument><expr><name><name>azArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If compiled statement pSql appears to be an EXPLAIN statement, allocate
** and populate the ShellState.aiIndent[] array with the number of
** spaces each opcode should be indented before it is output.
**
** The indenting rules are:
**
**     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent
**       all opcodes that occur between the p2 jump destination and the opcode
**       itself by 2 spaces.
**
**     * Do the previous for "Return" instructions for when P2 is positive.
**       See tag-20220407a in wherecode.c and vdbe.c.
**
**     * For each "Goto", if the jump destination is earlier in the program
**       and ends on one of:
**          Yield  SeekGt  SeekLt  RowSetRead  Rewind
**       or if the P1 parameter is one instead of zero,
**       then indent all opcodes between the earlier instruction
**       and "Goto" by 2 spaces.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explain_data_prepare</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>               <comment type="block">/* The text of the SQL statement */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>                  <comment type="block">/* Used to check if this is an EXPLAIN */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>abYield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* True if op is an OP_Yield */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Allocated size of p-&gt;aiIndent[], abYield */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOp</name></decl>;</decl_stmt>                        <comment type="block">/* Index of operation in p-&gt;aiIndent[] */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azNext</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"Next"</literal></expr>, <expr><literal type="string">"Prev"</literal></expr>, <expr><literal type="string">"VPrev"</literal></expr>, <expr><literal type="string">"VNext"</literal></expr>, <expr><literal type="string">"SorterNext"</literal></expr>,
                           <expr><literal type="string">"Return"</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azYield</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"Yield"</literal></expr>, <expr><literal type="string">"SeekLT"</literal></expr>, <expr><literal type="string">"SeekGT"</literal></expr>, <expr><literal type="string">"RowSetRead"</literal></expr>,
                            <expr><literal type="string">"Rewind"</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azGoto</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"Goto"</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Try to figure out if this is really an EXPLAIN statement. If this
  ** cannot be verified, return early.  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>z</name><operator>=</operator><name>zSql</name></expr>;</init> <condition><expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\f'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'\r'</literal></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"explain"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>iOp</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>iOp</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Set p2 to the P2 field of the current opcode. Then, assuming that
    ** p2 is an instruction address, set variable p2op to the index of that
    ** instruction in the aiIndent[] array. p2 and p2op may be different if
    ** the current instruction is part of a sub-program generated by an
    ** SQL trigger or foreign key.  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>p2</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p2op</name> <init>= <expr><operator>(</operator><name>p2</name> <operator>+</operator> <operator>(</operator><name>iOp</name><operator>-</operator><name>iAddr</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Grow the p-&gt;aiIndent array as required */</comment>
    <if_stmt><if>if<condition>( <expr><name>iOp</name><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* Do further verfication that this is explain output.  Abort if
        ** it is not */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>explainCols</name><index>[]</index></name> <init>= <expr><block>{
           <expr><literal type="string">"addr"</literal></expr>, <expr><literal type="string">"opcode"</literal></expr>, <expr><literal type="string">"p1"</literal></expr>, <expr><literal type="string">"p2"</literal></expr>, <expr><literal type="string">"p3"</literal></expr>, <expr><literal type="string">"p4"</literal></expr>, <expr><literal type="string">"p5"</literal></expr>, <expr><literal type="string">"comment"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>explainCols</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>,<argument><expr><name>jj</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>explainCols</name><index>[<expr><name>jj</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nAlloc</name> <operator>+=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>abYield</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>abYield</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>abYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>abYield</name><index>[<expr><name>iOp</name></expr>]</index></name> <operator>=</operator> <call><name>str_in_array</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>, <argument><expr><name>azYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name><index>[<expr><name>iOp</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIndent</name></name> <operator>=</operator> <name>iOp</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><call><name>str_in_array</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>, <argument><expr><name>azNext</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>p2op</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>p2op</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iOp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>str_in_array</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>, <argument><expr><name>azGoto</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>p2op</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nIndent</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>abYield</name><index>[<expr><name>p2op</name></expr>]</index></name> <operator>||</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>p2op</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iOp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIndent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>abYield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Free the array allocated by explain_data_prepare().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>explain_data_delete</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aiIndent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nIndent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iIndent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Disable and restore .wheretrace and .treetrace/.selecttrace settings.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>savedSelectTrace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>savedWhereTrace</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>disable_debug_trace_modes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSelectTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedWhereTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>restore_debug_trace_modes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSelectTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedWhereTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create the TEMP table used to store parameter bindings */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bind_table_init</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>wrSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>defensiveMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_DEFENSIVE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>defensiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_DEFENSIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_WRITABLE_SCHEMA</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>wrSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_WRITABLE_SCHEMA</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
    <argument><expr><literal type="string">"CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n"</literal>
    <literal type="string">"  key TEXT PRIMARY KEY,\n"</literal>
    <literal type="string">"  value\n"</literal>
    <literal type="string">") WITHOUT ROWID;"</literal></expr></argument>,
    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_WRITABLE_SCHEMA</name></expr></argument>, <argument><expr><name>wrSchema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_DEFENSIVE</name></expr></argument>, <argument><expr><name>defensiveMode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Bind parameters on a prepared statement.
**
** Parameter bindings are taken from a TEMP table of the form:
**
**    CREATE TEMP TABLE sqlite_parameters(key TEXT PRIMARY KEY, value)
**    WITHOUT ROWID;
**
** No bindings occur if this table does not exist.  The name of the table
** begins with "sqlite_" so that it will not collide with ordinary application
** tables.  The table must be in the TEMP schema.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bind_prepared_stmt</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pQ</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>nVar</name> <operator>=</operator> <call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nVar</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Nothing to do */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"TEMP"</literal></expr></argument>, <argument><expr><literal type="string">"sqlite_parameters"</literal></expr></argument>,
                                    <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <return>return;</return> <comment type="block">/* Parameter table does not exist */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
          <argument><expr><literal type="string">"SELECT value FROM temp.sqlite_parameters"</literal>
          <literal type="string">" WHERE key=?1"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>pQ</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nVar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zNum</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVar</name> <init>= <expr><call><name>sqlite3_bind_parameter_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVar</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zNum</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zNum</name></expr></argument>,<argument><expr><literal type="string">"?%d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zVar</name> <operator>=</operator> <name>zNum</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pQ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zVar</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQ</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** UTF8 box-drawing characters.  Imagine box lines like this:
**
**           1
**           |
**       4 --+-- 2
**           |
**           3
**
** Each box characters has between 2 and 4 of the lines leading from
** the center.  The characters are here identified by the numbers of
** their corresponding lines.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_24</name></cpp:macro>   <cpp:value>"\342\224\200"</cpp:value></cpp:define>  <comment type="block">/* U+2500 --- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_13</name></cpp:macro>   <cpp:value>"\342\224\202"</cpp:value></cpp:define>  <comment type="block">/* U+2502  |  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_23</name></cpp:macro>   <cpp:value>"\342\224\214"</cpp:value></cpp:define>  <comment type="block">/* U+250c  ,- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_34</name></cpp:macro>   <cpp:value>"\342\224\220"</cpp:value></cpp:define>  <comment type="block">/* U+2510 -,  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_12</name></cpp:macro>   <cpp:value>"\342\224\224"</cpp:value></cpp:define>  <comment type="block">/* U+2514  '- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_14</name></cpp:macro>   <cpp:value>"\342\224\230"</cpp:value></cpp:define>  <comment type="block">/* U+2518 -'  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_123</name></cpp:macro>  <cpp:value>"\342\224\234"</cpp:value></cpp:define>  <comment type="block">/* U+251c  |- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_134</name></cpp:macro>  <cpp:value>"\342\224\244"</cpp:value></cpp:define>  <comment type="block">/* U+2524 -|  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_234</name></cpp:macro>  <cpp:value>"\342\224\254"</cpp:value></cpp:define>  <comment type="block">/* U+252c -,- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_124</name></cpp:macro>  <cpp:value>"\342\224\264"</cpp:value></cpp:define>  <comment type="block">/* U+2534 -'- */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOX_1234</name></cpp:macro> <cpp:value>"\342\224\274"</cpp:value></cpp:define>  <comment type="block">/* U+253c -|- */</comment>

<comment type="block">/* Draw horizontal line N characters long using unicode box
** characters
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_box_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>zDash</name><index>[]</index></name> <init>= 
      <expr><name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name>
      <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name> <name>BOX_24</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nDash</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>zDash</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>N</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>N</name><operator>&gt;</operator><name>nDash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>zDash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name> <operator>-=</operator> <name>nDash</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>zDash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Draw a horizontal separator for a MODE_Box table.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_box_row_separator</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep1</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep2</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep3</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSep1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_box_line</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSep2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_box_line</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zSep3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** z[] is a line of text that is to be displayed the .mode box or table or
** similar tabular formats.  z[] might contain control characters such
** as \n, \t, \f, or \r.
**
** Compute characters to display on the first line of z[].  Stop at the
** first \r, \n, or \f.  Expand \t into spaces.  Return a copy (obtained
** from malloc()) of that first line, which caller should free sometime.
** Write anything to display on the next line into *pzTail.  If this is
** the last line, write a NULL into *pzTail. (*pzTail is not allocated.)
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>translateForDisplayAndDup</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,            <comment type="block">/* Input text to be transformed */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTail</name></decl></parameter>,      <comment type="block">/* OUT: Tail of the input for next line */</comment>
  <parameter><decl><type><name>int</name></type> <name>mxWidth</name></decl></parameter>,                       <comment type="block">/* Max width.  0 means no limit */</comment>
  <parameter><decl><type><name>u8</name></type> <name>bWordWrap</name></decl></parameter>                       <comment type="block">/* If true, avoid breaking mid-word */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Input bytes consumed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                 <comment type="block">/* Output bytes generated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>                 <comment type="block">/* Input bytes to be displayed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                 <comment type="block">/* Output column number */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>   <comment type="block">/* Output text */</comment>

  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mxWidth</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxWidth</name> <operator>=</operator> <operator>-</operator><name>mxWidth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mxWidth</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mxWidth</name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&lt;</operator><name>mxWidth</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      <do>do<block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition>;</do>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\t'</literal></expr> )</condition><block>{<block_content>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><name>n</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>mxWidth</name></expr> )</condition>;</do>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>mxWidth</name> <operator>&amp;&amp;</operator> <name>bWordWrap</name></expr>  )</condition><block>{<block_content>
    <comment type="block">/* Perhaps try to back up to a better place to break the line */</comment>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name>k</name><operator>&gt;</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;=</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name>k</name><operator>&gt;</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>isalnum</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>z</name><index>[<expr><name>k</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>!=</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>k</name><operator>&lt;=</operator><name>i</name><operator>/</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><name>mxWidth</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
   <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <ternary><condition><expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>k</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">' '</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      <do>do<block>{<block_content> <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><operator>(</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition>;</do>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\t'</literal></expr> )</condition><block>{<block_content>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
      </block_content>}</block>while<condition>( <expr><operator>(</operator><name>n</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>mxWidth</name></expr> )</condition>;</do>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zOut</name></expr>;</return>  
</block_content>}</block></function>

<comment type="block">/* Extract the value of the i-th current column for pStmt as an SQL literal
** value.  Memory is obtained from sqlite3_malloc64() and must be freed by
** the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>quoted_column</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%Q"</literal></expr></argument>,<argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_str</name> <modifier>*</modifier></type><name>pStr</name> <init>= <expr><call><name>sqlite3_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"x'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_str_appendf</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_str_append</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>sqlite3_str_finish</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Not reached */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Run a prepared statement and output the result in one of the
** table-oriented formats: MODE_Column, MODE_Markdown, MODE_Table,
** or MODE_Box.
**
** This is different from ordinary exec_prepared_stmt() in that
** it has to run the entire query and gather the results into memory
** first, in order to determine column widths, before providing
** any output.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exec_prepared_stmt_columnar</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                        <comment type="block">/* Pointer to ShellState */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>                   <comment type="block">/* Statment to run */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nRow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>abRowDiv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>uz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azQuoted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nTotal</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colSep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rowSep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azNextLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bNextLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bMultiLineRowExists</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bw</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bWordWrap</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEmpty</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zShowNull</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nColumn</name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nAlloc</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>azData</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>azNextLine</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nColumn</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>azNextLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>azNextLine</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nColumn</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bQuote</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>azQuoted</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nColumn</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>azQuoted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nColumn</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>abRowDiv</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nAlloc</name><operator>/</operator><name>nColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>abRowDiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nColumn</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name></expr></argument>, <argument><expr><operator>(</operator><name>nColumn</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name> <operator>=</operator> <name>nColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>nColumn</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nColumn</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>w</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>-</operator><name>w</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zNotUsed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>wx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>wx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>iWrap</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>wx</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>wx</name> <operator>=</operator> <operator>-</operator><name>wx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>uz</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>translateForDisplayAndDup</name><argument_list>(<argument><expr><name>uz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zNotUsed</name></expr></argument>, <argument><expr><name>wx</name></expr></argument>, <argument><expr><name>bw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <do>do<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>useNextLine</name> <init>= <expr><name>bNextLine</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>bNextLine</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nRow</name><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>*</operator><name>nColumn</name> <operator>&gt;=</operator> <name>nAlloc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAlloc</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>azData</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>azData</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>abRowDiv</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>abRowDiv</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>/</operator><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>abRowDiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>abRowDiv</name><index>[<expr><name>nRow</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRow</name><operator>++</operator></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>wx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>wx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>wx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>iWrap</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>wx</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>wx</name> <operator>=</operator> <operator>-</operator><name>wx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>useNextLine</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>uz</name> <operator>=</operator> <name><name>azNextLine</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>uz</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>uz</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zEmpty</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bQuote</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azQuoted</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azQuoted</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>quoted_column</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>uz</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>azQuoted</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>uz</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>uz</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>uz</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zShowNull</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>azData</name><index>[<expr><name>nRow</name><operator>*</operator><name>nColumn</name> <operator>+</operator> <name>i</name></expr>]</index></name>
        <operator>=</operator> <call><name>translateForDisplayAndDup</name><argument_list>(<argument><expr><name>uz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>azNextLine</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>wx</name></expr></argument>, <argument><expr><name>bw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>azNextLine</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bNextLine</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>abRowDiv</name><index>[<expr><name>nRow</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bMultiLineRowExists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block>while<condition>( <expr><name>bNextLine</name> <operator>||</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition>;</do>
  <expr_stmt><expr><name>nTotal</name> <operator>=</operator> <name>nColumn</name><operator>*</operator><operator>(</operator><name>nRow</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zEmpty</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>%</operator><name>nColumn</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>seenInterrupt</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>columnar_end</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nColumn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>columnar_end</name>;</goto></block_content></block></if></if_stmt>
  <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>MODE_Column</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>colSep</name> <operator>=</operator> <literal type="string">"  "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rowSep</name> <operator>=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>-</operator><name>w</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>utf8_width_print</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">"\n"</literal></expr></then><else>:<expr><literal type="string">"  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>print_dashes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">"\n"</literal></expr></then><else>:<expr><literal type="string">"  "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Table</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>colSep</name> <operator>=</operator> <literal type="string">" | "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rowSep</name> <operator>=</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"| "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%*s%s%*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">" |\n"</literal></expr></then><else>:<expr><literal type="string">" | "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>print_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Markdown</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>colSep</name> <operator>=</operator> <literal type="string">" | "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rowSep</name> <operator>=</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"| "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%*s%s%*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">" |\n"</literal></expr></then><else>:<expr><literal type="string">" | "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>print_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>MODE_Box</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>colSep</name> <operator>=</operator> <literal type="string">" "</literal> <name>BOX_13</name> <literal type="string">" "</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rowSep</name> <operator>=</operator> <literal type="string">" "</literal> <name>BOX_13</name> <literal type="string">"\n"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_box_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>BOX_23</name></expr></argument>, <argument><expr><name>BOX_234</name></expr></argument>, <argument><expr><name>BOX_34</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>BOX_13</name> <literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlenChar</name><argument_list>(<argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%*s%s%*s%s"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>w</name><operator>-</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><literal type="string">" "</literal><name>BOX_13</name><literal type="string">"\n"</literal></expr></then><else>:<expr><literal type="string">" "</literal><name>BOX_13</name><literal type="string">" "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>print_box_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>BOX_123</name></expr></argument>, <argument><expr><name>BOX_1234</name></expr></argument>, <argument><expr><name>BOX_134</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nColumn</name></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTotal</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>!=</operator><name>MODE_Column</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Box</name></expr>?</condition><then><expr><name>BOX_13</name><literal type="string">" "</literal></expr></then><else>:<expr><literal type="string">"| "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>actualWidth</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>j</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>w</name> <operator>=</operator> <operator>-</operator><name>w</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>utf8_width_print</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>==</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>rowSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bMultiLineRowExists</name> <operator>&amp;&amp;</operator> <name><name>abRowDiv</name><index>[<expr><name>i</name><operator>/</operator><name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nTotal</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Table</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>print_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Box</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>print_box_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>BOX_123</name></expr></argument>, <argument><expr><name>BOX_1234</name></expr></argument>, <argument><expr><name>BOX_134</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Column</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>seenInterrupt</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>columnar_end</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>colSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Table</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>print_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Box</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>print_box_row_separator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>BOX_12</name></expr></argument>, <argument><expr><name>BOX_124</name></expr></argument>, <argument><expr><name>BOX_14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>columnar_end</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>seenInterrupt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Interrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nData</name> <operator>=</operator> <operator>(</operator><name>nRow</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>nColumn</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nData</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>!=</operator><name>zEmpty</name> <operator>&amp;&amp;</operator> <name>z</name><operator>!=</operator><name>zShowNull</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>azData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>azNextLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>abRowDiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azQuoted</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azQuoted</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Run a prepared statement
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exec_prepared_stmt</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,                                <comment type="block">/* Pointer to ShellState */</comment>
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>                              <comment type="block">/* Statment to run */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>nRow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Column</name>
   <operator>||</operator> <name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Table</name>
   <operator>||</operator> <name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Box</name>
   <operator>||</operator> <name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Markdown</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>exec_prepared_stmt_columnar</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* perform the first step.  this will tell us if we
  ** have a result set or not and how wide it is.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* if we have a result set... */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name> <operator>==</operator> <name>rc</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* allocate space for col name ptr, value ptr, and type */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>*</operator><name>nCol</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pData</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCols</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>pData</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Names of result columns */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azVals</name> <init>= <expr><operator>&amp;</operator><name><name>azCols</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Results */</comment>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aiTypes</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azVals</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Result types */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* save off ptrs to column names */</comment>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>azCols</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <do>do<block>{<block_content>
        <expr_stmt><expr><name>nRow</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* extract the data and data types */</comment>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>aiTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name> <operator>=</operator> <call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><name>SQLITE_BLOB</name>
           <operator>&amp;&amp;</operator> <name>pArg</name>
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Insert</name> <operator>||</operator> <name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Quote</name><operator>)</operator></expr>
          )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>azVals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>azVals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azVals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>aiTypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>SQLITE_NULL</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <break>break;</break> <comment type="block">/* from for */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for> <comment type="block">/* end for */</comment>

        <comment type="block">/* if data and types extracted successfully... */</comment>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name> <operator>==</operator> <name>rc</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* call the supplied callback with the result row data */</comment>
          <if_stmt><if>if<condition>( <expr><call><name>shell_callback</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>azVals</name></expr></argument>, <argument><expr><name>azCols</name></expr></argument>, <argument><expr><name>aiTypes</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ABORT</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block> while<condition>( <expr><name>SQLITE_ROW</name> <operator>==</operator> <name>rc</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Json</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Count</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%llu row%s\n"</literal></expr></argument>,
                         <argument><expr><name>nRow</name></expr></argument>, <argument><expr><ternary><condition><expr><name>nRow</name><operator>!=</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** This function is called to process SQL if the previous shell command
** was ".expert". It passes the SQL in the second argument directly to
** the sqlite3expert object.
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
** code. In this case, (*pzErr) may be set to point to a buffer containing
** an English language error message. It is the responsibility of the
** caller to eventually free this buffer using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertHandleSQL</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzErr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pzErr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_expert_sql</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called either to silently clean up the object
** created by the ".expert" command (if bCancel==1), or to generate a 
** report from it and then clean it up (if bCancel==0).
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
** code. In this case, (*pzErr) may be set to point to a buffer containing
** an English language error message. It is the responsibility of the
** caller to eventually free this buffer using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertFinish</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>bCancel</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3expert</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bCancel</name> <operator>||</operator> <name>pzErr</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>pzErr</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>bCancel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bVerbose</name> <init>= <expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>bVerbose</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_expert_analyze</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nQuery</name> <init>= <expr><call><name>sqlite3_expert_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>bVerbose</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCand</name> <init>= <expr><call><name>sqlite3_expert_report</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>EXPERT_REPORT_CANDIDATES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- Candidates -----------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zCand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nQuery</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_expert_report</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>EXPERT_REPORT_SQL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIdx</name> <init>= <expr><call><name>sqlite3_expert_report</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>EXPERT_REPORT_INDEXES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEQP</name> <init>= <expr><call><name>sqlite3_expert_report</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>EXPERT_REPORT_PLAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zIdx</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIdx</name> <operator>=</operator> <literal type="string">"(no new indexes)\n"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>bVerbose</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- Query %d --------------------------------\n"</literal></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_expert_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of ".expert" dot command.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expertDotCommand</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>,             <comment type="block">/* Current shell tool state */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,                   <comment type="block">/* Array of arguments passed to dot command */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>                        <comment type="block">/* Number of entries in azArg[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSample</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pState</name><operator>-&gt;</operator><name>expert</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpertInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-verbose"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>bVerbose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>n</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-sample"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"option requires an argument: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>iSample</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>iSample</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>iSample</name></expr></argument>&gt;</argument_list></name><literal type="number">100</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"value out of range: %s\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown option: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name> <operator>=</operator> <call><name>sqlite3_expert_new</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"sqlite3_expert_new: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>zErr</name></expr> ?</condition><then> <expr><name>zErr</name></expr> </then><else>: <expr><literal type="string">"out of memory"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_expert_config</name><argument_list>(
          <argument><expr><name><name>pState</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr></argument>, <argument><expr><name>EXPERT_CONFIG_SAMPLE</name></expr></argument>, <argument><expr><name>iSample</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Execute a statement or set of statements.  Print
** any result rows/columns depending on the current mode
** set via the supplied callback.
**
** This is very similar to SQLite's built-in sqlite3_exec()
** function except it takes a slightly different callback
** and callback data argument.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>shell_exec</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,                         <comment type="block">/* Pointer to ShellState */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>,                         <comment type="block">/* SQL to be evaluated */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>                           <comment type="block">/* Error msg written here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Statement to execute. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return Code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLeftover</name></decl>;</decl_stmt>          <comment type="block">/* Tail of unprocessed SQL */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pArg</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expertHandleSQL</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>pzErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>expertFinish</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><operator>(</operator><name>rc</name><operator>!=</operator><name>SQLITE_OK</name><operator>)</operator></expr></argument>, <argument><expr><name>pzErrMsg</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <while>while<condition>( <expr><name><name>zSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>SQLITE_OK</name> <operator>==</operator> <name>rc</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStmtSql</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zLeftover</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name> <operator>!=</operator> <name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>save_err_msg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"in prepare"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pStmt</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* this happens for a comment or white-space */</comment>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <name>zLeftover</name></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zSql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zStmtSql</name> <operator>=</operator> <call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStmtSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zStmtSql</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zStmtSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zStmtSql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

      <comment type="block">/* save off the prepared statment handle and reset row count */</comment>
      <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Show the EXPLAIN QUERY PLAN if .eqp is on */</comment>
      <if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>&amp;&amp;</operator> <call><name>sqlite3_stmt_isexplain</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pExplain</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zEQP</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>triggerEQP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>disable_debug_trace_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>triggerEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>autoEQP</name></name><operator>&gt;=</operator><name>AUTOEQP_trigger</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>zEQP</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"EXPLAIN QUERY PLAN %s"</literal></expr></argument>, <argument><expr><name>zStmtSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zEQP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEQPLine</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>iEqpId</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>iParentId</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>zEQPLine</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zEQPLine</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>zEQPLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>eqp_render</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>eqp_append</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>iEqpId</name></expr></argument>, <argument><expr><name>iParentId</name></expr></argument>, <argument><expr><name>zEQPLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
          <expr_stmt><expr><call><name>eqp_render</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>autoEQP</name></name><operator>&gt;=</operator><name>AUTOEQP_full</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* Also do an EXPLAIN for ".eqp full" mode */</comment>
          <expr_stmt><expr><name>zEQP</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"EXPLAIN %s"</literal></expr></argument>, <argument><expr><name>zStmtSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zEQP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name>MODE_Explain</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>explain_data_prepare</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exec_prepared_stmt</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>explain_data_delete</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zEQP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>autoEQP</name></name><operator>&gt;=</operator><name>AUTOEQP_trigger</name> <operator>&amp;&amp;</operator> <name>triggerEQP</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Reprepare pStmt before reactiving trace modes */</comment>
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>pStmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>restore_debug_trace_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>pArg</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>autoExplain</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stmt_isexplain</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name>MODE_Explain</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stmt_isexplain</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name>MODE_EQP</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the shell is currently in ".explain" mode, gather the extra
        ** data required to add indents to the output.*/</comment>
        <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>cMode</name></name><operator>==</operator><name>MODE_Explain</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>explain_data_prepare</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>bind_prepared_stmt</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exec_prepared_stmt</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>explain_data_delete</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>eqp_render</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* print usage stats if stats on */</comment>
      <if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>statsOn</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>display_stats</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* print loop-counters if required */</comment>
      <if_stmt><if>if<condition>( <expr><name>pArg</name> <operator>&amp;&amp;</operator> <name><name>pArg</name><operator>-&gt;</operator><name>scanstatsOn</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>display_scanstats</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Finalize the statement just executed. If this fails, save a
      ** copy of the error message. Otherwise, set zSql to point to the
      ** next statement to execute. */</comment>
      <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <name>zLeftover</name></expr>;</expr_stmt>
        <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zSql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zSql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErrMsg</name> <operator>=</operator> <call><name>save_err_msg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"stepping"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* clear saved stmt handle */</comment>
      <if_stmt><if>if<condition>( <expr><name>pArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while> <comment type="block">/* end while */</comment>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Release memory previously allocated by tableColumnList().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeColumnList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* azCol[0] is a static string */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return a list of pointers to strings which are the names of all
** columns in table zTab.   The memory to hold the names is dynamically
** allocated and must be released by the caller using a subsequent call
** to freeColumnList().
**
** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
** value that needs to be preserved, then azCol[0] is filled in with the
** name of the rowid column.
**
** The first regular column in the table is azCol[1].  The list is terminated
** by an entry with azCol[i]==0.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tableColumnList</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Number of PRIMARY KEY columns seen */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isIPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* True if one PRIMARY KEY column of type INTEGER */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>preserveRowid</name> <init>= <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_PreserveRowid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA table_info=%Q"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>&gt;=</operator><name>nAlloc</name><operator>-</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nAlloc</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <name>nCol</name> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>azCol</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>, <argument><expr><name>nAlloc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>azCol</name><index>[<expr><operator>++</operator><name>nCol</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>nCol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nPK</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nPK</name><operator>==</operator><literal type="number">1</literal>
       <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><literal type="string">"INTEGER"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><name>isIPK</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>isIPK</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>nCol</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* The decision of whether or not a rowid really needs to be preserved
  ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table
  ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve
  ** rowids on tables where the rowid is inaccessible because there are other
  ** columns in the table named "rowid", "_rowid_", and "oid".
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>preserveRowid</name> <operator>&amp;&amp;</operator> <name>isIPK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If a single PRIMARY KEY column with type INTEGER was seen, then it
    ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID
    ** table or a INTEGER PRIMARY KEY DESC column, neither of which are
    ** ROWID aliases.  To distinguish these cases, check to see if
    ** there is a "pk" entry in "PRAGMA index_list".  There will be
    ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.
    */</comment>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT 1 FROM pragma_index_list(%Q)"</literal>
                           <literal type="string">" WHERE origin='pk'"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>freeColumnList</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>preserveRowid</name> <operator>=</operator> <name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>preserveRowid</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Only preserve the rowid if we can find a name to use for the
    ** rowid */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azRowid</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"rowid"</literal></expr>, <expr><literal type="string">"_rowid_"</literal></expr>, <expr><literal type="string">"oid"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>azRowid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>nCol</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* At this point, we know that azRowid[j] is not the name of any
        ** ordinary column in the table.  Verify that azRowid[j] is a valid
        ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID
        ** tables will fail this last check */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><name><name>azRowid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>azRowid</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>azCol</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Toggle the reverse_unordered_selects setting.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>toggleSelectOrder</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSetting</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zStmt</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA reverse_unordered_selects"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iSetting</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>,
       <argument><expr><literal type="string">"PRAGMA reverse_unordered_selects(%d)"</literal></expr></argument>, <argument><expr><operator>!</operator><name>iSetting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This is a different callback routine used for dumping the database.
** Each row received by this callback consists of a table name,
** the table type ("index" or "table") and SQL to create the table.
** This routine should print text sufficient to recreate the table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dump_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azNotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dataOnly</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>noSys</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>azNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">3</literal> <operator>||</operator> <name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zTable</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zType</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>dataOnly</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_DumpDataOnly</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>noSys</name>    <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_DumpNoSys</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>noSys</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>dataOnly</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM sqlite_sequence;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><literal type="string">"sqlite_stat?"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>noSys</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>dataOnly</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE sqlite_schema;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>dataOnly</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* no-op */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="string">"CREATE VIRTUAL TABLE"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zIns</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>writableSchema</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema=ON;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>writableSchema</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zIns</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
       <argument><expr><literal type="string">"INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)"</literal>
       <literal type="string">"VALUES('table','%q','%q',0,'%q');"</literal></expr></argument>,
       <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>printSchemaLine</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>sSelect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>sTable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>savedDestTable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>savedMode</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>azCol</name> <operator>=</operator> <call><name>tableColumnList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>azCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Always quote the table name, even if it appears to be pure ascii,
    ** in case it is a keyword. Ex:  INSERT INTO "table" ... */</comment>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><call><name>quoteChar</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If preserving the rowid, add a column list after the table name.
    ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"
    ** instead of the usual "INSERT INTO tab VALUES(...)".
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>quoteChar</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Build an appropriate SELECT statement */</comment>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>quoteChar</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>azCol</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>freeColumnList</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><call><name>quoteChar</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>savedDestTable</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>savedMode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name> <operator>=</operator> <name><name>sTable</name><operator>.</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name>MODE_Insert</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shell_exec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sSelect</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_CORRUPT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/****** CORRUPTION ERROR *******/\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>toggleSelectOrder</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_exec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sSelect</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>toggleSelectOrder</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zDestTable</name></name> <operator>=</operator> <name>savedDestTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>savedMode</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Run zQuery.  Use dump_callback() as the callback routine so that
** the contents of the query are output as SQL statements.
**
** If we get a SQLITE_CORRUPT error, rerun the query after appending
** "ORDER BY rowid DESC" to the end.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>run_schema_dump_query</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><name>dump_callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_CORRUPT</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQ2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/****** CORRUPTION ERROR *******/\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/****** %s ******/\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zQ2</name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name>len</name><operator>+</operator><literal type="number">100</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zQ2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">100</literal></expr></argument>, <argument><expr><name>zQ2</name></expr></argument>, <argument><expr><literal type="string">"%s ORDER BY rowid DESC"</literal></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQ2</name></expr></argument>, <argument><expr><name>dump_callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/****** ERROR: %s ******/\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CORRUPT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zQ2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Text of help messages.
**
** The help text for each individual command begins with a line that starts
** with ".".  Subsequent lines are supplemental information.
**
** There must be two or more spaces between the end of the command and the
** start of the description of what that command does.
*/</comment>
<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <operator>*</operator><operator>(</operator><name><name>azHelp</name><index>[]</index></name><operator>)</operator> <operator>=</operator> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> \
  <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">".archive ...             Manage SQL archives"</literal></expr>,
  <expr><literal type="string">"   Each command must have exactly one of the following options:"</literal></expr>,
  <expr><literal type="string">"     -c, --create               Create a new archive"</literal></expr>,
  <expr><literal type="string">"     -u, --update               Add or update files with changed mtime"</literal></expr>,
  <expr><literal type="string">"     -i, --insert               Like -u but always add even if unchanged"</literal></expr>,
  <expr><literal type="string">"     -r, --remove               Remove files from archive"</literal></expr>,
  <expr><literal type="string">"     -t, --list                 List contents of archive"</literal></expr>,
  <expr><literal type="string">"     -x, --extract              Extract files from archive"</literal></expr>,
  <expr><literal type="string">"   Optional arguments:"</literal></expr>,
  <expr><literal type="string">"     -v, --verbose              Print each filename as it is processed"</literal></expr>,
  <expr><literal type="string">"     -f FILE, --file FILE       Use archive FILE (default is current db)"</literal></expr>,
  <expr><literal type="string">"     -a FILE, --append FILE     Open FILE using the apndvfs VFS"</literal></expr>,
  <expr><literal type="string">"     -C DIR, --directory DIR    Read/extract files from directory DIR"</literal></expr>,
  <expr><literal type="string">"     -g, --glob                 Use glob matching for names in archive"</literal></expr>,
  <expr><literal type="string">"     -n, --dryrun               Show the SQL that would have occurred"</literal></expr>,
  <expr><literal type="string">"   Examples:"</literal></expr>,
  <expr><literal type="string">"     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar"</literal></expr>,
  <expr><literal type="string">"     .ar -tf ARCHIVE          # List members of ARCHIVE"</literal></expr>,
  <expr><literal type="string">"     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE"</literal></expr>,
  <expr><literal type="string">"   See also:"</literal></expr>,
  <expr><literal type="string">"      http://sqlite.org/cli.html#sqlite_archive_support"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr><literal type="string">".auth ON|OFF             Show authorizer callbacks"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".backup ?DB? FILE        Backup DB (default \"main\") to FILE"</literal></expr>,
  <expr><literal type="string">"   Options:"</literal></expr>,
  <expr><literal type="string">"       --append            Use the appendvfs"</literal></expr>,
  <expr><literal type="string">"       --async             Write to FILE without journal and fsync()"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".bail on|off             Stop after hitting an error.  Default OFF"</literal></expr>,
  <expr><literal type="string">".binary on|off           Turn binary output on or off.  Default OFF"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".cd DIRECTORY            Change the working directory to DIRECTORY"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".changes on|off          Show number of rows changed by SQL"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".check GLOB              Fail if output since .testcase does not match"</literal></expr>,
  <expr><literal type="string">".clone NEWDB             Clone data into NEWDB from the existing database"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".connection [close] [#]  Open or close an auxiliary database connection"</literal></expr>,
  <expr><literal type="string">".databases               List names and files of attached databases"</literal></expr>,
  <expr><literal type="string">".dbconfig ?op? ?val?     List or change sqlite3_db_config() options"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>
  <expr><literal type="string">".dbinfo ?DB?             Show status information about the database"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".dump ?OBJECTS?          Render database content as SQL"</literal></expr>,
  <expr><literal type="string">"   Options:"</literal></expr>,
  <expr><literal type="string">"     --data-only            Output only INSERT statements"</literal></expr>,
  <expr><literal type="string">"     --newlines             Allow unescaped newline characters in output"</literal></expr>,
  <expr><literal type="string">"     --nosys                Omit system tables (ex: \"sqlite_stat1\")"</literal></expr>,
  <expr><literal type="string">"     --preserve-rowids      Include ROWID values in the output"</literal></expr>,
  <expr><literal type="string">"   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump"</literal></expr>,
  <expr><literal type="string">"   Additional LIKE patterns can be given in subsequent arguments"</literal></expr>,
  <expr><literal type="string">".echo on|off             Turn command echo on or off"</literal></expr>,
  <expr><literal type="string">".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN"</literal></expr>,
  <expr><literal type="string">"   Other Modes:"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr><literal type="string">"      test                  Show raw EXPLAIN QUERY PLAN output"</literal></expr>,
  <expr><literal type="string">"      trace                 Like \"full\" but enable \"PRAGMA vdbe_trace\""</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">"      trigger               Like \"full\" but also show trigger bytecode"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".excel                   Display the output of next command in spreadsheet"</literal></expr>,
  <expr><literal type="string">"   --bom                   Put a UTF8 byte-order mark on intermediate file"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".exit ?CODE?             Exit this program with return-code CODE"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".expert                  EXPERIMENTAL. Suggest indexes for queries"</literal></expr>,
  <expr><literal type="string">".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto"</literal></expr>,
  <expr><literal type="string">".filectrl CMD ...        Run various sqlite3_file_control() operations"</literal></expr>,
  <expr><literal type="string">"   --schema SCHEMA         Use SCHEMA instead of \"main\""</literal></expr>,
  <expr><literal type="string">"   --help                  Show CMD details"</literal></expr>,
  <expr><literal type="string">".fullschema ?--indent?   Show schema and the content of sqlite_stat tables"</literal></expr>,
  <expr><literal type="string">".headers on|off          Turn display of headers on or off"</literal></expr>,
  <expr><literal type="string">".help ?-all? ?PATTERN?   Show help text for PATTERN"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".import FILE TABLE       Import data from FILE into TABLE"</literal></expr>,
  <expr><literal type="string">"   Options:"</literal></expr>,
  <expr><literal type="string">"     --ascii               Use \\037 and \\036 as column and row separators"</literal></expr>,
  <expr><literal type="string">"     --csv                 Use , and \\n as column and row separators"</literal></expr>,
  <expr><literal type="string">"     --skip N              Skip the first N rows of input"</literal></expr>,
  <expr><literal type="string">"     --schema S            Target table to be S.TABLE"</literal></expr>,
  <expr><literal type="string">"     -v                    \"Verbose\" - increase auxiliary output"</literal></expr>,
  <expr><literal type="string">"   Notes:"</literal></expr>,
  <expr><literal type="string">"     *  If TABLE does not exist, it is created.  The first row of input"</literal></expr>,
  <expr><literal type="string">"        determines the column names."</literal></expr>,
  <expr><literal type="string">"     *  If neither --csv or --ascii are used, the input mode is derived"</literal></expr>,
  <expr><literal type="string">"        from the \".mode\" output mode"</literal></expr>,
  <expr><literal type="string">"     *  If FILE begins with \"|\" then it is a command that generates the"</literal></expr>,
  <expr><literal type="string">"        input text."</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TEST_CONTROL</name></cpp:ifndef>
  <expr><literal type="string">".imposter INDEX TABLE    Create imposter table TABLE on index INDEX"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".indexes ?TABLE?         Show names of indexes"</literal></expr>,
  <expr><literal type="string">"                           If TABLE is specified, only show indexes for"</literal></expr>,
  <expr><literal type="string">"                           tables matching TABLE using the LIKE operator."</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
  <expr><literal type="string">".iotrace FILE            Enable I/O diagnostic logging to FILE"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT"</literal></expr>,
  <expr><literal type="string">".lint OPTIONS            Report potential schema issues."</literal></expr>,
  <expr><literal type="string">"     Options:"</literal></expr>,
  <expr><literal type="string">"        fkey-indexes     Find missing foreign key indexes"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_LOAD_EXTENSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">".load FILE ?ENTRY?       Load an extension library"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".mode MODE ?OPTIONS?     Set output mode"</literal></expr>,
  <expr><literal type="string">"   MODE is one of:"</literal></expr>,
  <expr><literal type="string">"     ascii       Columns/rows delimited by 0x1F and 0x1E"</literal></expr>,
  <expr><literal type="string">"     box         Tables using unicode box-drawing characters"</literal></expr>,
  <expr><literal type="string">"     csv         Comma-separated values"</literal></expr>,
  <expr><literal type="string">"     column      Output in columns.  (See .width)"</literal></expr>,
  <expr><literal type="string">"     html        HTML &lt;table&gt; code"</literal></expr>,
  <expr><literal type="string">"     insert      SQL insert statements for TABLE"</literal></expr>,
  <expr><literal type="string">"     json        Results in a JSON array"</literal></expr>,
  <expr><literal type="string">"     line        One value per line"</literal></expr>,
  <expr><literal type="string">"     list        Values delimited by \"|\""</literal></expr>,
  <expr><literal type="string">"     markdown    Markdown table format"</literal></expr>,
  <expr><literal type="string">"     qbox        Shorthand for \"box --wrap 60 --quote\""</literal></expr>,
  <expr><literal type="string">"     quote       Escape answers as for SQL"</literal></expr>,
  <expr><literal type="string">"     table       ASCII-art table"</literal></expr>,
  <expr><literal type="string">"     tabs        Tab-separated values"</literal></expr>,
  <expr><literal type="string">"     tcl         TCL list elements"</literal></expr>,
  <expr><literal type="string">"   OPTIONS: (for columnar modes or insert mode):"</literal></expr>,
  <expr><literal type="string">"     --wrap N       Wrap output lines to no longer than N characters"</literal></expr>,
  <expr><literal type="string">"     --wordwrap B   Wrap or not at word boundaries per B (on/off)"</literal></expr>,
  <expr><literal type="string">"     --ww           Shorthand for \"--wordwrap 1\""</literal></expr>,
  <expr><literal type="string">"     --quote        Quote output text as SQL literals"</literal></expr>,
  <expr><literal type="string">"     --noquote      Do not quote output text"</literal></expr>,
  <expr><literal type="string">"     TABLE          The name of SQL table used for \"insert\" mode"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".nonce STRING            Suspend safe mode for one command if nonce matches"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".nullvalue STRING        Use STRING in place of NULL values"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE"</literal></expr>,
  <expr><literal type="string">"     If FILE begins with '|' then open as a pipe"</literal></expr>,
  <expr><literal type="string">"       --bom  Put a UTF8 byte-order mark at the beginning"</literal></expr>,
  <expr><literal type="string">"       -e     Send output to the system text editor"</literal></expr>,
  <expr><literal type="string">"       -x     Send output as CSV to a spreadsheet (same as \".excel\")"</literal></expr>,
  <comment type="block">/* Note that .open is (partially) available in WASM builds but is
  ** currently only intended to be used by the fiddle tool, not
  ** end users, so is "undocumented." */</comment>
  <expr><literal type="string">".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE"</literal></expr>,
  <expr><literal type="string">"     Options:"</literal></expr>,
  <expr><literal type="string">"        --append        Use appendvfs to append database to the end of FILE"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
  <expr><literal type="string">"        --deserialize   Load into memory using sqlite3_deserialize()"</literal></expr>,
  <expr><literal type="string">"        --hexdb         Load the output of \"dbtotxt\" as an in-memory db"</literal></expr>,
  <expr><literal type="string">"        --maxsize N     Maximum size for --hexdb or --deserialized database"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">"        --new           Initialize FILE to an empty database"</literal></expr>,
  <expr><literal type="string">"        --nofollow      Do not follow symbolic links"</literal></expr>,
  <expr><literal type="string">"        --readonly      Open FILE readonly"</literal></expr>,
  <expr><literal type="string">"        --zip           FILE is a ZIP archive"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".output ?FILE?           Send output to FILE or stdout if FILE is omitted"</literal></expr>,
  <expr><literal type="string">"   If FILE begins with '|' then open it as a pipe."</literal></expr>,
  <expr><literal type="string">"   Options:"</literal></expr>,
  <expr><literal type="string">"     --bom                 Prefix output with a UTF8 byte-order mark"</literal></expr>,
  <expr><literal type="string">"     -e                    Send output to the system text editor"</literal></expr>,
  <expr><literal type="string">"     -x                    Send output as CSV to a spreadsheet"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".parameter CMD ...       Manage SQL parameter bindings"</literal></expr>,
  <expr><literal type="string">"   clear                   Erase all bindings"</literal></expr>,
  <expr><literal type="string">"   init                    Initialize the TEMP table that holds bindings"</literal></expr>,
  <expr><literal type="string">"   list                    List the current parameter bindings"</literal></expr>,
  <expr><literal type="string">"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE"</literal></expr>,
  <expr><literal type="string">"                           PARAMETER should start with one of: $ : @ ?"</literal></expr>,
  <expr><literal type="string">"   unset PARAMETER         Remove PARAMETER from the binding table"</literal></expr>,
  <expr><literal type="string">".print STRING...         Print literal STRING"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <expr><literal type="string">".progress N              Invoke progress handler after every N opcodes"</literal></expr>,
  <expr><literal type="string">"   --limit N                 Interrupt after N progress callbacks"</literal></expr>,
  <expr><literal type="string">"   --once                    Do no more than one progress interrupt"</literal></expr>,
  <expr><literal type="string">"   --quiet|-q                No output except at interrupts"</literal></expr>,
  <expr><literal type="string">"   --reset                   Reset the count for each input and interrupt"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".prompt MAIN CONTINUE    Replace the standard prompts"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".quit                    Exit this program"</literal></expr>,
  <expr><literal type="string">".read FILE               Read input from FILE or command output"</literal></expr>,
  <expr><literal type="string">"    If FILE begins with \"|\", it is a command that generates the input."</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>
  <expr><literal type="string">".recover                 Recover as much data as possible from corrupt db."</literal></expr>,
  <expr><literal type="string">"   --ignore-freelist        Ignore pages that appear to be on db freelist"</literal></expr>,
  <expr><literal type="string">"   --lost-and-found TABLE   Alternative name for the lost-and-found table"</literal></expr>,
  <expr><literal type="string">"   --no-rowids              Do not attempt to recover rowid values"</literal></expr>,
  <expr><literal type="string">"                            that are not also INTEGER PRIMARY KEYs"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE"</literal></expr>,
  <expr><literal type="string">".save ?OPTIONS? FILE     Write database to FILE (an alias for .backup ...)"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off"</literal></expr>,
  <expr><literal type="string">".schema ?PATTERN?        Show the CREATE statements matching PATTERN"</literal></expr>,
  <expr><literal type="string">"   Options:"</literal></expr>,
  <expr><literal type="string">"      --indent             Try to pretty-print the schema"</literal></expr>,
  <expr><literal type="string">"      --nosys              Omit objects whose names start with \"sqlite_\""</literal></expr>,
  <expr><literal type="string">".selftest ?OPTIONS?      Run tests defined in the SELFTEST table"</literal></expr>,
  <expr><literal type="string">"    Options:"</literal></expr>,
  <expr><literal type="string">"       --init               Create a new SELFTEST table"</literal></expr>,
  <expr><literal type="string">"       -v                   Verbose output"</literal></expr>,
  <expr><literal type="string">".separator COL ?ROW?     Change the column and row separators"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">".session ?NAME? CMD ...  Create or control sessions"</literal></expr>,
  <expr><literal type="string">"   Subcommands:"</literal></expr>,
  <expr><literal type="string">"     attach TABLE             Attach TABLE"</literal></expr>,
  <expr><literal type="string">"     changeset FILE           Write a changeset into FILE"</literal></expr>,
  <expr><literal type="string">"     close                    Close one session"</literal></expr>,
  <expr><literal type="string">"     enable ?BOOLEAN?         Set or query the enable bit"</literal></expr>,
  <expr><literal type="string">"     filter GLOB...           Reject tables matching GLOBs"</literal></expr>,
  <expr><literal type="string">"     indirect ?BOOLEAN?       Mark or query the indirect status"</literal></expr>,
  <expr><literal type="string">"     isempty                  Query whether the session is empty"</literal></expr>,
  <expr><literal type="string">"     list                     List currently open session names"</literal></expr>,
  <expr><literal type="string">"     open DB NAME             Open a new session on DB"</literal></expr>,
  <expr><literal type="string">"     patchset FILE            Write a patchset into FILE"</literal></expr>,
  <expr><literal type="string">"   If ?NAME? is omitted, the first defined session is used."</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".sha3sum ...             Compute a SHA3 hash of database content"</literal></expr>,
  <expr><literal type="string">"    Options:"</literal></expr>,
  <expr><literal type="string">"      --schema              Also hash the sqlite_schema table"</literal></expr>,
  <expr><literal type="string">"      --sha3-224            Use the sha3-224 algorithm"</literal></expr>,
  <expr><literal type="string">"      --sha3-256            Use the sha3-256 algorithm (default)"</literal></expr>,
  <expr><literal type="string">"      --sha3-384            Use the sha3-384 algorithm"</literal></expr>,
  <expr><literal type="string">"      --sha3-512            Use the sha3-512 algorithm"</literal></expr>,
  <expr><literal type="string">"    Any other argument is a LIKE pattern for tables to hash"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NOHAVE_SYSTEM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">".shell CMD ARGS...       Run CMD ARGS... in a system shell"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".show                    Show the current values for various settings"</literal></expr>,
  <expr><literal type="string">".stats ?ARG?             Show stats or turn stats on or off"</literal></expr>,
  <expr><literal type="string">"   off                      Turn off automatic stat display"</literal></expr>,
  <expr><literal type="string">"   on                       Turn on automatic stat display"</literal></expr>,
  <expr><literal type="string">"   stmt                     Show statement stats"</literal></expr>,
  <expr><literal type="string">"   vmstep                   Show the virtual machine step count only"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NOHAVE_SYSTEM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">".system CMD ARGS...      Run CMD ARGS... in a system shell"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".tables ?TABLE?          List names of tables matching LIKE pattern TABLE"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr><literal type="string">".testcase NAME           Begin redirecting output to 'testcase-out.txt'"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".testctrl CMD ...        Run various sqlite3_test_control() operations"</literal></expr>,
  <expr><literal type="string">"                           Run \".testctrl\" with no arguments for details"</literal></expr>,
  <expr><literal type="string">".timeout MS              Try opening locked tables for MS milliseconds"</literal></expr>,
  <expr><literal type="string">".timer on|off            Turn SQL timer on or off"</literal></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  <expr><literal type="string">".trace ?OPTIONS?         Output each SQL statement as it is run"</literal></expr>,
  <expr><literal type="string">"    FILE                    Send output to FILE"</literal></expr>,
  <expr><literal type="string">"    stdout                  Send output to stdout"</literal></expr>,
  <expr><literal type="string">"    stderr                  Send output to stderr"</literal></expr>,
  <expr><literal type="string">"    off                     Disable tracing"</literal></expr>,
  <expr><literal type="string">"    --expanded              Expand query parameters"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
  <expr><literal type="string">"    --normalized            Normal the SQL statements"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">"    --plain                 Show SQL as it is input"</literal></expr>,
  <expr><literal type="string">"    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)"</literal></expr>,
  <expr><literal type="string">"    --profile               Profile statements (SQLITE_TRACE_PROFILE)"</literal></expr>,
  <expr><literal type="string">"    --row                   Trace each row (SQLITE_TRACE_ROW)"</literal></expr>,
  <expr><literal type="string">"    --close                 Trace connection close (SQLITE_TRACE_CLOSE)"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr><literal type="string">".unmodule NAME ...       Unregister virtual table modules"</literal></expr>,
  <expr><literal type="string">"    --allexcept             Unregister everything except those named"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><literal type="string">".vfsinfo ?AUX?           Information about the top-level VFS"</literal></expr>,
  <expr><literal type="string">".vfslist                 List all available VFSes"</literal></expr>,
  <expr><literal type="string">".vfsname ?AUX?           Print the name of the VFS stack"</literal></expr>,
  <expr><literal type="string">".width NUM1 NUM2 ...     Set minimum column widths for columnar output"</literal></expr>,
  <expr><literal type="string">"     Negative values right-justify"</literal></expr>,
}</block></expr>;</expr_stmt>

<comment type="block">/*
** Output help text.
**
** zPattern describes the set of commands for which help text is provided.
** If zPattern is NULL, then show all commands, but only give a one-line
** description of each.
**
** Return the number of matches.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>showHelp</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPat</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal>
   <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><literal type="string">"-a"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><literal type="string">"-all"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
   <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><literal type="string">"--all"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
  )</condition><block>{<block_content>
    <comment type="block">/* Show all commands, but only one line per command */</comment>
    <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azHelp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>||</operator> <name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Look for commands that for which zPattern is an exact prefix */</comment>
    <expr_stmt><expr><name>zPat</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">".%s*"</literal></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azHelp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* when zPattern is a prefix of exactly one command, then include the
        ** details of that command, which should begin at offset j */</comment>
        <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azHelp</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>azHelp</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>n</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Look for commands that contain zPattern anywhere.  Show the complete
    ** text of all commands that match. */</comment>
    <expr_stmt><expr><name>zPat</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%%%s%%"</literal></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azHelp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azHelp</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>azHelp</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>azHelp</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>process_input</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Read the content of file zName into memory obtained from sqlite3_malloc64()
** and return a pointer to the buffer. The caller is responsible for freeing
** the memory.
**
** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes
** read.
**
** For convenience, a nul-terminator byte is always appended to the data read
** from the file before the buffer is returned. This byte is not included in
** the final value of (*pnByte), if applicable.
**
** NULL is returned if any error is encountered. The final value of *pnByte
** is undefined in this case.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>readFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>nIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nRead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nIn</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nRead</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pBuf</name><index>[<expr><name>nIn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pnByte</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pnByte</name> <operator>=</operator> <name>nIn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>pBuf</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Close a single OpenSession object and release all of its associated
** resources.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>session_close</name><parameter_list>(<parameter><decl><type><name>OpenSession</name> <modifier>*</modifier></type><name>pSession</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3session_delete</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSession</name><operator>-&gt;</operator><name>nFilter</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpenSession</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Close all OpenSession objects and release all associated resources.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>session_close_all</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>AuxDb</name></name> <modifier>*</modifier></type><name>pAuxDb</name> <init>= <expr><ternary><condition><expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>session_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>session_close_all</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Implementation of the xFilter function for an open session.  Omit
** any tables named by ".session filter" but let all other table through.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>session_filter</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>OpenSession</name> <modifier>*</modifier></type><name>pSession</name> <init>= <expr><operator>(</operator><name>OpenSession</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSession</name><operator>-&gt;</operator><name>nFilter</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Try to deduce the type of file for zName based on its content.  Return
** one of the SHELL_OPEN_* constants.
**
** If the file does not exist or is empty but its name looks like a ZIP
** archive and the dfltZip flag is true, then assume it is a ZIP archive.
** Otherwise, assume an ordinary database regardless of the filename if
** the type cannot be determined from content.
*/</comment>
<function><type><name>int</name></type> <name>deduceDatabaseType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dfltZip</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SHELL_OPEN_UNSPEC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>dfltZip</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"%.zip"</literal></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
       <return>return <expr><name>SHELL_OPEN_ZIPFILE</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
       <return>return <expr><name>SHELL_OPEN_NORMAL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"SQLite format 3"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SHELL_OPEN_NORMAL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">25</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"Start-Of-SQLite3-"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SHELL_OPEN_APPENDVFS</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">22</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0x50</literal> <operator>&amp;&amp;</operator> <name><name>zBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0x4b</literal> <operator>&amp;&amp;</operator> <name><name>zBuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="number">0x05</literal>
       <operator>&amp;&amp;</operator> <name><name>zBuf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>==</operator><literal type="number">0x06</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SHELL_OPEN_ZIPFILE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dfltZip</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"%.zip"</literal></expr></argument>,<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SHELL_OPEN_ZIPFILE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>  
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
<comment type="block">/*
** Reconstruct an in-memory database using the output from the "dbtotxt"
** program.  Read content from the file in p-&gt;aAuxDb[].zDbFilename.
** If p-&gt;aAuxDb[].zDbFilename is 0, then read from standard input.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>readHexDb</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pgsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbFilename</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>x</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zLine</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zDbFilename</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot open \"%s\" for reading\n"</literal></expr></argument>, <argument><expr><name>zDbFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nLine</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLine</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>in</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>in</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>nLine</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>readHexDb_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"| size %d pagesize %d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>readHexDb_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>readHexDb_error</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pgsz</name><argument_list type="generic">&lt;<argument><expr><literal type="number">512</literal> <operator>||</operator> <name>pgsz</name></expr></argument>&gt;</argument_list></name><literal type="number">65536</literal> <operator>||</operator> <operator>(</operator><name>pgsz</name><operator>&amp;</operator><operator>(</operator><name>pgsz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>readHexDb_error</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name><operator>+</operator><name>pgsz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><operator>(</operator><name>pgsz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Round n up to the next multiple of pgsz */</comment>
  <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><ternary><condition><expr><name>n</name></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pgsz</name><argument_list type="generic">&lt;<argument><expr><literal type="number">512</literal> <operator>||</operator> <name>pgsz</name></expr></argument>&gt;</argument_list></name><literal type="number">65536</literal> <operator>||</operator> <operator>(</operator><name>pgsz</name> <operator>&amp;</operator> <operator>(</operator><name>pgsz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid pagesize\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>readHexDb_error</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>nLine</name><operator>++</operator></expr>;</init> <condition><expr><call><name>fgets</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>nLine</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"| page %d offset %d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"| end "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>,<argument><expr><literal type="string">"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"</literal></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>x</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">17</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>iOffset</name><operator>+</operator><name>j</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>k</name><operator>+</operator><literal type="number">16</literal><operator>&lt;=</operator><name>n</name> <operator>&amp;&amp;</operator> <name>k</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name><operator>+</operator><name>ii</name></expr>]</index></name> <operator>=</operator> <name><name>x</name><index>[<expr><name>ii</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pnData</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>nLine</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>a</name></expr>;</return>

<label><name>readHexDb_error</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>in</name><operator>!=</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nLine</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><literal type="string">"| end "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>nLine</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error on line %d of --hexdb input\n"</literal></expr></argument>, <argument><expr><name>nLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DESERIALIZE */</comment>

<comment type="block">/*
** Scalar function "shell_int32". The first argument to this function
** must be a blob. The second a non-negative integer. This function
** reads and returns a 32-bit big-endian integer from byte
** offset (4*&lt;arg2&gt;) of the blob.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellInt32</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iInt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nBlob</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iInt</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iInt</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>iInt</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal><operator>&lt;=</operator><name>nBlob</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>&amp;</operator><name><name>pBlob</name><index>[<expr><name>iInt</name><operator>*</operator><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator>
                       <operator>+</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator>
                       <operator>+</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator>
                       <operator>+</operator> <operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Scalar function "shell_idquote(X)" returns string X quoted as an identifier,
** using "..." with internal double-quote characters doubled.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellIdQuote</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Scalar function "usleep(X)" invokes sqlite3_sleep(X) and returns X.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellUSleepFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argcUnused</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>sleep</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argcUnused</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><name>sleep</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>sleep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Scalar function "shell_escape_crnl" used by the .recover command.
** The argument passed to this function is the output of built-in
** function quote(). If the first character of the input is "'", 
** indicating that the value passed to quote() was a text value,
** then this function searches the input for "\n" and "\r" characters
** and adds a wrapper similar to the following:
**
**   replace(replace(&lt;input&gt;, '\n', char(10), '\r', char(13));
**
** Or, if the first character of the input is not "'", then a copy
** of the input is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellEscapeCrnl</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zText</name> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>nText</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf1</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf2</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nCR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>nNL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zNL</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zNL</name> <operator>=</operator> <call><name>unused_string</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><literal type="string">"\\012"</literal></expr></argument>, <argument><expr><name>zBuf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nNL</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zCR</name> <operator>=</operator> <call><name>unused_string</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>, <argument><expr><literal type="string">"\\015"</literal></expr></argument>, <argument><expr><name>zBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCR</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>||</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nMax</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nNL</name> <operator>&gt;</operator> <name>nCR</name><operator>)</operator></expr> ?</condition><then> <expr><name>nNL</name></expr> </then><else>: <expr><name>nCR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><name>nMax</name> <operator>*</operator> <name>nText</name> <operator>+</operator> <operator>(</operator><name>nMax</name><operator>+</operator><literal type="number">64</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>zNL</name> <operator>&amp;&amp;</operator> <name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace(replace("</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"replace("</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\n'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name> <operator>=</operator> <name><name>zText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iOut</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>zNL</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNL</name></expr></argument>, <argument><expr><name>nNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nNL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(10))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCR</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">",'"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><name>zCR</name></expr></argument>, <argument><expr><name>nCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <name>nCR</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>iOut</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"', char(13))"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>iOut</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>iOut</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Flags for open_db().
**
** The default behavior of open_db() is to exit(1) if the database fails to
** open.  The OPEN_DB_KEEPALIVE flag changes that so that it prints an error
** but still returns without calling exit.
**
** The OPEN_DB_ZIPFILE flag causes open_db() to prefer to open files as a
** ZIP archive if the file does not exist or is empty and its name matches
** the *.zip pattern.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPEN_DB_KEEPALIVE</name></cpp:macro>   <cpp:value>0x001</cpp:value></cpp:define>   <comment type="block">/* Return after error if true */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPEN_DB_ZIPFILE</name></cpp:macro>     <cpp:value>0x002</cpp:value></cpp:define>   <comment type="block">/* Open as ZIP if name matches *.zip */</comment>

<comment type="block">/*
** Make sure the database is open.  If it is not, then open it.  If
** the database fails to open, print an error message and exit.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>open_db</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>openFlags</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbFilename</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_UNSPEC</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>zDbFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zDbFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_NORMAL</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>deduceDatabaseType</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, 
                             <argument><expr><operator>(</operator><name>openFlags</name> <operator>&amp;</operator> <name>OPEN_DB_ZIPFILE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SHELL_OPEN_APPENDVFS</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, 
           <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name></expr></argument>, <argument><expr><literal type="string">"apndvfs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SHELL_OPEN_HEXDB</name></expr>:</case>
      <case>case <expr><name>SHELL_OPEN_DESERIALIZE</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SHELL_OPEN_ZIPFILE</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SHELL_OPEN_READONLY</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
            <argument><expr><name>SQLITE_OPEN_READONLY</name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>SHELL_OPEN_UNSPEC</name></expr>:</case>
      <case>case <expr><name>SHELL_OPEN_NORMAL</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
           <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>globalDb</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: unable to open database \"%s\": %s\n"</literal></expr></argument>,
          <argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>openFlags</name> <operator>&amp;</operator> <name>OPEN_DB_KEEPALIVE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><literal type="string">":memory:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3_enable_load_extension</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_shathree_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_uint_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_decimal_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_regexp_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_ieee_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_series_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3_fileio_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_completion_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>
    <expr_stmt><expr><call><name>sqlite3_dbdata_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bSafeModePersist</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_zipfile_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_sqlar_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_add_schema"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellAddSchemaName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_module_schema"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellModuleSchema</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_putsnl"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
                            <argument><expr><name>shellPutsFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_escape_crnl"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellEscapeCrnl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_int32"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellInt32</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_idquote"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellIdQuote</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"usleep"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>SQLITE_UTF8</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>shellUSleepFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_NOHAVE_SYSTEM</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"edit"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>editFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"edit"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><name>editFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_ZIPFILE</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
         <argument><expr><literal type="string">"CREATE VIRTUAL TABLE zip USING zipfile(%Q);"</literal></expr></argument>, <argument><expr><name>zDbFilename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    <if type="elseif">else
    if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_DESERIALIZE</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_HEXDB</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aData</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_DESERIALIZE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>readFile</name><argument_list>(<argument><expr><name>zDbFilename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>aData</name> <operator>=</operator> <call><name>readHexDb</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>aData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_deserialize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>,
                   <argument><expr><name>SQLITE_DESERIALIZE_RESIZEABLE</name> <operator>|</operator>
                   <name>SQLITE_DESERIALIZE_FREEONCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: sqlite3_deserialize() returns %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szMax</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_LIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>szMax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeModePersist</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>safeModeAuth</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Attempt to close the databaes connection.  Report errors.
*/</comment>
<function><type><name>void</name></type> <name>close_db</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: sqlite3_close() returns %d: %s\n"</literal></expr></argument>,
        <argument><expr><name>rc</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt> 
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_READLINE</name> <operator>||</operator> <name>HAVE_EDITLINE</name></expr></cpp:if>
<comment type="block">/*
** Readline completion callbacks
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>readline_completion_generator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRet</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>state</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT DISTINCT candidate COLLATE nocase"</literal>
                           <literal type="string">"  FROM completion(%Q) ORDER BY 1"</literal></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <ternary><condition><expr><name>z</name></expr> ?</condition><then> <expr><call><name>strdup</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zRet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>zRet</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>readline_completion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEnd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name>rl_attempted_completion_over</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>rl_completion_matches</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr><name>readline_completion_generator</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_LINENOISE</name></expr></cpp:elif>
<comment type="block">/*
** Linenoise completion callback
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>linenoise_completion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLine</name></decl></parameter>, <parameter><decl><type><name>linenoiseCompletions</name> <modifier>*</modifier></type><name>lc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>nLine</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLine</name><operator>&gt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">30</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>||</operator> <name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nLine</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>isalnum</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'_'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nLine</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT DISTINCT candidate COLLATE nocase"</literal>
                         <literal type="string">"  FROM completion(%Q,%Q) ORDER BY 1"</literal></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>zLine</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA page_count"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Load the schema */</comment>
  <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCompletion</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCompletion</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>+</operator><name>nCompletion</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>zCompletion</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name><operator>+</operator><name>iStart</name></expr></argument>, <argument><expr><name>zCompletion</name></expr></argument>, <argument><expr><name>nCompletion</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>linenoiseAddCompletion</name><argument_list>(<argument><expr><name>lc</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Do C-language style dequoting.
**
**    \a    -&gt; alarm
**    \b    -&gt; backspace
**    \t    -&gt; tab
**    \n    -&gt; newline
**    \v    -&gt; vertical tab
**    \f    -&gt; form feed
**    \r    -&gt; carriage return
**    \s    -&gt; space
**    \"    -&gt; "
**    \'    -&gt; '
**    \\    -&gt; backslash
**    \NNN  -&gt; ascii character NNN in octal
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolve_backslashes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>z</name><operator>!=</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'a'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\a'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'v'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'7'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'7'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'7'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;</operator><name>i</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
** for TRUE and FALSE.  Return the integer value if appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>booleanValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'x'</literal></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><call><name>hexDigitValue</name><argument_list>(<argument><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>integerValue</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n"</literal></expr></argument>,
          <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set or clear a shell flag according to a boolean value.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setOrClearFlag</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>mFlag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>ShellClearFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close an output file, assuming it is not stderr or stdout
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_file_close</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>f</name> <operator>&amp;&amp;</operator> <name>f</name><operator>!=</operator><name>stdout</name> <operator>&amp;&amp;</operator> <name>f</name><operator>!=</operator><name>stderr</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Try to open an output file.   The names "stdout" and "stderr" are
** recognized and do the right thing.  NULL is returned if the output
** filename is "off".
*/</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>output_file_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bTextMode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>,<argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bTextMode</name></expr> ?</condition><then> <expr><literal type="string">"w"</literal></expr> </then><else>: <expr><literal type="string">"wb"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>f</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** A routine for handling output from sqlite3_trace().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_trace_callback</name><parameter_list>(
  <parameter><decl><type><name>unsigned</name></type> <name>mType</name></decl></parameter>,         <comment type="block">/* The trace type */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>,             <comment type="block">/* The ShellState pointer */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pP</name></decl></parameter>,               <comment type="block">/* Usually a pointer to sqlite_stmt */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pX</name></decl></parameter>                <comment type="block">/* Auxiliary output */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nSql</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mType</name><operator>==</operator><name>SQLITE_TRACE_CLOSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name></expr></argument>, <argument><expr><literal type="string">"-- closing database connection\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>mType</name><operator>!=</operator><name>SQLITE_TRACE_ROW</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pX</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>pX</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>pP</name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eTraceType</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SHELL_TRACE_EXPANDED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_expanded_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
      <case>case <expr><name>SHELL_TRACE_NORMALIZED</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_normalized_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nSql</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nSql</name><operator>&gt;</operator><literal type="number">1000000000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nSql</name> <operator>=</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><name>nSql</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>zSql</name><index>[<expr><name>nSql</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">';'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>nSql</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <switch>switch<condition>( <expr><name>mType</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_TRACE_ROW</name></expr>:</case>
    <case>case <expr><name>SQLITE_TRACE_STMT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name></expr></argument>, <argument><expr><literal type="string">"%.*s;\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TRACE_PROFILE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nNanosec</name> <init>= <expr><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>*</operator><operator>)</operator><name>pX</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name></expr></argument>, <argument><expr><literal type="string">"%.*s; -- %lld ns\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nNanosec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** A no-op routine that runs with the ".breakpoint" doc-command.  This is
** a useful spot to set a debugger breakpoint.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>test_breakpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nCall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>nCall</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** An object used to read a CSV and other files for import.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ImportCtx</name></name></type> <name>ImportCtx</name>;</typedef>
<struct>struct <name>ImportCtx</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>  <comment type="block">/* Name of the input file */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>           <comment type="block">/* Read the CSV text from this input stream */</comment>
  <function_decl><type><name>int</name></type> (<name>SQLITE_CDECL</name> <modifier>*</modifier><name>xCloser</name>)<parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>      <comment type="block">/* Func to close in */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>            <comment type="block">/* Accumulated text for a field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>              <comment type="block">/* Number of bytes in z */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>         <comment type="block">/* Space allocated for z[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name></decl>;</decl_stmt>          <comment type="block">/* Current line number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>           <comment type="block">/* Number of rows imported */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>           <comment type="block">/* Number of errors encountered */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bNotFirst</name></decl>;</decl_stmt>      <comment type="block">/* True if one or more bytes already read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cTerm</name></decl>;</decl_stmt>          <comment type="block">/* Character that terminated the most recent field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cColSep</name></decl>;</decl_stmt>        <comment type="block">/* The column separator character.  (Usually ",") */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cRowSep</name></decl>;</decl_stmt>        <comment type="block">/* The row separator character.  (Usually "\n") */</comment>
}</block>;</struct>

<comment type="block">/* Clean up resourced used by an ImportCtx */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>import_cleanup</name><parameter_list>(<parameter><decl><type><name>ImportCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>xCloser</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>xCloser</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a single byte to z[] */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>import_append_char</name><parameter_list>(<parameter><decl><type><name>ImportCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Read a single field of CSV text.  Compatible with rfc4180 and extended
** with the option of having a separator other than ",".
**
**   +  Input comes from p-&gt;in.
**   +  Store results in p-&gt;z of length p-&gt;n.  Space to hold p-&gt;z comes
**      from sqlite3_malloc64().
**   +  Use p-&gt;cSep as the column separator.  The default is ",".
**   +  Use p-&gt;rSep as the row separator.  The default is "\n".
**   +  Keep track of the line number in p-&gt;nLine.
**   +  Store the character that terminates the field in p-&gt;cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><name>SQLITE_CDECL</name></type> <name>csv_read_one_field</name><parameter_list>(<parameter><decl><type><name>ImportCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cSep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cColSep</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rSep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cRowSep</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>EOF</name> <operator>||</operator> <name>seenInterrupt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>, <decl><type ref="prev"/><name>ppc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>startLine</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cQuote</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>ppc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>rSep</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>cQuote</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><name>cQuote</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>pc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><name>cSep</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><name>cQuote</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><name>rSep</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><name>cQuote</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><name>rSep</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>ppc</name><operator>==</operator><name>cQuote</name><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><name>EOF</name> <operator>&amp;&amp;</operator> <name>pc</name><operator>==</operator><name>cQuote</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <do>do<block>{<block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name><operator>!=</operator><name>cQuote</name></expr> )</condition>;</do>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pc</name><operator>==</operator><name>cQuote</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'\r'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: unescaped %c character\n"</literal></expr></argument>,
                <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name></expr></argument>, <argument><expr><name>cQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>EOF</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: unterminated %c-quoted field\n"</literal></expr></argument>,
                <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>startLine</name></expr></argument>, <argument><expr><name>cQuote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ppc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* If this is the first field being parsed and it begins with the
    ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xef</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xbb</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><literal type="number">0xbf</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><call><name>csv_read_one_field</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name>c</name><operator>!=</operator><name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name>cSep</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name>rSep</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>rSep</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'\r'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bNotFirst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a single field of ASCII delimited text.
**
**   +  Input comes from p-&gt;in.
**   +  Store results in p-&gt;z of length p-&gt;n.  Space to hold p-&gt;z comes
**      from sqlite3_malloc64().
**   +  Use p-&gt;cSep as the column separator.  The default is "\x1F".
**   +  Use p-&gt;rSep as the row separator.  The default is "\x1E".
**   +  Keep track of the row number in p-&gt;nLine.
**   +  Store the character that terminates the field in p-&gt;cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><name>SQLITE_CDECL</name></type> <name>ascii_read_one_field</name><parameter_list>(<parameter><decl><type><name>ImportCtx</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cSep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cColSep</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rSep</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cRowSep</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>EOF</name> <operator>||</operator> <name>seenInterrupt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><name>c</name><operator>!=</operator><name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name>cSep</name> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><name>rSep</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>rSep</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nLine</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cTerm</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to transfer data for table zTable.  If an error is seen while
** moving forward, try to go backwards.  The backwards movement won't
** work for WITHOUT ROWID tables.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tryToCloneData</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>newDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTable</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pInsert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zInsert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTable</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>spinRate</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM \"%w\""</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error %d: %s on [%s]\n"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_extended_errcode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_data_xfer</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zInsert</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><literal type="number">200</literal> <operator>+</operator> <name>nTable</name> <operator>+</operator> <name>n</name><operator>*</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><literal type="number">200</literal><operator>+</operator><name>nTable</name></expr></argument>,<argument><expr><name>zInsert</name></expr></argument>,
                   <argument><expr><literal type="string">"INSERT OR IGNORE INTO \"%s\" VALUES(?"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zInsert</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">",?"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zInsert</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>, <argument><expr><name>zInsert</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInsert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error %d: %s on [%s]\n"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_extended_errcode</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_data_xfer</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <switch>switch<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_double</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>,
                             <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
          <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block>
        </block_content>}</block></switch>
      </block_content>}</block></for> <comment type="block">/* End for */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error %d: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_extended_errcode</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>cnt</name><operator>%</operator><name>spinRate</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c\b"</literal></expr></argument>, <argument><expr><literal type="string">"|/-\\"</literal><index>[<expr><operator>(</operator><name>cnt</name><operator>/</operator><name>spinRate</name><operator>)</operator><operator>%</operator><literal type="number">4</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while> <comment type="block">/* End while */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM \"%w\" ORDER BY rowid DESC;"</literal></expr></argument>,
                             <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Warning: cannot step \"%s\" backwards"</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for> <comment type="block">/* End for(k=0...) */</comment>

<label><name>end_data_xfer</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to transfer all rows of the schema that match zWhere.  For
** each row, invoke xForEach() on the object defined by that row.
** If an error is encountered while moving forward through the
** sqlite_schema table, try again moving backwards.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tryToCloneSchema</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>newDb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xForEach</name>)<parameter_list>(<parameter><decl><type><name>ShellState</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT name, sql FROM sqlite_schema"</literal>
                           <literal type="string">" WHERE %s"</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: (%d) %s on [%s]\n"</literal></expr></argument>,
                    <argument><expr><call><name>sqlite3_extended_errcode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>end_schema_xfer</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s... "</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\nSQL: [%s]\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErrMsg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>xForEach</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>xForEach</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newDb</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zQuery</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT name, sql FROM sqlite_schema"</literal>
                             <literal type="string">" WHERE %s ORDER BY rowid DESC"</literal></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: (%d) %s on [%s]\n"</literal></expr></argument>,
                      <argument><expr><call><name>sqlite3_extended_errcode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>end_schema_xfer</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s... "</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\nSQL: [%s]\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zErrMsg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>xForEach</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>xForEach</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newDb</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
<label><name>end_schema_xfer</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Open a new database file named "zNewDb".  Try to recover as much information
** as possible out of the main database (which might be corrupt) and write it
** into zNewDb.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tryToClone</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNewDb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>newDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>zNewDb</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"File \"%s\" already exists.\n"</literal></expr></argument>, <argument><expr><name>zNewDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><name>zNewDb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Cannot create output database: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema=ON;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>, <argument><expr><literal type="string">"BEGIN EXCLUSIVE;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tryToCloneSchema</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newDb</name></expr></argument>, <argument><expr><literal type="string">"type='table'"</literal></expr></argument>, <argument><expr><name>tryToCloneData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tryToCloneSchema</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newDb</name></expr></argument>, <argument><expr><literal type="string">"type!='table'"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>, <argument><expr><literal type="string">"COMMIT;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema=OFF;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>newDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the output file back to stdout.
**
** If the p-&gt;doXdgOpen flag is set, that means the output was being
** redirected to a temporary file named by p-&gt;zTempFile.  In that case,
** launch start/open/xdg-open on that temporary file.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_reset</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_POPEN</name></cpp:ifndef>
    <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>output_file_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_NOHAVE_SYSTEM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>doXdgOpen</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zXdgOpenCmd</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr><literal type="string">"start"</literal></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <expr_stmt><expr><literal type="string">"open"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><literal type="string">"xdg-open"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCmd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>zXdgOpenCmd</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>system</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed: [%s]\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Give the start/open/xdg-open command some time to get
        ** going before we continue, and potential delete the
        ** p-&gt;zTempFile data file out from under it */</comment>
        <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>outputModePop</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doXdgOpen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_NOHAVE_SYSTEM) */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Run an SQL command and return the single integer result.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>db_int</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_DBPAGE_VTAB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Convert a 2-byte or 4-byte big-endian integer into a native integer
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>get2byteInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>get4byteInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the ".dbinfo" command.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>shell_dbinfo_command</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{ <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>ofst</name></decl>;</decl_stmt> }</block> <decl><name><name>aField</name><index>[]</index></name> <init>= <expr><block>{
     <expr><block>{ <expr><literal type="string">"file change counter:"</literal></expr>,  <expr><literal type="number">24</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"database page count:"</literal></expr>,  <expr><literal type="number">28</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"freelist page count:"</literal></expr>,  <expr><literal type="number">36</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"schema cookie:"</literal></expr>,        <expr><literal type="number">40</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"schema format:"</literal></expr>,        <expr><literal type="number">44</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"default cache size:"</literal></expr>,   <expr><literal type="number">48</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"autovacuum top root:"</literal></expr>,  <expr><literal type="number">52</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"incremental vacuum:"</literal></expr>,   <expr><literal type="number">64</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"text encoding:"</literal></expr>,        <expr><literal type="number">56</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"user version:"</literal></expr>,         <expr><literal type="number">60</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"application id:"</literal></expr>,       <expr><literal type="number">68</literal></expr>  }</block></expr>,
     <expr><block>{ <expr><literal type="string">"software version:"</literal></expr>,     <expr><literal type="number">96</literal></expr>  }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{ <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt> <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt> }</block> <decl><name><name>aQuery</name><index>[]</index></name> <init>= <expr><block>{
     <expr><block>{ <expr><literal type="string">"number of tables:"</literal></expr>,
       <expr><literal type="string">"SELECT count(*) FROM %s WHERE type='table'"</literal></expr> }</block></expr>,
     <expr><block>{ <expr><literal type="string">"number of indexes:"</literal></expr>,
       <expr><literal type="string">"SELECT count(*) FROM %s WHERE type='index'"</literal></expr> }</block></expr>,
     <expr><block>{ <expr><literal type="string">"number of triggers:"</literal></expr>,
       <expr><literal type="string">"SELECT count(*) FROM %s WHERE type='trigger'"</literal></expr> }</block></expr>,
     <expr><block>{ <expr><literal type="string">"number of views:"</literal></expr>,
       <expr><literal type="string">"SELECT count(*) FROM %s WHERE type='view'"</literal></expr> }</block></expr>,
     <expr><block>{ <expr><literal type="string">"schema size:"</literal></expr>,
       <expr><literal type="string">"SELECT total(length(sql)) FROM %s"</literal></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>iDataVersion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSchemaTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aHdr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
             <argument><expr><literal type="string">"SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1"</literal></expr></argument>,
             <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name>
   <operator>&amp;&amp;</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">100</literal></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>, <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to read database header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>get2byteInt</name><argument_list>(<argument><expr><name>aHdr</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"database page size:"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"write format:"</literal></expr></argument>, <argument><expr><name><name>aHdr</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"read format:"</literal></expr></argument>, <argument><expr><name><name>aHdr</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %d\n"</literal></expr></argument>, <argument><expr><literal type="string">"reserved bytes:"</literal></expr></argument>, <argument><expr><name><name>aHdr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aField</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ofst</name> <init>= <expr><name><name>aField</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofst</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name> <init>= <expr><call><name>get4byteInt</name><argument_list>(<argument><expr><name>aHdr</name> <operator>+</operator> <name>ofst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %u"</literal></expr></argument>, <argument><expr><name><name>aField</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>ofst</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">56</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (utf8)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (utf16le)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (utf16be)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSchemaTab</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"main.sqlite_schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>,<argument><expr><literal type="string">"temp"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSchemaTab</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"sqlite_temp_schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zSchemaTab</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\".sqlite_schema"</literal></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aQuery</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name><name>aQuery</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zSql</name></expr></argument>, <argument><expr><name>zSchemaTab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>db_int</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %d\n"</literal></expr></argument>, <argument><expr><name><name>aQuery</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSchemaTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_DATA_VERSION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDataVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-20s %u\n"</literal></expr></argument>, <argument><expr><literal type="string">"data version"</literal></expr></argument>, <argument><expr><name>iDataVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SHELL_HAVE_RECOVER */</comment>

<comment type="block">/*
** Print the current sqlite3_errmsg() value to stderr and return 1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>shellDatabaseError</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the pattern in zGlob[] against the text in z[].  Return TRUE
** if they match and FALSE (0) if they do not match.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
**      '#'       Matches any sequence of one or more digits with an
**                optional + or - sign in front
**
**      ' '       Any span of whitespace matches any other span of
**                whitespace.
**
** Extra whitespace at the end of z[] is ignored.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testcase_glob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGlob</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>invert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seen</name></decl>;</decl_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><name>zGlob</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zGlob</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <call><name>testcase_glob</name><argument_list>(<argument><expr><name>zGlob</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><operator>(</operator><operator>*</operator><name>z</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>c2</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>c2</name><operator>!=</operator><name>c</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><call><name>testcase_glob</name><argument_list>(<argument><expr><name>zGlob</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'?'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>prior_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name>c2</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name><name>zGlob</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prior_c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><name>prior_c</name> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><name>c2</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>c2</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zGlob</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>seen</name> <operator>^</operator> <name>invert</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'#'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>IsDigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IsDigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>IsDigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><operator>(</operator><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Compare the string as a command-line option with either one or two
** initial "-" characters.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optionMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>zStr</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zStr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zStr</name></expr></argument>, <argument><expr><name>zOpt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete a file.
*/</comment>
<function><type><name>int</name></type> <name>shellDeleteFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
  <decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_wunlink</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to delete the temporary file (if there is one) and free the
** memory used to hold the name of the temp file.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearTempFile</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>doXdgOpen</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>shellDeleteFile</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a new temp file name with the given suffix.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>newTempFile</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSuffix</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>clearTempFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If p-&gt;db is an in-memory database then the TEMPFILENAME file-control
    ** will not work and we will need to fallback to guessing */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTemp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
      <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <literal type="string">"\\tmp"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <literal type="string">"/tmp"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/temp%llx.%s"</literal></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>zSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z.%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>, <argument><expr><name>zSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The implementation of SQL scalar function fkey_collate_clause(), used
** by the ".lint fkey-indexes" command. This scalar function is always
** called with four arguments - the parent table name, the parent column name,
** the child table name and the child column name.
**
**   fkey_collate_clause('parent-tab', 'parent-col', 'child-tab', 'child-col')
**
** If either of the named tables or columns do not exist, this function
** returns an empty string. An empty string is also returned if both tables
** and columns exist but have the same default collation sequence. Or,
** if both exist but the default collation sequences are different, this
** function returns the string " COLLATE &lt;parent-collation&gt;", where
** &lt;parent-collation&gt; is the default collation sequence of the parent column.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellFkeyCollateClause</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nVal</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVal</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParentCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParentSeq</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zChild</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zChildCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zChildSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Initialize to avoid false-positive warning */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVal</name><operator>==</operator><literal type="number">4</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zParent</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zParentCol</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zChild</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zChildCol</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apVal</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zParent</name></expr></argument>, <argument><expr><name>zParentCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zParentSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>zChild</name></expr></argument>, <argument><expr><name>zChildCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zChildSeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zParentSeq</name></expr></argument>, <argument><expr><name>zChildSeq</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><name>zParentSeq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** The implementation of dot-command ".lint fkey-indexes".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lintFkeyIndexes</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>,             <comment type="block">/* Current shell tool state */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,                   <comment type="block">/* Array of arguments passed to dot command */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>                        <comment type="block">/* Number of entries in azArg[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pState</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Database handle to query "main" db of */</comment>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Stream to write non-error output to */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bVerbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>               <comment type="block">/* If -verbose is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bGroupByParent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* If -groupbyparent is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* To iterate through azArg[] */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIndent</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* How much to indent CREATE INDEX by */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Compiled version of SQL statement below */</comment>

  <comment type="block">/*
  ** This SELECT statement returns one row for each foreign key constraint
  ** in the schema of the main database. The column values are:
  **
  ** 0. The text of an SQL statement similar to:
  **
  **      "EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?"
  **
  **    This SELECT is similar to the one that the foreign keys implementation
  **    needs to run internally on child tables. If there is an index that can
  **    be used to optimize this query, then it can also be used by the FK
  **    implementation to optimize DELETE or UPDATE statements on the parent
  **    table.
  **
  ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by
  **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema
  **    contains an index that can be used to optimize the query.
  **
  ** 2. Human readable text that describes the child table and columns. e.g.
  **
  **       "child_table(child_key1, child_key2)"
  **
  ** 3. Human readable text that describes the parent table and columns. e.g.
  **
  **       "parent_table(parent_key1, parent_key2)"
  **
  ** 4. A full CREATE INDEX statement for an index that could be used to
  **    optimize DELETE or UPDATE statements on the parent table. e.g.
  **
  **       "CREATE INDEX child_table_child_key ON child_table(child_key)"
  **
  ** 5. The name of the parent table.
  **
  ** These six values are used by the C logic below to generate the report.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>=
  <expr><literal type="string">"SELECT "</literal>
    <literal type="string">"     'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '"</literal>
    <literal type="string">"  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "</literal>
    <literal type="string">"  || fkey_collate_clause("</literal>
    <literal type="string">"       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"</literal>
    <literal type="string">", "</literal>
    <literal type="string">"     'SEARCH ' || s.name || ' USING COVERING INDEX*('"</literal>
    <literal type="string">"  || group_concat('*=?', ' AND ') || ')'"</literal>
    <literal type="string">", "</literal>
    <literal type="string">"     s.name  || '(' || group_concat(f.[from],  ', ') || ')'"</literal>
    <literal type="string">", "</literal>
    <literal type="string">"     f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')'"</literal>
    <literal type="string">", "</literal>
    <literal type="string">"     'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))"</literal>
    <literal type="string">"  || ' ON ' || quote(s.name) || '('"</literal>
    <literal type="string">"  || group_concat(quote(f.[from]) ||"</literal>
    <literal type="string">"        fkey_collate_clause("</literal>
    <literal type="string">"          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"</literal>
    <literal type="string">"  || ');'"</literal>
    <literal type="string">", "</literal>
    <literal type="string">"     f.[table] "</literal>
    <literal type="string">"FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f "</literal>
    <literal type="string">"LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) "</literal>
    <literal type="string">"GROUP BY s.name, f.id "</literal>
    <literal type="string">"ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"</literal></expr></init></decl>
  ;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGlobIPK</name> <init>= <expr><literal type="string">"SEARCH * USING INTEGER PRIMARY KEY (rowid=?)"</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><literal type="string">"-verbose"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bVerbose</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><literal type="string">"-groupbyparent"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bGroupByParent</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zIndent</name> <operator>=</operator> <literal type="string">"    "</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: %s %s ?-verbose? ?-groupbyparent?\n"</literal></expr></argument>,
          <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Register the fkey_collate_clause() SQL function */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fkey_collate_clause"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
      <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>shellFkeyCollateClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>


  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bGroupByParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pExplain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEQP</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGlob</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTarget</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCI</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zParent</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>zEQP</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zGlob</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zEQP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPlan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>zPlan</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator>  <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><name>zGlob</name></expr></argument>, <argument><expr><name>zPlan</name></expr></argument>)</argument_list></call>
                          <operator>||</operator> <literal type="number">0</literal><operator>==</operator><call><name>sqlite3_strglob</name><argument_list>(<argument><expr><name>zGlobIPK</name></expr></argument>, <argument><expr><name>zPlan</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: internal error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>bGroupByParent</name>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>bVerbose</name> <operator>||</operator> <name>res</name><operator>==</operator><literal type="number">0</literal><operator>)</operator>
        <operator>&amp;&amp;</operator> <operator>(</operator><name>zPrev</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zParent</name></expr></argument>, <argument><expr><name>zPrev</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"-- Parent table %s\n"</literal></expr></argument>, <argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zPrev</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s%s --&gt; %s\n"</literal></expr></argument>, <argument><expr><name>zIndent</name></expr></argument>, <argument><expr><name>zCI</name></expr></argument>, <argument><expr><name>zTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>bVerbose</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s/* no extra indexes required for %s -&gt; %s */\n"</literal></expr></argument>,
              <argument><expr><name>zIndent</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>zTarget</name></expr></argument>
          )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of ".lint" dot command.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lintDotCommand</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>,             <comment type="block">/* Current shell tool state */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,                   <comment type="block">/* Array of arguments passed to dot command */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>                        <comment type="block">/* Number of entries in azArg[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">1</literal> <operator>||</operator> <call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"fkey-indexes"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>usage</name>;</goto></block_content></block></if></if_stmt>
  <return>return <expr><call><name>lintFkeyIndexes</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>usage</name>:</label>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage %s sub-command ?switches...?\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Where sub-commands are:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    fkey-indexes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>SQLITE_OMIT_VIRTUALTABLE</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>shellPrepare</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"sql error: %s (%d)\n"</literal></expr></argument>, 
          <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a prepared statement using printf-style arguments for the SQL.
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/</comment>
<function><type><name>void</name></type> <name>shellPreparePrintf</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, 
  <parameter><decl><type><modifier>...</modifier></type></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>shellPrepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRc</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Finalize the prepared statement created using shellPreparePrintf().
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/</comment>
<function><type><name>void</name></type> <name>shellFinalize</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SQL error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reset the prepared statement created using shellPreparePrintf().
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/</comment>
<function><type><name>void</name></type> <name>shellReset</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_db_handle</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SQL error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/******************************************************************************
** The ".archive" or ".ar" command.
*/</comment>
<comment type="block">/*
** Structure representing a single ".ar" command.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ArCommand</name></name></type> <name>ArCommand</name>;</typedef>
<struct>struct <name>ArCommand</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>eCmd</name></decl>;</decl_stmt>                        <comment type="block">/* An AR_CMD_* value */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bVerbose</name></decl>;</decl_stmt>                    <comment type="block">/* True if --verbose */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bZip</name></decl>;</decl_stmt>                        <comment type="block">/* True if the archive is a ZIP */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bDryRun</name></decl>;</decl_stmt>                     <comment type="block">/* True if --dry-run */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bAppend</name></decl>;</decl_stmt>                     <comment type="block">/* True if --append */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bGlob</name></decl>;</decl_stmt>                       <comment type="block">/* True if --glob */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>fromCmdLine</name></decl>;</decl_stmt>                 <comment type="block">/* Run from -A instead of .archive */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>                       <comment type="block">/* Number of command arguments */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSrcTable</name></decl>;</decl_stmt>                <comment type="block">/* "sqlar", "zipfile($file)" or "zip" */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>;</decl_stmt>              <comment type="block">/* --file argument, or NULL */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name></decl>;</decl_stmt>               <comment type="block">/* --directory argument, or NULL */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl>;</decl_stmt>                   <comment type="block">/* Array of command arguments */</comment>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* Shell state */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                    <comment type="block">/* Database containing the archive */</comment>
}</block>;</struct>

<comment type="block">/*
** Print a usage message for the .ar command to stderr and return SQLITE_ERROR.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arUsage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr><literal type="string">"archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Print an error message for the .ar command to stderr and return 
** SQLITE_ERROR.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arErrorMsg</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>fromCmdLine</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Use \"-A\" for more help\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Use \".archive --help\" for more help\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Values for ArCommand.eCmd.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_CREATE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_UPDATE</name></cpp:macro>       <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_INSERT</name></cpp:macro>       <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_EXTRACT</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_LIST</name></cpp:macro>         <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_HELP</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_CMD_REMOVE</name></cpp:macro>       <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/*
** Other (non-command) switches.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_VERBOSE</name></cpp:macro>     <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_FILE</name></cpp:macro>        <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_DIRECTORY</name></cpp:macro>  <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_APPEND</name></cpp:macro>     <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_DRYRUN</name></cpp:macro>     <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AR_SWITCH_GLOB</name></cpp:macro>       <cpp:value>13</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>arProcessSwitch</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eSwitch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name>eSwitch</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>AR_CMD_CREATE</name></expr>:</case>
    <case>case <expr><name>AR_CMD_EXTRACT</name></expr>:</case>
    <case>case <expr><name>AR_CMD_LIST</name></expr>:</case>
    <case>case <expr><name>AR_CMD_REMOVE</name></expr>:</case>
    <case>case <expr><name>AR_CMD_UPDATE</name></expr>:</case>
    <case>case <expr><name>AR_CMD_INSERT</name></expr>:</case>
    <case>case <expr><name>AR_CMD_HELP</name></expr>:</case>
      <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>eCmd</name></name></expr> )</condition><block>{<block_content>
        <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"multiple command options"</literal></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>eCmd</name></name> <operator>=</operator> <name>eSwitch</name></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>AR_SWITCH_DRYRUN</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>bDryRun</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>AR_SWITCH_GLOB</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>bGlob</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>AR_SWITCH_VERBOSE</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>bVerbose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>AR_SWITCH_APPEND</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>bAppend</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <comment type="block">/* Fall thru into --file */</comment>
    <case>case <expr><name>AR_SWITCH_FILE</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>zFile</name></name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>AR_SWITCH_DIRECTORY</name></expr>:</case>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>zDir</name></name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse the command line for an ".ar" command. The results are written into
** structure (*pAr). SQLITE_OK is returned if the command line is parsed
** successfully, otherwise an error message is written to stderr and 
** SQLITE_ERROR returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arParseCommand</name><parameter_list>(
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,                   <comment type="block">/* Array of arguments passed to dot command */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,                       <comment type="block">/* Number of entries in azArg[] */</comment>
  <parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>                  <comment type="block">/* Populate this object */</comment>
)</parameter_list><block>{<block_content>
  <struct>struct <name>ArSwitch</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLong</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>cShort</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>eSwitch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>bArg</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aSwitch</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"create"</literal></expr>,    <expr><literal type="char">'c'</literal></expr>, <expr><name>AR_CMD_CREATE</name></expr>,       <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"extract"</literal></expr>,   <expr><literal type="char">'x'</literal></expr>, <expr><name>AR_CMD_EXTRACT</name></expr>,      <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"insert"</literal></expr>,    <expr><literal type="char">'i'</literal></expr>, <expr><name>AR_CMD_INSERT</name></expr>,       <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"list"</literal></expr>,      <expr><literal type="char">'t'</literal></expr>, <expr><name>AR_CMD_LIST</name></expr>,         <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"remove"</literal></expr>,    <expr><literal type="char">'r'</literal></expr>, <expr><name>AR_CMD_REMOVE</name></expr>,       <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"update"</literal></expr>,    <expr><literal type="char">'u'</literal></expr>, <expr><name>AR_CMD_UPDATE</name></expr>,       <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"help"</literal></expr>,      <expr><literal type="char">'h'</literal></expr>, <expr><name>AR_CMD_HELP</name></expr>,         <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"verbose"</literal></expr>,   <expr><literal type="char">'v'</literal></expr>, <expr><name>AR_SWITCH_VERBOSE</name></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"file"</literal></expr>,      <expr><literal type="char">'f'</literal></expr>, <expr><name>AR_SWITCH_FILE</name></expr>,      <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"append"</literal></expr>,    <expr><literal type="char">'a'</literal></expr>, <expr><name>AR_SWITCH_APPEND</name></expr>,    <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"directory"</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><name>AR_SWITCH_DIRECTORY</name></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"dryrun"</literal></expr>,    <expr><literal type="char">'n'</literal></expr>, <expr><name>AR_SWITCH_DRYRUN</name></expr>,    <expr><literal type="number">0</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"glob"</literal></expr>,      <expr><literal type="char">'g'</literal></expr>, <expr><name>AR_SWITCH_GLOB</name></expr>,      <expr><literal type="number">0</literal></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type><name>int</name></type> <name>nSwitch</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSwitch</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>ArSwitch</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ArSwitch</name></name> <modifier>*</modifier></type><name>pEnd</name> <init>= <expr><operator>&amp;</operator><name><name>aSwitch</name><index>[<expr><name>nSwitch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Wrong number of arguments.  Usage:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>arUsage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Traditional style [tar] invocation */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iArg</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>ArSwitch</name></name> <modifier>*</modifier></type><name>pOpt</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>pOpt</name><operator>=</operator><operator>&amp;</operator><name><name>aSwitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>pOpt</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pOpt</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>pOpt</name><operator>-&gt;</operator><name>cShort</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>pOpt</name><operator>==</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %c"</literal></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pOpt</name><operator>-&gt;</operator><name>bArg</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iArg</name><operator>&gt;=</operator><name>nArg</name></expr> )</condition><block>{<block_content>
            <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"option requires an argument: %c"</literal></expr></argument>,<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>zArg</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>iArg</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>arProcessSwitch</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name><name>pOpt</name><operator>-&gt;</operator><name>eSwitch</name></name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <name>nArg</name><operator>-</operator><name>iArg</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>azArg</name><index>[<expr><name>iArg</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* Non-traditional invocation */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iArg</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>iArg</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iArg</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>iArg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>iArg</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* All remaining command line words are command arguments. */</comment>
          <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>azArg</name><index>[<expr><name>iArg</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <name>nArg</name><operator>-</operator><name>iArg</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <comment type="block">/* One or more short options */</comment>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>ArSwitch</name></name> <modifier>*</modifier></type><name>pOpt</name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>pOpt</name><operator>=</operator><operator>&amp;</operator><name><name>aSwitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>pOpt</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pOpt</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name><name>pOpt</name><operator>-&gt;</operator><name>cShort</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if<condition>( <expr><name>pOpt</name><operator>==</operator><name>pEnd</name></expr> )</condition><block>{<block_content>
              <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %c"</literal></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pOpt</name><operator>-&gt;</operator><name>bArg</name></name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>zArg</name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <if_stmt><if>if<condition>( <expr><name>iArg</name><operator>&gt;=</operator><operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
                  <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"option requires an argument: %c"</literal></expr></argument>,
                                    <argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>zArg</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><operator>++</operator><name>iArg</name></expr>]</index></name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><call><name>arProcessSwitch</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name><name>pOpt</name><operator>-&gt;</operator><name>eSwitch</name></name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block>{<block_content>
          <comment type="block">/* A -- option, indicating that all remaining command line words
          ** are command arguments.  */</comment>
          <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>azArg</name><index>[<expr><name>iArg</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name> <operator>=</operator> <name>nArg</name><operator>-</operator><name>iArg</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* A long option */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Argument for option, if any */</comment>
          <decl_stmt><decl><type><name><name>struct</name> <name>ArSwitch</name></name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Matching option */</comment>
          <decl_stmt><decl><type><name><name>struct</name> <name>ArSwitch</name></name> <modifier>*</modifier></type><name>pOpt</name></decl>;</decl_stmt>            <comment type="block">/* Iterator */</comment>
          <for>for<control>(<init><expr><name>pOpt</name><operator>=</operator><operator>&amp;</operator><name><name>aSwitch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>pOpt</name><operator>&lt;</operator><name>pEnd</name></expr>;</condition> <incr><expr><name>pOpt</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLong</name> <init>= <expr><name><name>pOpt</name><operator>-&gt;</operator><name>zLong</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><name>n</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>&lt;=</operator><call><name>strlen30</name><argument_list>(<argument><expr><name>zLong</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zLong</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>pMatch</name></expr> )</condition><block>{<block_content>
                <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"ambiguous option: %s"</literal></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <name>pOpt</name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>

          <if_stmt><if>if<condition>( <expr><name>pMatch</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>pMatch</name><operator>-&gt;</operator><name>bArg</name></name></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>iArg</name><operator>&gt;=</operator><operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
              <return>return <expr><call><name>arErrorMsg</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"option requires an argument: %s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>zArg</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><operator>++</operator><name>iArg</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>arProcessSwitch</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>eSwitch</name></name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function assumes that all arguments within the ArCommand.azArg[]
** array refer to archive members, as for the --extract, --list or --remove
** commands. It checks that each of them are "present". If any specified
** file is not present in the archive, an error is printed to stderr and an
** error code returned. Otherwise, if all specified arguments are present
** in the archive, SQLITE_OK is returned. Here, "present" means either an
** exact equality when pAr-&gt;bGlob is false or a "name GLOB pattern" match
** when pAr-&gt;bGlob is true.
**
** This function strips any trailing '/' characters from each argument.
** This is consistent with the way the [tar] command seems to work on
** Linux.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arCheckEntries</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pAr</name><operator>-&gt;</operator><name>bGlob</name></name><operator>)</operator></expr>
      ?</condition><then> <expr><literal type="string">"SELECT name FROM %s WHERE glob($name,name)"</literal></expr>
      </then><else>: <expr><literal type="string">"SELECT name FROM %s WHERE name=$name"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>shellPreparePrintf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTest</name></expr></argument>, <argument><expr><name>zSel</name></expr></argument>, <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zSrcTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3_bind_parameter_index</name><argument_list>(<argument><expr><name>pTest</name></expr></argument>, <argument><expr><literal type="string">"$name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pTest</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pTest</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>shellReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>bOk</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"not found in archive: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>shellFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Format a WHERE clause that can be used against the "sqlar" table to
** identify all archive members that match the command arguments held
** in (*pAr). Leave this WHERE clause in (*pzWhere) before returning.
** The caller is responsible for eventually calling sqlite3_free() on
** any non-NULL (*pzWhere) value. Here, "match" means strict equality
** when pAr-&gt;bGlob is false and GLOB match when pAr-&gt;bGlob is true.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>arWhereClause</name><parameter_list>(
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pRc</name></decl></parameter>, 
  <parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzWhere</name></decl></parameter>                  <comment type="block">/* OUT: New WHERE clause */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSameOp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pAr</name><operator>-&gt;</operator><name>bGlob</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"GLOB"</literal></expr> </then><else>: <expr><literal type="string">"="</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pRc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"%z%s name %s '%q' OR substr(name,1,%d) %s '%q/'"</literal></expr></argument>, 
          <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zSameOp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zSameOp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zWhere</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pRc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">" OR "</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzWhere</name> <operator>=</operator> <name>zWhere</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of .ar "lisT" command. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arListCommand</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="string">"SELECT %s FROM %s WHERE %s"</literal></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azCols</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"name"</literal></expr>,
    <expr><literal type="string">"lsmode(mode), sz, datetime(mtime, 'unixepoch'), name"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCheckEntries</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arWhereClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pAr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>shellPreparePrintf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name><name>azCols</name><index>[<expr><name><name>pAr</name><operator>-&gt;</operator><name>bVerbose</name></name></expr>]</index></name></expr></argument>,
                     <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zSrcTable</name></name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bDryRun</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bVerbose</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s % 10d  %s  %s\n"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, 
            <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>shellFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of .ar "Remove" command.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arRemoveCommand</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Verify that args actually exist within the archive before proceeding.
    ** And formulate a WHERE clause to match them.  */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCheckEntries</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>arWhereClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pAr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"DELETE FROM %s WHERE %s;"</literal></expr></argument>,
                           <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zSrcTable</name></name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bDryRun</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT ar;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO ar; RELEASE ar;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"RELEASE ar;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"ERROR: %s\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of .ar "eXtract" command. 
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arExtractCommand</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql1</name> <init>= 
    <expr><literal type="string">"SELECT "</literal>
    <literal type="string">" ($dir || name),"</literal>
    <literal type="string">" writefile(($dir || name), %s, mode, mtime) "</literal>
    <literal type="string">"FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0)"</literal>
    <literal type="string">" AND name NOT GLOB '*..[/\\]*'"</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azExtraArg</name><index>[]</index></name> <init>= <expr><block>{ 
    <expr><literal type="string">"sqlar_uncompress(data, sz)"</literal></expr>,
    <expr><literal type="string">"data"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

  <comment type="block">/* If arguments are specified, check that they actually exist within
  ** the archive before proceeding. And formulate a WHERE clause to
  ** match them.  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCheckEntries</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>arWhereClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pAr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>zDir</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zDir</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zDir</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>shellPreparePrintf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSql</name></expr></argument>, <argument><expr><name>zSql1</name></expr></argument>, 
      <argument><expr><name><name>azExtraArg</name><index>[<expr><name><name>pAr</name><operator>-&gt;</operator><name>bZip</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zSrcTable</name></name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3_bind_parameter_index</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"$dir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Run the SELECT statement twice. The first time, writefile() is called
    ** for all archive members that should be extracted. The second time,
    ** only for the directories. This is because the timestamps for
    ** extracted directories must be reset after they are populated (as
    ** populating them changes the timestamp).  */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3_bind_parameter_index</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="string">"$dirOnly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bDryRun</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pAr</name><operator>-&gt;</operator><name>bVerbose</name></name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>shellReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>shellFinalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rc</name></expr></argument>, <argument><expr><name>pSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Run the SQL statement in zSql.  Or if doing a --dryrun, merely print it out.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arExecSql</name><parameter_list>(<parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bDryRun</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"ERROR: %s\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of .ar "create", "insert", and "update" commands.
**
**     create    -&gt;     Create a new SQL archive
**     insert    -&gt;     Insert or reinsert all files listed
**     update    -&gt;     Insert files that have changed or that were not
**                      previously in the archive
**
** Create the "sqlar" table in the database if it does not already exist.
** Then add each file in the azFile[] array to the archive. Directories
** are added recursively. If argument bVerbose is non-zero, a message is
** printed on stdout for each file archived.
**
** The create command is the same as update, except that it drops
** any existing "sqlar" table before beginning.  The "insert" command
** always overwrites every file named on the command-line, where as
** "update" only overwrites if the size or mtime or mode has changed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arCreateOrUpdateCommand</name><parameter_list>(
  <parameter><decl><type><name>ArCommand</name> <modifier>*</modifier></type><name>pAr</name></decl></parameter>,                 <comment type="block">/* Command arguments and options */</comment>
  <parameter><decl><type><name>int</name></type> <name>bUpdate</name></decl></parameter>,                    <comment type="block">/* true for a --create. */</comment>
  <parameter><decl><type><name>int</name></type> <name>bOnlyIfChanged</name></decl></parameter>              <comment type="block">/* Only update if file has changed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCreate</name> <init>= 
      <expr><literal type="string">"CREATE TABLE IF NOT EXISTS sqlar(\n"</literal>
      <literal type="string">"  name TEXT PRIMARY KEY,  -- name of the file\n"</literal>
      <literal type="string">"  mode INT,               -- access permissions\n"</literal>
      <literal type="string">"  mtime INT,              -- last modification time\n"</literal>
      <literal type="string">"  sz INT,                 -- original file size\n"</literal>
      <literal type="string">"  data BLOB               -- compressed content\n"</literal>
      <literal type="string">")"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDrop</name> <init>= <expr><literal type="string">"DROP TABLE IF EXISTS sqlar"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>zInsertFmt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
     <expr><literal type="string">"REPLACE INTO %s(name,mode,mtime,sz,data)\n"</literal>
     <literal type="string">"  SELECT\n"</literal>
     <literal type="string">"    %s,\n"</literal>
     <literal type="string">"    mode,\n"</literal>
     <literal type="string">"    mtime,\n"</literal>
     <literal type="string">"    CASE substr(lsmode(mode),1,1)\n"</literal>
     <literal type="string">"      WHEN '-' THEN length(data)\n"</literal>
     <literal type="string">"      WHEN 'd' THEN 0\n"</literal>
     <literal type="string">"      ELSE -1 END,\n"</literal>
     <literal type="string">"    sqlar_compress(data)\n"</literal>
     <literal type="string">"  FROM fsdir(%Q,%Q) AS disk\n"</literal>
     <literal type="string">"  WHERE lsmode(mode) NOT LIKE '?%%'%s;"</literal></expr>
     ,
     <expr><literal type="string">"REPLACE INTO %s(name,mode,mtime,data)\n"</literal>
     <literal type="string">"  SELECT\n"</literal>
     <literal type="string">"    %s,\n"</literal>
     <literal type="string">"    mode,\n"</literal>
     <literal type="string">"    mtime,\n"</literal>
     <literal type="string">"    data\n"</literal>
     <literal type="string">"  FROM fsdir(%Q,%Q) AS disk\n"</literal>
     <literal type="string">"  WHERE lsmode(mode) NOT LIKE '?%%'%s;"</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                          <comment type="block">/* For iterating through azFile[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                         <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* SQL table into which to insert */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTemp</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExists</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA page_size=512"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT ar;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
  <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bZip</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Initialize the zipfile virtual table, if necessary */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>r</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zTemp</name></expr></argument>,<argument><expr><literal type="string">"zip%016llx"</literal></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zTab</name> <operator>=</operator> <name>zTemp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
         <argument><expr><literal type="string">"CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)"</literal></expr></argument>,
         <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zFile</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zTab</name> <operator>=</operator> <literal type="string">"zip"</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Initialize the table for an SQLAR */</comment>
    <expr_stmt><expr><name>zTab</name> <operator>=</operator> <literal type="string">"sqlar"</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bUpdate</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name>zDrop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>end_ar_transaction</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>bOnlyIfChanged</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zExists</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">" AND NOT EXISTS("</literal>
          <literal type="string">"SELECT 1 FROM %s AS mem"</literal>
          <literal type="string">" WHERE mem.name=disk.name"</literal>
          <literal type="string">" AND mem.mtime=disk.mtime"</literal>
          <literal type="string">" AND mem.mode=disk.mode)"</literal></expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zExists</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zExists</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAr</name><operator>-&gt;</operator><name>nArg</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql2</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><name><name>zInsertFmt</name><index>[<expr><name><name>pAr</name><operator>-&gt;</operator><name>bZip</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>pAr</name><operator>-&gt;</operator><name>bVerbose</name></name></expr> ?</condition><then> <expr><literal type="string">"shell_putsnl(name)"</literal></expr> </then><else>: <expr><literal type="string">"name"</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>zDir</name></name></expr></argument>, <argument><expr><name>zExists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name>zSql2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<label><name>end_ar_transaction</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>pAr</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO ar; RELEASE ar;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><literal type="string">"RELEASE ar;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pAr</name><operator>-&gt;</operator><name>bZip</name></name> <operator>&amp;&amp;</operator> <name><name>pAr</name><operator>-&gt;</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"DROP TABLE %s"</literal></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>arExecSql</name><argument_list>(<argument><expr><name>pAr</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of ".ar" dot command.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arDotCommand</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>,          <comment type="block">/* Current shell tool state */</comment>
  <parameter><decl><type><name>int</name></type> <name>fromCmdLine</name></decl></parameter>,             <comment type="block">/* True if -A command-line option, not .ar cmd */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>,                <comment type="block">/* Array of arguments passed to dot command */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>                     <comment type="block">/* Number of entries in azArg[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ArCommand</name></type> <name>cmd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>fromCmdLine</name></name> <operator>=</operator> <name>fromCmdLine</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arParseCommand</name><argument_list>(<argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>eDbType</name> <init>= <expr><name>SHELL_OPEN_UNSPEC</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>pState</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name><name>pState</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eDbType</name> <operator>=</operator> <call><name>deduceDatabaseType</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>eDbType</name> <operator>=</operator> <name><name>pState</name><operator>-&gt;</operator><name>openMode</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eDbType</name><operator>==</operator><name>SHELL_OPEN_ZIPFILE</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_EXTRACT</name> <operator>||</operator> <name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_LIST</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>zSrcTable</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>zSrcTable</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"zipfile(%Q)"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>bZip</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>bAppend</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eDbType</name> <operator>=</operator> <name>SHELL_OPEN_APPENDVFS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_CREATE</name> <operator>||</operator> <name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_INSERT</name> 
           <operator>||</operator> <name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_REMOVE</name> <operator>||</operator> <name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_UPDATE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>bDryRun</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-- open database '%s'%s\n"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr></argument>,
             <argument><expr><ternary><condition><expr><name>eDbType</name><operator>==</operator><name>SHELL_OPEN_APPENDVFS</name></expr> ?</condition><then> <expr><literal type="string">" using 'apndvfs'"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, 
             <argument><expr><ternary><condition><expr><name>eDbType</name><operator>==</operator><name>SHELL_OPEN_APPENDVFS</name></expr> ?</condition><then> <expr><literal type="string">"apndvfs"</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot open file: %s (%s)\n"</literal></expr></argument>, 
            <argument><expr><name><name>cmd</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>end_ar_command</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_fileio_init</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_sqlar_init</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"shell_putsnl"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>p</name></name></expr></argument>,
                              <argument><expr><name>shellPutsFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>zSrcTable</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>.</operator><name>bZip</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>!=</operator><name>AR_CMD_HELP</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>!=</operator><name>AR_CMD_CREATE</name>
       <operator>&amp;&amp;</operator> <call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"sqlar"</literal></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"database does not contain an 'sqlar' table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        <goto>goto <name>end_ar_command</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>zSrcTable</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"sqlar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch<condition>( <expr><name><name>cmd</name><operator>.</operator><name>eCmd</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>AR_CMD_CREATE</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCreateOrUpdateCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>AR_CMD_EXTRACT</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arExtractCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>AR_CMD_LIST</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arListCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>AR_CMD_HELP</name></expr>:</case>
        <expr_stmt><expr><call><name>arUsage</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>AR_CMD_INSERT</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCreateOrUpdateCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>AR_CMD_REMOVE</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arRemoveCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cmd</name><operator>.</operator><name>eCmd</name></name><operator>==</operator><name>AR_CMD_UPDATE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arCreateOrUpdateCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
<label><name>end_ar_command</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>cmd</name><operator>.</operator><name>db</name></name><operator>!=</operator><name><name>pState</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>zSrcTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* End of the ".archive" or ".ar" command logic
*******************************************************************************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIRTUALTABLE) &amp;&amp; defined(SQLITE_HAVE_ZLIB) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>

<comment type="block">/*
** This function is used as a callback by the recover extension. Simply
** print the supplied SQL statement to stdout.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverSqlCb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name> <init>= <expr><operator>(</operator><name>ShellState</name><operator>*</operator><operator>)</operator><name>pCtx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to recover data from the database. A script
** to construct a new database containing all recovered data is output
** on stream pState-&gt;out.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recoverDatabaseCmd</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>pState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRecoveryDb</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Name of "recovery" database.  Debug only */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLAF</name> <init>= <expr><literal type="string">"lost_and_found"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bFreelist</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* 0 if --ignore-freelist is specified */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRowids</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* 0 if --no-rowids */</comment>
  <decl_stmt><decl><type><name>sqlite3_recover</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">17</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"-ignore-freelist"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bFreelist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">12</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"-recovery-db"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <comment type="block">/* This option determines the name of the ATTACH-ed database used
      ** internally by the recovery extension.  The default is "" which
      ** means to use a temporary database that is automatically deleted
      ** when closed.  This option is undocumented and might disappear at
      ** any moment. */</comment>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRecoveryDb</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">15</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"-lost-and-found"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><operator>(</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zLAF</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else
    if<condition>( <expr><name>n</name><operator>&lt;=</operator><literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"-no-rowids"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bRowids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unexpected option: %s\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_recover_init_sql</name><argument_list>(
      <argument><expr><name><name>pState</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>recoverSqlCb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pState</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_recover_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">789</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zRecoveryDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Debug use only */</comment>
  <expr_stmt><expr><call><name>sqlite3_recover_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_RECOVER_LOST_AND_FOUND</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>zLAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_recover_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_RECOVER_ROWIDS</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>bRowids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_recover_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_RECOVER_FREELIST_CORRUPT</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>bFreelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_recover_run</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_recover_errcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><call><name>sqlite3_recover_errmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errCode</name> <init>= <expr><call><name>sqlite3_recover_errcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"sql error: %s (%d)\n"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_recover_finish</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SHELL_HAVE_RECOVER */</comment>


<comment type="block">/*
 * zAutoColumn(zCol, &amp;db, ?) =&gt; Maybe init db, add column zCol to it.
 * zAutoColumn(0, &amp;db, ?) =&gt; (db!=0) Form columns spec for CREATE TABLE,
 *   close db and set it to 0, and return the columns spec, to later
 *   be sqlite3_free()'ed by the caller.
 * The return is 0 when either:
 *   (a) The db was not initialized and zCol==0 (There are no columns.)
 *   (b) zCol!=0  (Column was added, db initialized as needed.)
 * The 3rd argument, pRenamed, references an out parameter. If the
 * pointer is non-zero, its referent will be set to a summary of renames
 * done if renaming was necessary, or set to 0 if none was done. The out
 * string (if any) must be sqlite3_free()'ed by the caller.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rc_err_oom_die</name><parameter_list>(<parameter><type><name>rc</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if( rc==SQLITE_NOMEM ) shell_check_oom(0); \
  else if(!(rc==SQLITE_OK||rc==SQLITE_DONE)) \
    fprintf(stderr,"E:%d\n",rc), assert(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rc_err_oom_die</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name><operator>||</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_COLFIX_DB</name></cpp:ifdef> <comment type="block">/* If this is set, the DB can be in a file. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zCOL_DB</name><index>[]</index></name> <init>= <expr><call><name>SHELL_STRINGIFY</name><argument_list>(<argument><expr><name>SHELL_COLFIX_DB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* Otherwise, memory is faster/better for the transient DB. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCOL_DB</name> <init>= <expr><literal type="string">":memory:"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Define character (as C string) to separate generated column ordinal
 * from protected part of incoming column names. This defaults to "_"
 * so that incoming column identifiers that did not need not be quoted
 * remain usable without being quoted. It must be one character.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SHELL_AUTOCOLUMN_SEP</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOCOLUMN_SEP</name></cpp:macro> <cpp:value>"_"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AUTOCOLUMN_SEP</name></cpp:macro> <cpp:value>SHELL_STRINGIFY(SHELL_AUTOCOLUMN_SEP)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>zAutoColumn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zColNew</name></decl></parameter>, <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier><modifier>*</modifier></type><name>pDb</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzRenamed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Queries and D{D,M}L used here */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zTabMake</name> <init>= <expr><literal type="string">"\
CREATE TABLE ColNames(\
 cpos INTEGER PRIMARY KEY,\
 name TEXT, nlen INT, chop INT, reps INT, suff TEXT);\
CREATE VIEW RepeatedNames AS \
SELECT DISTINCT t.name FROM ColNames t \
WHERE t.name COLLATE NOCASE IN (\
 SELECT o.name FROM ColNames o WHERE o.cpos&lt;&gt;t.cpos\
);\
"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zTabFill</name> <init>= <expr><literal type="string">"\
INSERT INTO ColNames(name,nlen,chop,reps,suff)\
 VALUES(iif(length(?1)&gt;0,?1,'?'),max(length(?1),1),0,0,'')\
"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zHasDupes</name> <init>= <expr><literal type="string">"\
SELECT count(DISTINCT (substring(name,1,nlen-chop)||suff) COLLATE NOCASE)\
 &lt;count(name) FROM ColNames\
"</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_COLUMN_RENAME_CLEAN</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zDedoctor</name> <init>= <expr><literal type="string">"\
UPDATE ColNames SET chop=iif(\
  (substring(name,nlen,1) BETWEEN '0' AND '9')\
  AND (rtrim(name,'0123456790') glob '*"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"'),\
 nlen-length(rtrim(name, '"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"0123456789')),\
 0\
)\
"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zSetReps</name> <init>= <expr><literal type="string">"\
UPDATE ColNames AS t SET reps=\
(SELECT count(*) FROM ColNames d \
 WHERE substring(t.name,1,t.nlen-t.chop)=substring(d.name,1,d.nlen-d.chop)\
 COLLATE NOCASE\
)\
"</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MATH_FUNCTIONS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zColDigits</name> <init>= <expr><literal type="string">"\
SELECT CAST(ceil(log(count(*)+0.5)) AS INT) FROM ColNames \
"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Counting on SQLITE_MAX_COLUMN &lt; 100,000 here. (32767 is the hard limit.) */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zColDigits</name> <init>= <expr><literal type="string">"\
SELECT CASE WHEN (nc &lt; 10) THEN 1 WHEN (nc &lt; 100) THEN 2 \
 WHEN (nc &lt; 1000) THEN 3 WHEN (nc &lt; 10000) THEN 4 \
 ELSE 5 FROM (SELECT count(*) AS nc FROM ColNames) \
"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zRenameRank</name> <init>=
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_COLUMN_RENAME_CLEAN</name></cpp:ifdef>
    <expr><literal type="string">"UPDATE ColNames AS t SET suff="</literal>
    <literal type="string">"iif(reps&gt;1, printf('%c%0*d', '"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"', $1, cpos), '')"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* ...RENAME_MINIMAL_ONE_PASS */</comment>
<literal type="string">"WITH Lzn(nlz) AS ("</literal> <comment type="block">/* Find minimum extraneous leading 0's for uniqueness */</comment>
<literal type="string">"  SELECT 0 AS nlz"</literal>
<literal type="string">"  UNION"</literal>
<literal type="string">"  SELECT nlz+1 AS nlz FROM Lzn"</literal>
<literal type="string">"  WHERE EXISTS("</literal>
<literal type="string">"   SELECT 1"</literal>
<literal type="string">"   FROM ColNames t, ColNames o"</literal>
<literal type="string">"   WHERE"</literal>
<literal type="string">"    iif(t.name IN (SELECT * FROM RepeatedNames),"</literal>
<literal type="string">"     printf('%s"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"%s',"</literal>
<literal type="string">"      t.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,t.cpos),2)),"</literal>
<literal type="string">"     t.name"</literal>
<literal type="string">"    )"</literal>
<literal type="string">"    ="</literal>
<literal type="string">"    iif(o.name IN (SELECT * FROM RepeatedNames),"</literal>
<literal type="string">"     printf('%s"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"%s',"</literal>
<literal type="string">"      o.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,o.cpos),2)),"</literal>
<literal type="string">"     o.name"</literal>
<literal type="string">"    )"</literal>
<literal type="string">"    COLLATE NOCASE"</literal>
<literal type="string">"    AND o.cpos&lt;&gt;t.cpos"</literal>
<literal type="string">"   GROUP BY t.cpos"</literal>
<literal type="string">"  )"</literal>
<literal type="string">") UPDATE Colnames AS t SET"</literal>
<literal type="string">" chop = 0,"</literal> <comment type="block">/* No chopping, never touch incoming names. */</comment>
<literal type="string">" suff = iif(name IN (SELECT * FROM RepeatedNames),"</literal>
<literal type="string">"  printf('"</literal><name>AUTOCOLUMN_SEP</name><literal type="string">"%s', substring("</literal>
<literal type="string">"   printf('%.*c%0.*d',(SELECT max(nlz) FROM Lzn)+1,'0',1,t.cpos),2)),"</literal>
<literal type="string">"  ''"</literal>
<literal type="string">" )"</literal></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    ;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zCollectVar</name> <init>= <expr><literal type="string">"\
SELECT\
 '('||x'0a'\
 || group_concat(\
  cname||' TEXT',\
  ','||iif((cpos-1)%4&gt;0, ' ', x'0a'||' '))\
 ||')' AS ColsSpec \
FROM (\
 SELECT cpos, printf('\"%w\"',printf('%!.*s%s', nlen-chop,name,suff)) AS cname \
 FROM ColNames ORDER BY cpos\
)"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>zRenamesDone</name> <init>=
    <expr><literal type="string">"SELECT group_concat("</literal>
    <literal type="string">" printf('\"%w\" to \"%w\"',name,printf('%!.*s%s', nlen-chop, name, suff)),"</literal>
    <literal type="string">" ','||x'0a')"</literal>
    <literal type="string">"FROM ColNames WHERE suff&lt;&gt;'' OR chop!=0"</literal></expr></init></decl>
    ;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pDb</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zColNew</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Add initial or additional column. Init db if necessary. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><call><name>sqlite3_open</name><argument_list>(<argument><expr><name>zCOL_DB</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_COLFIX_DB</name></cpp:ifdef>
      <if_stmt><if>if<condition>(<expr><operator>*</operator><name>zCOL_DB</name><operator>!=</operator><literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>,<argument><expr><literal type="string">"drop table if exists ColNames;"</literal>
                     <literal type="string">"drop view if exists RepeatedNames;"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zTabMake</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zTabFill</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zColNew</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>pDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Formulate the columns spec, close the DB, zero *pDb. */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColsSpec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hasDupes</name> <init>= <expr><call><name>db_int</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zHasDupes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDigits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>hasDupes</name><operator>)</operator></expr>?</condition><then> <expr><call><name>db_int</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zColDigits</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>hasDupes</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHELL_COLUMN_RENAME_CLEAN</name></cpp:ifdef>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zDedoctor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zSetReps</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zRenameRank</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nDigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>db_int</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zHasDupes</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Consider: remove this */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zCollectVar</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rc_err_oom_die</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zColsSpec</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zColsSpec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pzRenamed</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>hasDupes</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pzRenamed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>, <argument><expr><name>zRenamesDone</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>pzRenamed</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>pzRenamed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><operator>*</operator><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>zColsSpec</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** If an input line begins with "." then invoke this routine to
** process that line.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>do_meta_command</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name></decl></parameter>, <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>azArg</name><index>[<expr><literal type="number">52</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>expert</name><operator>.</operator><name>pExpert</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>expertFinish</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Parse the input line into tokens.
  */</comment>
  <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>nArg</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azArg</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal> <operator>||</operator> <name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>delim</name> <init>= <expr><name><name>zLine</name><index>[<expr><name>h</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>nArg</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>!=</operator><name>delim</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>delim</name><operator>==</operator><literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name><name>zLine</name><index>[<expr><name>h</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name><operator>==</operator><name>delim</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>h</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>delim</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>resolve_backslashes</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>nArg</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>h</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>h</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>h</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>resolve_backslashes</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>nArg</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Process the input line.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* no tokens, no error */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>clearTempFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"auth"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .auth ON|OFF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>shellAuth</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeModePersist</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>safeModeAuth</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call> \
  <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"archive"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .archive in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>arDotCommand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"backup"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"save"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDestFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pDest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_backup</name> <modifier>*</modifier></type><name>pBackup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bAsync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .%s in safe mode"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-append"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zVfs</name> <operator>=</operator> <literal type="string">"apndvfs"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-async"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bAsync</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown option: %s\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zDestFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zDestFile</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name>zDestFile</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDestFile</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .backup ?DB? ?OPTIONS? FILENAME\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zDestFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"missing FILENAME argument on .backup\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDb</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name>zDestFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pDest</name></expr></argument>, 
                  <argument><expr><name>SQLITE_OPEN_READWRITE</name><operator>|</operator><name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zDestFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bAsync</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;"</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBackup</name> <operator>=</operator> <call><name>sqlite3_backup_init</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBackup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>(  <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_backup_step</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>,<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content/>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_backup_finish</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"bail"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bail_on_error</name> <operator>=</operator> <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .bail on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>setBinaryMode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>setTextMode</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .binary on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  <comment type="block">/* The undocumented ".breakpoint" command causes a call to the no-op
  ** routine named test_breakpoint().
  */</comment>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"breakpoint"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>test_breakpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"cd"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .cd in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_win32_utf8_to_unicode</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>!</operator><call><name>SetCurrentDirectoryW</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>chdir</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Cannot change to directory \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .cd DIRECTORY\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"changes"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>setOrClearFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_CountChanges</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .changes on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <comment type="block">/* Cancel output redirection, if it is currently set (by .testcase)
  ** Then read the content of the testcase-out.txt file and compare against
  ** azArg[1].  If there are differences, report an error and exit.
  */</comment>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"check"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .check GLOB-PATTERN\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zRes</name> <operator>=</operator> <call><name>readFile</name><argument_list>(<argument><expr><literal type="string">"testcase-out.txt"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot read 'testcase-out.txt'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>testcase_glob</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>zRes</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                 <argument><expr><literal type="string">"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n"</literal></expr></argument>,
                 <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"testcase-%s ok\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nCheck</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"clone"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .clone in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>tryToClone</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .clone FILENAME\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"connection"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* List available connections */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zDbFilename</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name><operator>!=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFile</name> <operator>=</operator> <literal type="string">"(not open)"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFile</name> <operator>=</operator> <literal type="string">"(memory)"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFile</name> <operator>=</operator> <literal type="string">"(temporary-file)"</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"ACTIVE %d: %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"       %d: %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IsDigit</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>globalDb</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
           <operator>&amp;&amp;</operator> <call><name>IsDigit</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>i</name><operator>&gt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <comment type="block">/* No-op */</comment>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"cannot close the active database connection\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>session_close_all</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .connection [close] [CONNECTION-NUMBER]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"databases"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA database_list"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>zSchema</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>azName</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>azName</name></expr></argument>, <argument><expr><operator>(</operator><name>nName</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azName</name><index>[<expr><name>nName</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azName</name><index>[<expr><name>nName</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nName</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nName</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>eTxn</name> <init>= <expr><call><name>sqlite3_txn_state</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bRdonly</name> <init>= <expr><call><name>sqlite3_db_readonly</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s %s%s\n"</literal></expr></argument>,
         <argument><expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>,
         <argument><expr><ternary><condition><expr><name>z</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>z</name></expr> </then><else>: <expr><literal type="string">"\"\""</literal></expr></else></ternary></expr></argument>,
         <argument><expr><ternary><condition><expr><name>bRdonly</name></expr> ?</condition><then> <expr><literal type="string">"r/o"</literal></expr> </then><else>: <expr><literal type="string">"r/w"</literal></expr></else></ternary></expr></argument>,
         <argument><expr><ternary><condition><expr><name>eTxn</name><operator>==</operator><name>SQLITE_TXN_NONE</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>:
            <expr><ternary><condition><expr><name>eTxn</name><operator>==</operator><name>SQLITE_TXN_READ</name></expr> ?</condition><then> <expr><literal type="string">" read-txn"</literal></expr> </then><else>: <expr><literal type="string">" write-txn"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>azName</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"dbconfig"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <name>DbConfigChoices</name> <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    }</block> <decl><name><name>aDbConfig</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{ <expr><literal type="string">"defensive"</literal></expr>,          <expr><name>SQLITE_DBCONFIG_DEFENSIVE</name></expr>             }</block></expr>,
        <expr><block>{ <expr><literal type="string">"dqs_ddl"</literal></expr>,            <expr><name>SQLITE_DBCONFIG_DQS_DDL</name></expr>               }</block></expr>,
        <expr><block>{ <expr><literal type="string">"dqs_dml"</literal></expr>,            <expr><name>SQLITE_DBCONFIG_DQS_DML</name></expr>               }</block></expr>,
        <expr><block>{ <expr><literal type="string">"enable_fkey"</literal></expr>,        <expr><name>SQLITE_DBCONFIG_ENABLE_FKEY</name></expr>           }</block></expr>,
        <expr><block>{ <expr><literal type="string">"enable_qpsg"</literal></expr>,        <expr><name>SQLITE_DBCONFIG_ENABLE_QPSG</name></expr>           }</block></expr>,
        <expr><block>{ <expr><literal type="string">"enable_trigger"</literal></expr>,     <expr><name>SQLITE_DBCONFIG_ENABLE_TRIGGER</name></expr>        }</block></expr>,
        <expr><block>{ <expr><literal type="string">"enable_view"</literal></expr>,        <expr><name>SQLITE_DBCONFIG_ENABLE_VIEW</name></expr>           }</block></expr>,
        <expr><block>{ <expr><literal type="string">"fts3_tokenizer"</literal></expr>,     <expr><name>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"legacy_alter_table"</literal></expr>, <expr><name>SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</name></expr>    }</block></expr>,
        <expr><block>{ <expr><literal type="string">"legacy_file_format"</literal></expr>, <expr><name>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT</name></expr>    }</block></expr>,
        <expr><block>{ <expr><literal type="string">"load_extension"</literal></expr>,     <expr><name>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</name></expr> }</block></expr>,
        <expr><block>{ <expr><literal type="string">"no_ckpt_on_close"</literal></expr>,   <expr><name>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</name></expr>      }</block></expr>,
        <expr><block>{ <expr><literal type="string">"reset_database"</literal></expr>,     <expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr>        }</block></expr>,
        <expr><block>{ <expr><literal type="string">"trigger_eqp"</literal></expr>,        <expr><name>SQLITE_DBCONFIG_TRIGGER_EQP</name></expr>           }</block></expr>,
        <expr><block>{ <expr><literal type="string">"trusted_schema"</literal></expr>,     <expr><name>SQLITE_DBCONFIG_TRUSTED_SCHEMA</name></expr>        }</block></expr>,
        <expr><block>{ <expr><literal type="string">"writable_schema"</literal></expr>,    <expr><name>SQLITE_DBCONFIG_WRITABLE_SCHEMA</name></expr>       }</block></expr>,
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aDbConfig</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aDbConfig</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>aDbConfig</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>, <argument><expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>aDbConfig</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>op</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%19s %s\n"</literal></expr></argument>, <argument><expr><name><name>aDbConfig</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><ternary><condition><expr><name>v</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ii</name><operator>==</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aDbConfig</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: unknown dbconfig \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Enter \".dbconfig\" with no arguments for a list\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>   
  </block_content>}</block></if><if type="elseif">else

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_HAVE_RECOVER</name></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"dbinfo"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shell_dbinfo_command</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"recover"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>recoverDatabaseCmd</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SHELL_HAVE_RECOVER */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"dump"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLike</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>savedShowHeader</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>savedShellFlags</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ShellClearFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
       <argument><expr><name>SHFLG_PreserveRowid</name><operator>|</operator><name>SHFLG_Newlines</name><operator>|</operator><name>SHFLG_Echo</name>
       <operator>|</operator><name>SHFLG_DumpDataOnly</name><operator>|</operator><name>SHFLG_DumpNoSys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"preserve-rowids"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifdef>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"The --preserve-rowids option is not compatible"</literal>
                             <literal type="string">" with SQLITE_OMIT_VIRTUALTABLE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zLike</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_PreserveRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"newlines"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Newlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"data-only"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_DumpDataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"nosys"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_DumpNoSys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown option \"%s\" on \".dump\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zLike</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* azArg[i] contains a LIKE pattern. This ".dump" request should
        ** only dump data for tables for which either the table name matches
        ** the LIKE pattern, or the table appears to be a shadow table of
        ** a virtual table for which the name matches the LIKE pattern.
        */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zExpr</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
            <argument><expr><literal type="string">"name LIKE %Q ESCAPE '\\' OR EXISTS ("</literal>
            <literal type="string">"  SELECT 1 FROM sqlite_schema WHERE "</literal>
            <literal type="string">"    name LIKE %Q ESCAPE '\\' AND"</literal>
            <literal type="string">"    sql LIKE 'CREATE VIRTUAL TABLE%%' AND"</literal>
            <literal type="string">"    substr(o.name, 1, length(name)+1) == (name||'_')"</literal>
            <literal type="string">")"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>
        )</argument_list></call></expr></init></decl>;</decl_stmt>
      
        <if_stmt><if>if<condition>( <expr><name>zLike</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zLike</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z OR %z"</literal></expr></argument>, <argument><expr><name>zLike</name></expr></argument>, <argument><expr><name>zExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>zLike</name> <operator>=</operator> <name>zExpr</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_DumpDataOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* When playing back a "dump", the content might appear in an order
      ** which causes immediate foreign key constraints to be violated.
      ** So disable foreign-key constraint enforcement to prevent problems. */</comment>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA foreign_keys=OFF;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN TRANSACTION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>writableSchema</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Set writable_schema=ON since doing so forces SQLite to initialize
    ** as much of the schema as it can even if the sqlite_schema table is
    ** corrupt. */</comment>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT dump; PRAGMA writable_schema=ON"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zLike</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zLike</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"SELECT name, type, sql FROM sqlite_schema AS o "</literal>
      <literal type="string">"WHERE (%s) AND type=='table'"</literal>
      <literal type="string">"  AND sql NOT NULL"</literal>
      <literal type="string">" ORDER BY tbl_name='sqlite_sequence', rowid"</literal></expr></argument>,
      <argument><expr><name>zLike</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>run_schema_dump_query</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_DumpDataOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
        <argument><expr><literal type="string">"SELECT sql FROM sqlite_schema AS o "</literal>
        <literal type="string">"WHERE (%s) AND sql NOT NULL"</literal>
        <literal type="string">"  AND type IN ('index','trigger','view')"</literal></expr></argument>,
        <argument><expr><name>zLike</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>run_table_dump_query</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zLike</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>writableSchema</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema=OFF;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>writableSchema</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA writable_schema=OFF;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"RELEASE dump;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_DumpDataOnly</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>nErr</name></name></expr>?</condition><then><expr><literal type="string">"ROLLBACK; -- due to errors\n"</literal></expr></then><else>:<expr><literal type="string">"COMMIT;\n"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name> <operator>=</operator> <name>savedShowHeader</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>=</operator> <name>savedShellFlags</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"echo"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>setOrClearFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Echo</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .echo on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"eqp"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtest</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtrace</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA vdbe_trace=OFF;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtrace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_full</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_trigger</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_on</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtest</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"trace"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_full</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQPtrace</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT name FROM sqlite_schema LIMIT 1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA vdbe_trace=ON;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .eqp off|on|trace|trigger|full\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"exit"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* The ".explain" command is automatic now.  It is largely pointless.  It
  ** retained purely for backwards compatibility */</comment>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"explain"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">99</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator>  <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>!=</operator><name>MODE_Explain</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>normalMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Explain</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoExplain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Explain</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>normalMode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoExplain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>val</name><operator>==</operator><literal type="number">99</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Explain</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>normalMode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>autoExplain</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"expert"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, 
        <argument><expr><literal type="string">"Cannot run experimental commands such as \"%s\" in safe mode\n"</literal></expr></argument>,
        <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expertDotCommand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"filectrl"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCtrlName</name></decl>;</decl_stmt>   <comment type="block">/* Name of a test-control option */</comment>
       <decl_stmt><decl><type><name>int</name></type> <name>ctrlCode</name></decl>;</decl_stmt>            <comment type="block">/* Integer code for that option */</comment>
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUsage</name></decl>;</decl_stmt>      <comment type="block">/* Usage notes */</comment>
    }</block> <decl><name><name>aCtrl</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"chunk_size"</literal></expr>,     <expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr>,      <expr><literal type="string">"SIZE"</literal></expr>           }</block></expr>,
      <expr><block>{ <expr><literal type="string">"data_version"</literal></expr>,   <expr><name>SQLITE_FCNTL_DATA_VERSION</name></expr>,    <expr><literal type="string">""</literal></expr>               }</block></expr>,
      <expr><block>{ <expr><literal type="string">"has_moved"</literal></expr>,      <expr><name>SQLITE_FCNTL_HAS_MOVED</name></expr>,       <expr><literal type="string">""</literal></expr>               }</block></expr>,  
      <expr><block>{ <expr><literal type="string">"lock_timeout"</literal></expr>,   <expr><name>SQLITE_FCNTL_LOCK_TIMEOUT</name></expr>,    <expr><literal type="string">"MILLISEC"</literal></expr>       }</block></expr>,
      <expr><block>{ <expr><literal type="string">"persist_wal"</literal></expr>,    <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>,     <expr><literal type="string">"[BOOLEAN]"</literal></expr>      }</block></expr>,
   <comment type="block">/* { "pragma",         SQLITE_FCNTL_PRAGMA,          "NAME ARG"       },*/</comment>
      <expr><block>{ <expr><literal type="string">"psow"</literal></expr>,       <expr><name>SQLITE_FCNTL_POWERSAFE_OVERWRITE</name></expr>, <expr><literal type="string">"[BOOLEAN]"</literal></expr>      }</block></expr>,
      <expr><block>{ <expr><literal type="string">"reserve_bytes"</literal></expr>,  <expr><name>SQLITE_FCNTL_RESERVE_BYTES</name></expr>,   <expr><literal type="string">"[N]"</literal></expr>            }</block></expr>,
      <expr><block>{ <expr><literal type="string">"size_limit"</literal></expr>,     <expr><name>SQLITE_FCNTL_SIZE_LIMIT</name></expr>,      <expr><literal type="string">"[LIMIT]"</literal></expr>        }</block></expr>,
      <expr><block>{ <expr><literal type="string">"tempfilename"</literal></expr>,   <expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr>,    <expr><literal type="string">""</literal></expr>               }</block></expr>,
   <comment type="block">/* { "win32_av_retry", SQLITE_FCNTL_WIN32_AV_RETRY,  "COUNT DELAY"    },*/</comment>
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>filectrl</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCtrl</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iRes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Integer result to display if rc2==1 */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* 0: usage  1: %lld  2: no-result */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n2</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCmd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"help"</literal></expr></else></ternary></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>zCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> 
     <operator>&amp;&amp;</operator> <operator>(</operator><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"--schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"-schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
     <operator>&amp;&amp;</operator> <name>nArg</name><operator>&gt;=</operator><literal type="number">4</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
      <expr_stmt><expr><name>nArg</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The argument can optionally begin with "-" or "--" */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>zCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zCmd</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zCmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* --help lists all file-controls */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Available file-controls:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aCtrl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"  .filectrl %s %s\n"</literal></expr></argument>,
                    <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCtrlName</name></expr></argument>, <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* convert filectrl text option to value. allow any unique prefix
    ** of the option name, or a numerical value. */</comment>
    <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aCtrl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>, <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCtrlName</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>filectrl</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>filectrl</name> <operator>=</operator> <name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ctrlCode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iCtrl</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: ambiguous file-control: \"%s\"\n"</literal>
                              <literal type="string">"Use \".filectrl --help\" for help\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>filectrl</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: unknown file-control: %s\n"</literal>
                         <literal type="string">"Use \".filectrl --help\" for help\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <switch>switch<condition>(<expr><name>filectrl</name></expr>)</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_FCNTL_SIZE_LIMIT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nArg</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iRes</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_SIZE_LIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>SQLITE_FCNTL_LOCK_TIMEOUT</name></expr>:</case>
        <case>case <expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>:</case>
        <case>case <expr><name>SQLITE_FCNTL_POWERSAFE_OVERWRITE</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nArg</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>SQLITE_FCNTL_DATA_VERSION</name></expr>:</case>
        <case>case <expr><name>SQLITE_FCNTL_HAS_MOVED</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iRes</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>SQLITE_FCNTL_RESERVE_BYTES</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>filectrl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isOk</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCtrl</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Usage: .filectrl %s %s\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>,<argument><expr><name><name>aCtrl</name><index>[<expr><name>iCtrl</name></expr>]</index></name><operator>.</operator><name>zUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isOk</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>iRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"fullschema"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ShellState</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>doStats</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Semi</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>optionMatch</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"indent"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Pretty</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nArg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .fullschema ?--indent?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
       <argument><expr><literal type="string">"SELECT sql FROM"</literal>
       <literal type="string">"  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"</literal>
       <literal type="string">"     FROM sqlite_schema UNION ALL"</literal>
       <literal type="string">"   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) "</literal>
       <literal type="string">"WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' "</literal>
       <literal type="string">"ORDER BY x"</literal></expr></argument>,
       <argument><expr><name>callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
               <argument><expr><literal type="string">"SELECT rowid FROM sqlite_schema"</literal>
               <literal type="string">" WHERE name GLOB 'sqlite_stat[134]'"</literal></expr></argument>,
               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>doStats</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>doStats</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"/* No STAT tables available */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE sqlite_schema;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Insert</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>zDestTable</name></name> <operator>=</operator> <literal type="string">"sqlite_stat1"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_exec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM sqlite_stat1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>zDestTable</name></name> <operator>=</operator> <literal type="string">"sqlite_stat4"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_exec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM sqlite_stat4"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ANALYZE sqlite_schema;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'h'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"headers"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name> <operator>=</operator> <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>|=</operator> <name>SHFLG_HeaderSet</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .headers on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'h'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"help"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Nothing matches '%s'\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"import"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Insert data into this table */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* within this schema (may default to "main") */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Name of file to extra content from */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* A statement */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in an SQL string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counters */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>needCommit</name></decl>;</decl_stmt>             <comment type="block">/* True to COMMIT or ROLLBACK at end */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSep</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes in p-&gt;colSeparator[] */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>                 <comment type="block">/* An SQL statement */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFullTabName</name></decl>;</decl_stmt>         <comment type="block">/* Table name with schema if applicable */</comment>
    <decl_stmt><decl><type><name>ImportCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>             <comment type="block">/* Reader context */</comment>
    <function_decl><type><name>char</name> <modifier>*</modifier></type>(<name>SQLITE_CDECL</name> <modifier>*</modifier><name>xRead</name>)<parameter_list>(<parameter><decl><type><name>ImportCtx</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* Func to read one value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eVerbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Larger for more console output */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSkip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>              <comment type="block">/* Initial lines to skip */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>useOutputMode</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* Use output mode to determine separators */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCreate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* CREATE TABLE statement text */</comment>

    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .import in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Ascii</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>xRead</name> <operator>=</operator> <name>ascii_read_one_field</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>xRead</name> <operator>=</operator> <name>csv_read_one_field</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zTable</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ERROR: extra argument: \"%s\".  Usage:\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"import"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>eVerbose</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-skip"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>nArg</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nSkip</name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-ascii"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name> <operator>=</operator> <name><name>SEP_Unit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cRowSep</name></name> <operator>=</operator> <name><name>SEP_Record</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>xRead</name> <operator>=</operator> <name>ascii_read_one_field</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>useOutputMode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-csv"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cRowSep</name></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>xRead</name> <operator>=</operator> <name>csv_read_one_field</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>useOutputMode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ERROR: unknown option: \"%s\".  Usage:\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"import"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ERROR: missing %s argument. Usage:\n"</literal></expr></argument>,
                  <argument><expr><ternary><condition><expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"FILE"</literal></expr> </then><else>: <expr><literal type="string">"TABLE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"import"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>seenInterrupt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>useOutputMode</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If neither the --csv or --ascii options are specified, then set
      ** the column and row separator characters from the output mode. */</comment>
      <expr_stmt><expr><name>nSep</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                   <argument><expr><literal type="string">"Error: non-null column separator required for import\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
              <argument><expr><literal type="string">"Error: multi-character column separators not allowed"</literal>
              <literal type="string">" for import\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nSep</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr><literal type="string">"Error: non-null row separator required for import\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Csv</name>
       <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>,<argument><expr><name>SEP_CrLf</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <comment type="block">/* When importing CSV (only), if the row separator is set to the
        ** default output row separator, change it to the default input
        ** row separator.  This avoids having to maintain different input
        ** and output row separators. */</comment>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSep</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: multi-character row separators not allowed"</literal>
                           <literal type="string">" for import\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>colSeparator</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>cRowSep</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <name>zFile</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>nLine</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_POPEN</name></cpp:ifdef>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: pipes are not supported in this OS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>in</name></name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name> <operator>=</operator> <literal type="string">"&lt;pipe&gt;"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>xCloser</name></name> <operator>=</operator> <name>pclose</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>in</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>xCloser</name></name> <operator>=</operator> <name>fclose</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eVerbose</name><operator>&gt;=</operator><literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>eVerbose</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>useOutputMode</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zSep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>zSep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zSep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Column separator "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">", row separator "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zSep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>cRowSep</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>z</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><literal type="number">120</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>import_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Below, resources must be freed before exit. */</comment>
    <while>while<condition>( <expr><operator>(</operator><name>nSkip</name><operator>--</operator><operator>)</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><call><name>xRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr> )</condition><block>{<block_content/>}</block></while>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>zSchema</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zFullTabName</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\".\"%w\""</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zFullTabName</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT * FROM %s"</literal></expr></argument>, <argument><expr><name>zFullTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>zFullTabName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>import_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>import_append_char</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* To ensure sCtx.z is allocated */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_strglob</name><argument_list>(<argument><expr><literal type="string">"no such table: *"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>dbCols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRenames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zColDefs</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>zCreate</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"CREATE TABLE %s"</literal></expr></argument>, <argument><expr><name>zFullTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>xRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>zAutoColumn</name><argument_list>(<argument><expr><name><name>sCtx</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbCols</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>!=</operator><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>zColDefs</name> <operator>=</operator> <call><name>zAutoColumn</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbCols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zRenames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRenames</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>stdin_is_interactive</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><name>stdin</name><operator>)</operator></expr>?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr> </then><else>: <expr><name>stderr</name></expr></else></ternary></expr></argument>,
                    <argument><expr><literal type="string">"Columns renamed during .import %s due to duplicates:\n"</literal>
                    <literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>zRenames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zRenames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dbCols</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zColDefs</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s: empty file\n"</literal></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>import_fail</name>:</label>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>import_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zCreate</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z%z\n"</literal></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><name>zColDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eVerbose</name><operator>&gt;=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s failed:\n%s\n"</literal></expr></argument>, <argument><expr><name>zCreate</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>import_fail</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCreate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>pStmt</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>import_fail</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* no columns, no error */</comment>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>nByte</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">20</literal> <operator>+</operator> <name>nCol</name><operator>*</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>import_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name><operator>+</operator><literal type="number">20</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s VALUES(?"</literal></expr></argument>, <argument><expr><name>zFullTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>eVerbose</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Insert using: %s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pStmt</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <goto>goto <name>import_fail</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>needCommit</name> <operator>=</operator> <call><name>sqlite3_get_autocommit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>needCommit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <do>do<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>startLine</name> <init>= <expr><name><name>sCtx</name><operator>.</operator><name>nLine</name></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>xRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
        ** Did we reach end-of-file before finding any columns?
        ** If so, stop instead of NULL filling the remaining columns.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/*
        ** Did we reach end-of-file OR end-of-line before finding any
        ** columns in ASCII mode?  If so, stop instead of NULL filling
        ** the remaining columns.
        */</comment>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Ascii</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>z</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nCol</name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>!=</operator><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: expected %d columns but found %d - "</literal>
                          <literal type="string">"filling the rest with NULL\n"</literal></expr></argument>,
                          <argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>startLine</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>i</name><operator>&lt;=</operator><name>nCol</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr> )</condition><block>{<block_content>
        <do>do<block>{<block_content>
          <expr_stmt><expr><call><name>xRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>while<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>==</operator><name><name>sCtx</name><operator>.</operator><name>cColSep</name></name></expr> )</condition>;</do>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: expected %d columns but found %d - "</literal>
                        <literal type="string">"extras ignored\n"</literal></expr></argument>,
                        <argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>, <argument><expr><name>startLine</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: INSERT failed: %s\n"</literal></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>zFile</name></name></expr></argument>,
                      <argument><expr><name>startLine</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>nRow</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>while<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>cTerm</name></name><operator>!=</operator><name>EOF</name></expr> )</condition>;</do>

    <expr_stmt><expr><call><name>import_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>needCommit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>eVerbose</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
          <argument><expr><literal type="string">"Added %d rows with %d errors using %d lines of input\n"</literal></expr></argument>,
          <argument><expr><name><name>sCtx</name><operator>.</operator><name>nRow</name></name></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>nErr</name></name></expr></argument>, <argument><expr><name><name>sCtx</name><operator>.</operator><name>nLine</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"imposter"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCollist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isWO</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True if making an imposter of a WITHOUT ROWID table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lenPK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Length of the PRIMARY KEY string for isWO tables */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><operator>(</operator><name>nArg</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .imposter INDEX IMPOSTER\n"</literal>
                          <literal type="string">"       .imposter off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Also allowed, but not documented:
      **
      **    .imposter TABLE IMPOSTER
      **
      ** where TABLE is a WITHOUT ROWID table.  In that case, the
      ** imposter is another WITHOUT ROWID table with the columns in
      ** storage order. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"SELECT rootpage, 0 FROM sqlite_schema"</literal>
      <literal type="string">" WHERE name='%q' AND type='index'"</literal>
      <literal type="string">"UNION ALL "</literal>
      <literal type="string">"SELECT rootpage, 1 FROM sqlite_schema"</literal>
      <literal type="string">" WHERE name='%q' AND type='table'"</literal>
      <literal type="string">"   AND sql LIKE '%%without%%rowid%%'"</literal></expr></argument>,
      <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>tnum</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isWO</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"PRAGMA index_xinfo='%q'"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zLabel</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCol</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zCol</name> <operator>=</operator> <literal type="string">"_ROWID_"</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLabel</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zLabel</name></expr></argument>,<argument><expr><literal type="string">"expr%d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zCol</name> <operator>=</operator> <name>zLabel</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>isWO</name> <operator>&amp;&amp;</operator> <name>lenPK</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zCollist</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lenPK</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zCollist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zCollist</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zCollist</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"\"%w\""</literal></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zCollist</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z,\"%w\""</literal></expr></argument>, <argument><expr><name>zCollist</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>tnum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no such index: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCollist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>lenPK</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lenPK</name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID"</literal></expr></argument>,
          <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zCollist</name></expr></argument>, <argument><expr><name>lenPK</name></expr></argument>, <argument><expr><name>zCollist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCollist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error in [%s]: %s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
          <argument><expr><literal type="string">"WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n"</literal></expr></argument>,
          <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>isWO</name></expr> ?</condition><then> <expr><literal type="string">"table"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SQLITE_TESTCTRL_IMPOSTER returns %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_TEST_CONTROL) */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"iotrace"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SQLITE_API</name> <specifier>extern</specifier> <name>void</name></type> <argument_list>(<argument><expr><name>SQLITE_CDECL</name> <operator>*</operator><name>sqlite3IoTrace</name></expr></argument>)</argument_list><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>, <argument><expr><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>iotrace</name> <operator>&amp;&amp;</operator> <name>iotrace</name><operator>!=</operator><name>stdout</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>iotrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>iotrace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sqlite3IoTrace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>sqlite3IoTrace</name> <operator>=</operator> <name>iotracePrintf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iotrace</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iotrace</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iotrace</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sqlite3IoTrace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>sqlite3IoTrace</name> <operator>=</operator> <name>iotracePrintf</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"limits"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLimitName</name></decl>;</decl_stmt>   <comment type="block">/* Name of a limit */</comment>
       <decl_stmt><decl><type><name>int</name></type> <name>limitCode</name></decl>;</decl_stmt>            <comment type="block">/* Integer code for that limit */</comment>
    }</block> <decl><name><name>aLimit</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"length"</literal></expr>,                <expr><name>SQLITE_LIMIT_LENGTH</name></expr>                    }</block></expr>,
      <expr><block>{ <expr><literal type="string">"sql_length"</literal></expr>,            <expr><name>SQLITE_LIMIT_SQL_LENGTH</name></expr>                }</block></expr>,
      <expr><block>{ <expr><literal type="string">"column"</literal></expr>,                <expr><name>SQLITE_LIMIT_COLUMN</name></expr>                    }</block></expr>,
      <expr><block>{ <expr><literal type="string">"expr_depth"</literal></expr>,            <expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>                }</block></expr>,
      <expr><block>{ <expr><literal type="string">"compound_select"</literal></expr>,       <expr><name>SQLITE_LIMIT_COMPOUND_SELECT</name></expr>           }</block></expr>,
      <expr><block>{ <expr><literal type="string">"vdbe_op"</literal></expr>,               <expr><name>SQLITE_LIMIT_VDBE_OP</name></expr>                   }</block></expr>,
      <expr><block>{ <expr><literal type="string">"function_arg"</literal></expr>,          <expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr>              }</block></expr>,
      <expr><block>{ <expr><literal type="string">"attached"</literal></expr>,              <expr><name>SQLITE_LIMIT_ATTACHED</name></expr>                  }</block></expr>,
      <expr><block>{ <expr><literal type="string">"like_pattern_length"</literal></expr>,   <expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>       }</block></expr>,
      <expr><block>{ <expr><literal type="string">"variable_number"</literal></expr>,       <expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>           }</block></expr>,
      <expr><block>{ <expr><literal type="string">"trigger_depth"</literal></expr>,         <expr><name>SQLITE_LIMIT_TRIGGER_DEPTH</name></expr>             }</block></expr>,
      <expr><block>{ <expr><literal type="string">"worker_threads"</literal></expr>,        <expr><name>SQLITE_LIMIT_WORKER_THREADS</name></expr>            }</block></expr>,
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aLimit</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%20s %d\n"</literal></expr></argument>, <argument><expr><name><name>aLimit</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zLimitName</name></expr></argument>,
               <argument><expr><call><name>sqlite3_limit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>aLimit</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>limitCode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .limit NAME ?NEW-VALUE?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aLimit</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strnicmp</name><argument_list>(<argument><expr><name><name>aLimit</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zLimitName</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>iLimit</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ambiguous limit: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>meta_command_exit</name>;</goto>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>iLimit</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown limit: \"%s\"\n"</literal>
                        <literal type="string">"enter \".limits\" with no arguments for a list.\n"</literal></expr></argument>,
                         <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_limit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>aLimit</name><index>[<expr><name>iLimit</name></expr>]</index></name><operator>.</operator><name>limitCode</name></expr></argument>,
                      <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%20s %d\n"</literal></expr></argument>, <argument><expr><name><name>aLimit</name><index>[<expr><name>iLimit</name></expr>]</index></name><operator>.</operator><name>zLimitName</name></expr></argument>,
             <argument><expr><call><name>sqlite3_limit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>aLimit</name><index>[<expr><name>iLimit</name></expr>]</index></name><operator>.</operator><name>limitCode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"lint"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lintDotCommand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_LOAD_EXTENSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"load"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zProc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .load in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .load FILE ?ENTRYPOINT?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zFile</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zProc</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_load_extension</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"log"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .log in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .log FILENAME\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>output_file_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pLog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pLog</name></name> <operator>=</operator> <call><name>output_file_open</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTabname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ColModeOpts</name></type> <name>cmOpts</name> <init>= <expr><name>ColModeOpts_default</name></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"wrap"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>cmOpts</name><operator>.</operator><name>iWrap</name></name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"ww"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>cmOpts</name><operator>.</operator><name>bWordWrap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"wordwrap"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>cmOpts</name><operator>.</operator><name>bWordWrap</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"quote"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>cmOpts</name><operator>.</operator><name>bQuote</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"noquote"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>cmOpts</name><operator>.</operator><name>bQuote</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zMode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zMode</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        <comment type="block">/* Apply defaults for qbox pseudo-mode.  If that
         * overwrites already-set values, user was informed of this.
         */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"qbox"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>ColModeOpts</name></type> <name>cmo</name> <init>= <expr><name>ColModeOpts_default_qbox</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>zMode</name> <operator>=</operator> <literal type="string">"box"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>cmOpts</name> <operator>=</operator> <name>cmo</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zTabname</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zTabname</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown option: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"options:\n"</literal>
                            <literal type="string">"  --noquote\n"</literal>
                            <literal type="string">"  --quote\n"</literal>
                            <literal type="string">"  --wordwrap on/off\n"</literal>
                            <literal type="string">"  --wrap N\n"</literal>
                            <literal type="string">"  --ww\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"extra argument: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zMode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Column</name>
       <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>&gt;=</operator><name>MODE_Markdown</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>&lt;=</operator><name>MODE_Box</name><operator>)</operator></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name>
          <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
           <argument><expr><literal type="string">"current output mode: %s --wrap %d --wordwrap %s --%squote\n"</literal></expr></argument>,
           <argument><expr><name><name>modeDescr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>iWrap</name></name></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bWordWrap</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bQuote</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"no"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"current output mode: %s\n"</literal></expr></argument>, <argument><expr><name><name>modeDescr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>zMode</name> <operator>=</operator> <name><name>modeDescr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"lines"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Line</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"columns"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Column</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>&amp;</operator> <name>SHFLG_HeaderSet</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name></name> <operator>=</operator> <name>cmOpts</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_List</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"html"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Html</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"tcl"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Tcl</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"csv"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Csv</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_CrLf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"tabs"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_List</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"insert"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Insert</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_table_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zTabname</name></expr> ?</condition><then> <expr><name>zTabname</name></expr> </then><else>: <expr><literal type="string">"table"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"quote"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Quote</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"ascii"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Ascii</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"markdown"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Markdown</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name></name> <operator>=</operator> <name>cmOpts</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"table"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Table</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name></name> <operator>=</operator> <name>cmOpts</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"box"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Box</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name></name> <operator>=</operator> <name>cmOpts</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"count"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Count</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"off"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Off</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zMode</name></expr></argument>,<argument><expr><literal type="string">"json"</literal></expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Json</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: mode should be one of: "</literal>
         <literal type="string">"ascii box column csv html insert json line list markdown "</literal>
         <literal type="string">"qbox quote table tabs tcl\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"nonce"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .nonce NONCE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zNonce</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zNonce</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"line %d: incorrect nonce: \"%s\"\n"</literal></expr></argument>,
                 <argument><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Return immediately to bypass the safe mode reset
                 ** at the end of this procedure */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"nullvalue"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .nullvalue STRING\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'o'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"open"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* Pointer to constant filename */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNewFilename</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Name of the database file to open */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iName</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Index in azArg[] of the filename */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>newFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True to delete file before opening */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>openMode</name> <init>= <expr><name>SHELL_OPEN_UNSPEC</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check for command-line arguments */</comment>
    <for>for<control>(<init><expr><name>iName</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iName</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>iName</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>iName</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>newFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"zip"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>SHELL_OPEN_ZIPFILE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>SHELL_OPEN_APPENDVFS</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"readonly"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>SHELL_OPEN_READONLY</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"nofollow"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>|=</operator> <name>SQLITE_OPEN_NOFOLLOW</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"deserialize"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>SHELL_OPEN_DESERIALIZE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"hexdb"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>SHELL_OPEN_HEXDB</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"maxsize"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iName</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nArg</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMax</name></name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>iName</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DESERIALIZE */</comment>
      </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_SHELL_FIDDLE */</comment>
      if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown option: %s\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zFN</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"extra argument: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zFN</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Close the existing database */</comment>
    <expr_stmt><expr><call><name>session_close_all</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zFreeOnClose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zFreeOnClose</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openMode</name></name> <operator>=</operator> <name>openMode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>openFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szMax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* If a filename is specified, try to open it first */</comment>
    <if_stmt><if>if<condition>( <expr><name>zFN</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>==</operator><name>SHELL_OPEN_HEXDB</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>newFlag</name> <operator>&amp;&amp;</operator> <name>zFN</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>shellDeleteFile</name><argument_list>(<argument><expr><name>zFN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name>
       <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>openMode</name></name><operator>!=</operator><name>SHELL_OPEN_HEXDB</name>
       <operator>&amp;&amp;</operator> <name>zFN</name>
       <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zFN</name></expr></argument>,<argument><expr><literal type="string">":memory:"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>
      )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot open disk-based database files in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* WASM mode has its own sandboxed pseudo-filesystem. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if<condition>( <expr><name>zFN</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zNewFilename</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zNewFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zNewFilename</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name> <operator>=</operator> <name>zNewFilename</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OPEN_DB_KEEPALIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open '%s'\n"</literal></expr></argument>, <argument><expr><name>zNewFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zNewFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zFreeOnClose</name></name> <operator>=</operator> <name>zNewFilename</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* As a fall-back open a TEMP database */</comment>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'o'</literal>
        <operator>&amp;&amp;</operator> <operator>(</operator><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"output"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
            <operator>||</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"once"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"excel"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bTxtMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bOnce</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* 0: .output, 1: .once, 2: .excel */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBOM</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Byte-order mark to using if --bom is present */</comment>

    <expr_stmt><expr><name><name>zBOM</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .%s in safe mode"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>eMode</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"once"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bOnce</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-bom"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>zBOM</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xef</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zBOM</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xbb</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zBOM</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xbf</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zBOM</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-x"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>eMode</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>  <comment type="block">/* spreadsheet */</comment>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-e"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>eMode</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>  <comment type="block">/* text editor */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"ERROR: unknown option: \"%s\".  Usage:\n"</literal></expr></argument>,
                      <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eMode</name><operator>!=</operator><literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name>eMode</name><operator>!=</operator><literal type="char">'x'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zFile</name> <operator>&amp;&amp;</operator> <name><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
          <while>while<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nArg</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%z %s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"ERROR: extra parameter: \"%s\".  Usage:\n"</literal></expr></argument>,
                    <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zFile</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bOnce</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_NOHAVE_SYSTEM</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>eMode</name><operator>==</operator><literal type="char">'x'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>doXdgOpen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>outputModePush</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>eMode</name><operator>==</operator><literal type="char">'x'</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* spreadsheet mode.  Output as CSV. */</comment>
        <expr_stmt><expr><call><name>newTempFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ShellClearFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Csv</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_CrLf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* text editor mode */</comment>
        <expr_stmt><expr><call><name>newTempFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bTxtMode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zFile</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTempFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_NOHAVE_SYSTEM */</comment>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zFile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_POPEN</name></cpp:ifdef>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: pipes are not supported in this OS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>zFile</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: cannot open pipe \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zFile</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zBOM</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>zBOM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <call><name>output_file_open</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>bTxtMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>,<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: cannot write to \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>zBOM</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>zBOM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"parameter"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>parameter_syntax_error</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* .parameter clear
    ** Clear all bind parameters by dropping the TEMP table that holds them.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"clear"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE IF EXISTS temp.sqlite_parameters;"</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .parameter list
    ** List all bind parameters.
    */</comment>
    if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
             <argument><expr><literal type="string">"SELECT max(length(key)) "</literal>
             <literal type="string">"FROM temp.sqlite_parameters;"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rx</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><literal type="number">40</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>len</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
             <argument><expr><literal type="string">"SELECT key, quote(value) "</literal>
             <literal type="string">"FROM temp.sqlite_parameters;"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>rx</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%-*s %s\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .parameter init
    ** Make sure the TEMP table used to hold bind parameters exists.
    ** Create it if necessary.
    */</comment>
    if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"init"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>bind_table_init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .parameter set NAME VALUE
    ** Set or reset a bind parameter.  NAME should be the full parameter
    ** name exactly as it appears in the query.  (ex: $abc, @def).  The
    ** VALUE can be in either SQL literal notation, or if not it will be
    ** understood to be a text string.
    */</comment>
    if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zValue</name> <init>= <expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>bind_table_init</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                  <argument><expr><literal type="string">"REPLACE INTO temp.sqlite_parameters(key,value)"</literal>
                  <literal type="string">"VALUES(%Q,%s);"</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rx</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                   <argument><expr><literal type="string">"REPLACE INTO temp.sqlite_parameters(key,value)"</literal>
                   <literal type="string">"VALUES(%Q,%Q);"</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>zValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rx</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .parameter unset NAME
    ** Remove the NAME binding from the parameter binding table, if it
    ** exists.
    */</comment>
    if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"unset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"DELETE FROM temp.sqlite_parameters WHERE key=%Q"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block type="pseudo"><block_content>
    <comment type="block">/* If no command name matches, show a syntax error */</comment>
    <label><name>parameter_syntax_error</name>:</label>
    <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"print"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"progress"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"quiet"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"q"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>|=</operator> <name>SHELL_PROGRESS_QUIET</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>|=</operator> <name>SHELL_PROGRESS_RESET</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"once"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>|=</operator> <name>SHELL_PROGRESS_ONCE</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name>nArg</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: missing argument on --limit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>meta_command_exit</name>;</goto>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mxProgress</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: unknown option: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>nn</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_progress_handler</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>nn</name></expr></argument>, <argument><expr><name>progress_handler</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_PROGRESS_CALLBACK */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prompt"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>,<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>,<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'q'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"quit"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>inSaved</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>savedLineno</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .read in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .read FILE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_POPEN</name></cpp:ifdef>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: pipes are not supported in this OS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <call><name>openChrSource</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <name>inSaved</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>savedLineno</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"restore"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSrcFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>pSrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_backup</name> <modifier>*</modifier></type><name>pBackup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .restore in safe mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSrcFile</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zDb</name> <operator>=</operator> <literal type="string">"main"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSrcFile</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zDb</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .restore ?DB? FILE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_open</name><argument_list>(<argument><expr><name>zSrcFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open \"%s\"\n"</literal></expr></argument>, <argument><expr><name>zSrcFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBackup</name> <operator>=</operator> <call><name>sqlite3_backup_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBackup</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_backup_step</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>,<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_OK</name>
          <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr>  )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>nTimeout</name><operator>++</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_backup_finish</name><argument_list>(<argument><expr><name>pBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_LOCKED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: source database is busy\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"scanstats"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scanstatsOn</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_STMT_SCANSTATUS</name></cpp:ifndef>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Warning: .scanstats not available in this build.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .scanstats on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>sSelect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShellState</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDiv</name> <init>= <expr><literal type="string">"("</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bDebug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bNoSystemTabs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Semi</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"indent"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Pretty</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bDebug</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"nosys"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bNoSystemTabs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown option: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>zName</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>isSchema</name> <init>= <expr><call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_master"</literal></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
                  <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
                  <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"sqlite_temp_master"</literal></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
                  <operator>||</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"sqlite_temp_schema"</literal></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>isSchema</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>new_argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>new_colv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
                      <argument><expr><literal type="string">"CREATE TABLE %s (\n"</literal>
                      <literal type="string">"  type text,\n"</literal>
                      <literal type="string">"  name text,\n"</literal>
                      <literal type="string">"  tbl_name text,\n"</literal>
                      <literal type="string">"  rootpage integer,\n"</literal>
                      <literal type="string">"  sql text\n"</literal>
                      <literal type="string">")"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>new_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"sql"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>new_argv</name></expr></argument>, <argument><expr><name>new_colv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>new_argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDiv</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT name FROM pragma_database_list"</literal></expr></argument>,
                              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"SELECT sql FROM"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iSchema</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zScNum</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zScNum</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zScNum</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>++</operator><name>iSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zDiv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDiv</name> <operator>=</operator> <literal type="string">" UNION ALL "</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"SELECT shell_add_schema(sql,"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">",name) AS sql, type, tbl_name, name, rowid,"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zScNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">" AS snum, "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">" AS sname FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>quoteChar</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">".sqlite_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTROSPECTION_PRAGMAS</name></cpp:ifndef>
      <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>,
           <argument><expr><literal type="string">" UNION ALL SELECT shell_module_schema(name),"</literal>
           <literal type="string">" 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list"</literal></expr></argument>,
        <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">") WHERE "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zName</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQarg</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%Q"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>bGlob</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zQarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bGlob</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strchr</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>strchr</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"lower(printf('%s.%s',sname,tbl_name))"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"lower(tbl_name)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bGlob</name></expr> ?</condition><then> <expr><literal type="string">" GLOB "</literal></expr> </then><else>: <expr><literal type="string">" LIKE "</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><name>zQarg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bGlob</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">" ESCAPE '\\' "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>bNoSystemTabs</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"name NOT LIKE 'sqlite_%%' AND "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>, <argument><expr><literal type="string">"sql IS NOT NULL"</literal>
                           <literal type="string">" ORDER BY snum, rowid"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>bDebug</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"SQL: %s;\n"</literal></expr></argument>, <argument><expr><name><name>sSelect</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>sSelect</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: querying schema information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><literal type="number">11</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"selecttrace"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><literal type="number">9</literal>  <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"treetrace"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name> <init>= <expr><ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0xffffffff</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_SESSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"session"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>AuxDb</name></name> <modifier>*</modifier></type><name>pAuxDb</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OpenSession</name> <modifier>*</modifier></type><name>pSession</name> <init>= <expr><operator>&amp;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCmd</name> <init>= <expr><operator>&amp;</operator><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iSes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCmd</name> <init>= <expr><name>nArg</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>iSes</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iSes</name><operator>&lt;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>;</condition> <incr><expr><name>iSes</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>iSes</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name>iSes</name><operator>&lt;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pSession</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>iSes</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>azCmd</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCmd</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pSession</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iSes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* .session attach TABLE
    ** Invoke the sqlite3session_attach() interface to attach a particular
    ** table so that it is never filtered.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"attach"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <label><name>session_not_open</name>:</label>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: No sessions are open\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3session_attach</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: sqlite3session_attach() returns %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session changeset FILE
    ** .session patchset FILE
    ** Write a changeset or patchset into a file.  The file is overwritten.
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"changeset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"patchset"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run \".session %s\" in safe mode"</literal></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>!=</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_not_open</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: cannot open \"%s\" for writing\n"</literal></expr></argument>,
                    <argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>szChng</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pChng</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'c'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3session_changeset</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szChng</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3session_patchset</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>szChng</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pChng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error: error code %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>pChng</name>
          <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>pChng</name></expr></argument>, <argument><expr><name>szChng</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Failed to write entire %d-byte output\n"</literal></expr></argument>,
                  <argument><expr><name>szChng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pChng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session close
    ** Close the identified session
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>session_close</name><argument_list>(<argument><expr><name>pSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>iSes</name></expr>]</index></name> <operator>=</operator> <name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><operator>--</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session enable ?BOOLEAN?
    ** Query or set the enable flag
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"enable"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ii</name> <operator>=</operator> <ternary><condition><expr><name>nCmd</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>sqlite3session_enable</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"session %s enable flag = %d\n"</literal></expr></argument>,
                    <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session filter GLOB ....
    ** Set a list of GLOB patterns of table names to be excluded.
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>, <decl><type ref="prev"/><name>nByte</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name><name>pSession</name><operator>-&gt;</operator><name>nFilter</name></name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nByte</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>nCmd</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: out or memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nCmd</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name><name>pSession</name><operator>-&gt;</operator><name>azFilter</name><index>[<expr><name>ii</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nFilter</name></name> <operator>=</operator> <name>ii</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session indirect ?BOOLEAN?
    ** Query or set the indirect flag
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"indirect"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ii</name> <operator>=</operator> <ternary><condition><expr><name>nCmd</name><operator>==</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>sqlite3session_indirect</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"session %s indirect flag = %d\n"</literal></expr></argument>,
                    <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session isempty
    ** Determine if the session is empty
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"isempty"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>sqlite3session_isempty</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"session %s isempty flag = %d\n"</literal></expr></argument>,
                    <argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session list
    ** List all currently open sessions
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if><if type="elseif">else

    <comment type="block">/* .session open DB NAME
    ** Open a new session called NAME on the attached database DB.
    ** DB is normally "main".
    */</comment>
    if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"open"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zName</name> <operator>=</operator> <name><name>azCmd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>session_syntax_error</name>;</goto></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>,<argument><expr><name>zName</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Session \"%s\" already exists\n"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name><operator>&gt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Maximum of %d sessions\n"</literal></expr></argument>, <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pSession</name> <operator>=</operator> <operator>&amp;</operator><name><name>pAuxDb</name><operator>-&gt;</operator><name>aSession</name><index>[<expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3session_create</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Cannot open session: error code=%d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>nFilter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3session_table_filter</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>session_filter</name></expr></argument>, <argument><expr><name>pSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pAuxDb</name><operator>-&gt;</operator><name>nSession</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>pSession</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block type="pseudo"><block_content>
    <comment type="block">/* If no command name matches, show a syntax error */</comment>
    <label><name>session_syntax_error</name>:</label>
    <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"session"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Undocumented commands for internal testing.  Subject to change
  ** without notice. */</comment>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"selftest-"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %d 0x%x\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">9</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>v</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr><literal type="string">"%s: %lld 0x%llx\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"selftest"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>bIsInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* True to initialize the SELFTEST table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bVerbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Verbose output */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bSelftestExists</name></decl>;</decl_stmt>     <comment type="block">/* True if SELFTEST already exists */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>                <comment type="block">/* Loop counters */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nTest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of tests runs */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* Number of errors seen */</comment>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>str</name></decl>;</decl_stmt>           <comment type="block">/* Answer for a query */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Query against the SELFTEST table */</comment>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-init"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bIsInit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else
      if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>bVerbose</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown option \"%s\" on \"%s\"\n"</literal></expr></argument>,
                    <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Should be one of: --init -v\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><literal type="string">"main"</literal></expr></argument>,<argument><expr><literal type="string">"selftest"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
           <operator>!=</operator> <name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bSelftestExists</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>bSelftestExists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>bIsInit</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>createSelftestTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bSelftestExists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>k</name><operator>=</operator><name>bSelftestExists</name></expr>;</init> <condition><expr><name>k</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>k</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
            <argument><expr><literal type="string">"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno"</literal></expr></argument>,
            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
          <argument><expr><literal type="string">"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"</literal>
          <literal type="string">"      (1,'run','PRAGMA integrity_check','ok')"</literal></expr></argument>,
          <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error querying the selftest table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tno</name> <init>= <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zAns</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name>zOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>zAns</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>bVerbose</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d: %s %s\n"</literal></expr></argument>, <argument><expr><name>tno</name></expr></argument>, <argument><expr><name>zOp</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>,<argument><expr><literal type="string">"memo"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>,<argument><expr><literal type="string">"run"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>str</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>str</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>captureOutputCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nTest</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bVerbose</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Result: %s\n"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nErr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d: error-code-%d: %s\n"</literal></expr></argument>, <argument><expr><name>tno</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zAns</name></expr></argument>,<argument><expr><name><name>str</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nErr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d: Expected: [%s]\n"</literal></expr></argument>, <argument><expr><name>tno</name></expr></argument>, <argument><expr><name>zAns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d:      Got: [%s]\n"</literal></expr></argument>, <argument><expr><name>tno</name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if><else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr><literal type="string">"Unknown operation \"%s\" on selftest line %d\n"</literal></expr></argument>, <argument><expr><name>zOp</name></expr></argument>, <argument><expr><name>tno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for> <comment type="block">/* End loop over rows of content from SELFTEST */</comment>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for> <comment type="block">/* End loop over k */</comment>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d errors out of %d tests\n"</literal></expr></argument>, <argument><expr><name>nErr</name></expr></argument>, <argument><expr><name>nTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"separator"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>nArg</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal> <operator>||</operator> <name>nArg</name></expr></argument>&gt;</argument_list></name><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .separator COL ?ROW?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"sha3sum"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zLike</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Which table to checksum. 0 means everything */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bSchema</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Also hash the schema */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bSeparate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Hash each table separately */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iSize</name> <init>= <expr><literal type="number">224</literal></expr></init></decl>;</decl_stmt>         <comment type="block">/* Hash algorithm to use */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bDebug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Only show the query that would have run */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>     <comment type="block">/* For querying tables names */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>              <comment type="block">/* SQL to be run */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>              <comment type="block">/* Separator */</comment>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>sSql</name></decl>;</decl_stmt>          <comment type="block">/* Complete SQL for the query to run the hash */</comment>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>sQuery</name></decl>;</decl_stmt>        <comment type="block">/* Set of queries used to read all content */</comment>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bSchema</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"sha3-224"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"sha3-256"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"sha3-384"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"sha3-512"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
        )</condition><block>{<block_content>
          <expr_stmt><expr><name>iSize</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else
        if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>bDebug</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown option \"%s\" on \"%s\"\n"</literal></expr></argument>,
                      <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>showHelp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>zLike</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zLike</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bSeparate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3_strlike</name><argument_list>(<argument><expr><literal type="string">"sqlite\\_%"</literal></expr></argument>, <argument><expr><name>zLike</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bSchema</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>bSchema</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <literal type="string">"SELECT lower(name) FROM sqlite_schema"</literal>
             <literal type="string">" WHERE type='table' AND coalesce(rootpage,0)&gt;1"</literal>
             <literal type="string">" UNION ALL SELECT 'sqlite_schema'"</literal>
             <literal type="string">" ORDER BY 1 collate nocase"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <literal type="string">"SELECT lower(name) FROM sqlite_schema"</literal>
             <literal type="string">" WHERE type='table' AND coalesce(rootpage,0)&gt;1"</literal>
             <literal type="string">" AND name NOT LIKE 'sqlite_%'"</literal>
             <literal type="string">" ORDER BY 1 collate nocase"</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>, <argument><expr><literal type="string">"WITH [sha3sum$query](a,b) AS("</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"VALUES("</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>SQLITE_ROW</name><operator>==</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zLike</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_strlike</name><argument_list>(<argument><expr><name>zLike</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><name>zTab</name></expr></argument>,<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><literal type="string">" NOT INDEXED;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_schema"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><literal type="string">"SELECT type,name,tbl_name,sql FROM sqlite_schema"</literal>
                           <literal type="string">" ORDER BY name;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_sequence"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><literal type="string">"SELECT name,seq FROM sqlite_sequence"</literal>
                           <literal type="string">" ORDER BY name;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat1"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>,<argument><expr><literal type="string">"SELECT tbl,idx,stat FROM sqlite_stat1"</literal>
                           <literal type="string">" ORDER BY tbl,idx;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="string">"sqlite_stat4"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY tbl, idx, rowid;\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>, <argument><expr><name><name>sQuery</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sQuery</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">"),("</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bSeparate</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"%s))"</literal>
          <literal type="string">" SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label"</literal>
          <literal type="string">"   FROM [sha3sum$query]"</literal></expr></argument>,
          <argument><expr><name><name>sSql</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr><literal type="string">"%s))"</literal>
          <literal type="string">" SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash"</literal>
          <literal type="string">"   FROM [sha3sum$query]"</literal></expr></argument>,
          <argument><expr><name><name>sSql</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bDebug</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>shell_exec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NOHAVE_SYSTEM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_SHELL_FIDDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal>
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"shell"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
       <operator>||</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"system"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>failIfSafeMode</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"cannot run .%s in safe mode"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .system COMMAND\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>?</condition><then><expr><literal type="string">"%s"</literal></expr></then><else>:<expr><literal type="string">"\"%s\""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nArg</name> <operator>&amp;&amp;</operator> <name>zCmd</name><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>?</condition><then><expr><literal type="string">"%z %s"</literal></expr></then><else>:<expr><literal type="string">"%z \"%s\""</literal></expr></else></ternary></expr></argument>,
                             <argument><expr><name>zCmd</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <ternary><condition><expr><name>zCmd</name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>system</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>x</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"System command returns %d\n"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_NOHAVE_SYSTEM) &amp;&amp; !defined(SQLITE_SHELL_FIDDLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"show"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azBool</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"off"</literal></expr>, <expr><literal type="string">"on"</literal></expr>, <expr><literal type="string">"trigger"</literal></expr>, <expr><literal type="string">"full"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .show\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"echo"</literal></expr></argument>,
                <argument><expr><name><name>azBool</name><index>[<expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Echo</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"eqp"</literal></expr></argument>, <argument><expr><name><name>azBool</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>autoEQP</name></name><operator>&amp;</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"explain"</literal></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Explain</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>autoExplain</name></name></expr> ?</condition><then> <expr><literal type="string">"auto"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"headers"</literal></expr></argument>, <argument><expr><name><name>azBool</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>showHeader</name></name><operator>!=</operator><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>==</operator><name>MODE_Column</name>
     <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>&gt;=</operator><name>MODE_Markdown</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>mode</name></name><operator>&lt;=</operator><name>MODE_Box</name><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name>
        <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s --wrap %d --wordwrap %s --%squote\n"</literal></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>,
         <argument><expr><name><name>modeDescr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>iWrap</name></name></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bWordWrap</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
         <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>cmOpts</name><operator>.</operator><name>bQuote</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"no"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"mode"</literal></expr></argument>, <argument><expr><name><name>modeDescr</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: "</literal></expr></argument>, <argument><expr><literal type="string">"nullvalue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nullValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"output"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>outfile</name></name></expr> </then><else>: <expr><literal type="string">"stdout"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%12.12s: "</literal></expr></argument>, <argument><expr><literal type="string">"colseparator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,<argument><expr><literal type="string">"%12.12s: "</literal></expr></argument>, <argument><expr><literal type="string">"rowseparator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>statsOn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <literal type="string">"off"</literal></expr>;</expr_stmt>     <break>break;</break>
      <default>default:</default> <expr_stmt><expr><name>zOut</name> <operator>=</operator> <literal type="string">"on"</literal></expr>;</expr_stmt>      <break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case>  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <literal type="string">"stmt"</literal></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><literal type="number">3</literal></expr>:</case>  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <literal type="string">"vmstep"</literal></expr>;</expr_stmt>  <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>,<argument><expr><literal type="string">"stats"</literal></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: "</literal></expr></argument>, <argument><expr><literal type="string">"width"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%12.12s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"stats"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"stmt"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>statsOn</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"vmstep"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>statsOn</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>statsOn</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>display_stats</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .stats ?on|off|stmt|vmstep?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><operator>(</operator><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"tables"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator>
   <operator>||</operator> <operator>(</operator><name>c</name><operator>==</operator><literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"indices"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
                 <operator>||</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"indexes"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>, <decl><type ref="prev"/><name>nAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShellText</name></type> <name>s</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>initText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"PRAGMA database_list"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>shellDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>==</operator><literal type="char">'i'</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* It is an historical accident that the .indexes command shows an error
      ** when called with the wrong number of arguments whereas the .tables
      ** command does not. */</comment>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .indexes ?LIKE-PATTERN?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zDbName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>s</name><operator>.</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" UNION ALL "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_stricmp</name><argument_list>(<argument><expr><name>zDbName</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"SELECT name FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"||'.'||name FROM "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">".sqlite_schema "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><literal type="string">" WHERE type IN ('table','view')"</literal>
                      <literal type="string">"   AND name NOT LIKE 'sqlite_%'"</literal>
                      <literal type="string">"   AND name LIKE ?1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><literal type="string">" WHERE type='index'"</literal>
                      <literal type="string">"   AND tbl_name LIKE ?1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>appendText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY 1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>freeText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><call><name>shellDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Run the SQL statement prepared by the above block. Store the results
    ** as an array of nul-terminated strings in azResult[].  */</comment>
    <expr_stmt><expr><name>nRow</name> <operator>=</operator> <name>nAlloc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>azResult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <while>while<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nRow</name><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azNew</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><name>nAlloc</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>azNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>azResult</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>azResult</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>azResult</name> <operator>=</operator> <name>azNew</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>azResult</name><index>[<expr><name>nRow</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>azResult</name><index>[<expr><name>nRow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRow</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shellDatabaseError</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Pretty-print the contents of array azResult[] to the output */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nRow</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>maxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nPrintCol</name></decl>, <decl><type ref="prev"/><name>nPrintRow</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azResult</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>len</name><operator>&gt;</operator><name>maxlen</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>nPrintCol</name> <operator>=</operator> <literal type="number">80</literal><operator>/</operator><operator>(</operator><name>maxlen</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nPrintCol</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nPrintCol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nPrintRow</name> <operator>=</operator> <operator>(</operator><name>nRow</name> <operator>+</operator> <name>nPrintCol</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>nPrintCol</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nPrintRow</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator><name>nPrintRow</name></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSp</name> <init>= <expr><ternary><condition><expr><name>j</name><operator>&lt;</operator><name>nPrintRow</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"  "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s%-*s"</literal></expr></argument>, <argument><expr><name>zSp</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
                      <argument><expr><ternary><condition><expr><name><name>azResult</name><index>[<expr><name>j</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>azResult</name><index>[<expr><name>j</name></expr>]</index></name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nRow</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>azResult</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <comment type="block">/* Begin redirecting output to the file "testcase-out.txt" */</comment>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"testcase"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <call><name>output_file_open</name><argument_list>(<argument><expr><literal type="string">"testcase-out.txt"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open 'testcase-out.txt'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zTestcase</name></name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_SHELL_FIDDLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_UNTESTABLE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"testctrl"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCtrlName</name></decl>;</decl_stmt>   <comment type="block">/* Name of a test-control option */</comment>
       <decl_stmt><decl><type><name>int</name></type> <name>ctrlCode</name></decl>;</decl_stmt>            <comment type="block">/* Integer code for that option */</comment>
       <decl_stmt><decl><type><name>int</name></type> <name>unSafe</name></decl>;</decl_stmt>              <comment type="block">/* Not valid for --safe mode */</comment>
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUsage</name></decl>;</decl_stmt>      <comment type="block">/* Usage notes */</comment>
    }</block> <decl><name><name>aCtrl</name><index>[]</index></name> <init>= <expr><block>{
      <expr><block>{ <expr><literal type="string">"always"</literal></expr>,             <expr><name>SQLITE_TESTCTRL_ALWAYS</name></expr>, <expr><literal type="number">1</literal></expr>,     <expr><literal type="string">"BOOLEAN"</literal></expr>         }</block></expr>,
      <expr><block>{ <expr><literal type="string">"assert"</literal></expr>,             <expr><name>SQLITE_TESTCTRL_ASSERT</name></expr>, <expr><literal type="number">1</literal></expr>,     <expr><literal type="string">"BOOLEAN"</literal></expr>         }</block></expr>,
    <comment type="block">/*{ "benign_malloc_hooks",SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,1, ""        },*/</comment>
    <comment type="block">/*{ "bitvec_test",        SQLITE_TESTCTRL_BITVEC_TEST, 1,  ""              },*/</comment>
      <expr><block>{ <expr><literal type="string">"byteorder"</literal></expr>,          <expr><name>SQLITE_TESTCTRL_BYTEORDER</name></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="string">""</literal></expr>                }</block></expr>,
      <expr><block>{ <expr><literal type="string">"extra_schema_checks"</literal></expr>,<expr><name>SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"BOOLEAN"</literal></expr>  }</block></expr>,
    <comment type="block">/*{ "fault_install",      SQLITE_TESTCTRL_FAULT_INSTALL, 1,""              },*/</comment>
      <expr><block>{ <expr><literal type="string">"imposter"</literal></expr>,         <expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="string">"SCHEMA ON/OFF ROOTPAGE"</literal></expr>}</block></expr>,
      <expr><block>{ <expr><literal type="string">"internal_functions"</literal></expr>, <expr><name>SQLITE_TESTCTRL_INTERNAL_FUNCTIONS</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">""</literal></expr>          }</block></expr>,
      <expr><block>{ <expr><literal type="string">"localtime_fault"</literal></expr>,    <expr><name>SQLITE_TESTCTRL_LOCALTIME_FAULT</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"BOOLEAN"</literal></expr>      }</block></expr>,
      <expr><block>{ <expr><literal type="string">"never_corrupt"</literal></expr>,      <expr><name>SQLITE_TESTCTRL_NEVER_CORRUPT</name></expr>,<expr><literal type="number">1</literal></expr>, <expr><literal type="string">"BOOLEAN"</literal></expr>       }</block></expr>,
      <expr><block>{ <expr><literal type="string">"optimizations"</literal></expr>,      <expr><name>SQLITE_TESTCTRL_OPTIMIZATIONS</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"DISABLE-MASK"</literal></expr>   }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYCOVERAGE</name></cpp:ifdef>
      <expr><block>{ <expr><literal type="string">"parser_coverage"</literal></expr>,    <expr><name>SQLITE_TESTCTRL_PARSER_COVERAGE</name></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">""</literal></expr>             }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr><block>{ <expr><literal type="string">"pending_byte"</literal></expr>,       <expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="string">"OFFSET  "</literal></expr>       }</block></expr>,
      <expr><block>{ <expr><literal type="string">"prng_restore"</literal></expr>,       <expr><name>SQLITE_TESTCTRL_PRNG_RESTORE</name></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="string">""</literal></expr>               }</block></expr>,
      <expr><block>{ <expr><literal type="string">"prng_save"</literal></expr>,          <expr><name>SQLITE_TESTCTRL_PRNG_SAVE</name></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="string">""</literal></expr>               }</block></expr>,
      <expr><block>{ <expr><literal type="string">"prng_seed"</literal></expr>,          <expr><name>SQLITE_TESTCTRL_PRNG_SEED</name></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"SEED ?db?"</literal></expr>      }</block></expr>,
      <expr><block>{ <expr><literal type="string">"seek_count"</literal></expr>,         <expr><name>SQLITE_TESTCTRL_SEEK_COUNT</name></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="string">""</literal></expr>               }</block></expr>,
      <expr><block>{ <expr><literal type="string">"sorter_mmap"</literal></expr>,        <expr><name>SQLITE_TESTCTRL_SORTER_MMAP</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"NMAX"</literal></expr>           }</block></expr>,
      <expr><block>{ <expr><literal type="string">"tune"</literal></expr>,               <expr><name>SQLITE_TESTCTRL_TUNE</name></expr>,        <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"ID VALUE"</literal></expr>       }</block></expr>,
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>testctrl</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCtrl</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* 0: usage.  1: %d  2: %x  3: no-output */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isOk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCmd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCmd</name> <operator>=</operator> <ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"help"</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* The argument can optionally begin with "-" or "--" */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>zCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zCmd</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zCmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zCmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* --help lists all test-controls */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>,<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Available test-controls:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aCtrl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"  .testctrl %s %s\n"</literal></expr></argument>,
                    <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCtrlName</name></expr></argument>, <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* convert testctrl text option to value. allow any unique prefix
    ** of the option name, or a numerical value. */</comment>
    <expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aCtrl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zCmd</name></expr></argument>, <argument><expr><name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zCtrlName</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>testctrl</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>testctrl</name> <operator>=</operator> <name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ctrlCode</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>iCtrl</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: ambiguous test-control: \"%s\"\n"</literal>
                              <literal type="string">"Use \".testctrl --help\" for help\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>testctrl</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: unknown test-control: %s\n"</literal>
                         <literal type="string">"Use \".testctrl --help\" for help\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>aCtrl</name><index>[<expr><name>iCtrl</name></expr>]</index></name><operator>.</operator><name>unSafe</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
         <argument><expr><literal type="string">"line %d: \".testctrl %s\" may not be used in safe mode\n"</literal></expr></argument>,
         <argument><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>aCtrl</name><index>[<expr><name>iCtrl</name></expr>]</index></name><operator>.</operator><name>zCtrlName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <switch>switch<condition>(<expr><name>testctrl</name></expr>)</condition><block>{<block_content>

        <comment type="block">/* sqlite3_test_control(int, db, int) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_OPTIMIZATIONS</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>opt</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(int) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SAVE</name></expr>:</case>
        <case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESTORE</name></expr>:</case>
        <case>case <expr><name>SQLITE_TESTCTRL_BYTEORDER</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <ternary><condition><expr><name>testctrl</name><operator>==</operator><name>SQLITE_TESTCTRL_BYTEORDER</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(int, uint) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>opt</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(int, int, sqlite3*) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SEED</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>nArg</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
            <if_stmt><if>if<condition>( <expr><name>ii</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"random"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><operator>&amp;</operator><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- random seed: %d\n"</literal></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
              <comment type="block">/* Make sure the schema has been loaded */</comment>
              <expr_stmt><expr><call><name>sqlite3_table_column_metadata</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(int, int) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_ASSERT</name></expr>:</case>
        <case>case <expr><name>SQLITE_TESTCTRL_ALWAYS</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>opt</name> <init>= <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(int, int) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_LOCALTIME_FAULT</name></expr>:</case>
        <case>case <expr><name>SQLITE_TESTCTRL_NEVER_CORRUPT</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>opt</name> <init>= <expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <comment type="block">/* sqlite3_test_control(sqlite3*) */</comment>
        <case>case <expr><name>SQLITE_TESTCTRL_INTERNAL_FUNCTIONS</name></expr>:</case>
          <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_TESTCTRL_IMPOSTER</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,
                          <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
                          <argument><expr><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <case>case <expr><name>SQLITE_TESTCTRL_SEEK_COUNT</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>u64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%llu\n"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYCOVERAGE</name></cpp:ifdef>
        <case>case <expr><name>SQLITE_TESTCTRL_PARSER_COVERAGE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
        <case>case <expr><name>SQLITE_TESTCTRL_TUNE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><operator>-</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><operator>-</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>id</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d: %d"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>id</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if<condition>( <expr><name>id</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>SQLITE_TESTCTRL_SORTER_MMAP</name></expr>:</case>
          <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>opt</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>testctrl</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isOk</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>isOk</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCtrl</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"Usage: .testctrl %s %s\n"</literal></expr></argument>, <argument><expr><name>zCmd</name></expr></argument>,<argument><expr><name><name>aCtrl</name><index>[<expr><name>iCtrl</name></expr>]</index></name><operator>.</operator><name>zUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isOk</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>rc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isOk</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"0x%08x\n"</literal></expr></argument>, <argument><expr><name>rc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_UNTESTABLE) */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"timeout"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_busy_timeout</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;=</operator><literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"timer"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>enableTimer</name> <operator>=</operator> <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>enableTimer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAS_TIMER</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: timer not available on this system.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>enableTimer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .timer on|off\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"trace"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>mType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>jj</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>jj</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>jj</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>jj</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>azArg</name><index>[<expr><name>jj</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"expanded"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eTraceType</name></name> <operator>=</operator> <name>SHELL_TRACE_EXPANDED</name></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_NORMALIZE</name></cpp:ifdef>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"normalized"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eTraceType</name></name> <operator>=</operator> <name>SHELL_TRACE_NORMALIZED</name></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eTraceType</name></name> <operator>=</operator> <name>SHELL_TRACE_PLAIN</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"profile"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mType</name> <operator>|=</operator> <name>SQLITE_TRACE_PROFILE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"row"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mType</name> <operator>|=</operator> <name>SQLITE_TRACE_ROW</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"stmt"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mType</name> <operator>|=</operator> <name>SQLITE_TRACE_STMT</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>( <expr><call><name>optionMatch</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>mType</name> <operator>|=</operator> <name>SQLITE_TRACE_CLOSE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown option \"%s\" on \".trace\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>meta_command_exit</name>;</goto>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>output_file_close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name> <operator>=</operator> <call><name>output_file_open</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>traceOut</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_trace_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>mType</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mType</name> <operator>=</operator> <name>SQLITE_TRACE_STMT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_trace_v2</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>mType</name></expr></argument>, <argument><expr><name>sql_trace_callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_TRACE) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"unmodule"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lenOpt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOpt</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .unmodule [--allexcept] NAME ...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOpt</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zOpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zOpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zOpt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zOpt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>lenOpt</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>lenOpt</name><operator>&gt;=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zOpt</name></expr></argument>, <argument><expr><literal type="string">"-allexcept"</literal></expr></argument>,<argument><expr><name>lenOpt</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>azArg</name><index>[<expr><name>nArg</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_drop_modules</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>nArg</name><operator>&gt;</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>azArg</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"user"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user SUBCOMMAND ...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"login"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user login USER PASSWORD\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_user_authenticate</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
                                     <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Authentication failed for user %s\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"add"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user add USER PASSWORD ISADMIN\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_user_add</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"User-Add failed: %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"edit"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">5</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user edit USER PASSWORD ISADMIN\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_user_change</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"User-Edit failed: %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>!=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user delete USER\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>meta_command_exit</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_user_delete</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"User-Delete failed: %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: .user login|add|edit|delete ...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>meta_command_exit</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_USER_AUTHENTICATION */</comment>

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"SQLite %s %s\n"</literal></expr></argument> <comment type="block">/*extra-version-info*/</comment>,
        <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_HAVE_ZLIB</name></expr></cpp:if>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"zlib version %s\n"</literal></expr></argument>, <argument><expr><call><name>zlibVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTIMEOPT_VAL_</name><parameter_list>(<parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#opt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTIMEOPT_VAL</name><parameter_list>(<parameter><type><name>opt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CTIMEOPT_VAL_(opt)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang_major__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"clang-"</literal> <call><name>CTIMEOPT_VAL</name><argument_list>(<argument><expr><name>__clang_major__</name></expr></argument>)</argument_list></call> <literal type="string">"."</literal>
                    <call><name>CTIMEOPT_VAL</name><argument_list>(<argument><expr><name>__clang_minor__</name></expr></argument>)</argument_list></call> <literal type="string">"."</literal>
                    <call><name>CTIMEOPT_VAL</name><argument_list>(<argument><expr><name>__clang_patchlevel__</name></expr></argument>)</argument_list></call> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"msvc-"</literal> <call><name>CTIMEOPT_VAL</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__VERSION__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"gcc-"</literal> <name>__VERSION__</name> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"vfsinfo"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name> <init>= <expr><ternary><condition><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_VFS_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pVfs</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.zName      = \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.iVersion   = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>iVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.szOsFile   = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.mxPathname = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"vfslist"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pCurrent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_VFS_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for<control>(<init><expr><name>pVfs</name><operator>=</operator><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pVfs</name></expr>;</condition> <incr><expr><name>pVfs</name><operator>=</operator><name><name>pVfs</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.zName      = \"%s\"%s\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
           <argument><expr><ternary><condition><expr><name>pVfs</name><operator>==</operator><name>pCurrent</name></expr> ?</condition><then> <expr><literal type="string">"  &lt;--- CURRENT"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.iVersion   = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>iVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.szOsFile   = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"vfs.mxPathname = %d\n"</literal></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pVfs</name><operator>-&gt;</operator><name>pNext</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"-----------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"vfsname"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name> <init>= <expr><ternary><condition><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zVfsName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_VFSNAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zVfsName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zVfsName</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zVfsName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zVfsName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'w'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"wheretrace"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name> <init>= <expr><ternary><condition><expr><name>nArg</name><operator>&gt;=</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0xffffffff</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_TRACEFLAGS</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else

  if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'w'</literal> <operator>&amp;&amp;</operator> <call><name>cli_strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"width"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>&lt;=</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>azArg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name> <operator>=</operator> <name>nArg</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>shell_out_of_memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>actualWidth</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nWidth</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nArg</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>colWidth</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else

  <block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: unknown command or invalid arguments: "</literal>
      <literal type="string">" \"%s\". Enter \".help\" for help\n"</literal></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>meta_command_exit</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bSafeModePersist</name></name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Line scan result and intermediate states (supporting scan resumption)
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CHAR_BIT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_BIT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><enum>enum <block>{
  <decl><name>QSS_HasDark</name> <init>= <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><name>CHAR_BIT</name></expr></init></decl>, <decl><name>QSS_EndingSemi</name> <init>= <expr><literal type="number">2</literal><operator>&lt;&lt;</operator><name>CHAR_BIT</name></expr></init></decl>,
  <decl><name>QSS_CharMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>CHAR_BIT</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><name>QSS_ScanMask</name> <init>= <expr><literal type="number">3</literal><operator>&lt;&lt;</operator><name>CHAR_BIT</name></expr></init></decl>,
  <decl><name>QSS_Start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
}</block></enum></type> <name>QuickScanState</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSS_SETV</name><parameter_list>(<parameter><type><name>qss</name></type></parameter>, <parameter><type><name>newst</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((newst) | ((qss) &amp; QSS_ScanMask))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSS_INPLAIN</name><parameter_list>(<parameter><type><name>qss</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qss)&amp;QSS_CharMask)==QSS_Start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSS_PLAINWHITE</name><parameter_list>(<parameter><type><name>qss</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qss)&amp;~QSS_EndingSemi)==QSS_Start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSS_PLAINDARK</name><parameter_list>(<parameter><type><name>qss</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qss)&amp;~QSS_EndingSemi)==QSS_HasDark)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QSS_SEMITERM</name><parameter_list>(<parameter><type><name>qss</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qss)&amp;~QSS_HasDark)==QSS_EndingSemi)</cpp:value></cpp:define>

<comment type="block">/*
** Scan line for classification to guide shell's handling.
** The scan is resumable for subsequent lines when prior
** return values are passed as the 2nd argument.
*/</comment>
<function><type><specifier>static</specifier> <name>QuickScanState</name></type> <name>quickscan</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name></decl></parameter>, <parameter><decl><type><name>QuickScanState</name></type> <name>qss</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>cin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>cWait</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><name>qss</name></expr></init></decl>;</decl_stmt> <comment type="block">/* intentional narrowing loss */</comment>
  <if_stmt><if>if<condition>( <expr><name>cWait</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
  <label><name>PlainScan</name>:</label>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cWait</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>cin</name> <operator>=</operator> <operator>*</operator><name>zLine</name><operator>++</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name>cin</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>
      <switch>switch <condition>(<expr><name>cin</name></expr>)</condition><block>{<block_content>
      <case>case <expr><literal type="char">'-'</literal></expr>:</case>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zLine</name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>cin</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>zLine</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
          <if_stmt><if>if<condition>( <expr><name>cin</name><operator>==</operator><literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>PlainScan</name>;</goto></block_content></block></if></if_stmt></block_content></block></while>
        <return>return <expr><name>qss</name></expr>;</return>
      <case>case <expr><literal type="char">';'</literal></expr>:</case>
        <expr_stmt><expr><name>qss</name> <operator>|=</operator> <name>QSS_EndingSemi</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      <case>case <expr><literal type="char">'/'</literal></expr>:</case>
        <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zLine</name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>zLine</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cWait</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>qss</name> <operator>=</operator> <call><name>QSS_SETV</name><argument_list>(<argument><expr><name>qss</name></expr></argument>, <argument><expr><name>cWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>TermScan</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <case>case <expr><literal type="char">'['</literal></expr>:</case>
        <expr_stmt><expr><name>cin</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
        <comment type="block">/* fall thru */</comment>
      <case>case <expr><literal type="char">'`'</literal></expr>:</case> <case>case <expr><literal type="char">'\''</literal></expr>:</case> <case>case <expr><literal type="char">'"'</literal></expr>:</case>
        <expr_stmt><expr><name>cWait</name> <operator>=</operator> <name>cin</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>qss</name> <operator>=</operator> <name>QSS_HasDark</name> <operator>|</operator> <name>cWait</name></expr>;</expr_stmt>
        <goto>goto <name>TermScan</name>;</goto>
      <default>default:</default>
        <break>break;</break>
      </block_content>}</block></switch>
      <expr_stmt><expr><name>qss</name> <operator>=</operator> <operator>(</operator><name>qss</name> <operator>&amp;</operator> <operator>~</operator><name>QSS_EndingSemi</name><operator>)</operator> <operator>|</operator> <name>QSS_HasDark</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if><else>else<block>{<block_content>
  <label><name>TermScan</name>:</label>
    <while>while<condition>( <expr><operator>(</operator><name>cin</name> <operator>=</operator> <operator>*</operator><name>zLine</name><operator>++</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>cin</name><operator>==</operator><name>cWait</name></expr> )</condition><block>{<block_content>
        <switch>switch<condition>( <expr><name>cWait</name></expr> )</condition><block>{<block_content>
        <case>case <expr><literal type="char">'*'</literal></expr>:</case>
          <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zLine</name> <operator>!=</operator> <literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
          <expr_stmt><expr><operator>++</operator><name>zLine</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cWait</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>qss</name> <operator>=</operator> <call><name>QSS_SETV</name><argument_list>(<argument><expr><name>qss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>PlainScan</name>;</goto>
        <case>case <expr><literal type="char">'`'</literal></expr>:</case> <case>case <expr><literal type="char">'\''</literal></expr>:</case> <case>case <expr><literal type="char">'"'</literal></expr>:</case>
          <if_stmt><if>if<condition>(<expr><operator>*</operator><name>zLine</name><operator>==</operator><name>cWait</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>zLine</name></expr>;</expr_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <comment type="block">/* fall thru */</comment>
        <case>case <expr><literal type="char">']'</literal></expr>:</case>
          <expr_stmt><expr><name>cWait</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>qss</name> <operator>=</operator> <call><name>QSS_SETV</name><argument_list>(<argument><expr><name>qss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>PlainScan</name>;</goto>
        <default>default:</default> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>qss</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the line typed in is an SQL command terminator other
** than a semi-colon.  The SQL Server style "go" command is understood
** as is the Oracle "/".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>line_is_command_terminator</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zLine</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while><empty_stmt>;</empty_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal></expr> )</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>zLine</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* Oracle */</comment>
  <if type="elseif">else if <condition>( <expr><call><name>ToLower</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'g'</literal> <operator>&amp;&amp;</operator> <call><name>ToLower</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'o'</literal></expr> )</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>zLine</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* SQL Server */</comment>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
  <return>return <expr><call><name>quickscan</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>QSS_Start</name></expr></argument>)</argument_list></call><operator>==</operator><name>QSS_Start</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** We need a default sqlite3_complete() implementation to use in case
** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
** any arbitrary text is a complete SQL statement.  This is not very
** user-friendly, but it does seem to work.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_COMPLETE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3_complete</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return true if zSql is a complete SQL statement.  Return false if it
** ends in the middle of a string literal or C-style comment.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>line_is_complete</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Run a single line of SQL.  Return the number of errors.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>runOneSqlLine</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startline</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>SHFLG_Backslash</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>resolve_backslashes</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flgProgress</name></name> <operator>&amp;</operator> <name>SHELL_PROGRESS_RESET</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nProgress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>BEGIN_TIMER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shell_exec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>END_TIMER</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>||</operator> <name>zErrMsg</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zPrefix</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErrorTail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErrorType</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErrMsg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErrorType</name> <operator>=</operator> <literal type="string">"Error"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErrorTail</name> <operator>=</operator> <call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><literal type="string">"in prepare, "</literal></expr></argument>,<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErrorType</name> <operator>=</operator> <literal type="string">"Parse error"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErrorTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>zErrMsg</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><literal type="string">"stepping, "</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zErrorType</name> <operator>=</operator> <literal type="string">"Runtime error"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErrorTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>zErrMsg</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zErrorType</name> <operator>=</operator> <literal type="string">"Error"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zErrorTail</name> <operator>=</operator> <name>zErrMsg</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>in</name><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>stdin_is_interactive</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>,
                       <argument><expr><literal type="string">"%s near line %d:"</literal></expr></argument>, <argument><expr><name>zErrorType</name></expr></argument>, <argument><expr><name>startline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>zErrorType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><name>zErrorTail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErrMsg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_CountChanges</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zLineBuf</name><index>[<expr><literal type="number">2000</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zLineBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zLineBuf</name></expr></argument>,
            <argument><expr><literal type="string">"changes: %lld   total_changes: %lld"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_changes64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_total_changes64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zLineBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>echo_group_input</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>ShellHasFlag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SHFLG_Echo</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>zDo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
<comment type="block">/*
** Alternate one_input_line() impl for wasm mode. This is not in the primary impl
** because we need the global shellState and cannot access it from that function
** without moving lots of code around (creating a larger/messier diff).
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>one_input_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zPrior</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isContinuation</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Parse the next line from shellState.wasm.zInput. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zBegin</name> <init>= <expr><name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zPos</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zBegin</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>nZ</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>isContinuation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>z</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>z</name></expr>)</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>(<expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>z</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>zBegin</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <for>for<control>(<init>;</init> <condition><expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <literal type="char">'\n'</literal><operator>!=</operator><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><operator>++</operator><name>nZ</name></expr><operator>,</operator> <expr><operator>++</operator><name>z</name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>(<expr><name>nZ</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="char">'\r'</literal><operator>==</operator><name><name>zBegin</name><index>[<expr><name>nZ</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><operator>--</operator><name>nZ</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zPos</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zLine</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>zPrior</name></expr></argument>, <argument><expr><name>nZ</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>zBegin</name></expr></argument>, <argument><expr><name>nZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>nZ</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>zLine</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SHELL_FIDDLE */</comment>

<comment type="block">/*
** Read input from *in and process it.  If *in==0 then input
** is interactive - the user is typing it it.  Otherwise, input
** is coming from a file or device.  A prompt is issued and history
** is saved only if input is interactive.  An interrupt signal will
** cause this routine to exit immediately, unless input is interactive.
**
** Return the number of errors.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>process_input</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* A single input line */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Accumulated SQL text */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nLine</name></decl>;</decl_stmt>                <comment type="block">/* Length of current line */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nSql</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Bytes of zSql[] used */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nAlloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Allocated zSql[] space */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                   <comment type="block">/* Error code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Number of errors seen */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>startline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Line number for start of current input */</comment>
  <decl_stmt><decl><type><name>QuickScanState</name></type> <name>qss</name> <init>= <expr><name>QSS_Start</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Accumulated line status (so far) */</comment>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>inputNesting</name></name><operator>==</operator><name>MAX_INPUT_NESTING</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This will be more informative in a later version. */</comment>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Input nesting limit (%d) reached at line %d."</literal>
                <literal type="string">" Check recursion.\n"</literal></expr></argument>, <argument><expr><name>MAX_INPUT_NESTING</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><name><name>p</name><operator>-&gt;</operator><name>inputNesting</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>errCnt</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>bail_on_error</name> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>stdin_is_interactive</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zLine</name> <operator>=</operator> <call><name>one_input_line</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nSql</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zLine</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* End of input */</comment>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>stdin_is_interactive</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>seenInterrupt</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>seenInterrupt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>QSS_INPLAIN</name><argument_list>(<argument><expr><name>qss</name></expr></argument>)</argument_list></call>
        <operator>&amp;&amp;</operator> <call><name>line_is_command_terminator</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call>
        <operator>&amp;&amp;</operator> <call><name>line_is_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>,<argument><expr><literal type="string">";"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>qss</name> <operator>=</operator> <call><name>quickscan</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>qss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>QSS_PLAINWHITE</name><argument_list>(<argument><expr><name>qss</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Just swallow single-line whitespace */</comment>
      <expr_stmt><expr><call><name>echo_group_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>qss</name> <operator>=</operator> <name>QSS_Start</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zLine</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal> <operator>||</operator> <name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'#'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>nSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>echo_group_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zLine</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>do_meta_command</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content> <comment type="block">/* exit requested */</comment>
          <break>break;</break>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>errCnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>qss</name> <operator>=</operator> <name>QSS_Start</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* No single-line dispositions remain; accumulate line(s). */</comment>
    <expr_stmt><expr><name>nLine</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSql</name><operator>+</operator><name>nLine</name><operator>+</operator><literal type="number">2</literal><operator>&gt;=</operator><name>nAlloc</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Grow buffer by half-again increments when big. */</comment>
      <expr_stmt><expr><name>nAlloc</name> <operator>=</operator> <name>nSql</name><operator>+</operator><operator>(</operator><name>nSql</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>nLine</name><operator>+</operator><literal type="number">100</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSql</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAlloc</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zSql</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zLine</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>nLine</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>startline</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> <operator>=</operator> <name>nLine</name><operator>-</operator><name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zSql</name><operator>+</operator><name>nSql</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nLine</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> <operator>+=</operator> <name>nLine</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nSql</name> <operator>&amp;&amp;</operator> <call><name>QSS_SEMITERM</name><argument_list>(<argument><expr><name>qss</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>echo_group_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errCnt</name> <operator>+=</operator> <call><name>runOneSqlLine</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>startline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>clearTempFile</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bSafeMode</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>bSafeModePersist</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>qss</name> <operator>=</operator> <name>QSS_Start</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nSql</name> <operator>&amp;&amp;</operator> <call><name>QSS_PLAINWHITE</name><argument_list>(<argument><expr><name>qss</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>echo_group_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>qss</name> <operator>=</operator> <name>QSS_Start</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>nSql</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This may be incomplete. Let the SQL parser deal with that. */</comment>
    <expr_stmt><expr><call><name>echo_group_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>errCnt</name> <operator>+=</operator> <call><name>runOneSqlLine</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>startline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>inputNesting</name></name></expr>;</expr_stmt>
  <return>return <expr><name>errCnt</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pathname which is the user's home directory.  A
** 0 return indicates an error of some kind.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_home_dir</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>clearFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>home_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>clearFlag</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>home_dir</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>home_dir</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call> \
     <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pwent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name> <init>= <expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>pwent</name><operator>=</operator><call><name>getpwuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <name><name>pwent</name><operator>-&gt;</operator><name>pw_dir</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()
   */</comment>
  <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <literal type="string">"/"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>home_dir</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"USERPROFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>home_dir</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>home_dir</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zDrive</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zDrive</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOMEDRIVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOMEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zDrive</name> <operator>&amp;&amp;</operator> <name>zPath</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zDrive</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>home_dir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>home_dir</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>zDrive</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>home_dir</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <literal type="string">"c:\\"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !_WIN32_WCE */</comment>

  <if_stmt><if>if<condition>( <expr><name>home_dir</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>i64</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>home_dir</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>home_dir</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read input from the file given by sqliterc_override.  Or if that
** parameter is NULL, take input from ~/.sqliterc
**
** Returns the number of errors.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>process_sqliterc</name><parameter_list>(
  <parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                  <comment type="block">/* Configuration data */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqliterc_override</name></decl></parameter>   <comment type="block">/* Name of config file. NULL to use default */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>home_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqliterc</name> <init>= <expr><name>sqliterc_override</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>inSaved</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>savedLineno</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>sqliterc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>home_dir</name> <operator>=</operator> <call><name>find_home_dir</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>home_dir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"-- warning: cannot find home directory;"</literal>
                      <literal type="string">" cannot read ~/.sqliterc\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s/.sqliterc"</literal></expr></argument>,<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqliterc</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>sqliterc</name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>stdin_is_interactive</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"-- Loading resources from %s\n"</literal></expr></argument>,<argument><expr><name>sqliterc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>process_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bail_on_error</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>sqliterc_override</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"cannot open: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>sqliterc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>bail_on_error</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <name>inSaved</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>savedLineno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Show available command line options
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zOptions</name><index>[]</index></name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><literal type="string">"   -A ARGS...           run \".archive ARGS\" and exit\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -append              append the database to the end of the file\n"</literal>
  <literal type="string">"   -ascii               set output mode to 'ascii'\n"</literal>
  <literal type="string">"   -bail                stop after hitting an error\n"</literal>
  <literal type="string">"   -batch               force batch I/O\n"</literal>
  <literal type="string">"   -box                 set output mode to 'box'\n"</literal>
  <literal type="string">"   -column              set output mode to 'column'\n"</literal>
  <literal type="string">"   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"</literal>
  <literal type="string">"   -csv                 set output mode to 'csv'\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DESERIALIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <literal type="string">"   -deserialize         open the database using sqlite3_deserialize()\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -echo                print inputs before execution\n"</literal>
  <literal type="string">"   -init FILENAME       read/process named file\n"</literal>
  <literal type="string">"   -[no]header          turn headers on or off\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS5</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <literal type="string">"   -heap SIZE           Size of heap for memsys3 or memsys5\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -help                show this message\n"</literal>
  <literal type="string">"   -html                set output mode to HTML\n"</literal>
  <literal type="string">"   -interactive         force interactive I/O\n"</literal>
  <literal type="string">"   -json                set output mode to 'json'\n"</literal>
  <literal type="string">"   -line                set output mode to 'line'\n"</literal>
  <literal type="string">"   -list                set output mode to 'list'\n"</literal>
  <literal type="string">"   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n"</literal>
  <literal type="string">"   -markdown            set output mode to 'markdown'\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DESERIALIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <literal type="string">"   -maxsize N           maximum size for a --deserialize database\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -memtrace            trace all memory allocations and deallocations\n"</literal>
  <literal type="string">"   -mmap N              default mmap size set to N\n"</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MULTIPLEX</name></cpp:ifdef>
  <literal type="string">"   -multiplex           enable the multiplexor VFS\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -newline SEP         set output row separator. Default: '\\n'\n"</literal>
  <literal type="string">"   -nofollow            refuse to open symbolic links to database files\n"</literal>
  <literal type="string">"   -nonce STRING        set the safe-mode escape nonce\n"</literal>
  <literal type="string">"   -nullvalue TEXT      set text string for NULL values. Default ''\n"</literal>
  <literal type="string">"   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n"</literal>
  <literal type="string">"   -quote               set output mode to 'quote'\n"</literal>
  <literal type="string">"   -readonly            open the database read-only\n"</literal>
  <literal type="string">"   -safe                enable safe-mode\n"</literal>
  <literal type="string">"   -separator SEP       set output column separator. Default: '|'\n"</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
  <literal type="string">"   -sorterref SIZE      sorter references threshold size\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <literal type="string">"   -stats               print memory stats before each finalize\n"</literal>
  <literal type="string">"   -table               set output mode to 'table'\n"</literal>
  <literal type="string">"   -tabs                set output mode to 'tabs'\n"</literal>
  <literal type="string">"   -version             show SQLite version\n"</literal>
  <literal type="string">"   -vfs NAME            use NAME as the default VFS\n"</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_VFSTRACE</name></cpp:ifdef>
  <literal type="string">"   -vfstrace            enable tracing of all VFS calls\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
  <literal type="string">"   -zip                 open the file as a ZIP Archive\n"</literal></expr></init></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>showDetail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr><literal type="string">"Usage: %s [OPTIONS] FILENAME [SQL]\n"</literal>
      <literal type="string">"FILENAME is the name of an SQLite database. A new database is created\n"</literal>
      <literal type="string">"if the file does not previously exist.\n"</literal></expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>showDetail</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"OPTIONS include:\n%s"</literal></expr></argument>, <argument><expr><name>zOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Use the -help option for additional information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Internal check:  Verify that the SQLite is uninitialized.  Print a
** error message if it is initialized.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>verify_uninitialized</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_MISUSE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"WARNING: attempt to configure SQLite after"</literal>
                        <literal type="string">" initialization.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the state information in data
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>main_init</name><parameter_list>(<parameter><decl><type><name>ShellState</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>normalMode</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>MODE_List</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>autoExplain</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pAuxDb</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>aAuxDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>colSeparator</name></name></expr></argument>,<argument><expr><name>SEP_Column</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>rowSeparator</name></name></expr></argument>,<argument><expr><name>SEP_Row</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>shellFlgs</name></name> <operator>=</operator> <name>SHFLG_Lookaside</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>verify_uninitialized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_URI</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_LOG</name></expr></argument>, <argument><expr><name>shellLog</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MULTITHREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>mainPrompt</name></expr></argument>,<argument><expr><literal type="string">"sqlite&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>continuePrompt</name></expr></argument>,<argument><expr><literal type="string">"   ...&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Output text to the console in a font that attracts extra attention.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printBold</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>out</name> <init>= <expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_OUTPUT_HANDLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CONSOLE_SCREEN_BUFFER_INFO</name></type> <name>defaultScreenInfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetConsoleScreenBufferInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defaultScreenInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetConsoleTextAttribute</name><argument_list>(<argument><expr><name>out</name></expr></argument>,
         <argument><expr><name>FOREGROUND_RED</name><operator>|</operator><name>FOREGROUND_INTENSITY</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <expr_stmt><expr><call><name>SetConsoleTextAttribute</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>defaultScreenInfo</name><operator>.</operator><name>wAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printBold</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\033[1m%s\033[0m"</literal></expr></argument>, <argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Get the argument to an --option.  Throw an error and die if no argument
** is available.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdline_option_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Error: missing argument to %s\n"</literal></expr></argument>,
            <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_IS_UTF8</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> \
   <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNICODE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SHELL_IS_UTF8</name></cpp:macro>          <cpp:value>(0)</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_SHELL_IS_UTF8</name></cpp:macro>          <cpp:value>(1)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>main</name></cpp:macro> <cpp:value>fiddle_main</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_SHELL_IS_UTF8</name></expr></cpp:if>
<function><type><name>int</name> <name>SQLITE_CDECL</name></type> <name>sqlite3_shell_main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name> <name>SQLITE_CDECL</name></type> <name>wmain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>wargv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>mem_main_enter</name> <init>= <expr><call><name>sqlite3_memory_used</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>data</name></cpp:macro> <cpp:value>shellState</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ShellState</name></type> <name>data</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInitFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>warnInmemoryDb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>readStdin</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCmd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azCmd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Value of -vfs command-line option */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_SHELL_IS_UTF8</name></expr></cpp:if>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argvToFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>argcToFree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>setBinaryMode</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Make sure stderr is unbuffered */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
  <expr_stmt><expr><name>stdin_is_interactive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>stdout_is_console</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zDefaultDbName</name></name> <operator>=</operator> <literal type="string">"/fiddle.sqlite3"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>stdin_is_interactive</name> <operator>=</operator> <call><name>isatty</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stdout_is_console</name> <operator>=</operator> <call><name>isatty</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"SQLITE_DEBUG_BREAK"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>isatty</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isatty</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
          <argument><expr><literal type="string">"attach debugger to process %d and press any key to continue.\n"</literal></expr></argument>,
          <argument><expr><call><name>GETPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fgetc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
      <expr_stmt><expr><call><name>__debugbreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>DebugBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_SYSTEM_SQLITE</name><operator>+</operator><literal type="number">0</literal><operator>!=</operator><literal type="number">1</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>SQLITE_SOURCE_ID</name></expr></argument>,<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"SQLite header and source version mismatch\n%s\n%s\n"</literal></expr></argument>,
            <argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_SOURCE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>main_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* On Windows, we must translate command-line arguments into UTF-8.
  ** The SQLite memory allocator subsystem has to be enabled in order to
  ** do this.  But we want to run an sqlite3_shutdown() afterwards so that
  ** subsequent sqlite3_config() calls will work.  So copy all results into
  ** memory that does not come from the SQLite memory allocator.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_SHELL_IS_UTF8</name></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>argvToFree</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>argvToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>argcToFree</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>argv</name> <operator>=</operator> <name>argvToFree</name> <operator>+</operator> <name>argc</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_win32_unicode_to_utf8</name><argument_list>(<argument><expr><name><name>wargv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argvToFree</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>argv</name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>Argv0</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Make sure we have a valid signal handler early, before anything
  ** else is done.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>interrupt_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><call><name>SetConsoleCtrlHandler</name><argument_list>(<argument><expr><name>ConsoleCtrlHandler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_DBNAME_PROC</name></cpp:ifdef>
  <block>{<block_content>
    <comment type="block">/* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name
    ** of a C-function that will provide the name of the database file.  Use
    ** this compile-time option to embed this shell program in larger
    ** applications. */</comment>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>SQLITE_SHELL_DBNAME_PROC</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SQLITE_SHELL_DBNAME_PROC</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>warnInmemoryDb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do an initial pass through the command-line argument to locate
  ** the name of the database file, the name of the initialization file,
  ** the size of the alternative malloc heap,
  ** and the first command to execute.
  */</comment>
  <expr_stmt><expr><call><name>verify_uninitialized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>data</name><operator>.</operator><name>aAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>data</name><operator>.</operator><name>aAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Excesss arguments are interpreted as SQL (or dot-commands) and
        ** mean that nothing is read from stdin */</comment>
        <expr_stmt><expr><name>readStdin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCmd</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>azCmd</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>azCmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_check_oom</name><argument_list>(<argument><expr><name>azCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>azCmd</name><index>[<expr><name>nCmd</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-separator"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nullvalue"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-newline"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
     <operator>||</operator> <call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-cmd"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-init"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zInitFile</name> <operator>=</operator> <call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-batch"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Need to check for batch mode here to so we can avoid printing
      ** informational messages (like from process_sqliterc) before
      ** we do the actual processing of arguments later in a second pass.
      */</comment>
      <expr_stmt><expr><name>stdin_is_interactive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-heap"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS5</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSize</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>szHeap</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>zSize</name> <operator>=</operator> <call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>szHeap</name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name>zSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>szHeap</name><operator>&gt;</operator><literal type="number">0x7fff0000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szHeap</name> <operator>=</operator> <literal type="number">0x7fff0000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_HEAP</name></expr></argument>, <argument><expr><call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>szHeap</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>szHeap</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-pagecache"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&gt;</operator><literal type="number">70000</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">70000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0xffffffffffffLL</literal><operator>/</operator><name>sz</name><operator>&lt;</operator><name>n</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0xffffffffffffLL</literal><operator>/</operator><name>sz</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_PAGECACHE</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><operator>(</operator><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sz</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>malloc</name><argument_list>(<argument><expr><name>n</name><operator>*</operator><name>sz</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>shellFlgs</name></name> <operator>|=</operator> <name>SHFLG_Pagecache</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-lookaside"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_LOOKASIDE</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>sz</name><operator>*</operator><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>data</name><operator>.</operator><name>shellFlgs</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SHFLG_Lookaside</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-threadsafe"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name>n</name></expr> )</condition><block>{<block_content>
         <case>case <expr><literal type="number">0</literal></expr>:</case>  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_SINGLETHREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <break>break;</break>
         <case>case <expr><literal type="number">2</literal></expr>:</case>  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MULTITHREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <break>break;</break>
         <default>default:</default> <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_SERIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <break>break;</break>
      </block_content>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_VFSTRACE</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-vfstrace"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>vfstrace_register</name><argument_list>(
         <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>zTraceName</name></expr></argument>,
         <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>zOldVfsName</name></expr></argument>,
         <argument><expr><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><name>xOut</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>void</name> <operator>*</operator><name>pOutArg</name></expr></argument>,
         <argument><expr><name>int</name> <name>makeDefault</name></expr></argument>
      )</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>vfstrace_register</name><argument_list>(<argument><expr><literal type="string">"trace"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><call><call><name>int</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>fputs</name></expr></argument>,<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MULTIPLEX</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-multiplex"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sqlite3_multiple_initialize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_multiplex_initialize</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-mmap"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_MMAP_SIZE</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-sorterref"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name> <init>= <expr><call><name>integerValue</name><argument_list>(<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_SORTERREF_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-vfs"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zVfs</name> <operator>=</operator> <call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-zip"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_ZIPFILE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-append"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_APPENDVFS</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-deserialize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_DESERIALIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-maxsize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>argc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>szMax</name></name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-readonly"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_READONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nofollow"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openFlags</name></name> <operator>=</operator> <name>SQLITE_OPEN_NOFOLLOW</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-A"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* All remaining command-line arguments are passed to the ".archive"
      ** command, so ignore them */</comment>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-memtrace"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3MemTraceActivate</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-bail"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>bail_on_error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nonce"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>zNonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>zNonce</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-safe"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* no-op - catch this on the second pass */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>verify_uninitialized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_INIT_PROC</name></cpp:ifdef>
  <block>{<block_content>
    <comment type="block">/* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name
    ** of a C-function that will perform initialization actions on SQLite that
    ** occur just before or after sqlite3_initialize(). Use this compile-time
    ** option to embed this shell program in larger applications. */</comment>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>SQLITE_SHELL_INIT_PROC</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SQLITE_SHELL_INIT_PROC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* All the sqlite3_config() calls have now been made. So it is safe
  ** to call sqlite3_initialize() and process any command line -vfs option. */</comment>
  <expr_stmt><expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>zVfs</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name> <init>= <expr><call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVfs</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no such VFS: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>data</name><operator>.</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifndef>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name> <operator>=</operator> <literal type="string">":memory:"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>warnInmemoryDb</name> <operator>=</operator> <name>argc</name><operator>==</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s: Error: no database filename specified\n"</literal></expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>data</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3_appendvfs_init</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Go ahead and open the database file if it already exists.  If the
  ** file does not exist, delay opening it.  This prevents empty database
  ** files from being created if a user mistypes the database name argument
  ** to the sqlite command-line tool.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>pAuxDb</name><operator>-&gt;</operator><name>zDbFilename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process the initialization file if there is one.  If no -init option
  ** is given on the command line, look for a file named ~/.sqliterc and
  ** try to process it.
  */</comment>
  <expr_stmt><expr><call><name>process_sqliterc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,<argument><expr><name>zInitFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a second pass through the command-line argument and set
  ** options.  This second pass is delayed until after the initialization
  ** file is processed so that the command-line arguments will override
  ** settings in the initialization file.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-init"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-html"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Html</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-list"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_List</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-quote"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Quote</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-line"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Line</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-column"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Column</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-json"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Json</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-markdown"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Markdown</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-table"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Table</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-box"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Box</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-csv"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Csv</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>,<argument><expr><literal type="string">","</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAVE_ZLIB</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-zip"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_ZIPFILE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-append"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_APPENDVFS</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DESERIALIZE</name></cpp:ifndef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-deserialize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_DESERIALIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-maxsize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>argc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>szMax</name></name> <operator>=</operator> <call><name>integerValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-readonly"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openMode</name></name> <operator>=</operator> <name>SHELL_OPEN_READONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nofollow"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>openFlags</name></name> <operator>|=</operator> <name>SQLITE_OPEN_NOFOLLOW</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-ascii"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_Ascii</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-tabs"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MODE_List</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>, <argument><expr><name>SEP_Row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-separator"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>colSeparator</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-newline"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>rowSeparator</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nullvalue"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>nullValue</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>nullValue</name></name></expr></argument>,
                       <argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-header"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>SHFLG_HeaderSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-noheader"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>showHeader</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>SHFLG_HeaderSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-echo"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>SHFLG_Echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-eqp"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_on</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-eqpfull"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>autoEQP</name></name> <operator>=</operator> <name>AUTOEQP_full</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-stats"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>statsOn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-scanstats"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>scanstatsOn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-backslash"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Undocumented command-line option: -backslash
      ** Causes C-style backslash escapes to be evaluated in SQL statements
      ** prior to sending the SQL into SQLite.  Useful for injecting
      ** crazy bytes in the middle of SQL statements for testing and debugging.
      */</comment>
      <expr_stmt><expr><call><name>ShellSetFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>SHFLG_Backslash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-bail"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* No-op.  The bail_on_error flag should already be set. */</comment>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-version"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-interactive"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>stdin_is_interactive</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-batch"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>stdin_is_interactive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-heap"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-pagecache"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-lookaside"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-threadsafe"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-nonce"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-mmap"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-memtrace"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_SORTER_REFERENCES</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-sorterref"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-vfs"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_VFSTRACE</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-vfstrace"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MULTIPLEX</name></cpp:ifdef>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-multiplex"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-help"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-cmd"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Run commands that follow -cmd first and separately from commands
      ** that simply appear on the command-line.  This seems goofy.  It would
      ** be better if all commands ran in the order that they appear.  But
      ** we retain the goofy behavior for historical compatibility. */</comment>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>argc</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>cmdline_option_value</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>do_meta_command</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <name>bail_on_error</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shell_exec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zErrMsg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bail_on_error</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: unable to process SQL \"%s\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>bail_on_error</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_ZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"-A"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>nCmd</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot mix regular SQL or dot-commands"</literal>
                            <literal type="string">" with \"%s\"\n"</literal></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>OPEN_DB_ZIPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>arDotCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><operator>(</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><operator>(</operator><name>i</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>arDotCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>readStdin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>cli_strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr><literal type="string">"-safe"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>bSafeMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>bSafeModePersist</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"%s: Error: unknown option: %s\n"</literal></expr></argument>, <argument><expr><name>Argv0</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>raw_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Use -help for a list of options.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cMode</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>mode</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>readStdin</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Run all arguments that do not begin with '-' as if they were separate
    ** command-line inputs, except for the argToSkip argument which contains
    ** the database filename.
    */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nCmd</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>azCmd</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>do_meta_command</name><argument_list>(<argument><expr><name><name>azCmd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>shell_exec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zErrMsg</name> <operator>||</operator> <name>rc</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>zErrMsg</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: unable to process SQL: %s\n"</literal></expr></argument>, <argument><expr><name><name>azCmd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><ternary><condition><expr><name>rc</name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Run commands received from standard input
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>stdin_is_interactive</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zHome</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zHistory</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nHistory</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>print_FTL_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(
        <argument><expr><literal type="string">"SQLite version %s %.19s\n"</literal> <comment type="block">/*extra-version-info*/</comment>
        <literal type="string">"Enter \".help\" for usage hints.\n"</literal></expr></argument>,
        <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>warnInmemoryDb</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Connected to a "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printBold</name><argument_list>(<argument><expr><literal type="string">"transient in-memory database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">".\nUse \".open FILENAME\" to reopen on a "</literal>
               <literal type="string">"persistent database.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zHistory</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"SQLITE_HISTORY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zHistory</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zHistory</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zHome</name> <operator>=</operator> <call><name>find_home_dir</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nHistory</name> <operator>=</operator> <call><name>strlen30</name><argument_list>(<argument><expr><name>zHome</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zHistory</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nHistory</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nHistory</name></expr></argument>, <argument><expr><name>zHistory</name></expr></argument>,<argument><expr><literal type="string">"%s/.sqlite_history"</literal></expr></argument>, <argument><expr><name>zHome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zHistory</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>shell_read_history</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_READLINE</name> <operator>||</operator> <name>HAVE_EDITLINE</name></expr></cpp:if>
      <expr_stmt><expr><name>rl_attempted_completion_function</name> <operator>=</operator> <name>readline_completion</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_LINENOISE</name></expr></cpp:elif>
      <expr_stmt><expr><call><name>linenoiseSetCompletionCallback</name><argument_list>(<argument><expr><name>linenoise_completion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zHistory</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>shell_stifle_history</name><argument_list>(<argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shell_write_history</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>data</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifndef>
  <comment type="block">/* In WASM mode we have to leave the db state in place so that
  ** client code can "push" SQL into it after this call returns. */</comment>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_table_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>data</name><operator>.</operator><name>db</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>session_close_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>aAuxDb</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zFreeOnClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>data</name><operator>.</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>session_close_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close_db</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>aAuxDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>find_home_dir</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>output_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><operator>.</operator><name>doXdgOpen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>clearTempFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_SHELL_IS_UTF8</name></expr></cpp:if>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argcToFree</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>argvToFree</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argvToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>colWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>zNonce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Clear the global data structure so that valgrind will detect memory
  ** leaks */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_memory_used</name><argument_list>()</argument_list></call><operator>&gt;</operator><name>mem_main_enter</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>utf8_printf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Memory leaked: %u bytes\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><call><name>sqlite3_memory_used</name><argument_list>()</argument_list></call><operator>-</operator><name>mem_main_enter</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_SHELL_FIDDLE */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SHELL_FIDDLE</name></cpp:ifdef>
<comment type="block">/* Only for emcc experimentation purposes. */</comment>
<function><type><name>int</name></type> <name>fiddle_experiment</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>a</name> <operator>+</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Returns a pointer to the current DB handle.
*/</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type> <name>fiddle_db_handle</name><parameter_list>()</parameter_list><block>{<block_content>
  <return>return <expr><name>globalDb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Returns a pointer to the given DB name's VFS. If zDbName is 0 then
** "main" is assumed. Returns 0 if no db with the given name is
** open.
*/</comment>
<function><type><name>sqlite3_vfs</name> <modifier>*</modifier></type> <name>fiddle_db_vfs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type> <name>pVfs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><name>globalDb</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zDbName</name></expr> ?</condition><then> <expr><name>zDbName</name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></argument>,
                         <argument><expr><name>SQLITE_FCNTL_VFS_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pVfs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Only for emcc experimentation purposes. */</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type> <name>fiddle_db_arg</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"fiddle_db_arg(%p)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>arg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Intended to be called via a SharedWorker() while a separate
** SharedWorker() (which manages the wasm module) is performing work
** which should be interrupted. Unfortunately, SharedWorker is not
** portable enough to make real use of.
*/</comment>
<function><type><name>void</name></type> <name>fiddle_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>globalDb</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Returns the filename of the given db name, assuming "main" if
** zDbName is NULL. Returns NULL if globalDb is not opened.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>fiddle_db_filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zDbName</name></decl></parameter>)</parameter_list><block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>globalDb</name></expr>
      ?</condition><then> <expr><call><name>sqlite3_db_filename</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zDbName</name></expr> ?</condition><then> <expr><name>zDbName</name></expr> </then><else>: <expr><literal type="string">"main"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>
      </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Completely wipes out the contents of the currently-opened database
** but leaves its storage intact for reuse.
*/</comment>
<function><type><name>void</name></type> <name>fiddle_reset_db</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>globalDb</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_db_config</name><argument_list>(<argument><expr><name>globalDb</name></expr></argument>, <argument><expr><name>SQLITE_DBCONFIG_RESET_DATABASE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Uses the current database's VFS xRead to stream the db file's
** contents out to the given callback. The callback gets a single
** chunk of size n (its 2nd argument) on each call and must return 0
** on success, non-0 on error. This function returns 0 on success,
** SQLITE_NOTFOUND if no db is open, or propagates any other non-0
** code from the callback. Note that this is not thread-friendly: it
** expects that it will be the only thread reading the db file and
** takes no measures to ensure that is the case.
*/</comment>
<function><type><name>int</name></type> <name>fiddle_export_db</name><parameter_list>( <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xCallback</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list></function_decl></parameter> )</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type> <name>pFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><ternary><condition><expr><name><name>shellState</name><operator>.</operator><name>db</name></name></expr>
    ?</condition><then> <expr><call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>shellState</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>,
                           <argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>)</argument_list></call></expr>
    </then><else>: <expr><name>SQLITE_NOTFOUND</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>(<expr><name>nSize</name> <operator>%</operator> <name>nBuf</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* DB size is not an even multiple of the buffer size. Reduce
    ** buffer size so that we do not unduly inflate the db size when
    ** exporting. */</comment>
    <if_stmt><if>if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">2048</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">2048</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nSize</name> <operator>%</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>( <init>;</init> <condition><expr><literal type="number">0</literal><operator>==</operator><name>rc</name> <operator>&amp;&amp;</operator> <name>nPos</name><operator>&lt;</operator><name>nSize</name></expr>;</condition> <incr><expr><name>nPos</name> <operator>+=</operator> <name>nBuf</name></expr></incr> )</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pFile</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>nPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>SQLITE_IOERR_SHORT_READ</name> <operator>==</operator> <name>rc</name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nPos</name> <operator>+</operator> <name>nBuf</name><operator>)</operator> <operator>&lt;</operator> <name>nSize</name></expr> ?</condition><then> <expr><name>rc</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr><comment type="block">/*assume EOF*/</comment>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xCallback</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Trivial exportable function for emscripten. It processes zSql as if
** it were input to the sqlite3 shell and redirects all output to the
** wasm binding. fiddle_main() must have been called before this
** is called, or results are undefined.
*/</comment>
<function><type><name>void</name></type> <name>fiddle_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zSql</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>(<expr><name>zSql</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>zSql</name></expr>)</condition><block>{<block_content>
    <if_stmt><if>if<condition>(<expr><literal type="char">'.'</literal><operator>==</operator><operator>*</operator><name>zSql</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zInput</name></name> <operator>=</operator> <name>zSql</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zPos</name></name> <operator>=</operator> <name>zSql</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>process_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shellState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zInput</name></name> <operator>=</operator> <name><name>shellState</name><operator>.</operator><name>wasm</name><operator>.</operator><name>zPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function></block_content></block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SHELL_FIDDLE */</comment></unit>
