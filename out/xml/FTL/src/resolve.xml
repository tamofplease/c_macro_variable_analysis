<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/resolve.c"><comment type="block">/* Pi-hole: A black hole for Internet advertisements
*  (c) 2017 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  FTL Engine
*  DNS Client Implementation
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FTL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"resolve.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shmem.h"</cpp:file></cpp:include>
<comment type="line">// struct config</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<comment type="line">// sleepms()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timers.h"</cpp:file></cpp:include>
<comment type="line">// logg()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<comment type="line">// global variable killed</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"signals.h"</cpp:file></cpp:include>
<comment type="line">// getDatabaseHostname()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/network-table.h"</cpp:file></cpp:include>
<comment type="line">// struct _res</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;resolv.h&gt;</cpp:file></cpp:include>
<comment type="line">// resolveNetworkTableNames()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/network-table.h"</cpp:file></cpp:include>
<comment type="line">// resolver_ready</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"daemon.h"</cpp:file></cpp:include>
<comment type="line">// logg_hostname_warning()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/message-table.h"</cpp:file></cpp:include>
<comment type="line">// Eventqueue routines</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"events.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>res_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="line">// Validate given hostname</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>valid_hostname</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>clientip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Check for validity of input</comment>
	<if_stmt><if>if<condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Check for maximum length of hostname</comment>
	<comment type="line">// Truncate if too long (MAXHOSTNAMELEN defaults to 64, see asm-generic/param.h)</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXHOSTNAMELEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARNING: Hostname of client %s too long, truncating to %d chars!"</literal></expr></argument>,
		     <argument><expr><name>clientip</name></expr></argument>, <argument><expr><name>MAXHOSTNAMELEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// We can modify the string in-place as the target is</comment>
		<comment type="line">// shorter than the source</comment>
		<expr_stmt><expr><name><name>name</name><index>[<expr><name>MAXHOSTNAMELEN</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Iterate over characters in hostname</comment>
	<comment type="line">// to check for legal char: A-Z a-z 0-9 - _ .</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator>
		    <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
		    <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>
			 <name>c</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator>
			 <name>c</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator>
			 <name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr> )</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="line">// Invalid character found, log and return hostname being invalid</comment>
		<expr_stmt><expr><call><name>logg_hostname_warning</name><argument_list>(<argument><expr><name>clientip</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></for>

	<comment type="line">// No invalid characters found</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_used_resolvers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>MAXNS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>in_port_t</name></type> <name>port</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MAXNS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Regular name servers (IPv4)</comment>

			<comment type="line">// Some of the entries may not be configured</comment>
			<if_stmt><if>if<condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>_res</name><operator>.</operator><name>nscount</name></name> <operator>||</operator> <name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sin_family</name> <operator>!=</operator> <name>AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="line">// IPv4 name servers</comment>
			<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>&amp;</operator><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sin_addr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sin_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>family</name> <operator>=</operator> <name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sin_family</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// Extension name servers (IPv6)</comment>
			<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>MAXNS</name></expr>;</expr_stmt>
			<comment type="line">// Some of the entries may not be configured</comment>
			<if_stmt><if>if<condition>(<expr><name><name>_res</name><operator>.</operator><name>_u</name><operator>.</operator><name>_ext</name><operator>.</operator><name>nsaddrs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			   <name><name>_res</name><operator>.</operator><name>_u</name><operator>.</operator><name>_ext</name><operator>.</operator><name>nsaddrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>sin6_family</name> <operator>!=</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>&amp;</operator><name><name>_res</name><operator>.</operator><name>_u</name><operator>.</operator><name>_ext</name><operator>.</operator><name>nsaddrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>sin6_addr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>_res</name><operator>.</operator><name>_u</name><operator>.</operator><name>_ext</name><operator>.</operator><name>nsaddrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>sin6_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>family</name> <operator>=</operator> <name><name>_res</name><operator>.</operator><name>_u</name><operator>.</operator><name>_ext</name><operator>.</operator><name>nsaddrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>sin6_family</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="line">// Convert nameserver information to human-readable form</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>nsname</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nsname</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" %s %u: %s:%d (IPv%i)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXNS</name></expr> ?</condition><then> <expr><literal type="string">"   "</literal></expr> </then><else>: <expr><literal type="string">"EXT"</literal></expr></else></ternary></expr></argument>,
		     <argument><expr><name>j</name></expr></argument>, <argument><expr><name>nsname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">6</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Return if we want to resolve address to names at all</comment>
<comment type="line">// (may be disabled due to config settings)</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>pure</name><operator>)</operator></expr></argument>)</argument_list> <name>resolve_names</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>resolveIPv4</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>config</name><operator>.</operator><name>resolveIPv6</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="line">// Return if we want to resolve this type of address to a name</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>pure</name><operator>)</operator></expr></argument>)</argument_list> <name>resolve_this_name</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>ipaddr</name></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>resolveIPv4</name></name> <operator>||</operator>
	  <operator>(</operator><operator>!</operator><name><name>config</name><operator>.</operator><name>resolveIPv6</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>char</name> <modifier>*</modifier></type><name>resolveHostname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Get host name</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Trying to resolve %s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Check if this is a hidden client</comment>
	<comment type="line">// if so, return "hidden" as hostname</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="string">"0.0.0.0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"hidden"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"---&gt; \"%s\" (privacy settings)"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>hostname</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if this is the internal client</comment>
	<comment type="line">// if so, return "hidden" as hostname</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="string">"::"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"pi.hole"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"---&gt; \"%s\" (special)"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>hostname</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if we want to resolve host names</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>resolve_this_name</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Configured to not resolve host name for %s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Return an empty host name</comment>
		<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Test if we want to resolve an IPv6 address</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>IPv6</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>IPv6</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Convert address into binary form</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>ss</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>IPv6</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get binary form of IPv6 address</comment>
		<expr_stmt><expr><name><name>ss</name><operator>.</operator><name>ss_family</name></name> <operator>=</operator> <name>AF_INET6</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>inet_pton</name><argument_list>(<argument><expr><name><name>ss</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name><operator>)</operator><operator>-&gt;</operator><name>sin6_addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Invalid IPv6 address when trying to resolve hostname: %s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Get binary form of IPv4 address</comment>
		<expr_stmt><expr><name><name>ss</name><operator>.</operator><name>ss_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>inet_pton</name><argument_list>(<argument><expr><name><name>ss</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name><operator>)</operator><operator>-&gt;</operator><name>sin_addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Invalid IPv4 address when trying to resolve hostname: %s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Initialize resolver subroutines if trying to resolve for the first time</comment>
	<comment type="line">// res_init() reads resolv.conf to get the default domain name and name server</comment>
	<comment type="line">// address(es). If no server is given, the local host is tried. If no domain</comment>
	<comment type="line">// is given, that associated with the local host is used.</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res_initialized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>res_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// INADDR_LOOPBACK is in host byte order, however, in_addr has to be in</comment>
	<comment type="line">// network byte order, convert it here if necessary</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>FTLaddr</name> <init>= <expr><block>{ <macro><name>htonl</name><argument_list>(<argument>INADDR_LOOPBACK</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>in_port_t</name></type> <name>FTLport</name> <init>= <expr><call><name>htons</name><argument_list>(<argument><expr><name><name>config</name><operator>.</operator><name>dns_port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Set FTL as system resolver only if not already the primary resolver</comment>
	<if_stmt><if>if<condition>(<expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>!=</operator> <name><name>FTLaddr</name><operator>.</operator><name>s_addr</name></name> <operator>||</operator> <name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sin_port</name> <operator>!=</operator> <name>FTLport</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Backup configured name servers and invalidate them</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name><name>ns_addr_bck</name><index>[<expr><name>MAXNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>in_port_t</name></type> <name><name>ns_port_bck</name><index>[<expr><name>MAXNS</name></expr>]</index></name></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXNS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ns_addr_bck</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sin_addr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ns_port_bck</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sin_port</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// 0.0.0.0</comment>
		</block_content>}</block></for>

		<comment type="line">// Set FTL at 127.0.0.1 as the only resolver</comment>
		<expr_stmt><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <name><name>FTLaddr</name><operator>.</operator><name>s_addr</name></name></expr>;</expr_stmt>
		<comment type="line">// Set resolver port</comment>
		<expr_stmt><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sin_port</name> <operator>=</operator> <name>FTLport</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>print_used_resolvers</name><argument_list>(<argument><expr><literal type="string">"Setting nameservers to:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Try to resolve address</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getnameinfo</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Check if getnameinfo() returned a host name</comment>
		<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>valid_hostname</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Return hostname copied to new memory location</comment>
				<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"[invalid host name]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"%s\" (found internally)"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"\" (not found internally: %s"</literal></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Restore resolvers (without forced FTL)</comment>
		<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXNS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sin_addr</name> <operator>=</operator> <name><name>ns_addr_bck</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>_res</name><operator>.</operator><name>nsaddr_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sin_port</name> <operator>=</operator> <name><name>ns_port_bck</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>print_used_resolvers</name><argument_list>(<argument><expr><literal type="string">"Setting nameservers back to default:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_used_resolvers</name><argument_list>(<argument><expr><literal type="string">"FTL already primary nameserver:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// If no host name was found before, try again with system-configured</comment>
	<comment type="line">// resolvers (necessary for docker and friends)</comment>
	<if_stmt><if>if<condition>(<expr><name>hostname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Try to resolve address</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getnameinfo</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Check if getnameinfo() returned a host name this time</comment>
		<comment type="line">// First check for he not being NULL before trying to dereference it</comment>
		<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>valid_hostname</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Return hostname copied to new memory location</comment>
				<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"[invalid host name]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"%s\" (found externally)"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// No hostname found (empty PTR)</comment>
			<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"\" (not found externally: %s)"</literal></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Return result</comment>
	<return>return <expr><name>hostname</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Resolve upstream destination host names</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>resolveAndAddHostname</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>ippos</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>oldnamepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Get IP and host name strings. They are cloned in case shared memory is</comment>
	<comment type="line">// resized before the next lock</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ipaddr</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldname</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Test if we want to resolve host names, otherwise all calls to resolveHostname()</comment>
	<comment type="line">// and getNameFromIP() can be skipped as they will all return empty names (= no records)</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>resolve_this_name</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"\" (configured to not resolve host name)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Free allocated memory</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Return fixed position of empty string</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Important: Don't hold a lock while resolving as the main thread</comment>
	<comment type="line">// (dnsmasq) needs to be operable during the call to resolveHostname()</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newname</name> <init>= <expr><call><name>resolveHostname</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// If no hostname was found, try to obtain hostname from the network table</comment>
	<comment type="line">// This may be disabled due to a user setting</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>names_from_netdb</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newname</name> <operator>=</operator> <call><name>getNameFromIP</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>newname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">" ---&gt; \"%s\" (provided by database)"</literal></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Only store new newname if it is valid and differs from oldname</comment>
	<comment type="line">// We do not need to check for oldname == NULL as names are</comment>
	<comment type="line">// always initialized with an empty string at position 0</comment>
	<if_stmt><if>if<condition>(<expr><name>newname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>newnamepos</name> <init>= <expr><call><name>addstr</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// newname has already been checked against NULL</comment>
		<comment type="line">// so we can safely free it</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>newnamepos</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Debugging output</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Not adding \"%s\" to buffer (unchanged)"</literal></expr></argument>, <argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>newname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Not changed, return old namepos</comment>
	<return>return <expr><name>oldnamepos</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Resolve client host names</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveClients</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>onlynew</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>force_refreshing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Lock counter access here, we use a copy in the following loop</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>clientscount</name> <init>= <expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>clientID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientID</name> <operator>&lt;</operator> <name>clientscount</name></expr>;</condition> <incr><expr><name>clientID</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Memory access needs to get locked</comment>
		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Get client pointer for the first time (reading data)</comment>
		<decl_stmt><decl><type><name>clientsData</name><modifier>*</modifier></type> <name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>client</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Unable to get client pointer (1) with ID %i, skipping..."</literal></expr></argument>, <argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Skip alias-clients</comment>
		<if_stmt><if>if<condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>aliasclient</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>newflag</name> <init>= <expr><name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>new</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>ippos</name> <init>= <expr><name><name>client</name><operator>-&gt;</operator><name>ippos</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>oldnamepos</name> <init>= <expr><name><name>client</name><operator>-&gt;</operator><name>namepos</name></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// Only try to resolve host names of clients which were recently active if we are re-resolving</comment>
		<comment type="line">// Limit for a "recently active" client is two hours ago</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>force_refreshing</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>onlynew</name> <operator>&amp;&amp;</operator> <name><name>client</name><operator>-&gt;</operator><name>lastQuery</name></name> <operator>&lt;</operator> <name>now</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping client %s (%s) because it was inactive for %i seconds"</literal></expr></argument>,
				     <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>now</name> <operator>-</operator> <name><name>client</name><operator>-&gt;</operator><name>lastQuery</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// If onlynew flag is set, we will only resolve new clients</comment>
		<comment type="line">// If not, we will try to re-resolve all known clients</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>force_refreshing</name> <operator>&amp;&amp;</operator> <name>onlynew</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>newflag</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping client %s (%s) because it is not new"</literal></expr></argument>,
				     <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Check if we want to resolve an IPv6 address</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>IPv6</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ipaddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>ipaddr</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>ipaddr</name></expr></argument>,<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>IPv6</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// If we're in refreshing mode (onlynew == false), we skip clients if</comment>
		<comment type="line">// 1. We should not refresh any hostnames</comment>
		<comment type="line">// 2. We should only refresh IPv4 client, but this client is IPv6</comment>
		<comment type="line">// 3. We should only refresh unknown hostnames, but leave</comment>
		<comment type="line">//    existing ones as they are</comment>
		<if_stmt><if>if<condition>(<expr><name>onlynew</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_NONE</name> <operator>||</operator>
		   <operator>(</operator><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_IPV4_ONLY</name> <operator>&amp;&amp;</operator> <name>IPv6</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>oldnamepos</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name> <init>= <expr><literal type="string">"N/A"</literal></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>reason</name> <operator>=</operator> <literal type="string">"Not refreshing any hostnames"</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_IPV4_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>reason</name> <operator>=</operator> <literal type="string">"Only refreshing IPv4 names"</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>refresh_hostnames</name></name> <operator>==</operator> <name>REFRESH_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>reason</name> <operator>=</operator> <literal type="string">"Looking only for unknown hostnames"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping client %s (%s) because it should not be refreshed: %s"</literal></expr></argument>,
				     <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Client %s -&gt; \"%s\" already known"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Obtain/update hostname of this client</comment>
		<decl_stmt><decl><type><name>size_t</name></type> <name>newnamepos</name> <init>= <expr><call><name>resolveAndAddHostname</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>, <argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Get client pointer for the second time (writing data)</comment>
		<comment type="line">// We cannot use the same pointer again as we released</comment>
		<comment type="line">// the lock in between so we cannot know if something</comment>
		<comment type="line">// happened to the shared memory object (resize event)</comment>
		<expr_stmt><expr><name>client</name> <operator>=</operator> <call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>client</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Unable to get client pointer (2) with ID %i, skipping..."</literal></expr></argument>, <argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Store obtained host name (may be unchanged)</comment>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>namepos</name></name> <operator>=</operator> <name>newnamepos</name></expr>;</expr_stmt>
		<comment type="line">// Mark entry as not new</comment>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>new</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Client %s -&gt; \"%s\" is new"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>newnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%i / %i client host names resolved"</literal></expr></argument>,
		     <argument><expr><name>clientscount</name><operator>-</operator><name>skipped</name></expr></argument>, <argument><expr><name>clientscount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Resolve upstream destination host names</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resolveUpstreams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>onlynew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Lock counter access here, we use a copy in the following loop</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>upstreams</name> <init>= <expr><name><name>counters</name><operator>-&gt;</operator><name>upstreams</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>upstreamID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>upstreamID</name> <operator>&lt;</operator> <name>upstreams</name></expr>;</condition> <incr><expr><name>upstreamID</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Memory access needs to get locked</comment>
		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Get upstream pointer for the first time (reading data)</comment>
		<decl_stmt><decl><type><name>upstreamsData</name><modifier>*</modifier></type> <name>upstream</name> <init>= <expr><call><name>getUpstream</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>upstream</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Unable to get upstream pointer with ID %i, skipping..."</literal></expr></argument>, <argument><expr><name>upstreamID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>newflag</name> <init>= <expr><name><name>upstream</name><operator>-&gt;</operator><name>new</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>ippos</name> <init>= <expr><name><name>upstream</name><operator>-&gt;</operator><name>ippos</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>oldnamepos</name> <init>= <expr><name><name>upstream</name><operator>-&gt;</operator><name>namepos</name></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// Only try to resolve host names of upstream servers which were recently active</comment>
		<comment type="line">// Limit for a "recently active" upstream server is two hours ago</comment>
		<if_stmt><if>if<condition>(<expr><name><name>upstream</name><operator>-&gt;</operator><name>lastQuery</name></name> <operator>&lt;</operator> <name>now</name> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">60</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping upstream %s (%s) because it was inactive for %i seconds"</literal></expr></argument>,
				     <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>now</name> <operator>-</operator> <name><name>upstream</name><operator>-&gt;</operator><name>lastQuery</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// If onlynew flag is set, we will only resolve new upstream destinations</comment>
		<comment type="line">// If not, we will try to re-resolve all known upstream destinations</comment>
		<if_stmt><if>if<condition>(<expr><name>onlynew</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>newflag</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream %s -&gt; \"%s\" already known"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Obtain/update hostname of this client</comment>
		<decl_stmt><decl><type><name>size_t</name></type> <name>newnamepos</name> <init>= <expr><call><name>resolveAndAddHostname</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>, <argument><expr><name>oldnamepos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Get upstream pointer for the second time (writing data)</comment>
		<comment type="line">// We cannot use the same pointer again as we released</comment>
		<comment type="line">// the lock in between so we cannot know if something</comment>
		<comment type="line">// happened to the shared memory object (resize event)</comment>
		<expr_stmt><expr><name>upstream</name> <operator>=</operator> <call><name>getUpstream</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>upstream</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Unable to get upstream pointer with ID %i, skipping..."</literal></expr></argument>, <argument><expr><name>upstreamID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Store obtained host name (may be unchanged)</comment>
		<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>namepos</name></name> <operator>=</operator> <name>newnamepos</name></expr>;</expr_stmt>
		<comment type="line">// Mark entry as not new</comment>
		<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>new</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream %s -&gt; \"%s\" is new"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ippos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>newnamepos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_RESOLVER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%i / %i upstream server host names resolved"</literal></expr></argument>,
		     <argument><expr><name>upstreams</name><operator>-</operator><name>skipped</name></expr></argument>, <argument><expr><name>upstreams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>DNSclient_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Set thread name</comment>
	<expr_stmt><expr><name><name>thread_names</name><index>[<expr><name>DNSclient</name></expr>]</index></name> <operator>=</operator> <literal type="string">"DNS client"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_SET_NAME</name></expr></argument>, <argument><expr><name><name>thread_names</name><index>[<expr><name>DNSclient</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Initial delay until we first try to resolve anything</comment>
	<expr_stmt><expr><call><name>thread_sleepms</name><argument_list>(<argument><expr><name>DNSclient</name></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Run as long as this thread is not canceled</comment>
	<while>while<condition>(<expr><operator>!</operator><name>killed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Run whenever necessary to resolve only new clients and</comment>
		<comment type="line">// upstream servers</comment>
		<if_stmt><if>if<condition>(<expr><name>resolver_ready</name> <operator>&amp;&amp;</operator> <call><name>get_and_clear_event</name><argument_list>(<argument><expr><name>RESOLVE_NEW_HOSTNAMES</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Try to resolve new client host names</comment>
			<comment type="line">// (onlynew=true)</comment>
			<comment type="line">// We're not forcing refreshing here</comment>
			<expr_stmt><expr><call><name>resolveClients</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Try to resolve new upstream destination host names</comment>
			<comment type="line">// (onlynew=true)</comment>
			<expr_stmt><expr><call><name>resolveUpstreams</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Intermediate cancellation-point</comment>
		<if_stmt><if>if<condition>(<expr><name>killed</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="line">// Run every hour to update possibly changed client host names</comment>
		<if_stmt><if>if<condition>(<expr><name>resolver_ready</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>RERESOLVE_INTERVAL</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RERESOLVE_HOSTNAMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="line">// done below</comment>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>force_refreshing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>get_and_clear_event</name><argument_list>(<argument><expr><name>RERESOLVE_HOSTNAMES_FORCE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RERESOLVE_HOSTNAMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="line">// done below</comment>
			<expr_stmt><expr><name>force_refreshing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Process resolver related event queue elements</comment>
		<if_stmt><if>if<condition>(<expr><call><name>get_and_clear_event</name><argument_list>(<argument><expr><name>RERESOLVE_HOSTNAMES</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Try to resolve all client host names</comment>
			<comment type="line">// (onlynew=false)</comment>
			<expr_stmt><expr><call><name>resolveClients</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>force_refreshing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// Intermediate cancellation-point</comment>
			<if_stmt><if>if<condition>(<expr><name>killed</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="line">// Try to resolve all upstream destination host names</comment>
			<comment type="line">// (onlynew=false)</comment>
			<expr_stmt><expr><call><name>resolveUpstreams</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Idle for 1 sec</comment>
		<expr_stmt><expr><call><name>thread_sleepms</name><argument_list>(<argument><expr><name>DNSclient</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Terminating resolver thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
