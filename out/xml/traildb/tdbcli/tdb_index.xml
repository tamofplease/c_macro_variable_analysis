<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/traildb/tdbcli/tdb_index.c">
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro></cpp:define> <comment type="block">/* strdup(), mkstemp() */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Judy.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;traildb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tdb_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tdb_bits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xxhash/xxhash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdbcli.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_index.h"</cpp:file></cpp:include>

<comment type="block">/*

# TDB Index

Tdb_index is a simple mapping

tdb_item -&gt; [trail_id, ...]

indicating trails that have at least one occurrence of the item. An
inverted index like this is especially useful for queries that match a
small number of trails based on infrequent items. By using the index,
one can avoid checking every trail in the db ("full table scan").
However, a TrailDB can contain tens of millions of items and trails, so
creating and storing this mapping can be expensive.

To make the index faster and smaller, instead of using the mapping above
we partition TrailDB to 2^16 = 65536 pages. Each page contains min(1,
num_trails / 2^16) trails. Hence the optimized index mapping becomes

tdb_item -&gt; [page_id, ...]

By definition, page_id can be represented with a uint16_t that saves
space compared to a uint64_t trail_id. To use the index, we need to
check every trail in the page for possible matches. This is less costly
than it sounds: processing TrailDBs is typically bounded by disk or
memory bandwidth. To access a single trail, we need to read at least one
OS page (4KB, or more in the case of SSD pages) of data anyways. Hence,
the optimized page-level index should perform almost as well as the
item-level index, while being much cheaper to construct and store.

## Index Binary Format

HEADER
    [ header           (sizeof(struct header)) ]
    [ field 0 offset   (8 bytes) ]
    ...
    [ field M offset   ) ]
FIELD SECTION
    PAGES
        [ item 0 num_pages] [ item 0 page_id, ... (list of 2 byte values) ]
        ...
        [ item K num_pages ] [ item K page_id, ... ]
    OFFSETS
        [ are offsets 4 or 8 bytes (4 bytes) ]
        [ item 0 offset (4 or 8 bytes) ]
        ...
        [ item K offset ]

To find the list of candidate trails for an item X, we need to perform
the following steps:

1. Find the correct FIELD SECTION for X using the HEADER.
2. Use OFFSETS to find the list of pages in the FIELD SECTION.
3. Read the list of pages and expand each page to all trail_ids it contains.

Thus, looking up the list of pages for an item is an O(1) operation.

## Optimizing Index Construction

### Optimization 1) Multi-threading

We construct the mapping

tdb_item -&gt; [page_id, ...]

by iterating over all trails in the TrailDB. We can shard a TrailDB to
K shards and perform this operation in K threads in parallel. Since we
don't know which items occur in which shards, we need to maintain a
dynamic mapping (JudyL), keyed by tdb_item, in each shard. The value of
JudyL needs to be a dynamically growing list of some kind.

### Optimization 2) Dense packing of small lists

A straightforward implementation of a dictionary of lists incurs a
large number of small allocations that are relatively expensive. We can
optimize away a good number of these allocations if we assume that there
is a long tail of infrequently occurring items which is often the case
with real-world TrailDBs.

JudyL is a mapping uint64_t -&gt; uint64_t. Thus, we can store a list of
maximum four 16-bit page_ids in a single value of the mapping. We call
this specially packed mapping `small_items`. If an item has more than
four page ids, we spill over the rest of pages to a separate mapping,
`large_items`, which is a straightforward but more expensive,
JudyL -&gt; Judy1 -&gt; PageID mapping.

Each thread constructs its `small_items` and `large_items` mappings
independently for the pages in its shard. Once all the threads have
finished, we can merge results as an O(N) operation, since all page_ids
are already stored in the sorted order.

### Optimization 3) Deduplication of lists

Typically there are many items in the mapping that have exactly the same
value, i.e. the list of pages where the item occurs. Storing duplicate
lists is redundant. We can save space by storing only distinct lists
and updating OFFSETS to point at the shared list. This optimization is
applied only to values of `small_items` i.e. only to lists of up to four
pages.
*/</comment>

<comment type="block">/* UINT16_MAX as unsigned long long */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_MAX_LLU</name></cpp:macro> <cpp:value>65535LLU</cpp:value></cpp:define>
<comment type="block">/* Number of distinct page_ids - we reserve page_id=0 for special use */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_NUM_PAGES</name></cpp:macro> <cpp:value>(UINT16_MAX - 1)</cpp:value></cpp:define>
<comment type="block">/* Version identifier for forward compatibility */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_VERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<struct>struct <name>job_arg</name><block>{
    <comment type="block">/* input */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tdb_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>trails_per_page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>start_trail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>end_trail</name></decl>;</decl_stmt>

    <comment type="block">/* output */</comment>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>small_items</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>large_items</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>header</name><block>{
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>checksum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>trails_per_page</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>field_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>packed</name><operator>)</operator></expr></argument>)</argument_list></decl>;</struct>

<struct>struct <name>tdb_index</name><block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>header</name></name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>num_trails</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
Pack a 16-bit page identifier `page` in the 64-bit value `old_val`.

Return 0 if the value is already full.
*/</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type> <name>add_small</name><parameter_list>(<parameter><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>old_val</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>v0</name> <init>= <expr><operator>*</operator><name>old_val</name> <operator>&amp;</operator> <name>UINT16_MAX_LLU</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>v1</name> <init>= <expr><operator>*</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">16LLU</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>v2</name> <init>= <expr><operator>*</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">32LLU</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>v3</name> <init>= <expr><operator>*</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">48LLU</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>page</name> <operator>&amp;=</operator> <name>UINT16_MAX_LLU</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>v0</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>old_val</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if <condition>(<expr><operator>!</operator><name>v1</name></expr>)</condition><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v0</name> <operator>!=</operator> <name>page</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>old_val</name> <operator>|=</operator> <name>page</name> <operator>&lt;&lt;</operator> <literal type="number">16LLU</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if <condition>(<expr><operator>!</operator><name>v2</name></expr>)</condition><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v1</name> <operator>!=</operator> <operator>(</operator><name>page</name> <operator>&lt;&lt;</operator> <literal type="number">16LLU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>old_val</name> <operator>|=</operator> <name>page</name> <operator>&lt;&lt;</operator> <literal type="number">32LLU</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if <condition>(<expr><operator>!</operator><name>v3</name></expr>)</condition><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v2</name> <operator>!=</operator> <operator>(</operator><name>page</name> <operator>&lt;&lt;</operator> <literal type="number">32LLU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>old_val</name> <operator>|=</operator> <name>page</name> <operator>&lt;&lt;</operator> <literal type="number">48LLU</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>v3</name> <operator>!=</operator> <operator>(</operator><name>page</name> <operator>&lt;&lt;</operator> <literal type="number">48LLU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Unpack four 16-bit page IDs from a 64-bit value `old_val`.
*/</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>get_small</name><parameter_list>(<parameter><decl><type><name>Word_t</name></type> <name>old_val</name></decl></parameter>,
                             <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>v0</name></decl></parameter>,
                             <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>,
                             <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>,
                             <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>v3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>v0</name> <operator>=</operator> <name>old_val</name> <operator>&amp;</operator> <name>UINT16_MAX_LLU</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">16LLU</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16LLU</literal><operator>)</operator> <operator>&amp;</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">32LLU</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32LLU</literal><operator>)</operator> <operator>&amp;</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v3</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>old_val</name> <operator>&amp;</operator> <operator>(</operator><name>UINT16_MAX_LLU</name> <operator>&lt;&lt;</operator> <literal type="number">48LLU</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">48LLU</literal><operator>)</operator> <operator>&amp;</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Construct

tdb_item -&gt; [page_id, ...]

mapping for a single shard of pages.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>job_index_shard</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>job_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>job_arg</name><operator>*</operator><operator>)</operator><name>arg0</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb_error</name></type> <name>err</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>tdb</name><modifier>*</modifier></type> <name>db</name> <init>= <expr><call><name>tdb_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tdb_path</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Opening TrailDB failed: %s"</literal></expr></argument>, <argument><expr><call><name>tdb_error_str</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>tdb_cursor</name> <modifier>*</modifier></type><name>cursor</name> <init>= <expr><call><name>tdb_cursor_new</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>start_trail</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arg</name><operator>-&gt;</operator><name>end_trail</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name></type> <name>page</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>i</name> <operator>/</operator> <name><name>arg</name><operator>-&gt;</operator><name>trails_per_page</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>tdb_event</name> <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>tdb_get_trail</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"get_trail %"</literal><name>PRIu64</name><literal type="string">" failed"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>event</name> <operator>=</operator> <call><name>tdb_cursor_next</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>event</name><operator>-&gt;</operator><name>num_items</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>JLI</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>small_items</name></name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>add_small</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>tst</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>JLI</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>large_items</name></name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>large</name> <init>= <expr><operator>(</operator><name>Pvoid_t</name><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>J1S</name><argument_list>(<argument><expr><name>tst</name></expr></argument>, <argument><expr><name>large</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Word_t</name><operator>)</operator><name>large</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></while>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>tdb_cursor_free</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Write one FIELD SECTION (see above for details), given
the mapping:

tdb_item -&gt; [page_id, ...]
*/</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>write_field</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>tdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
                            <parameter><decl><type><name>tdb_field</name></type> <name>field</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>job_arg</name></name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                            <parameter><decl><type><name>uint64_t</name></type> <name>num_shards</name></decl></parameter>,
                            <parameter><decl><type><name>Pvoid_t</name> <modifier>*</modifier></type><name>dedup0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>num_items</name> <init>= <expr><call><name>tdb_lexicon_size</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>dedup</name> <init>= <expr><operator>*</operator><name>dedup0</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list> <name>ret</name></decl>;</decl_stmt> <comment type="block">/* for TDB_WRITE */</comment>

    <struct>struct <name>shard_data</name><block>{
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>v0</name></decl>, <decl><type ref="prev"/><name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>v3</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>small_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>large_ptr</name></decl>;</decl_stmt>
    }</block> <decl><modifier>*</modifier><name>shards</name></decl>;</struct>

    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsets</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Getting file offset failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>offsets</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num_items</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate offsets for %"</literal><name>PRIu64</name><literal type="string">" items in field %u"</literal></expr></argument>,
            <argument><expr><name>num_items</name></expr></argument>,
            <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>shards</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>num_shards</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>shard_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate shard data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* write pages for each item in this field */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_items</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>tdb_item</name></type> <name>item</name> <init>= <expr><call><name>tdb_make_item</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>key</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>key_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get data for `item` from each shard - order matters! */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>shards</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_shards</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>shard_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><call><name>JLG</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>small_ptr</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>small_items</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* collect small values of this mapping */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>small_ptr</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>get_small</name><argument_list>(<argument><expr><operator>*</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>small_ptr</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name></expr>)</condition><block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>key_idx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>key</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><operator>++</operator><name>key_idx</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name></expr>)</condition><block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>key_idx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>key</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><operator>++</operator><name>key_idx</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name></expr>)</condition><block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>key_idx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>key</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><operator>++</operator><name>key_idx</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name></expr>)</condition><block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>key_idx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>key</name><index>[<expr><name>key_idx</name></expr>]</index></name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><operator>++</operator><name>key_idx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JLG</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>large_ptr</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>large_items</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>large_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>key_idx</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>key_idx</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block>{<block_content>
            <comment type="block">/*
            if this item doesn't have large items, it is eligible
            for deduplication (optimization 3 above). If this exact
            list is already stored, we can just update the offset of
            the item and continue.
            */</comment>
            <decl_stmt><decl><type><name>Word_t</name></type> <name>dedup_key</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dedup_key</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JLI</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>dedup</name></expr></argument>, <argument><expr><name>dedup_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if><else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
        write the list of page ids, starting from the
        contents of the small_items.
        */</comment>
        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        <comment type="block">/* write placeholder for the num pages */</comment>
        <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_shards</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v0</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v1</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v2</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>v3</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>large_ptr</name></expr>)</condition><block>{<block_content>
                <comment type="block">/*
                write the list of page ids, continue with
                large_items
                */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>Pvoid_t</name></type> <name>large</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>Pvoid_t</name><operator>)</operator><operator>*</operator><name><name>shards</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>large_ptr</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Word_t</name></type> <name>key</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tst</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>J1F</name><argument_list>(<argument><expr><name>tst</name></expr></argument>, <argument><expr><name>large</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>tst</name></expr>)</condition><block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>J1N</name><argument_list>(<argument><expr><name>tst</name></expr></argument>, <argument><expr><name>large</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>TDB_SEEK</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_pages</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_pages</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TDB_SEEK</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
    if all offsets fit in uint32_t, write them as 4 byte values,
    otherwise use 8 bytes. Indicate the choice in the first 4 bytes.
    */</comment>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>EIGHT</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>EIGHT</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>num_items</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>FOUR</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FOUR</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_items</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>dedup0</name> <operator>=</operator> <name>dedup</name></expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"IO error when writing index (disk full?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Produce a sanity check of a checksum that can be used to make sure that
the index matches with the db it was based on.
*/</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type> <name>db_checksum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>XXH64_state_t</name></type> <name>hash_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>data</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name>tdb_num_trails</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name>tdb_num_events</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name>tdb_num_fields</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name>tdb_min_timestamp</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                       <expr><call><name>tdb_max_timestamp</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                       <macro><name>tdb_version</name><argument_list>(<argument>db</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>XXH64_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_state</name></expr></argument>, <argument><expr><literal type="number">2016</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>XXH64_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_state</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>XXH64_digest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Initialize the index blob.
*/</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>init_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                       <parameter><decl><type><name>uint64_t</name></type> <name>trails_per_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>header</name></name></type> <name>head</name> <init>= <expr><block>{<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>INDEX_VERSION</name></expr>,
                          <expr><operator>.</operator><name>checksum</name> <operator>=</operator> <call><name>db_checksum</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>,
                          <expr><operator>.</operator><name>trails_per_page</name> <operator>=</operator> <name>trails_per_page</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list> <name>ret</name></decl>;</decl_stmt> <comment type="block">/* TDB_WRITE */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>mkstemp</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not open temp file at %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>out</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not create an index at %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>out</name></expr>;</return>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Writing index header failed. Disk full?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Write the index to disk. See above for the specification of
the binary format.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>write_index</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>tdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>job_arg</name></name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                        <parameter><decl><type><name>uint64_t</name></type> <name>num_shards</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>dedup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>num_fields</name> <init>= <expr><call><name>tdb_num_fields</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list> <name>ret</name></decl>;</decl_stmt> <comment type="block">/* for TDB_WRITE */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Getting file offset failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>offsets</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num_fields</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate field offsets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>num_fields</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>tdb_num_fields</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>write_field</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dedup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>TDB_SEEK</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TDB_WRITE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>num_fields</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JLFA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>dedup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Writing index failed. Disk full?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Get pages for the given item.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>get_index_pages</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_index</name></name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
                                       <parameter><decl><type><name>tdb_item</name></type> <name>item</name></decl></parameter>,
                                       <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>num_pages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tdb_val</name></type> <name>idx</name> <init>= <expr><call><name>tdb_item_val</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>field_offset</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>field_offsets</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>field_offset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>width</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>field_offset</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>width</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>offsets</name> <init>= <expr><name>data</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>num_pages</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if <condition>(<expr><name>width</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>offsets</name> <init>= <expr><name>data</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>num_pages</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><specifier>const</specifier> <name>uint16_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if><else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Corrupted index (item %"</literal><name>PRIu64</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
Perform a bitwise-AND operation between two bitmaps.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>intersect</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
Return a list of trail IDs that can contain matches for the given filter
(some may be false positives, due to the index being at the page level,
not at the exact item level).
*/</comment>
<function><type><name>uint64_t</name> <modifier>*</modifier></type><name>tdb_index_match_candidates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_index</name></name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_event_filter</name></name> <modifier>*</modifier></type><name>filter</name></decl></parameter>,
                                     <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>num_candidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>BUFFER_SIZE</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>INDEX_NUM_PAGES</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conjunction</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>disjunction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>candidates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>conjunction</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate conjunction buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>conjunction</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>disjunction</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate disjunction buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
    We can pre-evaluate CNF queries at the page level:
    Each clause (disjunction) is evaluated by constructing a bitmap
    that represents the union of pages in the clause. Clauses are
    combined together by conjunction, i.e. by producing the intersection
    between the clauses with bitwise-AND.

    Page-level negation is a special case: We need to evaluate each
    trail for negations, so the page-level index is useless for negations.
    */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>tdb_event_filter_num_clauses</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>tdb_item</name></type> <name>item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>is_negative</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>disjunction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>!</operator><call><name>tdb_event_filter_get_item</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_negative</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>is_negative</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>disjunction</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if><else>else<block>{<block_content>
                <comment type="block">/* union this item with the previous ones in this clause */</comment>
                <decl_stmt><decl><type><name>uint16_t</name></type> <name>n</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>pages</name> <init>= <expr><call><name>get_index_pages</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>write_bits</name><argument_list>(<argument><expr><name>disjunction</name></expr></argument>, <argument><expr><name><name>pages</name><index>[<expr><name>k</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* intersect this clause with the previous clauses */</comment>
        <expr_stmt><expr><call><name>intersect</name><argument_list>(<argument><expr><name>conjunction</name></expr></argument>, <argument><expr><name>disjunction</name></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>num_candidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INDEX_NUM_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>read_bits</name><argument_list>(<argument><expr><name>conjunction</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>num_candidates</name> <operator>+=</operator> <name><name>index</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>trails_per_page</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>candidates</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_candidates</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate a buffer for %"</literal><name>PRIu64</name><literal type="string">" match candidates"</literal></expr></argument>,
            <argument><expr><operator>*</operator><name>num_candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>INDEX_NUM_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>read_bits</name><argument_list>(<argument><expr><name>conjunction</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>trails_per_page</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <decl_stmt><decl><type><name>uint64_t</name></type> <name>trail_id</name> <init>= <expr><name>i</name> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>trails_per_page</name></name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>trail_id</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>num_trails</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>candidates</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>trail_id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conjunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>disjunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>num_candidates</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
    <return>return <expr><name>candidates</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Utility function that tests if any of the canonical index
paths are found for the given TrailDB path.
*/</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>tdb_index_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>TDB_MAX_PATH_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list> <name>ret</name></decl>;</decl_stmt> <comment type="block">/* for TDB_PATH */</comment>

    <expr_stmt><expr><call><name>TDB_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/index"</literal></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TDB_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s.index"</literal></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>TDB_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s.tdb.index"</literal></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
<label><name>found</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>fd</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Path %s too long"</literal></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Open an index.
*/</comment>
<function><type><name><name>struct</name> <name>tdb_index</name></name> <modifier>*</modifier></type><name>tdb_index_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tdb_path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tdb_index</name></name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb</name><modifier>*</modifier></type> <name>db</name> <init>= <expr><call><name>tdb_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb_error</name></type> <name>err</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>tdb_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Opening TrailDB at %s failed: %s\n"</literal></expr></argument>,
            <argument><expr><name>tdb_path</name></expr></argument>,
            <argument><expr><call><name>tdb_error_str</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>index</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tdb_index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Could not allocate a new index handle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>index_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Opening index at %s failed"</literal></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Reading index at %s failed"</literal></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Memory mapping index at %s failed"</literal></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>header</name><operator>*</operator><operator>)</operator><name><name>index</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>num_trails</name></name> <operator>=</operator> <call><name>tdb_num_trails</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>db_checksum</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>index</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>checksum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"TrailDB at %s and index at %s mismatch"</literal></expr></argument>, <argument><expr><name>tdb_path</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Close an index.
*/</comment>
<function><type><name>void</name></type> <name>tdb_index_close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tdb_index</name></name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
Create an index.
*/</comment>
<function><type><name>tdb_error</name></type> <name>tdb_index_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>db_path</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>,
                           <parameter><decl><type><name>uint32_t</name></type> <name>num_shards</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp_path</name><index>[<expr><name>TDB_MAX_PATH_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>job_arg</name></name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>thread_job</name></name> <modifier>*</modifier></type><name>jobs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb</name><modifier>*</modifier></type> <name>db</name> <init>= <expr><call><name>tdb_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb_error</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>tdb_open</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Opening TrailDB at %s failed: %s\n"</literal></expr></argument>,
            <argument><expr><name>db_path</name></expr></argument>,
            <argument><expr><call><name>tdb_error_str</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>num_trails</name> <init>= <expr><call><name>tdb_num_trails</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>trails_per_page</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>num_trails</name> <operator>/</operator> <name>INDEX_NUM_PAGES</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>pages_per_shard</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>INDEX_NUM_PAGES</name> <operator>/</operator> <name>num_shards</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>TDB_PATH</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><literal type="string">"%s.tmp.XXXXXX"</literal></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>init_file</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>trails_per_page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>args</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num_shards</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>job_arg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Couldn't allocate %u features args\n"</literal></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>jobs</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num_shards</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>thread_job</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Couldn't allocate %u features jobs\n"</literal></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_shards</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tdb_path</name> <operator>=</operator> <name>db_path</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trails_per_page</name> <operator>=</operator> <name>trails_per_page</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start_trail</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>pages_per_shard</name> <operator>*</operator> <name>trails_per_page</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end_trail</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>pages_per_shard</name> <operator>*</operator> <name>trails_per_page</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end_trail</name> <operator>&gt;</operator> <name>num_trails</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end_trail</name> <operator>=</operator> <name>num_trails</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arg</name> <operator>=</operator> <operator>&amp;</operator><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* construct the item -&gt; pages mapping on K threads in parallel */</comment>
    <expr_stmt><expr><call><name>execute_jobs</name><argument_list>(<argument><expr><name>job_index_shard</name></expr></argument>, <argument><expr><name>jobs</name></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* write the mapping to disk */</comment>
    <expr_stmt><expr><call><name>write_index</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>num_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Closing index failed. Disk full?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Renaming %s -&gt; %s failed"</literal></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>index_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* FIXME free args.small_items and args.large_items */</comment>
    <expr_stmt><expr><call><name>tdb_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><literal type="string">"Path name too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
int main(int argc, char **argv)
{
    create_index(argv[1], argv[2]);
    const struct tdb_index *index = open_index(argv[1], argv[2]);
    uint16_t i, num;
    const uint16_t *pages = get_index_pages(index, 22761987, &amp;num);
    printf("pages:");
    for (i = 0; i &lt; num; i++)
        printf(" %u", pages[i]);
    printf("\n");
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
