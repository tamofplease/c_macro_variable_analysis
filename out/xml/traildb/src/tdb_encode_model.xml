<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/traildb/src/tdb_encode_model.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JUDYERROR</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUDYERROR</name><parameter_list>(<parameter><type><name>CallerFile</name></type></parameter>, <parameter><type><name>CallerLine</name></type></parameter>, <parameter><type><name>JudyFunc</name></type></parameter>, <parameter><type><name>JudyErrno</name></type></parameter>, <parameter><type><name>JudyErrID</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>{                                                                         \
   if ((JudyErrno) == JU_ERRNO_NOMEM)                                     \
       goto out_of_memory;                                                \
}</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Judy.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_encode_model.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_huffman.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_io.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSFMT_MEXP</name></cpp:macro> <cpp:value>521</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dsfmt/dSFMT.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAMPLE_SIZE</name></cpp:macro> <cpp:value>(0.1 * RAND_MAX)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANDOM_SEED</name></cpp:macro> <cpp:value>238713</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIGRAM_SUPPORT</name></cpp:macro> <cpp:value>0.00001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_EVENTS_SAMPLING_THRESHOLD</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_GRAM_BUF_LEN</name></cpp:macro> <cpp:value>(256 * 256)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a)&gt;(b)?(b):(a))</cpp:value></cpp:define>

<comment type="block">/* event op handles one *event* (not one trail) */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>event_op</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name></decl></parameter>,
                        <parameter><decl><type><name>uint64_t</name></type> <name>n</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_grouped_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>,
                        <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>ngram_state</name><block>{
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>candidates</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>judy_128_map</name></name></type> <name>ngram_freqs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>final_freqs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>__uint128_t</name> <modifier>*</modifier></type><name>grams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>gram_bufs</name></name></type> <name>gbufs</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>double</name></type> <name>get_sample_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* TODO remove this env var */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><literal type="number">0.1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TDB_SAMPLE_SIZE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TDB_SAMPLE_SIZE"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>||</operator> <name><name>d</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0.01</literal> <operator>||</operator> <name>d</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block>{<block_content>
            <comment type="block">/* TODO fix this */</comment>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Invalid TDB_SAMPLE_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>event_fold</name><parameter_list>(<parameter><decl><type><name>event_op</name></type> <name>op</name></decl></parameter>,
                            <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>grouped</name></decl></parameter>,
                            <parameter><decl><type><name>uint64_t</name></type> <name>num_events</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
                            <parameter><decl><type><name>uint64_t</name></type> <name>num_fields</name></decl></parameter>,
                            <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>dsfmt_t</name></type> <name>rand_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb_item</name> <modifier>*</modifier></type><name>prev_items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>encoded_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>sample_size</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>tdb_grouped_event</name></name></type> <name>ev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_events</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>dsfmt_init_gen_rand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rand_state</name></expr></argument>, <argument><expr><name>RANDOM_SEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* enable sampling only if there is a large number of events */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_events</name> <operator>&gt;</operator> <name>NUM_EVENTS_SAMPLING_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sample_size</name> <operator>=</operator> <call><name>get_sample_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>prev_items</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>num_fields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tdb_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TDB_ERR_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>grouped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TDB_READ</name><argument_list>(<argument><expr><name>grouped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tdb_grouped_event</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this function scans through *all* unencoded data, takes a sample
       of trails, edge-encodes events for a trail, and calls the
       given function (op) for each event */</comment>

    <while>while <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>num_events</name></expr>)</condition><block>{<block_content>
        <comment type="block">/* NB: We sample trails, not events, below.
           We can't encode *and* sample events efficiently at the same time.

           If data is very unevenly distributed over trails, sampling trails
           will produce suboptimal results. We could compensate for this by
           always include all very long trails in the sample.
        */</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>trail_id</name> <init>= <expr><name><name>ev</name><operator>.</operator><name>trail_id</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Always include the first trail so we don't end up empty */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>dsfmt_genrand_close_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rand_state</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>sample_size</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>prev_items</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_fields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tdb_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><name><name>ev</name><operator>.</operator><name>trail_id</name></name> <operator>==</operator> <name>trail_id</name></expr>)</condition><block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>edge_encode_items</name><argument_list>(<argument><expr><name>items</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>encoded</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>encoded_size</name></expr></argument>,
                                             <argument><expr><name>prev_items</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>op</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>&lt;</operator> <name>num_events</name></expr>)</condition><block>{<block_content>
                    <expr_stmt><expr><call><name>TDB_READ</name><argument_list>(<argument><expr><name>grouped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tdb_grouped_event</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if><else>else<block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if><else>else<block>{<block_content>
            <comment type="block">/* given that we are sampling trails, we need to skip all events
               related to a trail not included in the sample */</comment>
            <for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name>num_events</name> <operator>&amp;&amp;</operator> <name><name>ev</name><operator>.</operator><name>trail_id</name></name> <operator>==</operator> <name>trail_id</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>TDB_READ</name><argument_list>(<argument><expr><name>grouped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tdb_grouped_event</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>alloc_gram_bufs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gram_bufs</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>chosen</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>buf_len</name></name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>scores</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>buf_len</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>tdb_error</name></type> <name>init_gram_bufs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gram_bufs</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>num_fields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>gram_bufs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_fields</name></expr>)</condition><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>covered</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>num_fields</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buf_len</name></name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>num_fields</name> <operator>*</operator> <name>num_fields</name></expr></argument>, <argument><expr><name>INITIAL_GRAM_BUF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num_fields</name></name> <operator>=</operator> <name>num_fields</name></expr>;</expr_stmt>
        <return>return <expr><call><name>alloc_gram_bufs</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_gram_bufs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gram_bufs</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>chosen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>scores</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>covered</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* given a set of edge-encoded values (encoded), choose a set of unigrams
   and bigrams that cover the original set. In essence, this tries to
   solve Weigted Exact Cover Problem for the universe of 'encoded'. */</comment>
<function><type><name>tdb_error</name></type> <name>choose_grams_one_event</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name></decl></parameter>,
                                 <parameter><decl><type><name>uint64_t</name></type> <name>num_encoded</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>gram_freqs</name></decl></parameter>,
                                 <parameter><decl><type><name><name>struct</name> <name>gram_bufs</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
                                 <parameter><decl><type><name>__uint128_t</name> <modifier>*</modifier></type><name>grams</name></decl></parameter>,
                                 <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>num_grams</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_grouped_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>unigram1</name> <init>= <expr><name><name>ev</name><operator>-&gt;</operator><name>timestamp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
    in the worst case we need O(num_fields^2) of memory but typically
    either num_fields is small or events are sparse, i.e.
    num_encoded &lt;&lt; num_fields, so in practice these shouldn't take a
    huge amount of space
    */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>buf_len</name></name> <operator>&lt;</operator> <name>num_encoded</name> <operator>*</operator> <name>num_encoded</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>scores</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>chosen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>buf_len</name></name> <operator>=</operator> <name>num_encoded</name> <operator>*</operator> <name>num_encoded</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>alloc_gram_bufs</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>covered</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>num_fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* First, produce all candidate bigrams for this set. */</comment>
    <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_encoded</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><name>unigram1</name> <operator>=</operator> <name><name>encoded</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <for>for <control>(<init>;</init><condition><expr><name>j</name> <operator>&lt;</operator> <name>num_encoded</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <decl_stmt><decl><type><name>__uint128_t</name></type> <name>bigram</name> <init>= <expr><name>unigram1</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>bigram</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>__uint128_t</name><operator>)</operator><name><name>encoded</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">64</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>j128m_get</name><argument_list>(<argument><expr><name>gram_freqs</name></expr></argument>, <argument><expr><name>bigram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block>{<block_content>
                <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>chosen</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>bigram</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>scores</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* timestamp *must* be the first item in the list, add unigram as
       a placeholder - this may get replaced by a bigram below */</comment>
    <expr_stmt><expr><name><name>grams</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ev</name><operator>-&gt;</operator><name>timestamp</name></name></expr>;</expr_stmt>

    <comment type="block">/* Pick non-overlapping histograms, in the order of descending score.
       As we go, mark fields covered (consumed) in the set. */</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>max_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>max_score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <comment type="block">/* consider only bigrams whose both unigrams are non-covered */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>covered</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>chosen</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name> <operator>||</operator>
                  <name><name>g</name><operator>-&gt;</operator><name>covered</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_OTHER_ITEM</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>chosen</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
                  <name><name>g</name><operator>-&gt;</operator><name>scores</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>max_score</name></expr>)</condition><block>{<block_content>

                <expr_stmt><expr><name>max_score</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>scores</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>max_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></for>

        <if_stmt><if>if <condition>(<expr><name>max_score</name></expr>)</condition><block>{<block_content>
            <comment type="block">/* mark both unigrams of this bigram covered */</comment>
            <decl_stmt><decl><type><name>__uint128_t</name></type> <name>chosen</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>chosen</name><index>[<expr><name>max_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>covered</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name>chosen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>covered</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_OTHER_ITEM</name><argument_list>(<argument><expr><name>chosen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name>chosen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>grams</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>chosen</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <comment type="block">/*
                make sure timestamp stays as the first item.
                This is safe since grams[0] was reserved above for
                the timestamp. */</comment>
                <expr_stmt><expr><name><name>grams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>chosen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if><else>else<block type="pseudo"><block_content>
            <comment type="block">/* all bigrams used */</comment>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Finally, add all remaining unigrams to the result set which have not
       been covered by any bigrams */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_encoded</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>covered</name><index>[<expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><name><name>encoded</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>grams</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>encoded</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

    <expr_stmt><expr><operator>*</operator><name>num_grams</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>choose_grams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name></decl></parameter>,
                              <parameter><decl><type><name>uint64_t</name></type> <name>num_encoded</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_grouped_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list><block>{<block_content>

    <decl_stmt><decl><type><name><name>struct</name> <name>ngram_state</name></name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator>struct <name>ngram_state</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>choose_grams_one_event</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>,
                                      <argument><expr><name>num_encoded</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>ngram_freqs</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>gbufs</name></name></expr></argument>,
                                      <argument><expr><name><name>g</name><operator>-&gt;</operator><name>grams</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,
                                      <argument><expr><name>ev</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block>{<block_content>
        <comment type="block">/* TODO fix this once j128m returns proper error codes */</comment>
        <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>j128m_insert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>final_freqs</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>grams</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><operator>*</operator><name>ptr</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>find_candidates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Pvoid_t</name></type> <name>unigram_freqs</name></decl></parameter>,
                                 <parameter><decl><type><name>Pvoid_t</name> <modifier>*</modifier></type><name>candidates0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>candidates</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>num_values</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>support</name></decl>;</decl_stmt>

    <comment type="block">/* find all unigrams whose probability of occurrence is greater than
       UNIGRAM_SUPPORT */</comment>

    <expr_stmt><expr><call><name>JLF</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>unigram_freqs</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>ptr</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>num_values</name> <operator>+=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JLN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>unigram_freqs</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>support</name> <operator>=</operator> <name>num_values</name> <operator>/</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <name>UNIGRAM_SUPPORT</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JLF</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>unigram_freqs</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>ptr</name></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;</operator> <name>support</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>J1S</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>candidates</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>JLN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>unigram_freqs</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>candidates0</name> <operator>=</operator> <name>candidates</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>out_of_memory</name>:</label>
    <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>all_bigrams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name></decl></parameter>,
                             <parameter><decl><type><name>uint64_t</name></type> <name>n</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_grouped_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>,
                             <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list><block>{<block_content>

    <decl_stmt><decl><type><name><name>struct</name> <name>ngram_state</name></name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator>struct <name>ngram_state</name> <operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>unigram1</name> <init>= <expr><name><name>ev</name><operator>-&gt;</operator><name>timestamp</name></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><name>unigram1</name> <operator>=</operator> <name><name>encoded</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>J1T</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>candidates</name></name></expr></argument>, <argument><expr><name>unigram1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>set</name></expr>)</condition><block>{<block_content>
            <for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <decl_stmt><decl><type><name>uint64_t</name></type> <name>unigram2</name> <init>= <expr><name><name>encoded</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>J1T</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>candidates</name></name></expr></argument>, <argument><expr><name>unigram2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>set</name></expr>)</condition><block>{<block_content>
                    <decl_stmt><decl><type><name>__uint128_t</name></type> <name>bigram</name> <init>= <expr><name>unigram1</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>bigram</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>__uint128_t</name><operator>)</operator><name>unigram2</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">64</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>j128m_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>ngram_freqs</name></name></expr></argument>, <argument><expr><name>bigram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>++</operator><operator>*</operator><name>ptr</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>tdb_error</name></type> <name>make_grams</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>grouped</name></decl></parameter>,
                     <parameter><decl><type><name>uint64_t</name></type> <name>num_events</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
                     <parameter><decl><type><name>uint64_t</name></type> <name>num_fields</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>Pvoid_t</name></type> <name>unigram_freqs</name></decl></parameter>,
                     <parameter><decl><type><name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>final_freqs</name></decl></parameter>,
                     <parameter><decl><type><name>uint64_t</name></type> <name>no_bigrams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ngram_state</name></name></type> <name>g</name> <init>= <expr><block>{<expr><operator>.</operator><name>final_freqs</name> <operator>=</operator> <name>final_freqs</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TDB_TIMER_DEF</name></type>

    <name>j128m_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>ngram_freqs</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>init_gram_bufs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>gbufs</name></name></expr></argument>, <argument><expr><name>num_fields</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>g</name><operator>.</operator><name>grams</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>num_fields</name> <operator>*</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TDB_ERR_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* below is a very simple version of the Apriori algorithm
       for finding frequent sets (bigrams) */</comment>

    <comment type="block">/* find unigrams that are sufficiently frequent */</comment>
    <macro><name>TDB_TIMER_START</name></macro>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>find_candidates</name><argument_list>(<argument><expr><name>unigram_freqs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>candidates</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
    <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"encode_model/find_candidates"</literal></argument>)</argument_list></macro>

    <comment type="block">/* collect frequencies of *all* occurring bigrams of candidate unigrams */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_bigrams</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>TDB_TIMER_START</name></type>
        <name>ret</name> <init>= <expr><call><name>event_fold</name><argument_list>(<argument><expr><name>all_bigrams</name></expr></argument>, <argument><expr><name>grouped</name></expr></argument>, <argument><expr><name>num_events</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>num_fields</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
        <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"encode_model/all_bigrams"</literal></argument>)</argument_list></macro>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* TODO: choose_grams below could also be optimized when !no_bigrams is true. */</comment>

    <comment type="block">/* collect frequencies of non-overlapping bigrams and unigrams
       (exact covering set for each event), store in final_freqs */</comment>
    <decl_stmt><decl><type><name>TDB_TIMER_START</name></type>
    <name>ret</name> <init>= <expr><call><name>event_fold</name><argument_list>(<argument><expr><name>choose_grams</name></expr></argument>, <argument><expr><name>grouped</name></expr></argument>, <argument><expr><name>num_events</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>num_fields</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
    <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"encode_model/choose_grams"</literal></argument>)</argument_list></macro>

<label><name>done</name>:</label>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>push</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wsign-compare"</cpp:literal></cpp:pragma>
    <expr_stmt><expr><call><name>J1FA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>g</name><operator>.</operator><name>candidates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>pop</name></cpp:pragma>
    <expr_stmt><expr><call><name>j128m_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>ngram_freqs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_gram_bufs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>.</operator><name>gbufs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>g</name><operator>.</operator><name>grams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>

<label><name>out_of_memory</name>:</label>
    <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>unigram_state</name><block>{
    <decl_stmt><decl><type><name>Pvoid_t</name></type> <name>freqs</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>tdb_error</name></type> <name>all_freqs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>encoded</name></decl></parameter>,
                           <parameter><decl><type><name>uint64_t</name></type> <name>n</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tdb_grouped_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>,
                           <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list><block>{<block_content>

    <decl_stmt><decl><type><name><name>struct</name> <name>unigram_state</name></name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator>struct <name>unigram_state</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>JLI</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>freqs</name></name></expr></argument>, <argument><expr><name><name>encoded</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><operator>*</operator><name>ptr</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* include frequencies for timestamp deltas */</comment>
    <expr_stmt><expr><call><name>JLI</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>freqs</name></name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><operator>*</operator><name>ptr</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>out_of_memory</name>:</label>
    <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Pvoid_t</name></type> <name>collect_unigrams</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>grouped</name></decl></parameter>,
                         <parameter><decl><type><name>uint64_t</name></type> <name>num_events</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>tdb_item</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
                         <parameter><decl><type><name>uint64_t</name></type> <name>num_fields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* calculate frequencies of all items */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>unigram_state</name></name></type> <name>state</name> <init>= <expr><block>{<expr><operator>.</operator><name>freqs</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>event_fold</name><argument_list>(<argument><expr><name>all_freqs</name></expr></argument>, <argument><expr><name>grouped</name></expr></argument>, <argument><expr><name>num_events</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>num_fields</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name><name>state</name><operator>.</operator><name>freqs</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

</unit>
