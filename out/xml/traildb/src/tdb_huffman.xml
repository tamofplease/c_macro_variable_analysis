<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/traildb/src/tdb_huffman.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_profile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_huffman.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdb_error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"judy_128_map.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a)&gt;(b)?(b):(a))</cpp:value></cpp:define>

<struct>struct <name>hnode</name><block>{
    <decl_stmt><decl><type><name>__uint128_t</name></type> <name>symbol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>weight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>sortpair</name><block>{
    <decl_stmt><decl><type><name>__uint128_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>uint8_t</name></type> <name>bits_needed</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><name>max</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>bits</name> <init>= <expr><ternary><condition><expr><name>x</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>x</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>bits</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>bits</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>sortpair</name><operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>y</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>sortpair</name><operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>value</name></name> <operator>&gt;</operator> <name><name>y</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>value</name></name> <operator>&lt;</operator> <name><name>y</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>sort_j128m_fun</name><parameter_list>(<parameter><decl><type><name>__uint128_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>(</operator>struct <name>sortpair</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>

    <return>return <expr><operator>++</operator><name>pair</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>sort_j128m</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>j128m</name></decl></parameter>,
                                   <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>num_items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>pairs</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>num_items</name> <operator>=</operator> <call><name>j128m_num_keys</name><argument_list>(<argument><expr><name>j128m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pairs</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_items</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sortpair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_items</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>pairs</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>j128m_fold</name><argument_list>(<argument><expr><name>j128m</name></expr></argument>, <argument><expr><name>sort_j128m_fun</name></expr></argument>, <argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><operator>*</operator><name>num_items</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sortpair</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pairs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>allocate_codewords</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>code</name></decl></parameter>,
                               <parameter><decl><type><name>uint32_t</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>right</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>left</name></name><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>allocate_codewords</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>allocate_codewords</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>code</name> <operator>|</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>depth</name><operator>)</operator></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_bits</name></name> <operator>=</operator> <name>depth</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>pop_min_weight</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>symbols</name></decl></parameter>,
                                    <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>num_symbols</name></decl></parameter>,
                                    <parameter><decl><type><name><name>struct</name> <name>tdb_queue</name></name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>hnode</name><operator>*</operator><operator>)</operator><call><name>tdb_queue_peek</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>num_symbols</name> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>weight</name></name> <operator>&lt;</operator> <name><name>symbols</name><index>[<expr><operator>*</operator><name>num_symbols</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>weight</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>tdb_queue_pop</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>num_symbols</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name><name>symbols</name><index>[<expr><operator>--</operator><operator>*</operator><name>num_symbols</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>huffman_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>symbols</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>tdb_queue</name></name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>newnodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>new_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>nodes</name> <operator>=</operator> <call><name>tdb_queue_new</name><argument_list>(<argument><expr><name>num</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>newnodes</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>hnode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>tdb_queue_free</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* construct the huffman tree bottom up */</comment>
    <while>while <condition>(<expr><name>num</name> <operator>||</operator> <call><name>tdb_queue_length</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>new</name> <init>= <expr><operator>&amp;</operator><name><name>newnodes</name><index>[<expr><name>new_i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>pop_min_weight</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>pop_min_weight</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>new</name><operator>-&gt;</operator><name>left</name></name></expr> ?</condition><then> <expr><name><name>new</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>weight</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                      <operator>(</operator><ternary><condition><expr><name><name>new</name><operator>-&gt;</operator><name>right</name></name></expr> ?</condition><then> <expr><name><name>new</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>weight</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tdb_queue_push</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* allocate codewords top down (depth-first) */</comment>
    <expr_stmt><expr><call><name>allocate_codewords</name><argument_list>(<argument><expr><call><name>tdb_queue_pop</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tdb_queue_free</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_symbols</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>freqs</name></decl></parameter>,
                        <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>totalfreq</name></decl></parameter>,
                        <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>num_symbols</name></decl></parameter>,
                        <parameter><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>book</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sortpair</name></name> <modifier>*</modifier></type><name>pairs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>num</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pairs</name> <operator>=</operator> <call><name>sort_j128m</name><argument_list>(<argument><expr><name>freqs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>totalfreq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>totalfreq</name> <operator>+=</operator> <name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><operator>*</operator><name>num_symbols</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><call><name>MIN</name><argument_list>(<argument><expr><name>HUFF_CODEBOOK_SIZE</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_symbols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>book</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>=</operator> <name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>book</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>=</operator> <name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TDB_DEBUG_HUFFMAN</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_codeword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>num_bits</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>code</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>j</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>output_stats</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>book</name></decl></parameter>,
                         <parameter><decl><type><name>uint32_t</name></type> <name>num_symbols</name></decl></parameter>,
                         <parameter><decl><type><name>uint64_t</name></type> <name>tot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"#codewords: %u\n"</literal></expr></argument>, <argument><expr><name>num_symbols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>cum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"index) gramtype [field value] freq prob cum\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_symbols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>

        <decl_stmt><decl><type><name>long</name> <name>long</name> <name>unsigned</name> <name>int</name></type> <name>sym</name> <init>= <expr><name><name>book</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name> <name>long</name> <name>unsigned</name> <name>int</name></type> <name>sym2</name> <init>= <expr><name>sym</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>f</name> <init>= <expr><name><name>book</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>cum</name> <operator>+=</operator> <name>f</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%u) "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sym2</name> <operator>&amp;</operator> <literal type="number">255</literal></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                    <argument><expr><literal type="string">"bi [%llu %llu | %llu %llu] "</literal></expr></argument>,
                    <argument><expr><name>sym</name> <operator>&amp;</operator> <literal type="number">255</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>sym</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                    <argument><expr><name>sym2</name> <operator>&amp;</operator> <literal type="number">255</literal></expr></argument>,
                    <argument><expr><name>sym2</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"uni [%llu %llu] "</literal></expr></argument>, <argument><expr><name>sym</name> <operator>&amp;</operator> <literal type="number">255</literal></expr></argument>, <argument><expr><name>sym</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%lu %2.3f %2.3f | "</literal></expr></argument>,
                <argument><expr><name>f</name></expr></argument>,
                <argument><expr><literal type="number">100.</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>f</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>tot</name></expr></argument>,
                <argument><expr><literal type="number">100.</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><name>cum</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>tot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>print_codeword</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>book</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>make_codemap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>,
                        <parameter><decl><type><name>uint32_t</name></type> <name>num_symbols</name></decl></parameter>,
                        <parameter><decl><type><name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>codemap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>num_symbols</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>num_bits</name></expr>)</condition><block>{<block_content>
            <comment type="block">/* TODO TDB_ERR_NOMEM handling */</comment>
            <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>j128m_insert</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>code</name> <operator>|</operator> <operator>(</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>num_bits</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>field_stats</name></name> <modifier>*</modifier></type><name>huff_field_stats</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>field_cardinalities</name></decl></parameter>,
                                     <parameter><decl><type><name>uint64_t</name></type> <name>num_fields</name></decl></parameter>,
                                     <parameter><decl><type><name>uint64_t</name></type> <name>max_timestamp_delta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>field_stats</name></name> <modifier>*</modifier></type><name>fstats</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>fstats</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>field_stats</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>num_fields</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>fstats</name><operator>-&gt;</operator><name>field_id_bits</name></name> <operator>=</operator> <call><name>bits_needed</name><argument_list>(<argument><expr><name>num_fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstats</name><operator>-&gt;</operator><name>field_bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bits_needed</name><argument_list>(<argument><expr><name>max_timestamp_delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_fields</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>fstats</name><operator>-&gt;</operator><name>field_bits</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bits_needed</name><argument_list>(<argument><expr><name><name>field_cardinalities</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <return>return <expr><name>fstats</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>huff_create_codemap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>gram_freqs</name></decl></parameter>,
                        <parameter><decl><type><name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>codemap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>hnode</name></name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>total_freq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_symbols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <macro><name>TDB_TIMER_DEF</name></macro>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>nodes</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>HUFF_CODEBOOK_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>hnode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TDB_ERR_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>done</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <macro><name>TDB_TIMER_START</name></macro>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>sort_symbols</name><argument_list>(<argument><expr><name>gram_freqs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_freq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_symbols</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

    <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"huffman/sort_symbols"</literal></argument>)</argument_list></macro>

    <macro><name>TDB_TIMER_START</name></macro>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>huffman_code</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>num_symbols</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
    <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"huffman/huffman_code"</literal></argument>)</argument_list></macro>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TDB_DEBUG_HUFFMAN</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TDB_DEBUG_HUFFMAN"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>output_stats</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>num_symbols</name></expr></argument>, <argument><expr><name>total_freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <macro><name>TDB_TIMER_START</name></macro>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>make_codemap</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>num_symbols</name></expr></argument>, <argument><expr><name>codemap</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
    <macro><name>TDB_TIMER_END</name><argument_list>(<argument><literal type="string">"huffman/make_codemap"</literal></argument>)</argument_list></macro>

<label><name>done</name>:</label>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>encode_gram</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>codemap</name></decl></parameter>,
                               <parameter><decl><type><name>__uint128_t</name></type> <name>gram</name></decl></parameter>,
                               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
                               <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offs</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>field_stats</name></name> <modifier>*</modifier></type><name>fstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>tdb_field</name></type> <name>field</name> <init>= <expr><call><name>tdb_item_field</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>tdb_val</name></type> <name>value</name> <init>= <expr><call><name>tdb_item_val</name><argument_list>(<argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>literal_bits</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name><name>fstats</name><operator>-&gt;</operator><name>field_id_bits</name></name> <operator>+</operator>
                                  <name><name>fstats</name><operator>-&gt;</operator><name>field_bits</name><index>[<expr><name>field</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>huff_code</name></decl>, <decl><type ref="prev"/><name>huff_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>j128m_get</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block>{<block_content>
        <comment type="block">/* codeword: prefix code by an up bit */</comment>
        <expr_stmt><expr><name>huff_code</name> <operator>=</operator> <literal type="number">1U</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>HUFF_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1U</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>huff_bits</name> <operator>=</operator> <call><name>HUFF_BITS</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>HUFF_IS_BIGRAM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>huff_bits</name> <operator>&lt;</operator> <name>literal_bits</name><operator>)</operator></expr>)</condition><block>{<block_content>
        <comment type="block">/* write huffman-coded codeword */</comment>
        <expr_stmt><expr><call><name>write_bits</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>offs</name></expr></argument>, <argument><expr><name>huff_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>offs</name> <operator>+=</operator> <name>huff_bits</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if <condition>(<expr><call><name>HUFF_IS_BIGRAM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <comment type="block">/* non-huffman bigrams are encoded as two unigrams */</comment>
        <expr_stmt><expr><call><name>encode_gram</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><call><name>HUFF_BIGRAM_TO_ITEM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>, <argument><expr><name>fstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encode_gram</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><call><name>HUFF_BIGRAM_OTHER_ITEM</name><argument_list>(<argument><expr><name>gram</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>, <argument><expr><name>fstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* write literal:
           [0 (1 bit) | field (field_bits) | value (field_bits[field])]

           huff_encoded_size_max_bits() must match with the above definition
           in tdb_huffman.h
        */</comment>
        <expr_stmt><expr><call><name>write_bits</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>offs</name> <operator>+=</operator> <name><name>fstats</name><operator>-&gt;</operator><name>field_id_bits</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_bits64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>offs</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>offs</name> <operator>+=</operator> <name><name>fstats</name><operator>-&gt;</operator><name>field_bits</name><index>[<expr><name>field</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>huff_encode_grams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>codemap</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>__uint128_t</name> <modifier>*</modifier></type><name>grams</name></decl></parameter>,
                       <parameter><decl><type><name>uint64_t</name></type> <name>num_grams</name></decl></parameter>,
                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
                       <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offs</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>field_stats</name></name> <modifier>*</modifier></type><name>fstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_grams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>encode_gram</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><name><name>grams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>, <argument><expr><name>fstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>create_codebook_fun</name><parameter_list>(<parameter><decl><type><name>__uint128_t</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>Word_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>huff_codebook</name></name> <modifier>*</modifier></type><name>book</name> <init>= <expr><operator>(</operator>struct <name>huff_codebook</name><operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>code</name> <init>= <expr><call><name>HUFF_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><call><name>HUFF_BITS</name><argument_list>(<argument><expr><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>j</name> <init>= <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">16</literal> <operator>-</operator> <name>n</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>j</name><operator>--</operator></expr>)</condition><block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name> <init>= <expr><name>code</name> <operator>|</operator> <operator>(</operator><name>j</name> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>book</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>=</operator> <name>symbol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>book</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>bits</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>huff_codebook</name></name> <modifier>*</modifier></type><name>huff_create_codebook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>judy_128_map</name></name> <modifier>*</modifier></type><name>codemap</name></decl></parameter>,
                                           <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>huff_codebook</name></name> <modifier>*</modifier></type><name>book</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>HUFF_CODEBOOK_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>huff_codebook</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>book</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>j128m_fold</name><argument_list>(<argument><expr><name>codemap</name></expr></argument>, <argument><expr><name>create_codebook_fun</name></expr></argument>, <argument><expr><name>book</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>book</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
this function converts old 64-bit symbols in v0 to new 128-bit
symbols in v1
*/</comment>
<function><type><name>int</name></type> <name>huff_convert_v0_codebook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tdb_file</name></name> <modifier>*</modifier></type><name>codebook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <struct><specifier>const</specifier> struct <name>huff_codebook_v0</name><block>{
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>symbol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    }</block> <decl><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>packed</name><operator>)</operator></expr></argument>)</argument_list> <modifier>*</modifier><name>old</name> <init>=
        <expr><operator>(</operator><specifier>const</specifier> struct <name>huff_codebook_v0</name><operator>*</operator><operator>)</operator><name><name>codebook</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</struct>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>size</name> <init>= <expr><name>HUFF_CODEBOOK_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>huff_codebook</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>huff_codebook</name></name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

    <comment type="block">/*
    we want to allocate memory with mmap() and not malloc() so that tdb_file
    can be munmap()'ed as usual
    */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><name>size</name></expr></argument>,
                   <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>,
                   <argument><expr><name>MAP_PRIVATE</name> <operator>|</operator> <name>MAP_ANON</name></expr></argument>,
                   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TDB_ERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>new</name> <operator>=</operator> <operator>(</operator>struct <name>huff_codebook</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HUFF_CODEBOOK_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <comment type="block">/* extract the second part of the bigram */</comment>
        <decl_stmt><decl><type><name>__uint128_t</name></type> <name>gram</name> <init>= <expr><name><name>old</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>gram</name> <operator>&lt;&lt;=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
        <comment type="block">/* extract the first part of the bigram */</comment>
        <expr_stmt><expr><name>gram</name> <operator>|=</operator> <operator>(</operator><name><name>old</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>&amp;</operator> <name>UINT32_MAX</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol</name> <operator>=</operator> <name>gram</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bits</name> <operator>=</operator> <name><name>old</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bits</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>codebook</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>codebook</name><operator>-&gt;</operator><name>mmap_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>codebook</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>codebook</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>codebook</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>codebook</name><operator>-&gt;</operator><name>mmap_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

</unit>
