<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/tz/localtime.c"><comment type="block">/* Convert timestamp from time_t to struct tm.  */</comment>

<comment type="block">/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/</comment>

<comment type="block">/*
** Leap second handling from Bradley White.
** POSIX-style TZ environment variable handling from Guy Harris.
*/</comment>

<comment type="block">/*LINTLIBRARY*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCALTIME_IMPLEMENTATION</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tzfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>THREAD_SAFE</name> <operator>&amp;&amp;</operator> <name>THREAD_SAFE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>locallock</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZ_ABBR_MAX_LEN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TZ_ABBR_MAX_LEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined TZ_ABBR_MAX_LEN */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZ_ABBR_CHAR_SET</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TZ_ABBR_CHAR_SET</name></cpp:macro> \
	<cpp:value>"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined TZ_ABBR_CHAR_SET */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZ_ABBR_ERR_CHAR</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TZ_ABBR_ERR_CHAR</name></cpp:macro> <cpp:value>'_'</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined TZ_ABBR_ERR_CHAR */</comment>

<comment type="block">/*
** Support non-POSIX platforms that distinguish between text and binary files.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_BINARY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WILDABBR</name></cpp:ifndef>
<comment type="block">/*
** Someone might make incorrect use of a time zone abbreviation:
**	1.	They might reference tzname[0] before calling tzset (explicitly
**		or implicitly).
**	2.	They might reference tzname[1] before calling tzset (explicitly
**		or implicitly).
**	3.	They might reference tzname[1] after setting to a time zone
**		in which Daylight Saving Time is never observed.
**	4.	They might reference tzname[0] after setting to a time zone
**		in which Standard Time is never observed.
**	5.	They might reference tm.TM_ZONE after calling offtime.
** What's best to do in the above cases is open to debate;
** for now, we just set things up so that in any of the five cases
** WILDABBR is used. Another possibility: initialize tzname[0] to the
** string "tzname[0] used before set", and similarly for the other cases.
** And another: initialize tzname[0] to "ERA", with an explanation in the
** manual page of what this "time zone abbreviation" means (doing this so
** that tzname[0] has the "normal" length of three characters).
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WILDABBR</name></cpp:macro> <cpp:value>"   "</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined WILDABBR */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type>	<name><name>wildabbr</name><index>[]</index></name> <init>= <expr><name>WILDABBR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>etc_utc</name><index>[]</index></name> <init>= <expr><literal type="string">"Etc/UTC"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>utc</name> <init>= <expr><name>etc_utc</name> <operator>+</operator> <sizeof>sizeof <name/></sizeof>"Etc/" <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** Default to US rules as of 2017-05-07.
** POSIX does not specify the default DST rules;
** for historical reasons, US rules are a common default.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZDEFRULESTRING</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TZDEFRULESTRING</name></cpp:macro> <cpp:value>",M3.2.0,M11.1.0"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>ttinfo</name> <block>{				<comment type="block">/* time type information */</comment>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>	<name>tt_utoff</name></decl>;</decl_stmt>	<comment type="block">/* UT offset in seconds */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tt_isdst</name></decl>;</decl_stmt>	<comment type="block">/* used to set tm_isdst */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>tt_desigidx</name></decl>;</decl_stmt>	<comment type="block">/* abbreviation list index */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tt_ttisstd</name></decl>;</decl_stmt>	<comment type="block">/* transition is std time */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tt_ttisut</name></decl>;</decl_stmt>	<comment type="block">/* transition is UT */</comment>
}</block>;</struct>

<struct>struct <name>lsinfo</name> <block>{				<comment type="block">/* leap second information */</comment>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>ls_trans</name></decl>;</decl_stmt>	<comment type="block">/* transition time */</comment>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>	<name>ls_corr</name></decl>;</decl_stmt>	<comment type="block">/* correction to apply */</comment>
}</block>;</struct>

<comment type="block">/* This abbreviation means local time is unspecified.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>UNSPEC</name><index>[]</index></name> <init>= <expr><literal type="string">"-00"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* How many extra bytes are needed at the end of struct state's chars array.
   This needs to be at least 1 for null termination in case the input
   data isn't properly terminated, and it also needs to be big enough
   for ttunspecified to work without crashing.  */</comment>
<enum>enum <block>{ <decl><name>CHARS_EXTRA</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr><sizeof>sizeof <name>UNSPEC</name></sizeof></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TZNAME_MAX</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MY_TZNAME_MAX</name></cpp:macro> <cpp:value>TZNAME_MAX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined TZNAME_MAX */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZNAME_MAX</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MY_TZNAME_MAX</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined TZNAME_MAX */</comment>

<struct>struct <name>state</name> <block>{
	<decl_stmt><decl><type><name>int</name></type>		<name>leapcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>timecnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>typecnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>charcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>goback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>goahead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>		<name><name>ats</name><index>[<expr><name>TZ_MAX_TIMES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name><name>types</name><index>[<expr><name>TZ_MAX_TIMES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ttinfo</name></name></type>	<name><name>ttis</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><name>char</name> <name><name>chars</name><index>[<expr><call><name>max</name><argument_list>(<argument><expr><call><name>max</name><argument_list>(<argument><expr><name>TZ_MAX_CHARS</name> <operator>+</operator> <name>CHARS_EXTRA</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof></expr></argument></argument_list></call></expr></argument></argument_list></call></expr></index></name>"UTC"</expr></expr_stmt>)</block><operator>,</operator>
		       <expr_stmt><expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>MY_TZNAME_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></expr_stmt></struct>)]<empty_stmt>;</empty_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>lsinfo</name></name></type>	<name><name>lsis</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* The time type to use for early times or if no transitions.
	   It is always zero for recent tzdb releases.
	   It might be nonzero for data from tzdb 2018e or earlier.  */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>defaulttype</name></decl>;</decl_stmt>
};

<enum>enum <name>r_type</name> <block>{
  <decl><name>JULIAN_DAY</name></decl>,		<comment type="block">/* Jn = Julian day */</comment>
  <decl><name>DAY_OF_YEAR</name></decl>,		<comment type="block">/* n = day of year */</comment>
  <decl><name>MONTH_NTH_DAY_OF_WEEK</name></decl>	<comment type="block">/* Mm.n.d = month, week, day of week */</comment>
}</block>;</enum>

<struct>struct <name>rule</name> <block>{
	<decl_stmt><decl><type><name><name>enum</name> <name>r_type</name></name></type>	<name>r_type</name></decl>;</decl_stmt>		<comment type="block">/* type of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>r_day</name></decl>;</decl_stmt>		<comment type="block">/* day number of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>r_week</name></decl>;</decl_stmt>		<comment type="block">/* week number of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>r_mon</name></decl>;</decl_stmt>		<comment type="block">/* month number of rule */</comment>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>	<name>r_time</name></decl>;</decl_stmt>		<comment type="block">/* transition time of rule */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>gmtsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>increment_overflow</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>increment_overflow_time</name><parameter_list>(<parameter><decl><type><name>time_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int_fast32_t</name></type> <name>leapcorr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>time_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>normalize_overflow32</name><parameter_list>(<parameter><decl><type><name>int_fast32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>timesub</name><parameter_list>(<parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,
			  <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>typesequiv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tzparse</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALL_STATE</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>	<name>lclptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type>	<name>gmtptr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined ALL_STATE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ALL_STATE</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name></type>	<name>lclmem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name></type>	<name>gmtmem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>lclptr</name> <init>= <expr><operator>&amp;</operator><name>lclmem</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>gmtptr</name> <init>= <expr><operator>&amp;</operator><name>gmtmem</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* State Farm */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TZ_STRLEN_MAX</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TZ_STRLEN_MAX</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined TZ_STRLEN_MAX */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>		<name><name>lcl_TZname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>lcl_is_set</name></decl>;</decl_stmt>

<comment type="block">/*
** Section 4.12.3 of X3.159-1989 requires that
**	Except for the strftime function, these functions [asctime,
**	ctime, gmtime, localtime] return values in one of two static
**	objects: a broken-down time structure and an array of char.
** Thanks to Paul Eggert for noting this.
**
** This requirement was removed in C99, so support it only if requested,
** as support is more likely to lead to bugs in badly-written programs.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SUPPORT_C89</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type>	<name>tm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>HAVE_TZNAME</name> <operator>+</operator> <name>TZ_TIME_T</name></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>			<name><name>tzname</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>wildabbr</name></expr>,
	<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>wildabbr</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>USG_COMPAT</name> <operator>+</operator> <name>TZ_TIME_T</name></expr></cpp:if>
<decl_stmt><decl><type><name>long</name></type>			<name>timezone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>daylight</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">2</literal> <operator>&lt;=</operator> <name>ALTZONE</name> <operator>+</operator> <name>TZ_TIME_T</name></expr></cpp:if>
<decl_stmt><decl><type><name>long</name></type>			<name>altzone</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialize *S to a value based on UTOFF, ISDST, and DESIGIDX.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_ttinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type> <name>utoff</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>desigidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>=</operator> <name>utoff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>=</operator> <name>desigidx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if SP's time type I does not specify local time.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ttunspecified</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>abbr</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* memcmp is likely faster than strcmp, and is safe due to CHARS_EXTRA.  */</comment>
  <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>UNSPEC</name></expr></argument>, <argument><expr><sizeof>sizeof <name>UNSPEC</name></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int_fast32_t</name></type>
<name>detzcode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>codep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>halfmaxval</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>maxval</name> <init>= <expr><name>halfmaxval</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>halfmaxval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>minval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>maxval</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>codep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Do two's-complement negation even on non-two's-complement machines.
	     If the result would be minval - 1, return minval.  */</comment>
	  <expr_stmt><expr><name>result</name> <operator>-=</operator> <operator>!</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int_fast32_t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>result</name> <operator>+=</operator> <name>minval</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int_fast64_t</name></type>
<name>detzcode64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>codep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast64_t</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast64_t</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast64_t</name></type> <name>halfmaxval</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast64_t</name></type> <name>maxval</name> <init>= <expr><name>halfmaxval</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>halfmaxval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast64_t</name></type> <name>minval</name> <init>= <expr><operator>-</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int_fast64_t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>maxval</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>codep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Do two's-complement negation even on non-two's-complement machines.
	     If the result would be minval - 1, return minval.  */</comment>
	  <expr_stmt><expr><name>result</name> <operator>-=</operator> <operator>!</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int_fast64_t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>result</name> <operator>+=</operator> <name>minval</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_tzname_etc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ttinfo</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>ttisp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_TZNAME</name></expr></cpp:if>
  <expr_stmt><expr><name><name>tzname</name><index>[<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USG_COMPAT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>timezone</name> <operator>=</operator> <operator>-</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALTZONE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>altzone</name> <operator>=</operator> <operator>-</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* If STDDST_MASK indicates that SP's TYPE provides useful info,
   update tzname, timezone, and/or altzone and return STDDST_MASK,
   diminished by the provided info if it is a specified local time.
   Otherwise, return STDDST_MASK.  See settzname for STDDST_MASK.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>may_update_tzname_etc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stddst_mask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>type</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>this_bit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>stddst_mask</name> <operator>&amp;</operator> <name>this_bit</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>update_tzname_etc</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ttisp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttunspecified</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>stddst_mask</name> <operator>&amp;</operator> <operator>~</operator><name>this_bit</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>stddst_mask</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>settzname</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier> <specifier>const</specifier></type>	<name>sp</name> <init>= <expr><name>lclptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* If STDDST_MASK &amp; 1 we need info about a standard time.
	   If STDDST_MASK &amp; 2 we need info about a daylight saving time.
	   When STDDST_MASK becomes zero we can stop looking.  */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>stddst_mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_TZNAME</name></expr></cpp:if>
	<expr_stmt><expr><name><name>tzname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tzname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>sp</name></expr> ?</condition><then> <expr><name>wildabbr</name></expr> </then><else>: <expr><name>utc</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>stddst_mask</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USG_COMPAT</name></expr></cpp:if>
	<expr_stmt><expr><name>timezone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>stddst_mask</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ALTZONE</name></expr></cpp:if>
	<expr_stmt><expr><name>altzone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>stddst_mask</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	** And to get the latest time zone abbreviations into tzname. . .
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>stddst_mask</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>stddst_mask</name> <operator>=</operator> <call><name>may_update_tzname_etc</name><argument_list>(<argument><expr><name>stddst_mask</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>stddst_mask</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>stddst_mask</name> <operator>=</operator> <call><name>may_update_tzname_etc</name><argument_list>(<argument><expr><name>stddst_mask</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USG_COMPAT</name></expr></cpp:if>
	<expr_stmt><expr><name>daylight</name> <operator>=</operator> <name>stddst_mask</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>scrub_abbrs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<comment type="block">/*
	** First, replace bogus characters.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>TZ_ABBR_CHAR_SET</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TZ_ABBR_ERR_CHAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<comment type="block">/*
	** Second, truncate long abbreviations.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier> <specifier>const</specifier></type>	<name>ttisp</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>TZ_ABBR_MAX_LEN</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>GRANDPARENTED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name>cp</name> <operator>+</operator> <name>TZ_ABBR_MAX_LEN</name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Input buffer for data read from a compiled tz file.  */</comment>
<union>union <name>input_buffer</name> <block>{
  <comment type="block">/* The first part of the buffer, interpreted as a header.  */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>tzhead</name></name></type> <name>tzhead</name></decl>;</decl_stmt>

  <comment type="block">/* The entire buffer.  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>tzhead</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof>
	   <operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name>TZ_MAX_TIMES</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>

<comment type="block">/* TZDIR with a trailing '/' rather than a trailing '\0'.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>tzdirslash</name><index>[<expr><sizeof>sizeof <name>TZDIR</name></sizeof></expr>]</index></name> <init>= <expr><name>TZDIR</name> <literal type="string">"/"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local storage needed for 'tzloadbody'.  */</comment>
<union>union <name>local_storage</name> <block>{
  <comment type="block">/* The results of analyzing the file's contents after it is opened.  */</comment>
  <struct>struct <name>file_analysis</name> <block>{
    <comment type="block">/* The input buffer.  */</comment>
    <decl_stmt><decl><type><name><name>union</name> <name>input_buffer</name></name></type> <name>u</name></decl>;</decl_stmt>

    <comment type="block">/* A temporary state used for parsing a TZ string in the file.  */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name></type> <name>st</name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</struct>

  <comment type="block">/* The file name to be opened.  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>fullname</name><index>[<expr><call><name>max</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>file_analysis</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof <name>tzdirslash</name></sizeof> <operator>+</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>

<comment type="block">/* Load tz data from the file named NAME into *SP.  Read extended
   format if DOEXTEND.  Use *LSP for temporary storage.  Return 0 on
   success, an errno value on failure.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tzloadbody</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doextend</name></decl></parameter>,
	   <parameter><decl><type><name><name>union</name> <name>local_storage</name></name> <modifier>*</modifier></type><name>lsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>fid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>stored</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ssize_t</name></type>		<name>nread</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type> <name>doaccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>union</name> <name>input_buffer</name></name> <modifier>*</modifier></type><name>up</name> <init>= <expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>u</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>tzheadsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tzhead</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name>TZDEFAULT</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPRESS_TZDIR</name></cpp:ifdef>
	<comment type="block">/* Do not prepend TZDIR.  This is intended for specialized
	   applications only, due to its security implications.  */</comment>
	<expr_stmt><expr><name>doaccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>doaccess</name> <operator>=</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>doaccess</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dot</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><sizeof>sizeof <name><name>lsp</name><operator>-&gt;</operator><name>fullname</name></name></sizeof> <operator>-</operator> <sizeof>sizeof <name>tzdirslash</name></sizeof> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>ENAMETOOLONG</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Create a string "TZDIR/NAME".  Using sprintf here
		   would pull in stdio (and would fail if the
		   resulting string length exceeded INT_MAX!).  */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>fullname</name></name></expr></argument>, <argument><expr><name>tzdirslash</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tzdirslash</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>lsp</name><operator>-&gt;</operator><name>fullname</name></name> <operator>+</operator> <sizeof>sizeof <name>tzdirslash</name></sizeof></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set doaccess if NAME contains a ".." file name
		   component, as such a name could read a file outside
		   the TZDIR virtual subtree.  */</comment>
		<for>for <control>(<init><expr><name>dot</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>(</operator><name>dot</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dot</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>dot</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dot</name> <operator>==</operator> <name>name</name> <operator>||</operator> <name><name>dot</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>dot</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal>
		      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dot</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>!</operator><name><name>dot</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><name>doaccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt></block_content></block></for>

		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>lsp</name><operator>-&gt;</operator><name>fullname</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>doaccess</name> <operator>&amp;&amp;</operator> <call><name>access</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fid</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fid</name></expr></argument>, <argument><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>up</name><operator>-&gt;</operator><name>buf</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <name>tzheadsize</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><ternary><condition><expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>EINVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>err</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>stored</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>stored</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>stored</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
	    <decl_stmt><decl><type><name>char</name></type> <name>version</name> <init>= <expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>bool</name></type> <name>skip_datablock</name> <init>= <expr><name>stored</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>version</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>datablock_size</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>ttisstdcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_ttisstdcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>ttisutcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_ttisutcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast64_t</name></type> <name>prevtr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>prevcorr</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>leapcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_leapcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>timecnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_timecnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>typecnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_typecnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>charcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_charcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>tzheadsize</name></expr></init></decl>;</decl_stmt>
	    <comment type="block">/* Although tzfile(5) currently requires typecnt to be nonzero,
	       support future formats that may allow zero typecnt
	       in files that have a TZ string and no transitions.  */</comment>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>leapcnt</name> <operator>&amp;&amp;</operator> <name>leapcnt</name> <operator>&lt;</operator> <name>TZ_MAX_LEAPS</name>
		   <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>typecnt</name> <operator>&amp;&amp;</operator> <name>typecnt</name> <operator>&lt;</operator> <name>TZ_MAX_TYPES</name>
		   <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>timecnt</name> <operator>&amp;&amp;</operator> <name>timecnt</name> <operator>&lt;</operator> <name>TZ_MAX_TIMES</name>
		   <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>charcnt</name> <operator>&amp;&amp;</operator> <name>charcnt</name> <operator>&lt;</operator> <name>TZ_MAX_CHARS</name>
		   <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>ttisstdcnt</name> <operator>&amp;&amp;</operator> <name>ttisstdcnt</name> <operator>&lt;</operator> <name>TZ_MAX_TYPES</name>
		   <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>ttisutcnt</name> <operator>&amp;&amp;</operator> <name>ttisutcnt</name> <operator>&lt;</operator> <name>TZ_MAX_TYPES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>datablock_size</name>
		    <operator>=</operator> <operator>(</operator><name>timecnt</name> <operator>*</operator> <name>stored</name>		<comment type="block">/* ats */</comment>
		       <operator>+</operator> <name>timecnt</name>		<comment type="block">/* types */</comment>
		       <operator>+</operator> <name>typecnt</name> <operator>*</operator> <literal type="number">6</literal>		<comment type="block">/* ttinfos */</comment>
		       <operator>+</operator> <name>charcnt</name>		<comment type="block">/* chars */</comment>
		       <operator>+</operator> <name>leapcnt</name> <operator>*</operator> <operator>(</operator><name>stored</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator>	<comment type="block">/* lsinfos */</comment>
		       <operator>+</operator> <name>ttisstdcnt</name>		<comment type="block">/* ttisstds */</comment>
		       <operator>+</operator> <name>ttisutcnt</name><operator>)</operator></expr>;</expr_stmt>		<comment type="block">/* ttisuts */</comment>
	    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <name>tzheadsize</name> <operator>+</operator> <name>datablock_size</name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	    <if_stmt><if>if <condition>(<expr><name>skip_datablock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>datablock_size</name></expr>;</expr_stmt></block_content></block></if>
	    <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><operator>(</operator><name>ttisstdcnt</name> <operator>==</operator> <name>typecnt</name> <operator>||</operator> <name>ttisstdcnt</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
		       <operator>&amp;&amp;</operator> <operator>(</operator><name>ttisutcnt</name> <operator>==</operator> <name>typecnt</name> <operator>||</operator> <name>ttisutcnt</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <name>typecnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>

		<comment type="block">/* Read transitions, discarding those out of time_t range.
		   But pretend the last transition before TIME_T_MIN
		   occurred at TIME_T_MIN.  */</comment>
		<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>int_fast64_t</name></type> <name>at</name>
			  <init>= <expr><ternary><condition><expr><name>stored</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>detzcode64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>at</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			  <decl_stmt><decl><type><name>time_t</name></type> <name>attime</name>
			    <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><ternary><condition><expr><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>at</name> <operator>&lt;</operator> <name>TIME_T_MIN</name></expr> </then><else>: <expr><name>at</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>
			       ?</condition><then> <expr><name>TIME_T_MIN</name></expr> </then><else>: <expr><name>at</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
			  <if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&amp;&amp;</operator> <name>attime</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
			    <if_stmt><if>if <condition>(<expr><name>attime</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			      <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			    <expr_stmt><expr><name>timecnt</name><operator>--</operator></expr>;</expr_stmt>
			  </block_content>}</block></if></if_stmt>
			  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>attime</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>stored</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>typ</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>&lt;=</operator> <name>typ</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>typ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>ttisp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>isdst</name></decl>, <decl><type ref="prev"/><name>desigidx</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>=</operator> <call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>isdst</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>isdst</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>desigidx</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>desigidx</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>=</operator> <name>desigidx</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
		<comment type="block">/* Ensure '\0'-terminated, and make it safe to call
		   ttunspecified later.  */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>CHARS_EXTRA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Read leap seconds, discarding those out of time_t range.  */</comment>
		<expr_stmt><expr><name>leapcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		  <decl_stmt><decl><type><name>int_fast64_t</name></type> <name>tr</name> <init>= <expr><ternary><condition><expr><name>stored</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>detzcode64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>corr</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>stored</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>stored</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

		  <comment type="block">/* Leap seconds cannot occur before the Epoch,
		     or out of order.  */</comment>
		  <if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&lt;=</operator> <name>prevtr</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

		  <comment type="block">/* To avoid other botches in this code, each leap second's
		     correction must differ from the previous one's by 1
		     second or less, except that the first correction can be
		     any value; these requirements are more generous than
		     RFC 8536, to allow future RFC extensions.  */</comment>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal>
			 <operator>||</operator> <operator>(</operator><ternary><condition><expr><name>prevcorr</name> <operator>&lt;</operator> <name>corr</name></expr>
			     ?</condition><then> <expr><name>corr</name> <operator>==</operator> <name>prevcorr</name> <operator>+</operator> <literal type="number">1</literal></expr>
			     </then><else>: <expr><operator>(</operator><name>corr</name> <operator>==</operator> <name>prevcorr</name>
				<operator>||</operator> <name>corr</name> <operator>==</operator> <name>prevcorr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>prevtr</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>prevcorr</name> <operator>=</operator> <name>corr</name></expr>;</expr_stmt>

		  <if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>leapcnt</name></expr>]</index></name><operator>.</operator><name>ls_trans</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>leapcnt</name></expr>]</index></name><operator>.</operator><name>ls_corr</name> <operator>=</operator> <name>corr</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>leapcnt</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>ttisp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ttisstdcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>true</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>ttisp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ttisutcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>true</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	    </block_content>}</block></else></if_stmt>

	    <expr_stmt><expr><name>nread</name> <operator>-=</operator> <name>p</name> <operator>-</operator> <name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* If this is an old file, we're done.  */</comment>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>version</name></expr>)</condition><block type="pseudo"><block_content>
	      <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>doextend</name> <operator>&amp;&amp;</operator> <name>nread</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
		<name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>TZ_MAX_TYPES</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name>	<modifier>*</modifier></type><name>ts</name> <init>= <expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>st</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>tzparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

			  <comment type="block">/* Attempt to reuse existing abbreviations.
			     Without this, America/Anchorage would be right on
			     the edge after 2037 when TZ_MAX_CHARS is 50, as
			     sp-&gt;charcnt equals 40 (for LMT AST AWT APT AHST
			     AHDT YST AKDT AKST) and ts-&gt;charcnt equals 10
			     (for AKST AKDT).  Reusing means sp-&gt;charcnt can
			     stay 40 in this example.  */</comment>
			  <decl_stmt><decl><type><name>int</name></type> <name>gotabbr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			  <decl_stmt><decl><type><name>int</name></type> <name>charcnt</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr></init></decl>;</decl_stmt>
			  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tsabbr</name> <init>= <expr><name><name>ts</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name></expr></init></decl>;</decl_stmt>
			    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
			    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>charcnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>gotabbr</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			      </block_content>}</block></if></if_stmt></block_content></block></for>
			    <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>j</name> <operator>&lt;</operator> <name>charcnt</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			      <decl_stmt><decl><type><name>int</name></type> <name>tsabbrlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <name>tsabbrlen</name> <operator>&lt;</operator> <name>TZ_MAX_CHARS</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>charcnt</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name>tsabbrlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>gotabbr</name><operator>++</operator></expr>;</expr_stmt>
			      </block_content>}</block></if></if_stmt>
			    </block_content>}</block></if></if_stmt>
			  </block_content>}</block></for>
			  <if_stmt><if>if <condition>(<expr><name>gotabbr</name> <operator>==</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition> <block>{<block_content>
			    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>

			    <comment type="block">/* Ignore any trailing, no-op transitions generated
			       by zic as they don't help here and can run afoul
			       of bugs in zic 2016j or earlier.  */</comment>
			    <while>while <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name>
				   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
				       <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

			    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
				 <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&lt;</operator> <name>TZ_MAX_TIMES</name></expr>;</condition>
				 <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			      <decl_stmt><decl><type><name>time_t</name></type> <name>t</name> <init>= <expr><name><name>ts</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			      <if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
				  <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name>
				      <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
			      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name>
							<operator>+</operator> <name><name>ts</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name><operator>++</operator></expr>;</expr_stmt>
			    </block_content>}</block></for>
			    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			  </block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <name>TIME_T_MAX</name> <operator>-</operator> <name>SECSPERREPEAT</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type> <name>repeatat</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>SECSPERREPEAT</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>repeattype</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		  <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>repeatat</name>
		      <operator>&amp;&amp;</operator> <call><name>typesequiv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>repeattype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
		  </block_content>}</block></if></if_stmt></block_content></block></for>
	    </block_content>}</block></if></if_stmt>
	    <if_stmt><if>if <condition>(<expr><name>TIME_T_MIN</name> <operator>+</operator> <name>SECSPERREPEAT</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type> <name>repeatat</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>SECSPERREPEAT</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>repeattype</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		  <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>repeatat</name>
		      <operator>&amp;&amp;</operator> <call><name>typesequiv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>repeattype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
		  </block_content>}</block></if></if_stmt></block_content></block></for>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Infer sp-&gt;defaulttype from the data.  Although this default
	   type is always zero for data from recent tzdb releases,
	   things are trickier for data from tzdb 2018e or earlier.

	   The first set of heuristics work around bugs in 32-bit data
	   generated by tzdb 2013c or earlier.  The workaround is for
	   zones like Australia/Macquarie where timestamps before the
	   first transition have a time type that is not the earliest
	   standard-time type.  See:
	   https://mm.icann.org/pipermail/tz/2013-May/019368.html */</comment>
	<comment type="block">/*
	** If type 0 does not specify local time, or is unused in transitions,
	** it's the type to use for early times.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>ttunspecified</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/*
	** Absent the above,
	** if there are transition times
	** and the first transition is to a daylight time
	** find the standard type less than and closest to
	** the type of the first transition.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* The next heuristics are for data generated by tzdb 2018e or
	   earlier, for zones like EST5EDT where the first transition
	   is to DST.  */</comment>
	<comment type="block">/*
	** If no result yet, find the first standard type.
	** If there is none, punt to type zero.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* A simple 'sp-&gt;defaulttype = 0;' would suffice here if we
	   didn't have to worry about 2018e-or-earlier data.  Even
	   simpler would be to remove the defaulttype member and just
	   use 0 in its place.  */</comment>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load tz data from the file named NAME into *SP.  Read extended
   format if DOEXTEND.  Return 0 on success, an errno value on failure.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tzload</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doextend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALL_STATE</name></cpp:ifdef>
  <decl_stmt><decl><type><name><name>union</name> <name>local_storage</name></name> <modifier>*</modifier></type><name>lsp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>lsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lsp</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>HAVE_MALLOC_ERRNO</name></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>ENOMEM</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>tzloadbody</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>doextend</name></expr></argument>, <argument><expr><name>lsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name><name>union</name> <name>local_storage</name></name></type> <name>ls</name></decl>;</decl_stmt>
  <return>return <expr><call><name>tzloadbody</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>doextend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>typesequiv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name>a</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>a</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>||</operator>
		<name>b</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>b</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* Compare the relevant members of *AP and *BP.
		   Ignore tt_ttisstd and tt_ttisut, as they are
		   irrelevant now and counting them could cause
		   sp-&gt;goahead to mistakenly remain false.  */</comment>
		<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>ap</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>a</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>bp</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>b</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>ap</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_utoff</name></name>
			  <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_isdst</name></name>
			  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ap</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></argument>,
				     <argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>bp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call>
			      <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>	<name><name>mon_lengths</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>MONSPERYEAR</name></expr>]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="number">31</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>	<name><name>year_lengths</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><name>DAYSPERNYEAR</name></expr>, <expr><name>DAYSPERLYEAR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Is C an ASCII digit?  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_digit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into a timezone string, scan until a character that is not
** a valid character in a time zone abbreviation is found.
** Return a pointer to that character.
*/</comment>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getzname</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name></type>	<name>c</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator>
		<name>c</name> <operator>!=</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into an extended timezone string, scan until the ending
** delimiter of the time zone abbreviation is located.
** Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We don't do any checking here; checking is done later in common-case code.
*/</comment>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getqzname</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>c</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into a timezone string, extract a number from that string.
** Check that the number is within a specified range; if it is not, return
** NULL.
** Otherwise, return a pointer to the first character not part of the number.
*/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getnum</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>nump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name></type>	<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do <block>{<block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* illegal value */</comment>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>strp</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* illegal value */</comment>
	<expr_stmt><expr><operator>*</operator><name>nump</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into a timezone string, extract a number of seconds,
** in hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the number
** of seconds.
*/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getsecs</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>secsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>secsperhour</name> <init>= <expr><name>SECSPERHOUR</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	** 'HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	** "M10.4.6/26", which does not conform to Posix,
	** but which specifies the equivalent of
	** "02:00 on the first Sunday on or after 23 Oct".
	*/</comment>
	<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HOURSPERDAY</name> <operator>*</operator> <name>DAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>=</operator> <name>num</name> <operator>*</operator> <name>secsperhour</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MINSPERHOUR</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>+=</operator> <name>num</name> <operator>*</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
			<comment type="block">/* 'SECSPERMIN' allows for leap seconds.  */</comment>
			<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SECSPERMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>+=</operator> <name>num</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into a timezone string, extract an offset, in
** [+-]hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the time.
*/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getoffset</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>offsetp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type> <name>neg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getsecs</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><name>offsetp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* illegal time */</comment>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>offsetp</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>offsetp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a pointer into a timezone string, extract a rule in the form
** date[/time]. See POSIX section 8 for the format of "date" and "time".
** If a valid rule is not found, return NULL.
** Otherwise, return a pointer to the first character not part of the rule.
*/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getrule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rulep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'J'</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Julian day.
		*/</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>JULIAN_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DAYSPERNYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'M'</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Month, week, day.
		*/</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>MONTH_NTH_DAY_OF_WEEK</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MONSPERYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_week</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><operator>*</operator><name>strp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Day of year.
		*/</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>DAY_OF_YEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DAYSPERLYEAR</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid format */</comment>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Time specified.
		*/</comment>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default = 2:00:00 */</comment>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a year, a rule, and the offset from UT at the time that rule takes
** effect, calculate the year-relative time that rule takes effect.
*/</comment>

<function><type><specifier>static</specifier> <name>int_fast32_t</name></type>
<name>transtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rulep</name></decl></parameter>,
	  <parameter><decl><type><specifier>const</specifier> <name>int_fast32_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>	<name>leapyear</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>d</name></decl>, <decl><type ref="prev"/><name>m1</name></decl>, <decl><type ref="prev"/><name>yy0</name></decl>, <decl><type ref="prev"/><name>yy1</name></decl>, <decl><type ref="prev"/><name>yy2</name></decl>, <decl><type ref="prev"/><name>dow</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>leapyear</name> <operator>=</operator> <call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name></expr>)</condition> <block>{<block_content>

	<case>case <expr><name>JULIAN_DAY</name></expr>:</case>
		<comment type="block">/*
		** Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
		** years.
		** In non-leap years, or if the day number is 59 or less, just
		** add SECSPERDAY times the day number-1 to the time of
		** January 1, midnight, to get the day.
		*/</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>leapyear</name> <operator>&amp;&amp;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>&gt;=</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>+=</operator> <name>SECSPERDAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<break>break;</break>

	<case>case <expr><name>DAY_OF_YEAR</name></expr>:</case>
		<comment type="block">/*
		** n - day of year.
		** Just add SECSPERDAY times the day number to the time of
		** January 1, midnight, to get the day.
		*/</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
		<break>break;</break>

	<case>case <expr><name>MONTH_NTH_DAY_OF_WEEK</name></expr>:</case>
		<comment type="block">/*
		** Mm.n.d - nth "dth day" of month m.
		*/</comment>

		<comment type="block">/*
		** Use Zeller's Congruence to get day-of-week of first day of
		** month.
		*/</comment>
		<expr_stmt><expr><name>m1</name> <operator>=</operator> <operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>+</operator> <literal type="number">9</literal><operator>)</operator> <operator>%</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>yy0</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>year</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>year</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>yy1</name> <operator>=</operator> <name>yy0</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>yy2</name> <operator>=</operator> <name>yy0</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dow</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">26</literal> <operator>*</operator> <name>m1</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">10</literal> <operator>+</operator>
			<literal type="number">1</literal> <operator>+</operator> <name>yy2</name> <operator>+</operator> <name>yy2</name> <operator>/</operator> <literal type="number">4</literal> <operator>+</operator> <name>yy1</name> <operator>/</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>yy1</name><operator>)</operator> <operator>%</operator> <literal type="number">7</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dow</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		** "dow" is the day-of-week of the first day of the month. Get
		** the day-of-month (zero-origin) of the first "dow" day of the
		** month.
		*/</comment>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>-</operator> <name>dow</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_week</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>+</operator> <name>DAYSPERWEEK</name> <operator>&gt;=</operator>
				<name><name>mon_lengths</name><index>[<expr><name>leapyear</name></expr>]</index><index>[<expr><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		** "d" is the day-of-month (zero-origin) of the day we want.
		*/</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name>d</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>+=</operator> <name><name>mon_lengths</name><index>[<expr><name>leapyear</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt></block_content></block></for>
		<break>break;</break>

	<default>default:</default> <expr_stmt><expr><call><name>unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	** "value" is the year-relative time of 00:00:00 UT on the day in
	** question. To get the year-relative time of the specified local
	** time on that day, add the transition time and the current offset
	** from UT.
	*/</comment>
	<return>return <expr><name>value</name> <operator>+</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Given a POSIX section 8-style TZ string, fill in the rule tables as
** appropriate.
*/</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tzparse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>basep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>			<name>stdname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>			<name>dstname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>			<name>stdoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>			<name>dstoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>load_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>stdlen</name></decl>, <decl><type ref="prev"/><name>dstlen</name></decl>, <decl><type ref="prev"/><name>charcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>atlo</name> <init>= <expr><name>TIME_T_MIN</name></expr></init></decl>, <decl><type ref="prev"/><name>leaplo</name> <init>= <expr><name>TIME_T_MIN</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>stdname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name>stdname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getqzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>stdlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>stdname</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>stdlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>stdname</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stdlen</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stdoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>charcnt</name> <operator>=</operator> <name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><sizeof>sizeof <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></sizeof> <operator>&lt;</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>basep</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>basep</name><operator>-&gt;</operator><name>timecnt</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>atlo</name> <operator>=</operator> <name><name>basep</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>basep</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>load_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <name><name>basep</name><operator>-&gt;</operator><name>leapcnt</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>lsis</name></name></expr></argument>, <argument><expr><name><name>basep</name><operator>-&gt;</operator><name>lsis</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name><name>sp</name><operator>-&gt;</operator><name>lsis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name>load_ok</name> <operator>=</operator> <call><name>tzload</name><argument_list>(<argument><expr><name>TZDEFRULES</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>load_ok</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* So, we're off a little.  */</comment>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>leaplo</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ls_trans</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>dstname</name> <operator>=</operator> <operator>++</operator><name>name</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getqzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>dstname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>dstname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>dstname</name></expr>;</expr_stmt> <comment type="block">/* length of DST abbr. */</comment>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstlen</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>charcnt</name> <operator>+=</operator> <name>dstlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><sizeof>sizeof <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></sizeof> <operator>&lt;</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dstoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>dstoffset</name> <operator>=</operator> <name>stdoffset</name> <operator>-</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>load_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <name>TZDEFRULESTRING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type>	<name>start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type>	<name>end</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>year</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>timecnt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>time_t</name></type>		<name>janfirst</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>janoffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>yearbeg</name></decl>, <decl><type ref="prev"/><name>yearlim</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>getrule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name><operator>++</operator> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>getrule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* standard time and DST */</comment>
			<comment type="block">/*
			** Two transitions per year, from EPOCH_YEAR forward.
			*/</comment>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>dstoffset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>janfirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>yearbeg</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>

			<do>do <block>{<block_content>
			  <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>yearsecs</name>
			    <init>= <expr><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>yearbeg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>*</operator> <name>SECSPERDAY</name></expr></init></decl>;</decl_stmt>
			  <expr_stmt><expr><name>yearbeg</name><operator>--</operator></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>janfirst</name></expr></argument>, <argument><expr><operator>-</operator><name>yearsecs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			    <expr_stmt><expr><name>janoffset</name> <operator>=</operator> <operator>-</operator><name>yearsecs</name></expr>;</expr_stmt>
			    <break>break;</break>
			  </block_content>}</block></if></if_stmt>
			</block_content>}</block> while <condition>(<expr><name>atlo</name> <operator>&lt;</operator> <name>janfirst</name>
				 <operator>&amp;&amp;</operator> <name>EPOCH_YEAR</name> <operator>-</operator> <name>YEARSPERREPEAT</name> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>yearbeg</name></expr>)</condition>;</do>

			<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
			  <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>yearsecs</name>
			    <init>= <expr><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>yearbeg</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>*</operator> <name>SECSPERDAY</name></expr></init></decl>;</decl_stmt>
			  <decl_stmt><decl><type><name>int</name></type> <name>yearbeg1</name> <init>= <expr><name>yearbeg</name></expr></init></decl>;</decl_stmt>
			  <decl_stmt><decl><type><name>time_t</name></type> <name>janfirst1</name> <init>= <expr><name>janfirst</name></expr></init></decl>;</decl_stmt>
			  <if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>janfirst1</name></expr></argument>, <argument><expr><name>yearsecs</name></expr></argument>)</argument_list></call>
			      <operator>||</operator> <call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yearbeg1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call>
			      <operator>||</operator> <name>atlo</name> <operator>&lt;=</operator> <name>janfirst1</name></expr>)</condition><block type="pseudo"><block_content>
			    <break>break;</break></block_content></block></if></if_stmt>
			  <expr_stmt><expr><name>yearbeg</name> <operator>=</operator> <name>yearbeg1</name></expr>;</expr_stmt>
			  <expr_stmt><expr><name>janfirst</name> <operator>=</operator> <name>janfirst1</name></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>yearbeg</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yearlim</name></expr></argument>, <argument><expr><name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>year</name> <operator>=</operator> <name>yearbeg</name></expr>;</init> <condition><expr><name>year</name> <operator>&lt;</operator> <name>yearlim</name></expr>;</condition> <incr><expr><name>year</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>int_fast32_t</name></type>
				  <name>starttime</name> <init>= <expr><call><name>transtime</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>stdoffset</name></expr></argument>)</argument_list></call></expr></init></decl>,
				  <decl><type ref="prev"/><name>endtime</name> <init>= <expr><call><name>transtime</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>dstoffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int_fast32_t</name></type>
				  <name>yearsecs</name> <init>= <expr><operator>(</operator><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index></name>
					      <operator>*</operator> <name>SECSPERDAY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>reversed</name> <init>= <expr><name>endtime</name> <operator>&lt;</operator> <name>starttime</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>reversed</name></expr>)</condition> <block>{<block_content>
					<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>swap</name> <init>= <expr><name>starttime</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>starttime</name> <operator>=</operator> <name>endtime</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>endtime</name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>reversed</name>
				    <operator>||</operator> <operator>(</operator><name>starttime</name> <operator>&lt;</operator> <name>endtime</name>
					<operator>&amp;&amp;</operator> <name>endtime</name> <operator>-</operator> <name>starttime</name> <operator>&lt;</operator> <name>yearsecs</name><operator>)</operator></expr>)</condition> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>TZ_MAX_TIMES</name> <operator>-</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>timecnt</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name>janfirst</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>increment_overflow_time</name>
					    <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr></argument>,
					     <argument><expr><name>janoffset</name> <operator>+</operator> <name>starttime</name></expr></argument>)</argument_list></call>
					    <operator>&amp;&amp;</operator> <name>atlo</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>reversed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name>janfirst</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>increment_overflow_time</name>
					    <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr></argument>,
					     <argument><expr><name>janoffset</name> <operator>+</operator> <name>endtime</name></expr></argument>)</argument_list></call>
					    <operator>&amp;&amp;</operator> <name>atlo</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>reversed</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>endtime</name> <operator>&lt;</operator> <name>leaplo</name></expr>)</condition> <block>{<block_content>
				  <expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>year</name></expr>;</expr_stmt>
				  <if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yearlim</name></expr></argument>,
							 <argument><expr><name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				    <expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name>
				    <argument_list>(<argument><expr><operator>&amp;</operator><name>janfirst</name></expr></argument>, <argument><expr><name>janoffset</name> <operator>+</operator> <name>yearsecs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>janoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>timecnt</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* Perpetual DST.  */</comment>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>YEARSPERREPEAT</name> <operator>&lt;</operator> <name>year</name> <operator>-</operator> <name>yearbeg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>	<name>theirstdoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>	<name>theirdstoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>	<name>theiroffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>		<name>isdst</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>j</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/*
			** Initial values of theirstdoffset and theirdstoffset.
			*/</comment>
			<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator>
						<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator>
						<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/*
			** Initially we're assumed to be in standard time.
			*/</comment>
			<expr_stmt><expr><name>isdst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/*
			** Now juggle transition times and types
			** tracking offsets as you do.
			*/</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_ttisut</name></expr>)</condition> <block>{<block_content>
					<comment type="block">/* No adjustment to transition time */</comment>
				</block_content>}</block></if> <else>else <block>{<block_content>
					<comment type="block">/*
					** If daylight saving time is in
					** effect, and the transition time was
					** not specified as standard time, add
					** the daylight saving time offset to
					** the transition time; otherwise, add
					** the standard time offset to the
					** transition time.
					*/</comment>
					<comment type="block">/*
					** Transitions from DST to DDST
					** will effectively disappear since
					** POSIX provides for only one DST
					** offset.
					*/</comment>
					<if_stmt><if>if <condition>(<expr><name>isdst</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_ttisstd</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>dstoffset</name> <operator>-</operator>
							<name>theirdstoffset</name></expr>;</expr_stmt>
					</block_content>}</block></if> <else>else <block>{<block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>stdoffset</name> <operator>-</operator>
							<name>theirstdoffset</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>theiroffset</name> <operator>=</operator> <operator>-</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator> <name>theiroffset</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator> <name>theiroffset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/*
			** Finally, fill in ttis.
			*/</comment>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>dstoffset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* only standard time */</comment>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>stdname</name></expr></argument>, <argument><expr><name>stdlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>+=</operator> <name>stdlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dstlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dstname</name></expr></argument>, <argument><expr><name>dstlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>cp</name> <operator>+</operator> <name>dstlen</name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gmtload</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tzload</name><argument_list>(<argument><expr><name>etc_utc</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>tzparse</name><argument_list>(<argument><expr><literal type="string">"UTC0"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize *SP to a value appropriate for the TZ setting NAME.
   Return 0 on success, an errno value on failure.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zoneinit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/*
    ** User wants it fast rather than right.
    */</comment>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* so, we're off a little */</comment>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></expr></argument>, <argument><expr><name>utc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>tzload</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>name</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <call><name>tzparse</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>scrub_abbrs</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>err</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tzset_unlocked</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TZ"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name>lclptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lcl</name> <init>= <expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof <name>lcl_TZname</name></sizeof></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>lcl</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
      ?</condition><then> <expr><name>lcl_is_set</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
      </then><else>: <expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lcl_is_set</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>lcl_TZname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALL_STATE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>sp</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lclptr</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>lclptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined ALL_STATE */</comment>
  <if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>zoneinit</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>zoneinit</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>lcl</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>lcl_TZname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>settzname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lcl_is_set</name> <operator>=</operator> <name>lcl</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tzset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lock</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>tzset_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gmtcheck</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>gmt_is_set</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lock</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>gmt_is_set</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ALL_STATE</name></cpp:ifdef>
    <expr_stmt><expr><name>gmtptr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>gmtptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>gmtptr</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>gmtload</name><argument_list>(<argument><expr><name>gmtptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>gmt_is_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NETBSD_INSPIRED</name></expr></cpp:if>

<function><type><name>timezone_t</name></type>
<name>tzalloc</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>timezone_t</name></type> <name>sp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>zoneinit</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>HAVE_MALLOC_ERRNO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>sp</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>tzfree</name><parameter_list>(<parameter><decl><type><name>timezone_t</name></type> <name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** NetBSD 6.1.4 has ctime_rz, but omit it because POSIX says ctime and
** ctime_r are obsolescent and have potential security problems that
** ctime_rz would share.  Callers can instead use localtime_rz + strftime.
**
** NetBSD 6.1.4 has tzgetname, but omit it because it doesn't work
** in zones with three or more time zone abbreviations.
** Callers can instead use localtime_rz + strftime.
*/</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The easy way to behave "as if no library function calls" localtime
** is to not call it, so we drop its guts into "localsub", which can be
** freely called. (And no, the PANS doesn't require the above behavior,
** but it *is* desirable.)
**
** If successful and SETNAME is nonzero,
** set the applicable parts of tzname, timezone and altzone;
** however, it's OK to omit this step if the timezone is POSIX-compatible,
** since in that case tzset should have already done this step correctly.
** SETNAME's type is int_fast32_t for compatibility with gmtsub,
** but it is actually a boolean and its value should be 0 or 1.
*/</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>localsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type> <name>setname</name></decl></parameter>,
	 <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type>	<name>ttisp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type>			<name>t</name> <init>= <expr><operator>*</operator><name>timep</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Don't bother to set tzname etc.; tzset has already done it.  */</comment>
	  <return>return <expr><call><name>gmtsub</name><argument_list>(<argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>time_t</name></type> <name>newt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>		<name>seconds</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>		<name>years</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><operator>--</operator><name>seconds</name></expr>;</expr_stmt>

			<comment type="block">/* Beware integer overflow, as SECONDS might
			   be close to the maximum time_t.  */</comment>
			<expr_stmt><expr><name>years</name> <operator>=</operator> <name>seconds</name> <operator>/</operator> <name>SECSPERREPEAT</name> <operator>*</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>years</name> <operator>*</operator> <name>AVGSECSPERYEAR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>years</name> <operator>+=</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>newt</name> <operator>=</operator> <name>t</name> <operator>+</operator> <name>seconds</name> <operator>+</operator> <name>SECSPERREPEAT</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
			  <expr_stmt><expr><name>newt</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>seconds</name> <operator>-</operator> <name>SECSPERREPEAT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>newt</name> <argument_list type="generic">&lt; <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
				<name>newt</name></expr></argument> &gt;</argument_list></name> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* "cannot happen" */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>localsub</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>setname</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>ckd_add</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>ckd_sub</name></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>
				    ?</condition><then> <expr><call><name>ckd_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
					      <argument><expr><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>years</name></expr></argument>)</argument_list></call></expr>
				    </then><else>: <expr><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
					      <argument><expr><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>years</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
				  <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast64_t</name></type> <name>newy</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newy</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newy</name> <operator>-=</operator> <name>years</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>newy</name> <operator>+=</operator> <name>years</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>INT_MIN</name> <operator>&lt;=</operator> <name>newy</name> <operator>&amp;&amp;</operator> <name>newy</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>newy</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>lo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>hi</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>mid</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>lo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/*
	** To get (wrong) behavior that's compatible with System V Release 2.0
	** you'd replace the statement below with
	**	t += ttisp-&gt;tt_utoff;
	**	timesub(&amp;t, 0L, sp, tmp);
	*/</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timesub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TM_ZONE</name></cpp:ifdef>
	  <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>TM_ZONE</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined TM_ZONE */</comment>
	  <if_stmt><if>if <condition>(<expr><name>setname</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>update_tzname_etc</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ttisp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NETBSD_INSPIRED</name></expr></cpp:if>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>localtime_rz</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>localsub</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>localtime_tzset</name><parameter_list>(<parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>setname</name> <operator>||</operator> <operator>!</operator><name>lcl_is_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>tzset_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>localsub</name><argument_list>(<argument><expr><name>lclptr</name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><name>setname</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>tmp</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>localtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SUPPORT_C89</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>localtime_tzset</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>localtime_r</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>localtime_tzset</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** gmtsub is to gmtime as localsub is to localtime.
*/</comment>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>gmtsub</name><parameter_list>(<parameter><decl><type><name>ATTRIBUTE_MAYBE_UNUSED</name> <name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>,
       <parameter><decl><type><name>int_fast32_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timesub</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TM_ZONE</name></cpp:ifdef>
	<comment type="block">/*
	** Could get fancy here and deliver something such as
	** "+xx" or "-xx" if offset is non-zero,
	** but this is no time for a treasure hunt.
	*/</comment>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>TM_ZONE</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><ternary><condition><expr><name>offset</name></expr> ?</condition><then> <expr><name>wildabbr</name></expr> </then><else>: <expr><ternary><condition><expr><name>gmtptr</name></expr> ?</condition><then> <expr><name><name>gmtptr</name><operator>-&gt;</operator><name>chars</name></name></expr> </then><else>: <expr><name>utc</name></expr></else></ternary></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined TM_ZONE */</comment>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
* Re-entrant version of gmtime.
*/</comment>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>gmtime_r</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>gmtcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>gmtsub</name><argument_list>(<argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>gmtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SUPPORT_C89</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>gmtime_r</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STD_INSPIRED</name></expr></cpp:if>

<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>offtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>gmtcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SUPPORT_C89</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>gmtsub</name><argument_list>(<argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/</comment>

<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>leaps_thru_end_of_nonneg</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name>y</name> <operator>/</operator> <literal type="number">4</literal> <operator>-</operator> <name>y</name> <operator>/</operator> <literal type="number">100</literal> <operator>+</operator> <name>y</name> <operator>/</operator> <literal type="number">400</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>leaps_thru_end_of</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
	  ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <call><name>leaps_thru_end_of_nonneg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>y</name></expr></argument>)</argument_list></call></expr>
	  </then><else>: <expr><call><name>leaps_thru_end_of_nonneg</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type>
<name>timesub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type> <name>offset</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lsinfo</name></name> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>			<name>tdays</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>int</name> <modifier>*</modifier></type>		<name>ip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>		<name>corr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>idays</name></decl>, <decl><type ref="prev"/><name>rem</name></decl>, <decl><type ref="prev"/><name>dayoff</name></decl>, <decl><type ref="prev"/><name>dayrem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>y</name></decl>;</decl_stmt>

	<comment type="block">/* If less than SECSPERMIN, the number of seconds since the
	   most recent positive leap second; otherwise, do not add 1
	   to localtime tm_sec because of leap seconds.  */</comment>
	<decl_stmt><decl><type><name>time_t</name></type> <name>secs_since_posleap</name> <init>= <expr><name>SECSPERMIN</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>corr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr></else></ternary></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>timep</name> <operator>&gt;=</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_trans</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>corr</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_corr</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>lp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ls_corr</name></expr></else></ternary><operator>)</operator> <operator>&lt;</operator> <name>corr</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>secs_since_posleap</name> <operator>=</operator> <operator>*</operator><name>timep</name> <operator>-</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_trans</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Calculate the year, avoiding integer overflow even if
	   time_t is unsigned.  */</comment>
	<expr_stmt><expr><name>tdays</name> <operator>=</operator> <operator>*</operator><name>timep</name> <operator>/</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>=</operator> <operator>*</operator><name>timep</name> <operator>%</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>+=</operator> <name>offset</name> <operator>%</operator> <name>SECSPERDAY</name> <operator>-</operator> <name>corr</name> <operator>%</operator> <name>SECSPERDAY</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <name>offset</name> <operator>/</operator> <name>SECSPERDAY</name> <operator>-</operator> <name>corr</name> <operator>/</operator> <name>SECSPERDAY</name> <operator>+</operator> <name>rem</name> <operator>/</operator> <name>SECSPERDAY</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>%=</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<comment type="block">/* y = (EPOCH_YEAR
	        + floor((tdays + dayoff) / DAYSPERREPEAT) * YEARSPERREPEAT),
	   sans overflow.  But calculate against 1570 (EPOCH_YEAR -
	   YEARSPERREPEAT) instead of against 1970 so that things work
	   for localtime values before 1970 when time_t is unsigned.  */</comment>
	<expr_stmt><expr><name>dayrem</name> <operator>=</operator> <name>tdays</name> <operator>%</operator> <name>DAYSPERREPEAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dayrem</name> <operator>+=</operator> <name>dayoff</name> <operator>%</operator> <name>DAYSPERREPEAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <operator>(</operator><name>EPOCH_YEAR</name> <operator>-</operator> <name>YEARSPERREPEAT</name>
	     <operator>+</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>dayoff</name> <operator>/</operator> <name>DAYSPERREPEAT</name> <operator>+</operator> <name>dayrem</name> <operator>/</operator> <name>DAYSPERREPEAT</name>
		 <operator>-</operator> <operator>(</operator><operator>(</operator><name>dayrem</name> <operator>%</operator> <name>DAYSPERREPEAT</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator>
		 <operator>+</operator> <name>tdays</name> <operator>/</operator> <name>DAYSPERREPEAT</name><operator>)</operator>
		<operator>*</operator> <name>YEARSPERREPEAT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* idays = (tdays + dayoff) mod DAYSPERREPEAT, sans overflow.  */</comment>
	<expr_stmt><expr><name>idays</name> <operator>=</operator> <name>tdays</name> <operator>%</operator> <name>DAYSPERREPEAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>idays</name> <operator>+=</operator> <name>dayoff</name> <operator>%</operator> <name>DAYSPERREPEAT</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>DAYSPERREPEAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>idays</name> <operator>%=</operator> <name>DAYSPERREPEAT</name></expr>;</expr_stmt>
	<comment type="block">/* Increase Y and decrease IDAYS until IDAYS is in range for Y.  */</comment>
	<while>while <condition>(<expr><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&lt;=</operator> <name>idays</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>tdelta</name> <init>= <expr><name>idays</name> <operator>/</operator> <name>DAYSPERLYEAR</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int_fast32_t</name></type> <name>ydelta</name> <init>= <expr><name>tdelta</name> <operator>+</operator> <operator>!</operator><name>tdelta</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type> <name>newy</name> <init>= <expr><name>y</name> <operator>+</operator> <name>ydelta</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>leapdays</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>leapdays</name> <operator>=</operator> <call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>newy</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idays</name> <operator>-=</operator> <name>ydelta</name> <operator>*</operator> <name>DAYSPERNYEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>idays</name> <operator>-=</operator> <name>leapdays</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name>newy</name></expr>;</expr_stmt>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>-</operator><name>TM_YEAR_BASE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EOVERFLOW</name></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <name>TM_YEAR_BASE</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>signed_y</name> <init>= <expr><name>y</name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>signed_y</name> <operator>-</operator> <name>TM_YEAR_BASE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>INT_MIN</name> <operator>+</operator> <name>TM_YEAR_BASE</name> <operator>&lt;=</operator> <name>y</name><operator>)</operator>
		   <operator>&amp;&amp;</operator> <name>y</name> <operator>-</operator> <name>TM_YEAR_BASE</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>y</name> <operator>-</operator> <name>TM_YEAR_BASE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
	  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EOVERFLOW</name></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <name>idays</name></expr>;</expr_stmt>
	<comment type="block">/*
	** The "extra" mods below avoid overflow problems.
	*/</comment>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <operator>(</operator><name>TM_WDAY_BASE</name>
			<operator>+</operator> <operator>(</operator><operator>(</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>%</operator> <name>DAYSPERWEEK</name><operator>)</operator>
			   <operator>*</operator> <operator>(</operator><name>DAYSPERNYEAR</name> <operator>%</operator> <name>DAYSPERWEEK</name><operator>)</operator><operator>)</operator>
			<operator>+</operator> <call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
			<operator>-</operator> <call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>TM_YEAR_BASE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
			<operator>+</operator> <name>idays</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>%=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>rem</name> <operator>/</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>%=</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>rem</name> <operator>/</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>rem</name> <operator>%</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>

	<comment type="block">/* Use "... ??:??:60" at the end of the localtime minute containing
	   the second just before the positive leap second.  */</comment>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <name>secs_since_posleap</name> <operator>&lt;=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>mon_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idays</name> <operator>&gt;=</operator> <name><name>ip</name><index>[<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><operator>(</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idays</name> <operator>-=</operator> <name><name>ip</name><index>[<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name>idays</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TM_GMTOFF</name></cpp:ifdef>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>TM_GMTOFF</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined TM_GMTOFF */</comment>
	<return>return <expr><name>tmp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Adapted from code provided by Robert Elz, who writes:
**	The "best" way to do mktime I think is based on an idea of Bob
**	Kridle's (so its said...) from a long time ago.
**	It does a binary search of the time_t space. Since time_t's are
**	just 32 bits, its a max of 32 iterations (even at 64 bits it
**	would still be very reasonable).
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WRONG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WRONG</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined WRONG */</comment>

<comment type="block">/*
** Normalize logic courtesy Paul Eggert.
*/</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>increment_overflow</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
	<return>return <expr><call><name>ckd_add</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>*</operator><name>ip</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name> <specifier>const</specifier></type>	<name>i</name> <init>= <expr><operator>*</operator><name>ip</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	** If i &gt;= 0 there can only be overflow if i + j &gt; INT_MAX
	** or if j &gt; INT_MAX - i; given i &gt;= 0, INT_MAX - i cannot overflow.
	** If i &lt; 0 there can only be overflow if i + j &lt; INT_MIN
	** or if j &lt; INT_MIN - i; given i &lt; 0, INT_MIN - i cannot overflow.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>-</operator> <name>i</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>j</name> <operator>&lt;</operator> <name>INT_MIN</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ip</name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>increment_overflow32</name><parameter_list>(<parameter><decl><type><name>int_fast32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>const</specifier></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
	<return>return <expr><call><name>ckd_add</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>*</operator><name>lp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name> <specifier>const</specifier></type>	<name>l</name> <init>= <expr><operator>*</operator><name>lp</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>l</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>m</name> <operator>&gt;</operator> <name>INT_FAST32_MAX</name> <operator>-</operator> <name>l</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>m</name> <operator>&lt;</operator> <name>INT_FAST32_MIN</name> <operator>-</operator> <name>l</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>lp</name> <operator>+=</operator> <name>m</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>increment_overflow_time</name><parameter_list>(<parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>, <parameter><decl><type><name>int_fast32_t</name></type> <name>j</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
	<return>return <expr><call><name>ckd_add</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><operator>*</operator><name>tp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/*
	** This is like
	** 'if (! (TIME_T_MIN &lt;= *tp + j &amp;&amp; *tp + j &lt;= TIME_T_MAX)) ...',
	** except that it does the right thing even if *tp + j would overflow.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><ternary><condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
	       ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TIME_T_MIN</name> <operator>-</operator> <name>j</name> <operator>&lt;=</operator> <operator>*</operator><name>tp</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name> <operator>&lt;</operator> <operator>*</operator><name>tp</name></expr></else></ternary><operator>)</operator></expr>
	       </then><else>: <expr><operator>*</operator><name>tp</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name> <operator>-</operator> <name>j</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>normalize_overflow</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tensptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>unitsptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>tensdelta</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tensdelta</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>unitsptr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>(</operator><operator>*</operator><name>unitsptr</name> <operator>/</operator> <name>base</name><operator>)</operator></expr> </then><else>:
		<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>*</operator><name>unitsptr</name><operator>)</operator> <operator>/</operator> <name>base</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>unitsptr</name> <operator>-=</operator> <name>tensdelta</name> <operator>*</operator> <name>base</name></expr>;</expr_stmt>
	<return>return <expr><call><name>increment_overflow</name><argument_list>(<argument><expr><name>tensptr</name></expr></argument>, <argument><expr><name>tensdelta</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>normalize_overflow32</name><parameter_list>(<parameter><decl><type><name>int_fast32_t</name> <modifier>*</modifier></type><name>tensptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>unitsptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>tensdelta</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tensdelta</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>unitsptr</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>(</operator><operator>*</operator><name>unitsptr</name> <operator>/</operator> <name>base</name><operator>)</operator></expr> </then><else>:
		<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>*</operator><name>unitsptr</name><operator>)</operator> <operator>/</operator> <name>base</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>unitsptr</name> <operator>-=</operator> <name>tensdelta</name> <operator>*</operator> <name>base</name></expr>;</expr_stmt>
	<return>return <expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><name>tensptr</name></expr></argument>, <argument><expr><name>tensdelta</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tmcomp</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>atmp</name></decl></parameter>,
       <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>btmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>atmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>!=</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_year</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>atmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_year</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <operator>(</operator><name><name>atmp</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>result</name> <operator>=</operator> <operator>(</operator><name><name>atmp</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>result</name> <operator>=</operator> <operator>(</operator><name><name>atmp</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>-</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>result</name> <operator>=</operator> <operator>(</operator><name><name>atmp</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>-</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>atmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>-</operator> <name><name>btmp</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Copy to *DEST from *SRC.  Copy only the members needed for mktime,
   as other members might not be initialized.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mktmcpy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>TM_GMTOFF</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>UNINIT_TRAP</name></expr></cpp:if>
  <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>TM_GMTOFF</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>TM_GMTOFF</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type>
<name>time2sub</name><argument_list>(<argument><expr>struct <name>tm</name> <operator>*</operator><specifier>const</specifier> <name>tmp</name></expr></argument>,
	 <argument><expr>struct <name>tm</name> <operator>*</operator><call>(<modifier>*</modifier><name>funcp</name>)<argument_list>(<argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><name>time_t</name> <specifier>const</specifier> <operator>*</operator></expr></argument>,
			     <argument><expr><name>int_fast32_t</name></expr></argument>, <argument><expr>struct <name>tm</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
	 <argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator><name>sp</name></expr></argument>,
	 <argument><expr><specifier>const</specifier> <name>int_fast32_t</name> <name>offset</name></expr></argument>,
	 <argument><expr><name>bool</name> <operator>*</operator><name>okayp</name></expr></argument>,
	 <argument><expr><name>bool</name> <name>do_norm_secs</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>saved_seconds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int_fast32_t</name></type>		<name>li</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>			<name>lo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>			<name>hi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int_fast32_t</name></type>			<name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>				<name>newt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>				<name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>			<name>yourtm</name></decl>, <decl><type ref="prev"/><name>mytm</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>okayp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mktmcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yourtm</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_norm_secs</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>normalize_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_min</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>,
			<argument><expr><name>SECSPERMIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>normalize_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name>MINSPERHOUR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>normalize_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name>HOURSPERDAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>yourtm</name><operator>.</operator><name>tm_year</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>normalize_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name>MONSPERYEAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	** Turn y into an actual year number for now.
	** It is converted back to an offset from TM_YEAR_BASE later.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><name>TM_YEAR_BASE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>li</name> <operator>=</operator> <name>y</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>+=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>&gt;</operator> <name>DAYSPERLYEAR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>li</name> <operator>=</operator> <name>y</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>-=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>mon_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_mday</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name> <operator>&gt;=</operator> <name>MONSPERYEAR</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><operator>-</operator><name>TM_YEAR_BASE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>-</operator><name>TM_YEAR_BASE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>INT_MIN</name> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name> <operator>&lt;</operator> <name>SECSPERMIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_seconds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_year</name></name> <operator>&lt;</operator> <name>EPOCH_YEAR</name> <operator>-</operator> <name>TM_YEAR_BASE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>-</operator> <name>SECSPERMIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>saved_seconds</name> <operator>=</operator> <name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <name>SECSPERMIN</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>saved_seconds</name> <operator>=</operator> <name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yourtm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/*
	** Do a binary search (this works whatever time_t's type is).
	*/</comment>
	<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>TIME_T_MIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>TIME_T_MAX</name></expr>;</expr_stmt>
	<for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <name>lo</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name>hi</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>lo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>t</name> <operator>&gt;</operator> <name>hi</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>funcp</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mytm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/</comment>
			<expr_stmt><expr><name>dir</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>t</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>tmcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mytm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yourtm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>lo</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TIME_T_MAX</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>++</operator><name>t</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>lo</name></expr>;</expr_stmt>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>hi</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TIME_T_MIN</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>--</operator><name>t</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>--</operator><name>hi</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>lo</name> <operator>&gt;</operator> <name>hi</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>TM_GMTOFF</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>UNINIT_TRAP</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>mytm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>!=</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name>
		    <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
			?</condition><then> <expr><operator>(</operator><operator>-</operator><name>SECSPERDAY</name> <operator>&lt;=</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name>
			   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mytm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>&lt;=</operator>
			       <operator>(</operator><call><name>min</name><argument_list>(<argument><expr><name>INT_FAST32_MAX</name></expr></argument>, <argument><expr><name>LONG_MAX</name></expr></argument>)</argument_list></call>
				<operator>+</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>
			</then><else>: <expr><operator>(</operator><name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>&lt;=</operator> <name>SECSPERDAY</name>
			   <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>max</name><argument_list>(<argument><expr><name>INT_FAST32_MIN</name></expr></argument>, <argument><expr><name>LONG_MIN</name></expr></argument>)</argument_list></call>
				<operator>+</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name><operator>)</operator>
			       <operator>&lt;=</operator> <name><name>mytm</name><operator>.</operator><name>TM_GMTOFF</name></name><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
		  <comment type="block">/* MYTM matches YOURTM except with the wrong UT offset.
		     YOURTM.TM_GMTOFF is plausible, so try it instead.
		     It's OK if YOURTM.TM_GMTOFF contains uninitialized data,
		     since the guess gets checked.  */</comment>
		  <decl_stmt><decl><type><name>time_t</name></type> <name>altt</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>diff</name> <init>= <expr><name><name>mytm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>-</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name></expr></init></decl>;</decl_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>altt</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		    <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>alttm</name></decl>;</decl_stmt>
		    <if_stmt><if>if <condition>(<expr><call><name>funcp</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>altt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alttm</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <name><name>alttm</name><operator>.</operator><name>tm_isdst</name></name> <operator>==</operator> <name><name>mytm</name><operator>.</operator><name>tm_isdst</name></name>
			<operator>&amp;&amp;</operator> <name><name>alttm</name><operator>.</operator><name>TM_GMTOFF</name></name> <operator>==</operator> <name><name>yourtm</name><operator>.</operator><name>TM_GMTOFF</name></name>
			<operator>&amp;&amp;</operator> <call><name>tmcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alttm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yourtm</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		      <expr_stmt><expr><name>t</name> <operator>=</operator> <name>altt</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>mytm</name> <operator>=</operator> <name>alttm</name></expr>;</expr_stmt>
		    </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>yourtm</name><operator>.</operator><name>tm_isdst</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>mytm</name><operator>.</operator><name>tm_isdst</name></name> <operator>==</operator> <name><name>yourtm</name><operator>.</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name> <operator>!=</operator> <name><name>yourtm</name><operator>.</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name> <operator>==</operator> <name><name>yourtm</name><operator>.</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ttunspecified</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				  <continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newt</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name>
					<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>funcp</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mytm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>tmcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mytm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yourtm</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>mytm</name><operator>.</operator><name>tm_isdst</name></name> <operator>!=</operator> <name><name>yourtm</name><operator>.</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<comment type="block">/*
				** We have a match.
				*/</comment>
				<expr_stmt><expr><name>t</name> <operator>=</operator> <name>newt</name></expr>;</expr_stmt>
				<goto>goto <name>label</name>;</goto>
			</block_content>}</block></for>
		</block_content>}</block></for>
		<return>return <expr><name>WRONG</name></expr>;</return>
	</block_content>}</block></for>
<label><name>label</name>:</label>
	<expr_stmt><expr><name>newt</name> <operator>=</operator> <name>t</name> <operator>+</operator> <name>saved_seconds</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newt</name> <operator>&lt;</operator> <name>t</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>saved_seconds</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name>newt</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>funcp</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>okayp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type>
<name>time2</name><argument_list>(<argument><expr>struct <name>tm</name> <operator>*</operator> <specifier>const</specifier>	<name>tmp</name></expr></argument>,
      <argument><expr>struct <name>tm</name> <operator>*</operator><call>(<modifier>*</modifier><name>funcp</name>)<argument_list>(<argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><name>time_t</name> <specifier>const</specifier> <operator>*</operator></expr></argument>,
			  <argument><expr><name>int_fast32_t</name></expr></argument>, <argument><expr>struct <name>tm</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator><name>sp</name></expr></argument>,
      <argument><expr><specifier>const</specifier> <name>int_fast32_t</name> <name>offset</name></expr></argument>,
      <argument><expr><name>bool</name> <operator>*</operator><name>okayp</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type>	<name>t</name></decl>;</decl_stmt>

	<comment type="block">/*
	** First try without normalization of seconds
	** (in case tm_sec contains a value associated with a leap second).
	** If that fails, try with normalization of seconds.
	*/</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>time2sub</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>funcp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>okayp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><operator>*</operator><name>okayp</name></expr> ?</condition><then> <expr><name>t</name></expr> </then><else>: <expr><call><name>time2sub</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>funcp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>okayp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type>
<name>time1</name><argument_list>(<argument><expr>struct <name>tm</name> <operator>*</operator><specifier>const</specifier> <name>tmp</name></expr></argument>,
      <argument><expr>struct <name>tm</name> <operator>*</operator><call>(<modifier>*</modifier><name>funcp</name>)<argument_list>(<argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><name>time_t</name> <specifier>const</specifier> <operator>*</operator></expr></argument>,
			  <argument><expr><name>int_fast32_t</name></expr></argument>, <argument><expr>struct <name>tm</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr>struct <name>state</name> <specifier>const</specifier> <operator>*</operator><name>sp</name></expr></argument>,
      <argument><expr><specifier>const</specifier> <name>int_fast32_t</name> <name>offset</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>time_t</name></type>			<name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>samei</name></decl>, <decl><type ref="prev"/><name>otheri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>sameind</name></decl>, <decl><type ref="prev"/><name>otherind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>nseen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>				<name><name>seen</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>			<name><name>types</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>okay</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<return>return <expr><name>WRONG</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>time2</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>funcp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>okay</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>t</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PCTS</name></cpp:ifdef>
		<comment type="block">/*
		** POSIX Conformance Test Suite code courtesy Grant Sullivan.
		*/</comment>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* reset to std and try again */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<return>return <expr><name>t</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined PCTS */</comment>
	<comment type="block">/*
	** We're supposed to assume that somebody took a time of one type
	** and did some math on it that yielded a "struct tm" that's bad.
	** We try to divine the type they started from and adjust to the
	** type they need.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WRONG</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>nseen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ttunspecified</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>seen</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>types</name><index>[<expr><name>nseen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt></block_content></block></for>
	<for>for <control>(<init><expr><name>sameind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sameind</name> <operator>&lt;</operator> <name>nseen</name></expr>;</condition> <incr><expr><operator>++</operator><name>sameind</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>samei</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>sameind</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>samei</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name> <operator>!=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>otherind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>otherind</name> <operator>&lt;</operator> <name>nseen</name></expr>;</condition> <incr><expr><operator>++</operator><name>otherind</name></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>otheri</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>otherind</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>otheri</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name> <operator>==</operator> <name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>otheri</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name>
					<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>samei</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>!</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>time2</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>funcp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>okay</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>t</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>-=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>otheri</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name>
					<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>samei</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>!</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<return>return <expr><name>WRONG</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>mktime_tzname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>time1</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>localsub</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>setname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>gmtcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>time1</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>gmtsub</name></expr></argument>, <argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NETBSD_INSPIRED</name></expr></cpp:if>

<function><type><name>time_t</name></type>
<name>mktime_z</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>mktime_tzname</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>time_t</name></type>
<name>mktime</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>tzset_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>mktime_tzname</name><argument_list>(<argument><expr><name>lclptr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STD_INSPIRED</name></expr></cpp:if>
<function><type><name>time_t</name></type>
<name>timelocal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* in case it wasn't initialized */</comment>
	<return>return <expr><call><name>mktime</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>time_t</name></type>
<name>timeoff</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>gmtcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>time1</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>gmtsub</name></expr></argument>, <argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>time_t</name></type>
<name>timegm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>tmcpy</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>mktmcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmcpy</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmcpy</name><operator>.</operator><name>tm_wday</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>timeoff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmcpy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>tmcpy</name><operator>.</operator><name>tm_wday</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <name>tmcpy</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int_fast32_t</name></type>
<name>leapcorr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>lsinfo</name></name> <specifier>const</specifier> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&gt;=</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_trans</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>lp</name><operator>-&gt;</operator><name>ls_corr</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** XXX--is the below the right way to conditionalize??
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>STD_INSPIRED</name></expr></cpp:if>

<comment type="block">/* NETBSD_INSPIRED_EXTERN functions are exported to callers if
   NETBSD_INSPIRED is defined, and are private otherwise.  */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>NETBSD_INSPIRED</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NETBSD_INSPIRED_EXTERN</name></cpp:macro></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NETBSD_INSPIRED_EXTERN</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** IEEE Std 1003.1 (POSIX) says that 536457599
** shall correspond to "Wed Dec 31 23:59:59 UTC 1986", which
** is not the case if we are accounting for leap seconds.
** So, we provide the following conversion routines for use
** when exchanging timestamps with POSIX conforming systems.
*/</comment>

<function><type><name>NETBSD_INSPIRED_EXTERN</name> <name>time_t</name></type>
<name>time2posix_z</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name>t</name> <operator>-</operator> <call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>time_t</name></type>
<name>time2posix</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lcl_is_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>tzset_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>lclptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>time2posix_z</name><argument_list>(<argument><expr><name>lclptr</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>NETBSD_INSPIRED_EXTERN</name> <name>time_t</name></type>
<name>posix2time_z</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>	<name>y</name></decl>;</decl_stmt>
	<comment type="block">/*
	** For a positive leap second hit, the result
	** is not unique. For a negative leap second
	** hit, the corresponding time doesn't exist,
	** so we return an adjacent second.
	*/</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <name>t</name> <operator>+</operator> <call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name> <operator>-</operator> <call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>
		<do>do <block>{<block_content>
			<expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name> <operator>-</operator> <call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>y</name> <operator>&lt;</operator> <name>t</name></expr>)</condition>;</do>
		<expr_stmt><expr><name>x</name> <operator>-=</operator> <name>y</name> <operator>!=</operator> <name>t</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>y</name> <operator>&gt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>
		<do>do <block>{<block_content>
			<expr_stmt><expr><operator>--</operator><name>x</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name> <operator>-</operator> <call><name>leapcorr</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>y</name> <operator>&gt;</operator> <name>t</name></expr>)</condition>;</do>
		<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>!=</operator> <name>t</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>time_t</name></type>
<name>posix2time</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>lock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lcl_is_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>tzset_unlocked</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>lclptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>posix2time_z</name><argument_list>(<argument><expr><name>lclptr</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STD_INSPIRED */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TZ_TIME_T</name></expr></cpp:if>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>USG_COMPAT</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>daylight</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>timezone</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ALTZONE</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>altzone</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Convert from the underlying system's time_t to the ersatz time_tz,
   which is called 'time_t' in this file.  Typically, this merely
   converts the time's integer width.  On some platforms, the system
   time is local time not UT, or uses some epoch other than the POSIX
   epoch.

   Although this code appears to define a function named 'time' that
   returns time_t, the macros in private.h cause this code to actually
   define a function named 'tz_time' that returns tz_time_t.  The call
   to sys_time invokes the underlying system's 'time' function.  */</comment>

<function><type><name>time_t</name></type>
<name>time</name><parameter_list>(<parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>time_t</name></type> <name>r</name> <init>= <expr><call><name>sys_time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int_fast32_t</name></type> <name>offset</name> <init>= <expr><ternary><condition><expr><name>EPOCH_LOCAL</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>daylight</name></expr> ?</condition><then> <expr><name>timezone</name></expr> </then><else>: <expr><name>altzone</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>increment_overflow32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>-</operator><name>EPOCH_OFFSET</name></expr></argument>)</argument_list></call>
	<operator>||</operator> <call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EOVERFLOW</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
