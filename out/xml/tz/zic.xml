<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/tz/zic.c"><comment type="block">/* Compile .zi time zone data into TZif binary files.  */</comment>

<comment type="block">/*
** This file is in the public domain, so clarified as of
** 2006-07-17 by Arthur David Olson.
*/</comment>

<comment type="block">/* Use the system 'time' function, instead of any private replacement.
   This avoids creating an unnecessary dependency on localtime.c.  */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EPOCH_LOCAL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EPOCH_OFFSET</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RESERVE_STD_EXT_IDS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>time_tz</name></cpp:undef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tzfile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><name>int_fast64_t</name></type>	<name>zic_t</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name> <specifier>const</specifier></type>
  <name>ZIC_MIN</name> <init>= <expr><name>INT_FAST64_MIN</name></expr></init></decl>,
  <decl><type ref="prev"/><name>ZIC_MAX</name> <init>= <expr><name>INT_FAST64_MAX</name></expr></init></decl>,
  <decl><type ref="prev"/><name>ZIC32_MIN</name> <init>= <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>zic_t</name><operator>)</operator> <literal type="number">0x7fffffff</literal></expr></init></decl>,
  <decl><type ref="prev"/><name>ZIC32_MAX</name> <init>= <expr><literal type="number">0x7fffffff</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCNdZIC</name></cpp:macro> <cpp:value>SCNdFAST64</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZIC_MAX_ABBR_LEN_WO_WARN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_MAX_ABBR_LEN_WO_WARN</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined ZIC_MAX_ABBR_LEN_WO_WARN */</comment>

<comment type="block">/* An upper bound on how much a format might grow due to concatenation.  */</comment>
<enum>enum <block>{ <decl><name>FORMAT_LEN_GROWTH_BOUND</name> <init>= <expr><literal type="number">5</literal></expr></init></decl> }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DIRECT_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>mkdir</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>mkdir</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_mkdir(name)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETRANDOM</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>__has_include</name></cpp:ifdef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>__has_include</name><argument_list>(<argument><expr><operator>&lt;</operator><name>sys</name><operator>/</operator><name><name>random</name><operator>.</operator><name>h</name></name><operator>&gt;</operator></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/random.h&gt;</cpp:file></cpp:include>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><literal type="number">2</literal> <operator>&lt;</operator> <name>__GLIBC__</name> <operator>+</operator> <operator>(</operator><literal type="number">25</literal> <operator>&lt;=</operator> <name>__GLIBC_MINOR__</name><operator>)</operator></expr></cpp:elif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/random.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETRANDOM</name></cpp:macro> <cpp:value>GRND_RANDOM</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_GETRANDOM</name></expr></cpp:elif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/random.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYS_STAT_H</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>S_IRUSR</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MKDIR_UMASK</name></cpp:macro> <cpp:value>(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>MKDIR_UMASK</name></cpp:macro> <cpp:value>0755</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The minimum alignment of a type, for pre-C23 platforms.
   The __SUNPRO_C test is because Oracle Developer Studio 12.6 lacks
   &lt;stdalign.h&gt; even though __STDC_VERSION__ == 201112.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">201112</literal> <operator>||</operator> <name>defined</name> <name>__SUNPRO_C</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>alignof</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(struct { char a; type b; }, b)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">202311</literal></expr></cpp:elif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdalign.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The maximum length of a text line, including the trailing newline.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_POSIX2_LINE_MAX</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX2_LINE_MAX</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The type for line numbers.  Use PRIdMAX to format them; formerly
   there was also "#define PRIdLINENO PRIdMAX" and formats used
   PRIdLINENO, but xgettext cannot grok that.  */</comment>
<typedef>typedef <type><name>intmax_t</name></type> <name>lineno</name>;</typedef>

<struct>struct <name>rule</name> <block>{
	<decl_stmt><decl><type><name>int</name></type>		<name>r_filenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lineno</name></type>		<name>r_linenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>r_name</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>zic_t</name></type>		<name>r_loyear</name></decl>;</decl_stmt>	<comment type="block">/* for example, 1986 */</comment>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>r_hiyear</name></decl>;</decl_stmt>	<comment type="block">/* for example, 1986 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r_lowasnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r_hiwasnum</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>		<name>r_month</name></decl>;</decl_stmt>	<comment type="block">/* 0..11 */</comment>

	<decl_stmt><decl><type><name>int</name></type>		<name>r_dycode</name></decl>;</decl_stmt>	<comment type="block">/* see below */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>r_dayofmonth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>r_wday</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>zic_t</name></type>		<name>r_tod</name></decl>;</decl_stmt>		<comment type="block">/* time from midnight */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r_todisstd</name></decl>;</decl_stmt>	<comment type="block">/* is r_tod standard time? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r_todisut</name></decl>;</decl_stmt>	<comment type="block">/* is r_tod UT? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r_isdst</name></decl>;</decl_stmt>	<comment type="block">/* is this daylight saving time? */</comment>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>r_save</name></decl>;</decl_stmt>		<comment type="block">/* offset from standard time */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>r_abbrvar</name></decl>;</decl_stmt>	<comment type="block">/* variable part of abbreviation */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name>r_todo</name></decl>;</decl_stmt>		<comment type="block">/* a rule to do (used in outzone) */</comment>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>r_temp</name></decl>;</decl_stmt>		<comment type="block">/* used in outzone */</comment>
}</block>;</struct>

<comment type="block">/*
** r_dycode	r_dayofmonth	r_wday
*/</comment>
<enum>enum <block>{
  <decl><name>DC_DOM</name></decl>,	<comment type="block">/* 1..31 */</comment>	<comment type="block">/* unused */</comment>
  <decl><name>DC_DOWGEQ</name></decl>,	<comment type="block">/* 1..31 */</comment>	<comment type="block">/* 0..6 (Sun..Sat) */</comment>
  <decl><name>DC_DOWLEQ</name></decl>	<comment type="block">/* 1..31 */</comment>	<comment type="block">/* 0..6 (Sun..Sat) */</comment>
}</block>;</enum>

<struct>struct <name>zone</name> <block>{
	<decl_stmt><decl><type><name>int</name></type>		<name>z_filenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lineno</name></type>		<name>z_linenum</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>z_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>z_stdoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>		<name>z_rule</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>z_format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>z_format_specifier</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>z_isdst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>z_save</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>	<name>z_rules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type>	<name>z_nrules</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type>	<name>z_untilrule</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>z_untiltime</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_POSIX_DECLS</name></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type>	<name>getopt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type>	<name>link</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>linkname</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type>	<name>optarg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>	<name>optind</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>HAVE_SYMLINK</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>readlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><specifier>restrict</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTSUP</name></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>symlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>linkname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTSUP</name></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AT_SYMLINK_FOLLOW</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>HAVE_LINK</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>linkat</name><parameter_list>(<parameter><type><name>targetdir</name></type></parameter>, <parameter><type><name>target</name></type></parameter>, <parameter><type><name>linknamedir</name></type></parameter>, <parameter><type><name>linkname</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>)</parameter_list></cpp:macro> \
     <cpp:value>(itssymlink(target) ? (errno = ENOTSUP, -1) : link(target, linkname))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>linkat</name><parameter_list>(<parameter><type><name>targetdir</name></type></parameter>, <parameter><type><name>target</name></type></parameter>, <parameter><type><name>linknamedir</name></type></parameter>, <parameter><type><name>linkname</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>)</parameter_list></cpp:macro> \
     <cpp:value>(errno = ENOTSUP, -1)</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>addtt</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>starttime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>addtype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>leapadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>adjleap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>associate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>dolink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getfields</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type>	<name>gethms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>errstring</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type>	<name>getsave</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>inexpires</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>infile</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>inleap</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>inlink</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>inrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>inzcont</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>inzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>inzsub</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>itssymlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>is_alpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type>	<name>lowerit</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>mkdirs</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>newabbr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>abbr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type>	<name>oadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>outzone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type> <name>zp</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>ntzones</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type>	<name>rpytime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type> <name>rp</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>wantedy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>rulesub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type> <name>rp</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>loyearp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>hiyearp</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>typep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>monthp</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>dayp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>timep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>zic_t</name></type>	<name>tadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Bound on length of what %z can expand to.  */</comment>
<enum>enum <block>{ <decl><name>PERCENT_Z_LEN_BOUND</name> <init>= <expr><sizeof>sizeof <name/></sizeof>"+995959" <operator>-</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>charcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>errors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>warnings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>filenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>leapcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>leapseen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name>leapminyear</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name>leapmaxyear</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>lineno</name></type>		<name>linenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>max_abbrvar_len</name> <init>= <expr><name>PERCENT_Z_LEN_BOUND</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>max_format_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name>max_year</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name>min_year</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>noise</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>rfilenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>lineno</name></type>		<name>rlinenum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type>	<name>leapsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type>	<name>main_argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>timecnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>timecnt_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>typecnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>		<name>unspecifiedtype</name></decl>;</decl_stmt>

<comment type="block">/*
** Line codes.
*/</comment>

<enum>enum <block>{
  <decl><name>LC_RULE</name></decl>,
  <decl><name>LC_ZONE</name></decl>,
  <decl><name>LC_LINK</name></decl>,
  <decl><name>LC_LEAP</name></decl>,
  <decl><name>LC_EXPIRES</name></decl>
}</block>;</enum>

<comment type="block">/*
** Which fields are which on a Zone line.
*/</comment>

<enum>enum <block>{
  <decl><name>ZF_NAME</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>ZF_STDOFF</name></decl>,
  <decl><name>ZF_RULE</name></decl>,
  <decl><name>ZF_FORMAT</name></decl>,
  <decl><name>ZF_TILYEAR</name></decl>,
  <decl><name>ZF_TILMONTH</name></decl>,
  <decl><name>ZF_TILDAY</name></decl>,
  <decl><name>ZF_TILTIME</name></decl>,
  <decl><name>ZONE_MAXFIELDS</name></decl>,
  <decl><name>ZONE_MINFIELDS</name> <init>= <expr><name>ZF_TILYEAR</name></expr></init></decl>
}</block>;</enum>

<comment type="block">/*
** Which fields are which on a Zone continuation line.
*/</comment>

<enum>enum <block>{
  <decl><name>ZFC_STDOFF</name></decl>,
  <decl><name>ZFC_RULE</name></decl>,
  <decl><name>ZFC_FORMAT</name></decl>,
  <decl><name>ZFC_TILYEAR</name></decl>,
  <decl><name>ZFC_TILMONTH</name></decl>,
  <decl><name>ZFC_TILDAY</name></decl>,
  <decl><name>ZFC_TILTIME</name></decl>,
  <decl><name>ZONEC_MAXFIELDS</name></decl>,
  <decl><name>ZONEC_MINFIELDS</name> <init>= <expr><name>ZFC_TILYEAR</name></expr></init></decl>
}</block>;</enum>

<comment type="block">/*
** Which files are which on a Rule line.
*/</comment>

<enum>enum <block>{
  <decl><name>RF_NAME</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>RF_LOYEAR</name></decl>,
  <decl><name>RF_HIYEAR</name></decl>,
  <decl><name>RF_COMMAND</name></decl>,
  <decl><name>RF_MONTH</name></decl>,
  <decl><name>RF_DAY</name></decl>,
  <decl><name>RF_TOD</name></decl>,
  <decl><name>RF_SAVE</name></decl>,
  <decl><name>RF_ABBRVAR</name></decl>,
  <decl><name>RULE_FIELDS</name></decl>
}</block>;</enum>

<comment type="block">/*
** Which fields are which on a Link line.
*/</comment>

<enum>enum <block>{
  <decl><name>LF_TARGET</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>LF_LINKNAME</name></decl>,
  <decl><name>LINK_FIELDS</name></decl>
}</block>;</enum>

<comment type="block">/*
** Which fields are which on a Leap line.
*/</comment>

<enum>enum <block>{
  <decl><name>LP_YEAR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>LP_MONTH</name></decl>,
  <decl><name>LP_DAY</name></decl>,
  <decl><name>LP_TIME</name></decl>,
  <decl><name>LP_CORR</name></decl>,
  <decl><name>LP_ROLL</name></decl>,
  <decl><name>LEAP_FIELDS</name></decl>,

  <comment type="block">/* Expires lines are like Leap lines, except without CORR and ROLL fields.  */</comment>
  <decl><name>EXPIRES_FIELDS</name> <init>= <expr><name>LP_TIME</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<comment type="block">/* The maximum number of fields on any of the above lines.
   (The "+"s pacify gcc -Wenum-compare.)  */</comment>
<enum>enum <block>{
  <decl><name>MAX_FIELDS</name> <init>= <macro><name>max</name><argument_list>(<argument>max(+RULE_FIELDS, +LINK_FIELDS)</argument>,
		   <argument>max(+LEAP_FIELDS, +EXPIRES_FIELDS)</argument>)</argument_list></macro></init></decl>
}</block>;</enum>

<comment type="block">/*
** Year synonyms.
*/</comment>

<enum>enum <block>{
  <decl><name>YR_MINIMUM</name></decl>,
  <decl><name>YR_MAXIMUM</name></decl>,
  <decl><name>YR_ONLY</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>	<name>rules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nrules</name></decl>;</decl_stmt>	<comment type="block">/* number of rules */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nrules_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type>	<name>zones</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nzones</name></decl>;</decl_stmt>	<comment type="block">/* number of zones */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nzones_alloc</name></decl>;</decl_stmt>

<struct>struct <name>link</name> <block>{
	<decl_stmt><decl><type><name>int</name></type>		<name>l_filenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lineno</name></type>		<name>l_linenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>l_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>l_linkname</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>link</name></name> <modifier>*</modifier></type>	<name>links</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nlinks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ptrdiff_t</name></type>	<name>nlinks_alloc</name></decl>;</decl_stmt>

<struct>struct <name>lookup</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>l_word</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>l_value</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier> <modifier>*</modifier></type>	<name>byword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>string</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type> <name>lp</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>zi_line_codes</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"Rule"</literal></expr>,	<expr><name>LC_RULE</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Zone"</literal></expr>,	<expr><name>LC_ZONE</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Link"</literal></expr>,	<expr><name>LC_LINK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type> <name><name>leap_line_codes</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"Leap"</literal></expr>,	<expr><name>LC_LEAP</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Expires"</literal></expr>,	<expr><name>LC_EXPIRES</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>mon_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"January"</literal></expr>,	<expr><name>TM_JANUARY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"February"</literal></expr>,	<expr><name>TM_FEBRUARY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"March"</literal></expr>,	<expr><name>TM_MARCH</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"April"</literal></expr>,	<expr><name>TM_APRIL</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"May"</literal></expr>,	<expr><name>TM_MAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"June"</literal></expr>,	<expr><name>TM_JUNE</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"July"</literal></expr>,	<expr><name>TM_JULY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"August"</literal></expr>,	<expr><name>TM_AUGUST</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"September"</literal></expr>,	<expr><name>TM_SEPTEMBER</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"October"</literal></expr>,	<expr><name>TM_OCTOBER</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"November"</literal></expr>,	<expr><name>TM_NOVEMBER</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"December"</literal></expr>,	<expr><name>TM_DECEMBER</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>wday_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"Sunday"</literal></expr>,	<expr><name>TM_SUNDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Monday"</literal></expr>,	<expr><name>TM_MONDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Tuesday"</literal></expr>,	<expr><name>TM_TUESDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Wednesday"</literal></expr>,	<expr><name>TM_WEDNESDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Thursday"</literal></expr>,	<expr><name>TM_THURSDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Friday"</literal></expr>,	<expr><name>TM_FRIDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Saturday"</literal></expr>,	<expr><name>TM_SATURDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>lasts</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"last-Sunday"</literal></expr>,	<expr><name>TM_SUNDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Monday"</literal></expr>,	<expr><name>TM_MONDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Tuesday"</literal></expr>,	<expr><name>TM_TUESDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Wednesday"</literal></expr>,	<expr><name>TM_WEDNESDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Thursday"</literal></expr>,	<expr><name>TM_THURSDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Friday"</literal></expr>,	<expr><name>TM_FRIDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"last-Saturday"</literal></expr>,	<expr><name>TM_SATURDAY</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,			<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>begin_years</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"minimum"</literal></expr>,	<expr><name>YR_MINIMUM</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"maximum"</literal></expr>,	<expr><name>YR_MAXIMUM</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>end_years</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"minimum"</literal></expr>,	<expr><name>YR_MINIMUM</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"maximum"</literal></expr>,	<expr><name>YR_MAXIMUM</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"only"</literal></expr>,	<expr><name>YR_ONLY</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier></type>	<name><name>leap_types</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"Rolling"</literal></expr>,	<expr><name>true</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"Stationary"</literal></expr>,	<expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>	<name><name>len_months</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>MONSPERYEAR</name></expr>]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="number">31</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>	<name><name>len_years</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><name>DAYSPERNYEAR</name></expr>, <expr><name>DAYSPERLYEAR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <name>attype</name> <block>{
	<decl_stmt><decl><type><name>zic_t</name></type>		<name>at</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dontmerge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>type</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier>			<name>attypes</name></decl>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name><name>utoffs</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>		<name><name>isdsts</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>	<name><name>desigidx</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name><name>ttisstds</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name><name>ttisuts</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>		<name><name>chars</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name><name>trans</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type>		<name><name>corr</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>		<name><name>roll</name><index>[<expr><name>TZ_MAX_LEAPS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
** Memory allocation.
*/</comment>

<function><type><name>ATTRIBUTE_NORETURN</name> <specifier>static</specifier> <name>void</name></type>
<name>memory_exhausted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Memory exhausted: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_NORETURN</name> <specifier>static</specifier> <name>void</name></type>
<name>size_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"size overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>size_sum</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>sum</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>sum</name> <operator>&lt;=</operator> <name>SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sum</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>sum_max</name> <init>= <expr><call><name>min</name><argument_list>(<argument><expr><name>PTRDIFF_MAX</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;=</operator> <name>sum_max</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&lt;=</operator> <name>sum_max</name> <operator>-</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>a</name> <operator>+</operator> <name>b</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>size_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>size_product</name><parameter_list>(<parameter><decl><type><name>ptrdiff_t</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>itemsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_mul</name></cpp:ifdef>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>product</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ckd_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>product</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>product</name> <operator>&lt;=</operator> <name>SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>product</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nitems_max</name> <init>= <expr><call><name>min</name><argument_list>(<argument><expr><name>PTRDIFF_MAX</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>itemsize</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <name>nitems_max</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>nitems</name> <operator>*</operator> <name>itemsize</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>size_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>align_to</name><parameter_list>(<parameter><decl><type><name>ptrdiff_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>alignment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>lo_bits</name> <init>= <expr><name>alignment</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>sum</name> <init>= <expr><call><name>size_sum</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>lo_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>sum</name> <operator>&amp;</operator> <operator>~</operator><name>lo_bits</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_STRDUP</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>strdup</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>result</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memcheck</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><ternary><condition><expr><name>HAVE_MALLOC_ERRNO</name></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>ENOMEM</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_MALLOC</name> <specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>emalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>erealloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_MALLOC</name> <specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>estrdup</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>memcheck</name><argument_list>(<argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>grow_nitems_alloc</name><parameter_list>(<parameter><decl><type><name>ptrdiff_t</name> <modifier>*</modifier></type><name>nitems_alloc</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>itemsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>addend</name> <init>= <expr><operator>(</operator><operator>*</operator><name>nitems_alloc</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>ckd_add</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>ckd_mul</name></expr></cpp:if>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>product</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ckd_add</name><argument_list>(<argument><expr><name>nitems_alloc</name></expr></argument>, <argument><expr><operator>*</operator><name>nitems_alloc</name></expr></argument>, <argument><expr><name>addend</name></expr></argument>)</argument_list></call>
      <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ckd_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>product</name></expr></argument>, <argument><expr><operator>*</operator><name>nitems_alloc</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>product</name> <operator>&lt;=</operator> <name>SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>product</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>amax</name> <init>= <expr><call><name>min</name><argument_list>(<argument><expr><name>PTRDIFF_MAX</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>nitems_alloc</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>amax</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name>itemsize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>nitems_alloc</name> <operator>+=</operator> <name>addend</name></expr>;</expr_stmt>
    <return>return <expr><operator>*</operator><name>nitems_alloc</name> <operator>*</operator> <name>itemsize</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>memory_exhausted</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"integer overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>growalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>nitems</name></decl></parameter>,
	  <parameter><decl><type><name>ptrdiff_t</name> <modifier>*</modifier></type><name>nitems_alloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>nitems</name> <operator>&lt;</operator> <operator>*</operator><name>nitems_alloc</name></expr>
	  ?</condition><then> <expr><name>ptr</name></expr>
	  </then><else>: <expr><call><name>erealloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>grow_nitems_alloc</name><argument_list>(<argument><expr><name>nitems_alloc</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Error handling.
*/</comment>

<comment type="block">/* In most of the code, an input file name is represented by its index
   into the main argument vector, except that LEAPSEC_FILENUM stands
   for leapsec and COMMAND_LINE_FILENUM stands for the command line.  */</comment>
<enum>enum <block>{ <decl><name>LEAPSEC_FILENUM</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>, <decl><name>COMMAND_LINE_FILENUM</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<comment type="block">/* Return the name of the Ith input file, for diagnostics.  */</comment>
<function><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type>
<name>filename</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>COMMAND_LINE_FILENUM</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"command line"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>fname</name> <init>= <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>LEAPSEC_FILENUM</name></expr> ?</condition><then> <expr><name>leapsec</name></expr> </then><else>: <expr><name><name>main_argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"standard input"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>fname</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>eats</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fnum</name></decl></parameter>, <parameter><decl><type><name>lineno</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rfnum</name></decl></parameter>, <parameter><decl><type><name>lineno</name></type> <name>rnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>filenum</name> <operator>=</operator> <name>fnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>linenum</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rfilenum</name> <operator>=</operator> <name>rfnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rlinenum</name> <operator>=</operator> <name>rnum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>eat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fnum</name></decl></parameter>, <parameter><decl><type><name>lineno</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name>fnum</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>ATTRIBUTE_FORMAT</name><argument_list>(<argument>(printf, <literal type="number">1</literal>, <literal type="number">0</literal>)</argument>)</argument_list></macro> <function><type><specifier>static</specifier> <name>void</name></type>
<name>verror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	** Match the format of "cc" to allow sh users to
	**	zic ... 2&gt;&amp;1 | error -t "*" -v
	** on BSD systems.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>filenum</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\", line %"</literal><name>PRIdMAX</name><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr></argument>,
		  <argument><expr><call><name>filename</name><argument_list>(<argument><expr><name>filenum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rfilenum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (rule from \"%s\", line %"</literal><name>PRIdMAX</name><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>filename</name><argument_list>(<argument><expr><name>rfilenum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rlinenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>ATTRIBUTE_FORMAT</name><argument_list>(<argument>(printf, <literal type="number">1</literal>, <literal type="number">2</literal>)</argument>)</argument_list></macro> <function><type><specifier>static</specifier> <name>void</name></type>
<name>error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errors</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>ATTRIBUTE_FORMAT</name><argument_list>(<argument>(printf, <literal type="number">1</literal>, <literal type="number">2</literal>)</argument>)</argument_list></macro> <function><type><specifier>static</specifier> <name>void</name></type>
<name>warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"warning: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>verror</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>warnings</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Close STREAM.  If it had an I/O error, report it against DIR/NAME,
   remove TEMPNAME if nonnull, and then exit.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_file</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>,
	   <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>tempname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"I/O error"</literal></expr></argument>)</argument_list></call></expr>
		   </then><else>: <expr><ternary><condition><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s%s%s%s%s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
	    <argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><name>dir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>dir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
	    <argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><name>name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><literal type="string">": "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
	    <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tempname</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_NORETURN</name> <specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
	  <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: usage is %s [ --version ] [ --help ] [ -v ] \\\n"</literal>
	    <literal type="string">"\t[ -b {slim|fat} ] [ -d directory ] [ -l localtime ]"</literal>
	    <literal type="string">" [ -L leapseconds ] \\\n"</literal>
	    <literal type="string">"\t[ -p posixrules ] [ -r '[@lo][/@hi]' ] [ -R '@hi' ] \\\n"</literal>
	    <literal type="string">"\t[ -t localtime-link ] \\\n"</literal>
	    <literal type="string">"\t[ filename ... ]\n\n"</literal>
	    <literal type="string">"Report bugs to %s.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
	  <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>REPORT_BUGS_TO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>EXIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the working directory to DIR, possibly creating DIR and its
   ancestors.  After this is done, all files are accessed with names
   relative to DIR.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_directory</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>chdir_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>chdir_errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>chdir_errno</name> <operator>=</operator> <ternary><condition><expr><call><name>chdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>errno</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>chdir_errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't chdir to %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>chdir_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare the two links A and B, for a stable sort by link name.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>qsort_linkcmp</name><parameter_list>(<parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>link</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>link</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>l_linkname</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>l_linkname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* The link names are the same.  Make the sort stable by comparing
     file numbers (where subtraction cannot overflow) and possibly
     line numbers (where it can).  */</comment>
  <expr_stmt><expr><name>cmp</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>l_filenum</name></name> <operator>-</operator> <name><name>m</name><operator>-&gt;</operator><name>l_filenum</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name><name>l</name><operator>-&gt;</operator><name>l_linenum</name></name> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>l_linenum</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>l</name><operator>-&gt;</operator><name>l_linenum</name></name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>l_linenum</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compare the string KEY to the link B, for bsearch.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bsearch_linkcmp</name><parameter_list>(<parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <specifier>const</specifier> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>link</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>l_linkname</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make the links specified by the Link lines.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_links</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nalinks</name></decl>, <decl><type ref="prev"/><name>pass_size</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>nlinks</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>links</name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>qsort_linkcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Ignore each link superseded by a later link with the same name.  */</comment>
  <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlinks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <while>while <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>nlinks</name>
	   <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>links</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>links</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>nlinks</name> <operator>=</operator> <name>pass_size</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

  <comment type="block">/* Walk through the link array making links.  However,
     if a link's target has not been made yet, append a copy to the
     end of the array.  The end of the array will gradually fill
     up with a small sorted subsequence of not-yet-made links.
     nalinks counts all the links in the array, including copies.
     When we reach the copied subsequence, it may still contain
     a link to a not-yet-made link, so the process repeats.
     At any given point in time, the link array consists of the
     following subregions, where 0 &lt;= i &lt;= j &lt;= nalinks and
     0 &lt;= nlinks &lt;= nalinks:

       0 .. (i - 1):
	 links that either have been made, or have been copied to a
	 later point point in the array (this later point can be in
	 any of the three subregions)
       i .. (j - 1):
	 not-yet-made links for this pass
       j .. (nalinks - 1):
	 not-yet-made links that this pass has skipped because
	 they were links to not-yet-made links

     The first subregion might not be sorted if nlinks &lt; i;
     the other two subregions are sorted.  This algorithm does
     not alter entries 0 .. (nlinks - 1), which remain sorted.

     If there are L links, this algorithm is O(C*L*log(L)) where
     C is the length of the longest link chain.  Usually C is
     short (e.g., 3) though its worst-case value is L.  */</comment>

  <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nalinks</name> <operator>=</operator> <name>nlinks</name></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nalinks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>link</name></name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_filenum</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this pass examined all its links, start the next pass.  */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>nalinks</name> <operator>-</operator> <name>i</name> <operator>==</operator> <name>pass_size</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"Link %s %s\" is part of a link cycle"</literal></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>nalinks</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pass_size</name> <operator>=</operator> <name>nalinks</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Diagnose self links, which the cycle detection algorithm would not
       otherwise catch.  */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"link %s targets itself"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make this link unless its target has not been made yet.  */</comment>
    <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>links</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
		<argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>bsearch_linkcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>links</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>nalinks</name> <operator>-</operator> <name>j</name></expr></argument>,
		  <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>bsearch_linkcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <comment type="block">/* The link target has not been made yet; copy the link to the end.  */</comment>
      <expr_stmt><expr><name>links</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>links</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>nalinks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlinks_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>links</name><index>[<expr><name>nalinks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>links</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>nlinks</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"link %s targeting link %s mishandled by pre-2023 zic"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>bsearch</name><argument_list>(<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>, <argument><expr><name>links</name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>,
		       <argument><expr><name>bsearch_linkcmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"link %s targeting link %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_linkname</name></expr></argument>, <argument><expr><name><name>links</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Simple signal handling: just set a flag that is checked
   periodically outside critical sections.  To set up the handler,
   prefer sigaction if available to close a signal race.  */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>sig_atomic_t</name></type> <name>got_signal</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SA_SIGINFO</name></cpp:ifndef>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>got_signal</name> <operator>=</operator> <name>sig</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Arrange for SIGINT etc. to be caught by the handler.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>catch_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <specifier>const</specifier></type> <name><name>signals</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
    <expr><name>SIGHUP</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>SIGINT</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
    <expr><name>SIGPIPE</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>SIGTERM</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <name>signals</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>signals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SA_SIGINFO</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>act0</name></decl>, <decl><type ref="prev"/><name>act</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>signal_handler</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>act</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>act</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act0</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
	<operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><name><name>act0</name><operator>.</operator><name>sa_flags</name></name> <operator>&amp;</operator> <name>SA_SIGINFO</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>act0</name><operator>.</operator><name>sa_handler</name></name> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sigaction</name><argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>act0</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>got_signal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>signal</name><argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>got_signal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* If a signal has arrived, terminate zic with appropriate status.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_for_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>sig</name> <init>= <expr><name>got_signal</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* A bug in 'raise'.  */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<enum>enum <block>{ <decl><name>TIME_T_BITS_IN_FILE</name> <init>= <expr><literal type="number">64</literal></expr></init></decl> }</block>;</enum>

<comment type="block">/* The minimum and maximum values representable in a TZif file.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name> <specifier>const</specifier></type> <name>min_time</name> <init>= <expr><call><name>MINVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name> <specifier>const</specifier></type> <name>max_time</name> <init>= <expr><call><name>MAXVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* The minimum, and one less than the maximum, values specified by
   the -r option.  These default to MIN_TIME and MAX_TIME.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>lo_time</name> <init>= <expr><call><name>MINVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>hi_time</name> <init>= <expr><call><name>MAXVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* The time specified by the -R option, defaulting to MIN_TIME.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>redundant_time</name> <init>= <expr><call><name>MINVAL</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>, <argument><expr><name>TIME_T_BITS_IN_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* The time specified by an Expires line, or negative if no such line.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>zic_t</name></type> <name>leapexpires</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Set the time range of the output to TIMERANGE.
   Return true if successful.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>timerange_option</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>timerange</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>intmax_t</name></type> <name>lo</name> <init>= <expr><name>min_time</name></expr></init></decl>, <decl><type ref="prev"/><name>hi</name> <init>= <expr><name>max_time</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lo_end</name> <init>= <expr><name>timerange</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hi_end</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>timerange</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>strtoimax</name><argument_list>(<argument><expr><name>timerange</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lo_end</name> <operator>==</operator> <name>timerange</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>lo</name> <operator>==</operator> <name>INTMAX_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>hi_end</name> <operator>=</operator> <name>lo_end</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>lo_end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>lo_end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>strtoimax</name><argument_list>(<argument><expr><name>lo_end</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hi_end</name> <operator>==</operator> <name>lo_end</name> <operator>+</operator> <literal type="number">2</literal> <operator>||</operator> <name>hi</name> <operator>==</operator> <name>INTMAX_MIN</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>hi</name> <operator>-=</operator> <operator>!</operator> <operator>(</operator><name>hi</name> <operator>==</operator> <name>INTMAX_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>hi_end</name> <operator>||</operator> <name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name>max_time</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name>hi</name> <operator>&lt;</operator> <name>min_time</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>lo_time</name> <operator>=</operator> <call><name>max</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>min_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hi_time</name> <operator>=</operator> <call><name>min</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>max_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate redundant time stamps up to OPT.  Return true if successful.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>redundant_time_option</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opt</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>intmax_t</name></type> <name>redundant</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt_end</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>redundant</name> <operator>=</operator> <call><name>strtoimax</name><argument_list>(<argument><expr><name>opt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>opt_end</name> <operator>!=</operator> <name>opt</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>opt_end</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>redundant_time</name> <operator>=</operator> <call><name>max</name><argument_list>(<argument><expr><name>redundant_time</name></expr></argument>, <argument><expr><name>redundant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>psxrules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>lcltime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>tzdefault</name></decl>;</decl_stmt>

<comment type="block">/* -1 if the TZif output file should be slim, 0 if default, 1 if the
   output should be fat for backward compatibility.  ZIC_BLOAT_DEFAULT
   determines the default.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bloat</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>want_bloat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>bloat</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZIC_BLOAT_DEFAULT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ZIC_BLOAT_DEFAULT</name></cpp:macro> <cpp:value>"slim"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>timerange_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>S_IWGRP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_GETTEXT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>TZ_DOMAINDIR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>bindtextdomain</name><argument_list>(<argument><expr><name>TZ_DOMAIN</name></expr></argument>, <argument><expr><name>TZ_DOMAINDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined TEXTDOMAINDIR */</comment>
	<expr_stmt><expr><call><name>textdomain</name><argument_list>(<argument><expr><name>TZ_DOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETTEXT */</comment>
	<expr_stmt><expr><name>main_argv</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <ternary><condition><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"zic"</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TYPE_BIT</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
			<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wild compilation-time specification of zic_t"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"zic %s%s\n"</literal></expr></argument>, <argument><expr><name>PKGVERSION</name></expr></argument>, <argument><expr><name>TZVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt></block_content></block></for>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"b:d:l:L:p:r:R:st:vy:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name>
	       <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
			<default>default:</default>
				<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"slim"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>bloat</name></expr>)</condition><block type="pseudo"><block_content>
				    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incompatible -b options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				  <expr_stmt><expr><name>bloat</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"fat"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				  <if_stmt><if>if <condition>(<expr><name>bloat</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incompatible -b options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				  <expr_stmt><expr><name>bloat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
				  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid option: -b '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>directory</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt></block_content></block></if>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -d option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>lcltime</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lcltime</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt></block_content></block></if>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -l option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>psxrules</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>psxrules</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt></block_content></block></if>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -p option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>tzdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					  <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -t option"</literal>
					    <literal type="string">" specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tzdefault</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'y'</literal></expr>:</case>
				<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"-y ignored"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>leapsec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>leapsec</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt></block_content></block></if>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -L option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name>noise</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>timerange_given</name></expr>)</condition> <block>{<block_content>
				  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: More than one -r option specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>timerange_option</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid time range: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>timerange_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>redundant_time_option</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid time: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"-s ignored"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>==</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* usage message by request */</comment>
	<if_stmt><if>if <condition>(<expr><name>hi_time</name> <operator>+</operator> <operator>(</operator><name>hi_time</name> <operator>&lt;</operator> <name>ZIC_MAX</name><operator>)</operator> <operator>&lt;</operator> <name>redundant_time</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: -R time exceeds -r cutoff\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>bloat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>bloat_default</name><index>[]</index></name> <init>= <expr><name>ZIC_BLOAT_DEFAULT</name></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>bloat_default</name></expr></argument>, <argument><expr><literal type="string">"slim"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>bloat</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>bloat_default</name></expr></argument>, <argument><expr><literal type="string">"fat"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>bloat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* Configuration error.  */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>directory</name> <operator>=</operator> <name>TZDIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tzdefault</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tzdefault</name> <operator>=</operator> <name>TZDEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name>leapsec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>infile</name><argument_list>(<argument><expr><name>LEAPSEC_FILENUM</name></expr></argument>, <argument><expr><name>leapsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>adjleap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>optind</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>infile</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>associate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>change_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>catch_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <name>j</name></expr></incr>)</control> <block>{<block_content>
		<comment type="block">/*
		** Find the next non-continuation zone entry.
		*/</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nzones</name> <operator>&amp;&amp;</operator> <name><name>zones</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>z_name</name> <operator>==</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></for>
		<expr_stmt><expr><call><name>outzone</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>make_links</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lcltime</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name>COMMAND_LINE_FILENUM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name>lcltime</name></expr></argument>, <argument><expr><name>tzdefault</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>psxrules</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name>COMMAND_LINE_FILENUM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dolink</name><argument_list>(<argument><expr><name>psxrules</name></expr></argument>, <argument><expr><name>TZDEFRULES</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>warnings</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ferror</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fclose</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>errors</name></expr> ?</condition><then> <expr><name>EXIT_FAILURE</name></expr> </then><else>: <expr><name>EXIT_SUCCESS</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>componentcheck</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component</name></decl></parameter>,
	       <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<enum>enum <block>{ <decl><name>component_len_max</name> <init>= <expr><literal type="number">14</literal></expr></init></decl> }</block>;</enum>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>component_len</name> <init>= <expr><name>component_end</name> <operator>-</operator> <name>component</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>component_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"empty file name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><ternary><condition><expr><name>component</name> <operator>==</operator> <name>name</name></expr>
		     ?</condition><then> <expr><literal type="string">"file name '%s' begins with '/'"</literal></expr>
		     </then><else>: <expr><ternary><condition><expr><operator>*</operator><name>component_end</name></expr>
		     ?</condition><then> <expr><literal type="string">"file name '%s' contains '//'"</literal></expr>
		     </then><else>: <expr><literal type="string">"file name '%s' ends with '/'"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>component_len</name> <operator>&amp;&amp;</operator> <name>component_len</name> <operator>&lt;=</operator> <literal type="number">2</literal>
	    <operator>&amp;&amp;</operator> <name><name>component</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>component_end</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>component_len</name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains '%.*s' component"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>component_len</name> <operator>&amp;&amp;</operator> <name><name>component</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' component contains leading '-'"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>component_len_max</name> <operator>&lt;</operator> <name>component_len</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains overlength component"</literal>
		      <literal type="string">" '%.*s...'"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>name</name></expr></argument>, <argument><expr><name>component_len_max</name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>namecheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<comment type="block">/* Benign characters in a portable file name.  */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>benign</name><index>[]</index></name> <init>=
	  <expr><literal type="string">"-/_"</literal>
	  <literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
	  <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Non-control chars in the POSIX portable character set,
	   excluding the benign characters.  */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>printable_and_not_benign</name><index>[]</index></name> <init>=
	  <expr><literal type="string">" !\"#$%&amp;'()*+,.0123456789:;&lt;=&gt;?@[\\]^`{|}~"</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>component</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>cp</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>benign</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><call><name>strchr</name><argument_list>(<argument><expr><name>printable_and_not_benign</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>
				 ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains byte '%c'"</literal></expr></argument>)</argument_list></call></expr>
				 </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"file name '%s' contains byte '\\%o'"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>,
				<argument><expr><name>name</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>componentcheck</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>component</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>componentcheck</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a random uint_fast64_t.  */</comment>
<function><type><specifier>static</specifier> <name>uint_fast64_t</name></type>
<name>get_rand_u64</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_GETRANDOM</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint_fast64_t</name></type> <name><name>entropy_buffer</name><index>[<expr><call><name>max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">256</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint_fast64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nwords</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nwords</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>s</name></decl>;</decl_stmt>
    <do>do<block type="pseudo"><block_content>
      <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>getrandom</name><argument_list>(<argument><expr><name>entropy_buffer</name></expr></argument>, <argument><expr><sizeof>sizeof <name>entropy_buffer</name></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
    while <condition>(<expr><name>s</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

    <expr_stmt><expr><name>nwords</name> <operator>=</operator> <ternary><condition><expr><name>s</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>s</name> <operator>/</operator> <sizeof>sizeof <name/></sizeof>*<name>entropy_buffer</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>nwords</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>entropy_buffer</name><index>[<expr><operator>--</operator><name>nwords</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* getrandom didn't work, so fall back on portable code that is
     not the best because the seed isn't cryptographically random and
     'rand' might not be cryptographically secure.  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>initialized</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initialized</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <comment type="block">/* Return a random number if rand() yields a random number and in
     the typical case where RAND_MAX is one less than a power of two.
     In other cases this code yields a sort-of-random number.  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>rand_max</name> <init>= <expr><name>RAND_MAX</name></expr></init></decl>,
      <decl><type ref="prev"/><name>nrand</name> <init>= <expr><ternary><condition><expr><name>rand_max</name> <operator>&lt;</operator> <name>UINT_FAST64_MAX</name></expr> ?</condition><then> <expr><name>rand_max</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>,
      <decl><type ref="prev"/><name>rmod</name> <init>= <expr><ternary><condition><expr><name>INT_MAX</name> <operator>&lt;</operator> <name>UINT_FAST64_MAX</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>UINT_FAST64_MAX</name> <operator>/</operator> <name>nrand</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>,
      <decl><type ref="prev"/><name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rmax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>rmax1</name> <init>= <expr><name>rmax</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>rmod</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Avoid signed integer overflow on theoretical platforms
	   where uint_fast64_t promotes to int.  */</comment>
	<expr_stmt><expr><name>rmax1</name> <operator>%=</operator> <name>rmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>%=</operator> <name>rmod</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rmax1</name> <operator>=</operator> <name>nrand</name> <operator>*</operator> <name>rmax1</name> <operator>+</operator> <name>rand_max</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <name>nrand</name> <operator>*</operator> <name>r</name> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rmax</name> <operator>=</operator> <ternary><condition><expr><name>rmax</name> <operator>&lt;</operator> <name>rmax1</name></expr> ?</condition><then> <expr><name>rmax1</name></expr> </then><else>: <expr><name>UINT_FAST64_MAX</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>rmax</name> <operator>&lt;</operator> <name>UINT_FAST64_MAX</name></expr>)</condition>;</do>

    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* Generate a randomish name in the same directory as *NAME.  If
   *NAMEALLOC, put the name into *NAMEALLOC which is assumed to be
   that returned by a previous call and is thus already almost set up
   and equal to *NAME; otherwise, allocate a new name and put its
   address into both *NAMEALLOC and *NAME.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>random_dirent</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>namealloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>*</operator><name>name</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><operator>*</operator><name>namealloc</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>prefix</name><index>[]</index></name> <init>= <expr><literal type="string">".zic"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>alphabet</name><index>[]</index></name> <init>=
    <expr><literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
    <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal>
    <literal type="string">"0123456789"</literal></expr></init></decl>;</decl_stmt>
  <enum>enum <block>{ <decl><name>prefixlen</name> <init>= <expr><sizeof>sizeof <name>prefix</name></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>, <decl><name>alphabetlen</name> <init>= <expr><sizeof>sizeof <name>alphabet</name></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>
  <decl_stmt><decl><type><name>int</name></type> <name>suffixlen</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>lastslash</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>dirlen</name> <init>= <expr><ternary><condition><expr><name>lastslash</name></expr> ?</condition><then> <expr><name>lastslash</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>src</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>base</name> <init>= <expr><name>alphabetlen</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* BASE**6 */</comment>
  <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>base__6</name> <init>= <expr><name>base</name> <operator>*</operator> <name>base</name> <operator>*</operator> <name>base</name> <operator>*</operator> <name>base</name> <operator>*</operator> <name>base</name> <operator>*</operator> <name>base</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The largest uintmax_t that is a multiple of BASE**6.  Any random
     uintmax_t value that is this value or greater, yields a biased
     remainder when divided by BASE**6.  UNFAIR_MIN equals the
     mathematical value of ((UINTMAX_MAX + 1) - (UINTMAX_MAX + 1) % BASE**6)
     computed without overflow.  */</comment>
  <decl_stmt><decl><type><name>uint_fast64_t</name></type> <name>unfair_min</name> <init>= <expr><operator>-</operator> <operator>(</operator><operator>(</operator><name>UINTMAX_MAX</name> <operator>%</operator> <name>base__6</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>base__6</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><call><name>size_sum</name><argument_list>(<argument><expr><name>dirlen</name></expr></argument>, <argument><expr><name>prefixlen</name> <operator>+</operator> <name>suffixlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name> <operator>+</operator> <name>dirlen</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dst</name><index>[<expr><name>dirlen</name> <operator>+</operator> <name>prefixlen</name> <operator>+</operator> <name>suffixlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>*</operator><name>namealloc</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <do>do<block type="pseudo"><block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>get_rand_u64</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block>
  while <condition>(<expr><name>unfair_min</name> <operator>&lt;=</operator> <name>r</name></expr>)</condition>;</do>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>suffixlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>dst</name><index>[<expr><name>dirlen</name> <operator>+</operator> <name>prefixlen</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>alphabet</name><index>[<expr><name>r</name> <operator>%</operator> <name>alphabetlen</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>/=</operator> <name>alphabetlen</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Prepare to write to the file *OUTNAME, using *TEMPNAME to store the
   name of the temporary file that will eventually be renamed to
   *OUTNAME.  Assign the temporary file's name to both *OUTNAME and
   *TEMPNAME.  If *TEMPNAME is null, allocate the name of any such
   temporary file; otherwise, reuse *TEMPNAME's storage, which is
   already set up and only needs its trailing suffix updated.  */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>open_outfile</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>outname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tempname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">201112</literal></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>fopen_mode</name><index>[]</index></name> <init>= <expr><literal type="string">"wb"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>fopen_mode</name><index>[]</index></name> <init>= <expr><literal type="string">"wbx"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>dirs_made</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>tempname</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>random_dirent</name><argument_list>(<argument><expr><name>outname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <while>while <condition>(<expr><operator>!</operator> <operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><operator>*</operator><name>outname</name></expr></argument>, <argument><expr><name>fopen_mode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>fopen_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>fopen_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dirs_made</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><operator>*</operator><name>outname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirs_made</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fopen_errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>random_dirent</name><argument_list>(<argument><expr><name>outname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't create %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><operator>*</operator><name>outname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>fopen_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>fp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If TEMPNAME, the result is in the temporary file TEMPNAME even
   though the user wanted it in NAME, so rename TEMPNAME to NAME.
   Report an error and exit if there is trouble.  Also, free TEMPNAME.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rename_dest</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>tempname</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rename_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: rename to %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>rename_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Create symlink contents suitable for symlinking FROM to TO, as a
   freshly allocated string.  FROM should be a relative file name, and
   is relative to the global variable DIRECTORY.  TO can be either
   relative or absolute.  */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>relname</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>linkname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>taillen</name></decl>, <decl><type ref="prev"/><name>dir_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dotdots</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>dotdotetcsize</name></decl>, <decl><type ref="prev"/><name>linksize</name> <init>= <expr><call><name>min</name><argument_list>(<argument><expr><name>PTRDIFF_MAX</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>target</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>linkname</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Make F absolute too.  */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lenslash</name> <init>= <expr><name>len</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>&amp;&amp;</operator> <name><name>directory</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>targetsize</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>linksize</name> <operator>=</operator> <call><name>size_sum</name><argument_list>(<argument><expr><name>lenslash</name></expr></argument>, <argument><expr><name>targetsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>linksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>lenslash</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>targetsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>linkname</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>f</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>dir_len</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <for>for <control>(<init>;</init> <condition><expr><name><name>linkname</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>dotdots</name> <operator>+=</operator> <name><name>linkname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>linkname</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>taillen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>f</name> <operator>+</operator> <name>dir_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dotdotetcsize</name> <operator>=</operator> <call><name>size_sum</name><argument_list>(<argument><expr><call><name>size_product</name><argument_list>(<argument><expr><name>dotdots</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>taillen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>dotdotetcsize</name> <operator>&lt;=</operator> <name>linksize</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>dotdotetcsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dotdots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>dotdots</name></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <name>dir_len</name></expr></argument>, <argument><expr><name>taillen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dolink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>linkname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>staysymlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>linkdirs_made</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>link_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>outname</name> <init>= <expr><name>linkname</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_for_signal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>remove</name><argument_list>(<argument><expr><name>linkname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOTDIR</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return;</return></block_content></block></if>
	  <else>else <block>{<block_content>
	    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't remove %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>linkat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>outname</name></expr></argument>, <argument><expr><name>AT_SYMLINK_FOLLOW</name></expr></argument>)</argument_list></call>
	      <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>link_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name>link_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>==</operator> <name>EXDEV</name> <operator>||</operator> <name>link_errno</name> <operator>==</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>

	  <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>staysymlink</name> <operator>&amp;=</operator> <operator>!</operator><name>tempname</name></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>random_dirent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>staysymlink</name> <operator>&amp;&amp;</operator> <call><name>itssymlink</name><argument_list>(<argument><expr><name>linkname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	      <break>break;</break></block_content></block></if></if_stmt>
	  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>link_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>linkdirs_made</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>linkdirs_made</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>
	    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't link %s/%s to %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>outname</name></expr></argument>,
		    <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>link_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>bool</name></type> <name>absolute</name> <init>= <expr><operator>*</operator><name>target</name> <operator>==</operator> <literal type="char">'/'</literal></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>linkalloc</name> <init>= <expr><ternary><condition><expr><name>absolute</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>relname</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>linkname</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>contents</name> <init>= <expr><ternary><condition><expr><name>absolute</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name>linkalloc</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>symlink_errno</name></decl>;</decl_stmt>

	  <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>outname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	      <expr_stmt><expr><name>symlink_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name>symlink_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>symlink_errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>random_dirent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	    <if type="elseif">else if <condition>(<expr><name>symlink_errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>linkdirs_made</name></expr>)</condition> <block>{<block_content>
	      <expr_stmt><expr><call><name>mkdirs</name><argument_list>(<argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>linkdirs_made</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
	      <break>break;</break></block_content></block></else></if_stmt>
	  </block_content>}</block></while>
	  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>linkalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>symlink_errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <name>ENOTSUP</name> <operator>&amp;&amp;</operator> <name>link_errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"symbolic link used because hard link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>link_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>
	    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
	      <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't read %s/%s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>open_outfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	    <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>link_errno</name> <operator>!=</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"copy used because hard link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>link_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	    <if type="elseif">else if <condition>(<expr><name>symlink_errno</name> <operator>!=</operator> <name>ENOTSUP</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"copy used because symbolic link failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>symlink_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>rename_dest</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>linkname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if NAME is a symbolic link.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>itssymlink</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <return>return <expr><literal type="number">0</literal> <operator>&lt;=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Associate sets of rules with zones.
*/</comment>

<comment type="block">/*
** Sort by rule name.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rcomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cp1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>cp2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>r1</name> <init>= <expr><name>cp1</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r2</name> <init>= <expr><name>cp2</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>r1</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>, <argument><expr><name><name>r2</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>associate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type>	<name>zp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>	<name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>base</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>nrules</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><name>nrules</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>rules</name></expr></argument>, <argument><expr><name>rcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrules</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>,
				<argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filenum</name> <operator>==</operator> <name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filenum</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filenum</name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"same rule name in multiple files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filenum</name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"same rule name in multiple files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>,
					<argument><expr><name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>r_filenum</name> <operator>==</operator> <name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_filenum</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rules</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>r_filenum</name>
				    <operator>==</operator> <name><name>rules</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>r_filenum</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></for>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>base</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><name>base</name> <operator>=</operator> <name>out</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>rules</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>out</name> <operator>=</operator> <name>base</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>out</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><operator>++</operator><name>out</name></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>, <argument><expr><name><name>rules</name><index>[<expr><name>out</name></expr>]</index></name><operator>.</operator><name>r_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rule</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>=</operator> <name>out</name> <operator>-</operator> <name>base</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>zp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			** Maybe we have a local standard time offset.
			*/</comment>
			<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>z_save</name></name> <operator>=</operator> <call><name>getsave</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_rule</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			** Note, though, that if there's no rule,
			** a '%s' in the format is a bad thing.
			*/</comment>
			<if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s in ruleless zone"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>errors</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Read a text line from FP into BUF, which is of size BUFSIZE.
   Terminate it with a NUL byte instead of a newline.
   Return true if successful, false if EOF.
   On error, report the error and exit.  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inputline</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>linelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"input error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unterminated line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ch</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NUL input byte"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>linelen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>==</operator> <name>bufsize</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"line too long"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>linelen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>infile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fnum</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>FILE</name> <modifier>*</modifier></type>			<name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>wantcont</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>lineno</name></type>			<name>num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>fp</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't open %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>num</name></expr></incr>)</control> <block>{<block_content>
		<enum>enum <block>{ <decl><name>bufsize_bound</name>
		  <init>= <expr><operator>(</operator><call><name>min</name><argument_list>(<argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name>PTRDIFF_MAX</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
		     <operator>/</operator> <name>FORMAT_LEN_GROWTH_BOUND</name><operator>)</operator></expr></init></decl> }</block>;</enum>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><call><name>min</name><argument_list>(<argument><expr><name>_POSIX2_LINE_MAX</name></expr></argument>, <argument><expr><name>bufsize_bound</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nfields</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>fields</name><index>[<expr><name>MAX_FIELDS</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name>fnum</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>inputline</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		  <break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>getfields</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>,
				    <argument><expr><sizeof>sizeof <name>fields</name></sizeof> <operator>/</operator> <sizeof>sizeof <name/></sizeof>*<name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* nothing to do */</comment>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>wantcont</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <call><name>inzcont</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>line_codes</name>
			  <init>= <expr><ternary><condition><expr><name>fnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>leap_line_codes</name></expr> </then><else>: <expr><name>zi_line_codes</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>line_codes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"input line of unknown type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition> <block>{<block_content>
				<case>case <expr><name>LC_RULE</name></expr>:</case>
					<expr_stmt><expr><call><name>inrule</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LC_ZONE</name></expr>:</case>
					<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <call><name>inzone</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LC_LINK</name></expr>:</case>
					<expr_stmt><expr><call><name>inlink</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LC_LEAP</name></expr>:</case>
					<expr_stmt><expr><call><name>inleap</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LC_EXPIRES</name></expr>:</case>
					<expr_stmt><expr><call><name>inexpires</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wantcont</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default> <expr_stmt><expr><call><name>unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>filename</name><argument_list>(<argument><expr><name>fnum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wantcont</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expected continuation line not found"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert a string of one of the forms
**	h	-h	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss
** into a number of seconds.
** A null string maps to zero.
** Call error with errstring and return zero on errors.
*/</comment>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>gethms</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>errstring</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>zic_t</name></type>	<name>hh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>, <decl><type ref="prev"/><name>mm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ss</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>hhx</name></decl>, <decl><type ref="prev"/><name>mmx</name></decl>, <decl><type ref="prev"/><name>ssx</name></decl>, <decl><type ref="prev"/><name>xr</name> <init>= <expr><literal type="char">'0'</literal></expr></init></decl>, <decl><type ref="prev"/><name>xs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tenths</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>string</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<switch>switch <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>string</name></expr></argument>,
		       <argument><expr><literal type="string">"%"</literal><name>SCNdZIC</name><literal type="string">"%c%d%c%d%c%1d%*[0]%c%*[0123456789]%c"</literal></expr></argument>,
		       <argument><expr><operator>&amp;</operator><name>hh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hhx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mmx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tenths</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <default>default:</default> <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <break>break;</break>
	  <case>case <expr><literal type="number">8</literal></expr>:</case>
	    <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="char">'0'</literal> <operator>&lt;=</operator> <name>xr</name> <operator>&amp;&amp;</operator> <name>xr</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><name>ATTRIBUTE_FALLTHROUGH</name></expr>;</expr_stmt>
	  <case>case <expr><literal type="number">7</literal></expr>:</case>
	    <expr_stmt><expr><name>ok</name> <operator>&amp;=</operator> <name>ssx</name> <operator>==</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name>noise</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fractional seconds rejected by"</literal>
			<literal type="string">" pre-2018 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>ATTRIBUTE_FALLTHROUGH</name></expr>;</expr_stmt>
	  <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>ok</name> <operator>&amp;=</operator> <name>mmx</name> <operator>==</operator> <literal type="char">':'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>ATTRIBUTE_FALLTHROUGH</name></expr>;</expr_stmt>
	  <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>ok</name> <operator>&amp;=</operator> <name>hhx</name> <operator>==</operator> <literal type="char">':'</literal></expr>;</expr_stmt> <expr_stmt><expr><name>ATTRIBUTE_FALLTHROUGH</name></expr>;</expr_stmt>
	  <case>case <expr><literal type="number">1</literal></expr>:</case> <break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hh</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>mm</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mm</name> <operator>&gt;=</operator> <name>MINSPERHOUR</name> <operator>||</operator>
		<name><name>ss</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ss</name></expr></argument> &gt;</argument_list></name> <name>SECSPERMIN</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ZIC_MAX</name> <operator>/</operator> <name>SECSPERHOUR</name> <operator>&lt;</operator> <name>hh</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ss</name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>ss</name> <operator>^</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>xr</name> <operator>==</operator> <literal type="char">'0'</literal><operator>)</operator><operator>)</operator> <operator>&lt;=</operator> <name>tenths</name></expr>;</expr_stmt> <comment type="block">/* Round to even.  */</comment>
	<if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>hh</name> <operator>&gt;</operator> <name>HOURSPERDAY</name> <operator>||</operator>
		<operator>(</operator><name>hh</name> <operator>==</operator> <name>HOURSPERDAY</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>mm</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ss</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"values over 24 hours not handled by pre-2007 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>oadd</name><argument_list>(<argument><expr><name>sign</name> <operator>*</operator> <name>hh</name> <operator>*</operator> <name>SECSPERHOUR</name></expr></argument>,
		    <argument><expr><name>sign</name> <operator>*</operator> <operator>(</operator><name>mm</name> <operator>*</operator> <name>SECSPERMIN</name> <operator>+</operator> <name>ss</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>getsave</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isdst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>dst</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>zic_t</name></type> <name>save</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>fieldlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>fieldlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name>field</name> <operator>+</operator> <name>fieldlen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><operator>*</operator><name>ep</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>dst</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'s'</literal></expr>:</case> <expr_stmt><expr><name>dst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid saved time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>isdst</name> <operator>=</operator> <ternary><condition><expr><name>dst</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>save</name> <operator>!=</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>dst</name></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name>save</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>RULE_FIELDS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Rule line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<switch>switch <condition>(<expr><operator>*</operator><name><name>fields</name><index>[<expr><name>RF_NAME</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
	  <case>case <expr><literal type="char">'\0'</literal></expr>:</case>
	  <case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'+'</literal></expr>:</case> <case>case <expr><literal type="char">'-'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Invalid rule name \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_filenum</name></name> <operator>=</operator> <name>filenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_save</name></name> <operator>=</operator> <call><name>getsave</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_SAVE</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>r_isdst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rulesub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_LOYEAR</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_HIYEAR</name></expr>]</index></name></expr></argument>,
		     <argument><expr><name><name>fields</name><index>[<expr><name>RF_COMMAND</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_MONTH</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>RF_DAY</name></expr>]</index></name></expr></argument>,
		     <argument><expr><name><name>fields</name><index>[<expr><name>RF_TOD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_name</name></name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>RF_ABBRVAR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>max_abbrvar_len</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_abbrvar_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_abbrvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rules</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>rules</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>rules</name></expr></argument>, <argument><expr><name>nrules</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nrules_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rules</name><index>[<expr><name>nrules</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nfields</name> <argument_list type="generic">&lt; <argument><expr><name>ZONE_MINFIELDS</name> <operator>||</operator> <name>nfields</name></expr></argument> &gt;</argument_list></name> <name>ZONE_MAXFIELDS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Zone line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>lcltime</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>, <argument><expr><name>tzdefault</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"Zone %s\" line and -l option are mutually exclusive"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>tzdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>, <argument><expr><name>TZDEFRULES</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>psxrules</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"Zone %s\" line and -p option are mutually exclusive"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>TZDEFRULES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nzones</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_name</name></expr></argument>, <argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"duplicate zone name %s"</literal>
					<literal type="string">" (file \"%s\", line %"</literal><name>PRIdMAX</name><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>,
				      <argument><expr><call><name>filename</name><argument_list>(<argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_filenum</name></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr><name><name>zones</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z_linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt></block_content></block></for>
	<return>return <expr><call><name>inzsub</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzcont</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>nfields</name> <argument_list type="generic">&lt; <argument><expr><name>ZONEC_MINFIELDS</name> <operator>||</operator> <name>nfields</name></expr></argument> &gt;</argument_list></name> <name>ZONEC_MAXFIELDS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Zone continuation line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>inzsub</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inzsub</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iscont</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>		<name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type>			<name>cp1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>format_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>i_stdoff</name></decl>, <decl><type ref="prev"/><name>i_rule</name></decl>, <decl><type ref="prev"/><name>i_format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>i_untilyear</name></decl>, <decl><type ref="prev"/><name>i_untilmonth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>i_untilday</name></decl>, <decl><type ref="prev"/><name>i_untiltime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>		<name>hasuntil</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>iscont</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i_stdoff</name> <operator>=</operator> <name>ZFC_STDOFF</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_rule</name> <operator>=</operator> <name>ZFC_RULE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_format</name> <operator>=</operator> <name>ZFC_FORMAT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilyear</name> <operator>=</operator> <name>ZFC_TILYEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilmonth</name> <operator>=</operator> <name>ZFC_TILMONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilday</name> <operator>=</operator> <name>ZFC_TILDAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untiltime</name> <operator>=</operator> <name>ZFC_TILTIME</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>namecheck</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><name>i_stdoff</name> <operator>=</operator> <name>ZF_STDOFF</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_rule</name> <operator>=</operator> <name>ZF_RULE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_format</name> <operator>=</operator> <name>ZF_FORMAT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilyear</name> <operator>=</operator> <name>ZF_TILYEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilmonth</name> <operator>=</operator> <name>ZF_TILMONTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untilday</name> <operator>=</operator> <name>ZF_TILDAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_untiltime</name> <operator>=</operator> <name>ZF_TILTIME</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_filenum</name></name> <operator>=</operator> <name>filenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_stdoff</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_stdoff</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid UT offset"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>++</operator><name>cp</name> <operator>!=</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call>
		    <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid abbreviation format"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_format_specifier</name></name> <operator>=</operator> <ternary><condition><expr><name>cp</name></expr> ?</condition><then> <expr><operator>*</operator><name>cp</name></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>format_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>max_format_len</name> <operator>&lt;</operator> <name>format_len</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>max_format_len</name> <operator>=</operator> <name>format_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>hasuntil</name> <operator>=</operator> <name>nfields</name> <operator>&gt;</operator> <name>i_untilyear</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasuntil</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_filenum</name></name> <operator>=</operator> <name>filenum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rulesub</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name><name>z</name><operator>.</operator><name>z_untilrule</name></name></expr></argument>,
			<argument><expr><name><name>fields</name><index>[<expr><name>i_untilyear</name></expr>]</index></name></expr></argument>,
			<argument><expr><literal type="string">"only"</literal></expr></argument>,
			<argument><expr><literal type="string">""</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untilmonth</name><operator>)</operator></expr> ?</condition><then>
			<expr><name><name>fields</name><index>[<expr><name>i_untilmonth</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"Jan"</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untilday</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>fields</name><index>[<expr><name>i_untilday</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"1"</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <name>i_untiltime</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>fields</name><index>[<expr><name>i_untiltime</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>=</operator> <call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>.</operator><name>z_untilrule</name></name></expr></argument>,
			<argument><expr><name><name>z</name><operator>.</operator><name>z_untilrule</name><operator>.</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>iscont</name> <operator>&amp;&amp;</operator> <name>nzones</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>&gt;</operator> <name>min_time</name> <operator>&amp;&amp;</operator>
			<name><name>z</name><operator>.</operator><name>z_untiltime</name></name> <operator>&lt;</operator> <name>max_time</name> <operator>&amp;&amp;</operator>
			<name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&gt;</operator> <name>min_time</name> <operator>&amp;&amp;</operator>
			<name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&lt;</operator> <name>max_time</name> <operator>&amp;&amp;</operator>
			<name><name>zones</name><index>[<expr><name>nzones</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_untiltime</name> <operator>&gt;=</operator> <name><name>z</name><operator>.</operator><name>z_untiltime</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(
<argument><expr><literal type="string">"Zone continuation line end time is not after end time of previous line"</literal></expr></argument>
					)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_name</name></name> <operator>=</operator> <ternary><condition><expr><name>iscont</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>ZF_NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_rule</name></name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_rule</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>z</name><operator>.</operator><name>z_format</name></name> <operator>=</operator> <name>cp1</name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>.</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>cp1</name><index>[<expr><name>cp</name> <operator>-</operator> <name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"format '%s' not handled by pre-2015 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name><name>fields</name><index>[<expr><name>i_format</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>zones</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>zones</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>zones</name></expr></argument>, <argument><expr><name>nzones</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nzones_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>zones</name><index>[<expr><name>nzones</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
	<comment type="block">/*
	** If there was an UNTIL field on this line,
	** there's more information about the zone on the next line.
	*/</comment>
	<return>return <expr><name>hasuntil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>getleapdatetime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expire_line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>		<name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>			<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>				<name>year</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>month</name></decl>, <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>				<name>dayoff</name></decl>, <decl><type ref="prev"/><name>tod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type>				<name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>xs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>fields</name><index>[<expr><name>LP_YEAR</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>SCNdZIC</name><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Leapin' Lizards!
		*/</comment>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid leaping year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expire_line</name></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>leapseen</name> <operator>||</operator> <name>leapmaxyear</name> <operator>&lt;</operator> <name>year</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leapmaxyear</name> <operator>=</operator> <name>year</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>leapseen</name> <operator>||</operator> <name>leapminyear</name> <operator>&gt;</operator> <name>year</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leapminyear</name> <operator>=</operator> <name>year</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>leapseen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>j</name> <operator>!=</operator> <name>year</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>year</name> <operator>&gt;</operator> <name>j</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><operator>--</operator><name>j</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_MONTH</name></expr>]</index></name></expr></argument>, <argument><expr><name>mon_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid month name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>month</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>j</name> <operator>!=</operator> <name>month</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>fields</name><index>[<expr><name>LP_DAY</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name>day</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>day</name> <operator>&gt;</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>month</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>day</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&lt;</operator> <name>min_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time too small"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&gt;</operator> <name>max_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time too large"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name>dayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tod</name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_TIME</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid time of day"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>tod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"leap second precedes Epoch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inleap</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>LEAP_FIELDS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>zic_t</name></type> <name>t</name> <init>= <expr><call><name>getleapdatetime</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>t</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>lookup</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>byword</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_ROLL</name></expr>]</index></name></expr></argument>, <argument><expr><name>leap_types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lp</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid Rolling/Stationary field on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>correction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fields</name><index>[<expr><name>LP_CORR</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* infile() turns "-" into "".  */</comment>
	  <expr_stmt><expr><name>correction</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LP_CORR</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>correction</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid CORRECTION field on Leap line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>correction</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>leapadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>correction</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inexpires</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>EXPIRES_FIELDS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Expires line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>leapexpires</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"multiple Expires lines"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>leapexpires</name> <operator>=</operator> <call><name>getleapdatetime</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>inlink</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>link</name></name></type>	<name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>LINK_FIELDS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"wrong number of fields on Link line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><index>[<expr><name>LF_TARGET</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"blank TARGET field on Link line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>namecheck</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_LINKNAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_filenum</name></name> <operator>=</operator> <name>filenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_linenum</name></name> <operator>=</operator> <name>linenum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_target</name></name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_TARGET</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>l</name><operator>.</operator><name>l_linkname</name></name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name><name>fields</name><index>[<expr><name>LF_LINKNAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>links</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>links</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>links</name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlinks_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>links</name><index>[<expr><name>nlinks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rulesub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loyearp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hiyearp</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>monthp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dayp</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>		<name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>xs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>monthp</name></expr></argument>, <argument><expr><name>mon_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid month name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name>timep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ep</name> <operator>=</operator> <name>dp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>	<comment type="block">/* Standard */</comment>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>	<comment type="block">/* Wall */</comment>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'g'</literal></expr>:</case>	<comment type="block">/* Greenwich */</comment>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>	<comment type="block">/* Universal */</comment>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>	<comment type="block">/* Zulu */</comment>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name> <operator>=</operator> <call><name>gethms</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid time of day"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	** Year work.
	*/</comment>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>loyearp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>begin_years</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name> <operator>=</operator> <name>lp</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name></expr>)</condition><block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>YR_MINIMUM</name></expr>:</case>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>YR_MAXIMUM</name></expr>:</case>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> <expr_stmt><expr><call><name>unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch></block_content></block></if> <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>SCNdZIC</name><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid starting year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>hiyearp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_years</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name> <operator>=</operator> <name>lp</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>YR_MINIMUM</name></expr>:</case>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>YR_MAXIMUM</name></expr>:</case>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>YR_ONLY</name></expr>:</case>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> <expr_stmt><expr><call><name>unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch></block_content></block></if> <if type="elseif">else if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>SCNdZIC</name><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid ending year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>&gt;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"starting year greater than ending year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>typep</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"year type \"%s\" is unsupported; use \"-\" instead"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>typep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	** Day work.
	** Accept things such as:
	**	1
	**	lastSunday
	**	last-Sunday (undocumented; warn about this)
	**	Sun&lt;=20
	**	Sun&gt;=7
	*/</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>estrdup</name><argument_list>(<argument><expr><name>dayp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lasts</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWLEQ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>=</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWLEQ</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>ep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOWGEQ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>ep</name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>!=</operator> <name>DC_DOM</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ep</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name><operator>++</operator> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>byword</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>wday_names</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid weekday name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>l_value</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><literal type="string">"%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>&gt;</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid day of month"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert</name><parameter_list>(<parameter><decl><type><name>uint_fast32_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>shift</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>b</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>shift</name> <operator>=</operator> <literal type="number">24</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>shift</name> <operator>-=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert64</name><parameter_list>(<parameter><decl><type><name>uint_fast64_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>shift</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>b</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>shift</name> <operator>=</operator> <literal type="number">56</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>shift</name> <operator>-=</operator> <literal type="number">8</literal></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puttzcode</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puttzcodepass</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>convert64</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>atcomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>avp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>attype</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>ap</name> <init>= <expr><name>avp</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name> <init>= <expr><name>bvp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>zic_t</name></type> <name>a</name> <init>= <expr><name><name>ap</name><operator>-&gt;</operator><name>at</name></name></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><name><name>bp</name><operator>-&gt;</operator><name>at</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>timerange</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>defaulttype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>leapbase</name></decl>, <decl><type ref="prev"/><name>leapcount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>leapexpiry</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>timerange</name></name></type>
<name>limitrange</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timerange</name></name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>hi</name></decl></parameter>,
	   <parameter><decl><type><name>zic_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>ats</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Omit ordinary transitions &lt; LO.  */</comment>
  <while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>count</name></name> <operator>&amp;&amp;</operator> <name><name>ats</name><index>[<expr><name><name>r</name><operator>.</operator><name>base</name></name></expr>]</index></name> <operator>&lt;</operator> <name>lo</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>defaulttype</name></name> <operator>=</operator> <name><name>types</name><index>[<expr><name><name>r</name><operator>.</operator><name>base</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>base</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Omit as many initial leap seconds as possible, such that the
     first leap second in the truncated list is &lt;= LO, and is a
     positive leap second if and only if it has a positive correction.
     This supports common TZif readers that assume that the first leap
     second is positive if and only if its correction is positive.  */</comment>
  <while>while <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>leapcount</name></name> <operator>&amp;&amp;</operator> <name><name>trans</name><index>[<expr><name><name>r</name><operator>.</operator><name>leapbase</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <name>lo</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapcount</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapbase</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>leapbase</name></name>
	 <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>corr</name><index>[<expr><name><name>r</name><operator>.</operator><name>leapbase</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>corr</name><index>[<expr><name><name>r</name><operator>.</operator><name>leapbase</name></name></expr>]</index></name><operator>)</operator>
	     <operator>!=</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;</operator> <name><name>corr</name><index>[<expr><name><name>r</name><operator>.</operator><name>leapbase</name></name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapcount</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapbase</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>


  <comment type="block">/* Omit ordinary and leap second transitions greater than HI + 1.  */</comment>
  <if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>max_time</name></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>count</name></name> <operator>&amp;&amp;</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ats</name><index>[<expr><name><name>r</name><operator>.</operator><name>base</name></name> <operator>+</operator> <name><name>r</name><operator>.</operator><name>count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>r</name><operator>.</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <while>while <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>r</name><operator>.</operator><name>leapcount</name></name> <operator>&amp;&amp;</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>trans</name><index>[<expr><name><name>r</name><operator>.</operator><name>leapbase</name></name> <operator>+</operator> <name><name>r</name><operator>.</operator><name>leapcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapcount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Determine whether to append an expiration to the leap second table.  */</comment>
  <expr_stmt><expr><name><name>r</name><operator>.</operator><name>leapexpiry</name></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>leapexpires</name> <operator>&amp;&amp;</operator> <name>leapexpires</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>hi</name></expr>;</expr_stmt>

  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>version</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>defaulttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>FILE</name> <modifier>*</modifier></type>			<name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type>		<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>outname</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Allocate the ATS and TYPES arrays via a single malloc,
	   as this is a bit faster.  Do not malloc(0) if !timecnt,
	   as that might return NULL even on success.  */</comment>
	<decl_stmt><decl><type><name>zic_t</name> <modifier>*</modifier></type><name>ats</name> <init>= <expr><call><name>emalloc</name><argument_list>(<argument><expr><call><name>align_to</name><argument_list>(<argument><expr><call><name>size_product</name><argument_list>(<argument><expr><name>timecnt</name> <operator>+</operator> <operator>!</operator><name>timecnt</name></expr></argument>,
						   <argument><expr><sizeof>sizeof <name/></sizeof>*<name>ats</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>zic_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>typesptr</name> <init>= <expr><name>ats</name> <operator>+</operator> <name>timecnt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>typesptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timerange</name></name></type> <name>rangeall</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name>range32</name></decl>, <decl><type ref="prev"/><name>range64</name></decl>;</decl_stmt>

	<comment type="block">/*
	** Sort.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>attypes</name></expr></argument>, <argument><expr><name>timecnt</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>attypes</name></expr></argument>, <argument><expr><name>atcomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	** Optimize.
	*/</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>fromi</name></decl>, <decl><type ref="prev"/><name>toi</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>toi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>fromi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>( <init>;</init> <condition><expr><name>fromi</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>fromi</name></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>toi</name> <operator>!=</operator> <literal type="number">0</literal>
			    <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>at</name>
				 <operator>+</operator> <name><name>utoffs</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator>
				<operator>&lt;=</operator> <operator>(</operator><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>at</name>
				    <operator>+</operator> <name><name>utoffs</name><index>[<expr><ternary><condition><expr><name>toi</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr>
					     </then><else>: <expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>type</name></expr></else></ternary></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator>
						<name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>
					<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>toi</name> <operator>==</operator> <literal type="number">0</literal>
			    <operator>||</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>dontmerge</name>
			    <operator>||</operator> <operator>(</operator><name><name>utoffs</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name>
				<operator>!=</operator> <name><name>utoffs</name><index>[<expr><name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator>
			    <operator>||</operator> <operator>(</operator><name><name>isdsts</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name>
				<operator>!=</operator> <name><name>isdsts</name><index>[<expr><name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator>
			    <operator>||</operator> <operator>(</operator><name><name>desigidx</name><index>[<expr><name><name>attypes</name><index>[<expr><name>toi</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name>
				<operator>!=</operator> <name><name>desigidx</name><index>[<expr><name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name><operator>.</operator><name>type</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>toi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>fromi</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <name>toi</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <name>timecnt</name> <operator>&gt;</operator> <literal type="number">1200</literal></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&gt;</operator> <name>TZ_MAX_TIMES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"reference clients mishandle"</literal>
			  <literal type="string">" more than %d transition times"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>TZ_MAX_TIMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pre-2014 clients may mishandle"</literal>
			  <literal type="string">" more than 1200 transition times"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	** Transfer.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>at</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	** Correct for leap seconds.
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>trans</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <name><name>corr</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>corr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></while>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>rangeall</name><operator>.</operator><name>defaulttype</name></name> <operator>=</operator> <name>defaulttype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeall</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeall</name><operator>.</operator><name>leapcount</name></name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>range64</name> <operator>=</operator> <call><name>limitrange</name><argument_list>(<argument><expr><name>rangeall</name></expr></argument>, <argument><expr><name>lo_time</name></expr></argument>,
			     <argument><expr><call><name>max</name><argument_list>(<argument><expr><name>hi_time</name></expr></argument>,
				 <argument><expr><name>redundant_time</name> <operator>-</operator> <operator>(</operator><name>ZIC_MIN</name> <operator>&lt;</operator> <name>redundant_time</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
			     <argument><expr><name>ats</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>range32</name> <operator>=</operator> <call><name>limitrange</name><argument_list>(<argument><expr><name>range64</name></expr></argument>, <argument><expr><name>ZIC32_MIN</name></expr></argument>, <argument><expr><name>ZIC32_MAX</name></expr></argument>, <argument><expr><name>ats</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TZif version 4 is needed if a no-op transition is appended to
	   indicate the expiration of the leap second table, or if the first
	   leap second transition is not to a +1 or -1 correction.  */</comment>
	<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <decl_stmt><decl><type><name><name>struct</name> <name>timerange</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>r</name> <init>= <expr><ternary><condition><expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name>range32</name></expr> </then><else>: <expr><operator>&amp;</operator><name>range64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <continue>continue;</continue></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>leapexpiry</name></name></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pre-2021b clients may mishandle"</literal>
			<literal type="string">" leap second expiry"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>version</name> <operator>=</operator> <literal type="char">'4'</literal></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>leapcount</name></name>
	      <operator>&amp;&amp;</operator> <name><name>corr</name><index>[<expr><name><name>r</name><operator>-&gt;</operator><name>leapbase</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>corr</name><index>[<expr><name><name>r</name><operator>-&gt;</operator><name>leapbase</name></name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pre-2021b clients may mishandle"</literal>
			<literal type="string">" leap second table truncation"</literal></expr></argument>)</argument_list></call></expr></argument>,
		      <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>version</name> <operator>=</operator> <literal type="char">'4'</literal></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="char">'4'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>open_outfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>pass</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type> <name>thistimei</name></decl>, <decl><type ref="prev"/><name>thistimecnt</name></decl>, <decl><type ref="prev"/><name>thistimelim</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>thisleapi</name></decl>, <decl><type ref="prev"/><name>thisleapcnt</name></decl>, <decl><type ref="prev"/><name>thisleaplim</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>tzhead</name></name></type> <name>tzh</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pretranstype</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>thisdefaulttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>locut</name></decl>, <decl><type ref="prev"/><name>hicut</name></decl>, <decl><type ref="prev"/><name>thisleapexpiry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>thismin</name></decl>, <decl><type ref="prev"/><name>thismax</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>old0</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>omittype</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name><name>typemap</name><index>[<expr><name>TZ_MAX_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>thistypecnt</name></decl>, <decl><type ref="prev"/><name>stdcnt</name></decl>, <decl><type ref="prev"/><name>utcnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>thischars</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>thischarcnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>toomanytimes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name><name>indmap</name><index>[<expr><name>TZ_MAX_CHARS</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>thisdefaulttype</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>defaulttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thistimei</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>base</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thistimecnt</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>toomanytimes</name> <operator>=</operator> <name>thistimecnt</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">1</literal> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapi</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>leapbase</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapcnt</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>leapcount</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapexpiry</name> <operator>=</operator> <name><name>range32</name><operator>.</operator><name>leapexpiry</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thismin</name> <operator>=</operator> <name>ZIC32_MIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thismax</name> <operator>=</operator> <name>ZIC32_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>thisdefaulttype</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>defaulttype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thistimei</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>base</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thistimecnt</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>toomanytimes</name> <operator>=</operator> <name>thistimecnt</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapi</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>leapbase</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapcnt</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>leapcount</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thisleapexpiry</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>leapexpiry</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thismin</name> <operator>=</operator> <name>min_time</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>thismax</name> <operator>=</operator> <name>max_time</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>toomanytimes</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many transition times"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>locut</name> <operator>=</operator> <name>thismin</name> <operator>&lt;</operator> <name>lo_time</name> <operator>&amp;&amp;</operator> <name>lo_time</name> <operator>&lt;=</operator> <name>thismax</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hicut</name> <operator>=</operator> <name>thismin</name> <operator>&lt;=</operator> <name>hi_time</name> <operator>&amp;&amp;</operator> <name>hi_time</name> <operator>&lt;</operator> <name>thismax</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>thistimelim</name> <operator>=</operator> <name>thistimei</name> <operator>+</operator> <name>thistimecnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>omittype</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>typecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Determine whether to output a transition before the first
		   transition in range.  This is needed when the output is
		   truncated at the start, and is also useful when catering to
		   buggy 32-bit clients that do not use time type 0 for
		   timestamps before the first transition.  */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>locut</name> <operator>||</operator> <operator>(</operator><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>thistimei</name><operator>)</operator><operator>)</operator>
		    <operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><name>thistimecnt</name> <operator>&amp;&amp;</operator> <name><name>ats</name><index>[<expr><name>thistimei</name></expr>]</index></name> <operator>==</operator> <name>lo_time</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		  <expr_stmt><expr><name>pretranstype</name> <operator>=</operator> <name>thisdefaulttype</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>omittype</name><index>[<expr><name>pretranstype</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Arguably the default time type in the 32-bit data
		   should be range32.defaulttype, which is suited for
		   timestamps just before ZIC32_MIN.  However, zic
		   traditionally used the time type of the indefinite
		   past instead.  Internet RFC 8532 says readers should
		   ignore 32-bit data, so this discrepancy matters only
		   to obsolete readers where the traditional type might
		   be more appropriate even if it's "wrong".  So, use
		   the historical zic value, unless -r specifies a low
		   cutoff that excludes some 32-bit timestamps.  */</comment>
		<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>lo_time</name> <operator>&lt;=</operator> <name>thismin</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>thisdefaulttype</name> <operator>=</operator> <name><name>range64</name><operator>.</operator><name>defaulttype</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>locut</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>thisdefaulttype</name> <operator>=</operator> <name>unspecifiedtype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>omittype</name><index>[<expr><name>thisdefaulttype</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>omittype</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>hicut</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>omittype</name><index>[<expr><name>unspecifiedtype</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Reorder types to make THISDEFAULTTYPE type 0.
		   Use TYPEMAP to swap OLD0 and THISDEFAULTTYPE so that
		   THISDEFAULTTYPE appears as type 0 in the output instead
		   of OLD0.  TYPEMAP also omits unused types.  */</comment>
		<expr_stmt><expr><name>old0</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>omittype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH</name></cpp:ifndef>
		<comment type="block">/*
		** For some pre-2011 systems: if the last-to-be-written
		** standard (or daylight) type has an offset different from the
		** most recently used offset,
		** append an (unused) copy of the most recently used type
		** (to help get global "altzone" and "timezone" variables
		** set correctly).
		*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>mrudst</name></decl>, <decl><type ref="prev"/><name>mrustd</name></decl>, <decl><type ref="prev"/><name>hidst</name></decl>, <decl><type ref="prev"/><name>histd</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>hidst</name> <operator>=</operator> <name>histd</name> <operator>=</operator> <name>mrudst</name> <operator>=</operator> <name>mrustd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pretranstype</name></expr>)</condition> <block>{<block_content>
			  <if_stmt><if>if <condition>(<expr><name><name>isdsts</name><index>[<expr><name>pretranstype</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>mrudst</name> <operator>=</operator> <name>pretranstype</name></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><name>mrustd</name> <operator>=</operator> <name>pretranstype</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>isdsts</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>mrudst</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>mrustd</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			  <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>==</operator> <name>old0</name></expr> ?</condition><then> <expr><name>thisdefaulttype</name></expr>
				   </then><else>: <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>thisdefaulttype</name></expr> ?</condition><then> <expr><name>old0</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
			  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>omittype</name><index>[<expr><name>h</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			    <if_stmt><if>if <condition>(<expr><name><name>isdsts</name><index>[<expr><name>h</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			      <expr_stmt><expr><name>hidst</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
			    <else>else<block type="pseudo"><block_content>
			      <expr_stmt><expr><name>histd</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			  </block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>hidst</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mrudst</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>hidst</name> <operator>!=</operator> <name>mrudst</name> <operator>&amp;&amp;</operator>
				<name><name>utoffs</name><index>[<expr><name>hidst</name></expr>]</index></name> <operator>!=</operator> <name><name>utoffs</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrudst</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name><name>utoffs</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr>]</index></name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>,
						<argument><expr><name><name>ttisstds</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>,
						<argument><expr><name><name>ttisuts</name><index>[<expr><name>mrudst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrudst</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>omittype</name><index>[<expr><name>type</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>histd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mrustd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>histd</name> <operator>!=</operator> <name>mrustd</name> <operator>&amp;&amp;</operator>
				<name><name>utoffs</name><index>[<expr><name>histd</name></expr>]</index></name> <operator>!=</operator> <name><name>utoffs</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrustd</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name><name>utoffs</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr>]</index></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>,
						<argument><expr><name><name>ttisstds</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>,
						<argument><expr><name><name>ttisuts</name><index>[<expr><name>mrustd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>mrustd</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>omittype</name><index>[<expr><name>type</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH */</comment>
		<expr_stmt><expr><name>thistypecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>omittype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name><name>typemap</name><index>[<expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>old0</name></expr> ?</condition><then> <expr><name>thisdefaulttype</name></expr>
			    </then><else>: <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>thisdefaulttype</name></expr> ?</condition><then> <expr><name>old0</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></else></ternary></expr>]</index></name>
		      <operator>=</operator> <name>thistypecnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <name>indmap</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>indmap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>indmap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name>thischarcnt</name> <operator>=</operator> <name>stdcnt</name> <operator>=</operator> <name>utcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>	<name>thisabbr</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>omittype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>stdcnt</name> <operator>=</operator> <name>thistypecnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ttisuts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>utcnt</name> <operator>=</operator> <name>thistypecnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>indmap</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>thisabbr</name> <operator>=</operator> <operator>&amp;</operator><name><name>chars</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>thischarcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thischars</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>thischarcnt</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thischars</name><index>[<expr><name>thischarcnt</name></expr>]</index></name></expr></argument>, <argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>thischarcnt</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thisabbr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>indmap</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		  <expr_stmt><expr><name>hicut</name> <operator>=</operator> <name>thisleapexpiry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>pretranstype</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><name>thistimecnt</name> <operator>=</operator> <name>thisleapcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><name>thistypecnt</name> <operator>=</operator> <name>thischarcnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO</name><parameter_list>(<parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>fwrite(tzh.field, sizeof tzh.field, 1, fp)</cpp:value></cpp:define>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tzh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>tzh</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_magic</name></name></expr></argument>, <argument><expr><name>TZ_MAGIC</name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>tzh</name><operator>.</operator><name>tzh_magic</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tzh</name><operator>.</operator><name>tzh_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>utcnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_ttisutcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>stdcnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_ttisstdcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thisleapcnt</name> <operator>+</operator> <name>thisleapexpiry</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_leapcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>pretranstype</name><operator>)</operator> <operator>+</operator> <name>thistimecnt</name> <operator>+</operator> <name>hicut</name></expr></argument>,
			<argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_timecnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thistypecnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_typecnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>convert</name><argument_list>(<argument><expr><name>thischarcnt</name></expr></argument>, <argument><expr><name><name>tzh</name><operator>.</operator><name>tzh_charcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_ttisutcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_ttisstdcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_leapcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_timecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_typecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DO</name><argument_list>(<argument><expr><name>tzh_charcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DO</name></cpp:undef>
		<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		  <comment type="block">/* Output a minimal data block with just one time type.  */</comment>
		  <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* utoff */</comment>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* dst */</comment>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* index of abbreviation */</comment>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* empty-string abbreviation */</comment>
		  <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Output a LO_TIME transition if needed; see limitrange.
		   But do not go below the minimum representable value
		   for this pass.  */</comment>
		<expr_stmt><expr><name>lo</name> <operator>=</operator> <ternary><condition><expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>lo_time</name> <operator>&lt;</operator> <name>ZIC32_MIN</name></expr> ?</condition><then> <expr><name>ZIC32_MIN</name></expr> </then><else>: <expr><name>lo_time</name></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pretranstype</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>puttzcodepass</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		  <expr_stmt><expr><call><name>puttzcodepass</name><argument_list>(<argument><expr><name><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>hicut</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>puttzcodepass</name><argument_list>(<argument><expr><name>hi_time</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>pretranstype</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>typemap</name><index>[<expr><name>pretranstype</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thistimei</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thistimelim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>typemap</name><index>[<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>hicut</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>typemap</name><index>[<expr><name>unspecifiedtype</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		  <decl_stmt><decl><type><name>int</name></type> <name>h</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>i</name> <operator>==</operator> <name>old0</name></expr> ?</condition><then> <expr><name>thisdefaulttype</name></expr>
			   </then><else>: <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>thisdefaulttype</name></expr> ?</condition><then> <expr><name>old0</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>omittype</name><index>[<expr><name>h</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name><name>utoffs</name><index>[<expr><name>h</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>isdsts</name><index>[<expr><name>h</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>indmap</name><index>[<expr><name><name>desigidx</name><index>[<expr><name>h</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>thischarcnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>thischars</name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>thischars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></argument>,
				      <argument><expr><name>thischarcnt</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>thisleaplim</name> <operator>=</operator> <name>thisleapi</name> <operator>+</operator> <name>thisleapcnt</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>thisleapi</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>thisleaplim</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>todo</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>roll</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<while>while <condition>(<expr><name><name>isdsts</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<if_stmt><if>if <condition>(<expr><operator>++</operator><name>j</name> <operator>&gt;=</operator> <name>typecnt</name></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt></block_content></block></while>
				</block_content>}</block></if> <else>else <block>{<block_content>
					<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>timecnt</name> <operator>&amp;&amp;</operator>
						<name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>ats</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></while>
					<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>todo</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name><name>utoffs</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>todo</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>puttzcodepass</name><argument_list>(<argument><expr><name>todo</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>thisleapexpiry</name></expr>)</condition> <block>{<block_content>
		  <comment type="block">/* Append a no-op leap correction indicating when the leap
		     second table expires.  Although this does not conform to
		     Internet RFC 8536, most clients seem to accept this and
		     the plan is to amend the RFC to allow this in version 4
		     TZif files.  */</comment>
		  <expr_stmt><expr><call><name>puttzcodepass</name><argument_list>(<argument><expr><name>leapexpires</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>puttzcode</name><argument_list>(<argument><expr><ternary><condition><expr><name>thisleaplim</name></expr> ?</condition><then> <expr><name><name>corr</name><index>[<expr><name>thisleaplim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>stdcnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>omittype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>utcnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>old0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>omittype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>ttisuts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close_file</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>tempname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rename_dest</name><argument_list>(<argument><expr><name>tempname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type>
<name>abbroffset</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>sign</name> <init>= <expr><literal type="char">'+'</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seconds</name></decl>, <decl><type ref="prev"/><name>minutes</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">100</literal> <operator>&lt;=</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%%z UT offset magnitude exceeds 99:59:59"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="string">"%z"</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>sign</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>offset</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>offset</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>minutes</name> <operator>|</operator> <name>seconds</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>minutes</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>minutes</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>seconds</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>seconds</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <name>seconds</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier></type> <name><name>disable_percent_s</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>doabbr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zp</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>letters</name></decl></parameter>,
       <parameter><decl><type><name>bool</name></type> <name>isdst</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>save</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doquotes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>	<name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>	<name>slashp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>format</name> <init>= <expr><name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>slashp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slashp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>char</name></type> <name><name>letterbuf</name><index>[<expr><name>PERCENT_Z_LEN_BOUND</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_format_specifier</name></name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>letters</name> <operator>=</operator> <call><name>abbroffset</name><argument_list>(<argument><expr><name>letterbuf</name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name> <operator>+</operator> <name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><operator>!</operator><name>letters</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>letters</name> <operator>=</operator> <literal type="string">"%s"</literal></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><name>letters</name> <operator>==</operator> <name>disable_percent_s</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>letters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isdst</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>slashp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>slashp</name> <operator>-</operator> <name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>abbr</name><index>[<expr><name>slashp</name> <operator>-</operator> <name>format</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>doquotes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>abbr</name></expr>;</init> <condition><expr><call><name>is_alpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>abbr</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>abbr</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>abbr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>abbr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>abbr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>
	<return>return <expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateminmax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>zic_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringoffset</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>hours</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>minutes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>seconds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>negative</name> <init>= <expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>negative</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>negative</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>offset</name> <operator>%</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>/=</operator> <name>MINSPERHOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hours</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hours</name> <operator>&gt;=</operator> <name>HOURSPERDAY</name> <operator>*</operator> <name>DAYSPERWEEK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>hours</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minutes</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>seconds</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">":%02d"</literal></expr></argument>, <argument><expr><name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">":%02d"</literal></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringrule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rp</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>save</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>stdoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>tod</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>compat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOM</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>month</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>==</operator> <literal type="number">29</literal> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>==</operator> <name>TM_FEBRUARY</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>month</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>month</name> <operator>&lt;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>month</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>len_months</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>month</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<comment type="block">/* Omit the "J" in Jan and Feb, as that's shorter.  */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>total</name> <operator>+</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
		  <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"J%d"</literal></expr></argument>, <argument><expr><name>total</name> <operator>+</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>week</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>wday</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>wdayoff</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>wdayoff</name> <operator>=</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>wdayoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>wday</name> <operator>-=</operator> <name>wdayoff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>wdayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>week</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>==</operator> <name><name>len_months</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>week</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
				<expr_stmt><expr><name>wdayoff</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>%</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>wdayoff</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>wday</name> <operator>-=</operator> <name>wdayoff</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>wdayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>week</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>/</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* "cannot happen" */</comment>
		<if_stmt><if>if <condition>(<expr><name>wday</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>wday</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"M%d.%d.%d"</literal></expr></argument>,
				  <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>week</name></expr></argument>, <argument><expr><name>wday</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>stdoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>tod</name> <operator>+=</operator> <name>save</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tod</name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SECSPERMIN</name> <operator>*</operator> <name>MINSPERHOUR</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <literal type="number">2013</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">2013</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>SECSPERDAY</name> <operator>&lt;=</operator> <name>tod</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <literal type="number">1994</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>compat</name> <operator>=</operator> <literal type="number">1994</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>compat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rule_cmp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rule</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><operator>!</operator><operator>!</operator><name>b</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <name>ZIC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>r_month</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>r_month</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_month</name></name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>r_dayofmonth</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stringzone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zpfirst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>zonecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type>	<name>zp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>		<name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>		<name>stdrp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type>		<name>dstrp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>compat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>offsetlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type>			<name>stdr</name></decl>, <decl><type ref="prev"/><name>dstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dstcmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name><name>lastrp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name></type> <name><name>zstr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>stdzp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>dstzp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Internet RFC 8536 section 5.1 says to use an empty TZ string if
	   future timestamps are truncated.  */</comment>
	<if_stmt><if>if <condition>(<expr><name>hi_time</name> <operator>&lt;</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>zp</name> <operator>=</operator> <name>zpfirst</name> <operator>+</operator> <name>zonecount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <operator>&amp;</operator><name><name>lastrp</name><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>rule_cmp</name><argument_list>(<argument><expr><operator>*</operator><name>last</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>stdrp</name> <operator>=</operator> <name><name>lastrp</name><index>[<expr><name>false</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstrp</name> <operator>=</operator> <name><name>lastrp</name><index>[<expr><name>true</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstcmp</name> <operator>=</operator> <ternary><condition><expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr> ?</condition><then> <expr><call><name>rule_cmp</name><argument_list>(<argument><expr><name>dstrp</name></expr></argument>, <argument><expr><name>stdrp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><ternary><condition><expr><name><name>zp</name><operator>-&gt;</operator><name>z_isdst</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>stdzp</name> <operator>=</operator> <name>dstzp</name> <operator>=</operator> <name>zp</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dstcmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Standard time all year.  */</comment>
	  <expr_stmt><expr><name>dstrp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>dstcmp</name></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* DST all year.  Use an abbreviation like
	     "XXX3EDT4,0/0,J365/23" for EDT (-04) all year.  */</comment>
	  <decl_stmt><decl><type><name>zic_t</name></type> <name>save</name> <init>= <expr><ternary><condition><expr><name>dstrp</name></expr> ?</condition><then> <expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name></expr> </then><else>: <expr><name><name>zp</name><operator>-&gt;</operator><name>z_save</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>save</name></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Positive DST, the typical case for all-year DST.
		 Fake a timezone with negative DST.  */</comment>
	      <expr_stmt><expr><name>stdzp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name>dstzp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z_stdoff</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>save</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z_format</name> <operator>=</operator> <literal type="string">"XXX"</literal></expr>;</expr_stmt>  <comment type="block">/* Any 3 letters will do.  */</comment>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z_format_specifier</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_stdoff</name> <operator>=</operator> <name><name>zstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>z_stdoff</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_format</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>zstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z_format_specifier</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_format_specifier</name></name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_todisstd</name></name> <operator>=</operator> <name><name>dstr</name><operator>.</operator><name>r_todisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_isdst</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_save</name></name> <operator>=</operator> <ternary><condition><expr><name>save</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>save</name></expr> </then><else>: <expr><operator>-</operator><name>save</name></expr></else></ternary></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>dstr</name><operator>.</operator><name>r_abbrvar</name></name> <operator>=</operator> <ternary><condition><expr><name>dstrp</name></expr> ?</condition><then> <expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_DECEMBER</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <name>SECSPERDAY</name> <operator>+</operator> <name><name>dstr</name><operator>.</operator><name>r_save</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_todisstd</name></name> <operator>=</operator> <name><name>stdr</name><operator>.</operator><name>r_todisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_isdst</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_save</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>stdr</name><operator>.</operator><name>r_abbrvar</name></name> <operator>=</operator> <ternary><condition><expr><name>save</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>stdrp</name></expr> ?</condition><then> <expr><name><name>stdrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	  <expr_stmt><expr><name>dstrp</name> <operator>=</operator> <operator>&amp;</operator><name>dstr</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>stdrp</name> <operator>=</operator> <operator>&amp;</operator><name>stdr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>doabbr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>stdzp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>stdrp</name></expr> ?</condition><then> <expr><name><name>stdrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
		     <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offsetlen</name> <operator>=</operator> <call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>-</operator> <name><name>stdzp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>offsetlen</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>offsetlen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dstrp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compat</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>doabbr</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>dstzp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
		      <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name> <operator>!=</operator> <name>SECSPERMIN</name> <operator>*</operator> <name>MINSPERHOUR</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>offsetlen</name> <operator>=</operator> <call><name>stringoffset</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>,
				   <argument><expr><operator>-</operator> <operator>(</operator><name><name>dstzp</name><operator>-&gt;</operator><name>z_stdoff</name></name> <operator>+</operator> <name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>offsetlen</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>offsetlen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>stringrule</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>dstrp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>, <argument><expr><name><name>stdzp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compat</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>stringrule</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>stdrp</name></expr></argument>, <argument><expr><name><name>dstrp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>, <argument><expr><name><name>stdzp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>compat</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compat</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>compat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>outzone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zone</name></name> <modifier>*</modifier></type><name>zpfirst</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>zonecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type>		<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>			<name>starttime</name></decl>, <decl><type ref="prev"/><name>untiltime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>startttisstd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>startttisut</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>startbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>ab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>			<name>envvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>max_abbr_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>max_envvar_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>prodstic</name></decl>;</decl_stmt> <comment type="block">/* all rules are min to max */</comment>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>			<name>compat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>bool</name></type>			<name>do_extend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name></type>			<name>version</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>lastatmax</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>zic_t</name></type> <name>max_year0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>defaulttype</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_for_signal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This cannot overflow; see FORMAT_LEN_GROWTH_BOUND.  */</comment>
	<expr_stmt><expr><name>max_abbr_len</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <name>max_format_len</name> <operator>+</operator> <name>max_abbrvar_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_envvar_len</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>max_abbr_len</name> <operator>+</operator> <literal type="number">5</literal> <operator>*</operator> <literal type="number">9</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>startbuf</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_abbr_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ab</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_abbr_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>envvar</name> <operator>=</operator> <call><name>emalloc</name><argument_list>(<argument><expr><name>max_envvar_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	** Now. . .finally. . .generate some useful data!
	*/</comment>
	<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>typecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>charcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>prodstic</name> <operator>=</operator> <name>zonecount</name> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/*
	** Thanks to Earl Chew
	** for noting the need to unconditionally initialize startttisstd.
	*/</comment>
	<expr_stmt><expr><name>startttisstd</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>startttisut</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>max_year</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leapseen</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name>leapminyear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name>leapmaxyear</name> <operator>+</operator> <operator>(</operator><name>leapmaxyear</name> <operator>&lt;</operator> <name>ZIC_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>&amp;</operator><name><name>zpfirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>updateminmax</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_lowasnum</name></name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiwasnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>prodstic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<comment type="block">/*
	** Generate lots of data if a rule can't cover all future times.
	*/</comment>
	<expr_stmt><expr><name>compat</name> <operator>=</operator> <call><name>stringzone</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>, <argument><expr><name>zpfirst</name></expr></argument>, <argument><expr><name>zonecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>=</operator> <ternary><condition><expr><name>compat</name> <operator>&lt;</operator> <literal type="number">2013</literal></expr> ?</condition><then> <expr><literal type="char">'2'</literal></expr> </then><else>: <expr><literal type="char">'3'</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>do_extend</name> <operator>=</operator> <name>compat</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>envvar</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"no POSIX environment variable for zone"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>compat</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Circa-COMPAT clients, and earlier clients, might
			   not work for this zone when given dates before
			   1970 or after 2038.  */</comment>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pre-%d clients may mishandle"</literal>
				  <literal type="string">" distant timestamps"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>, <argument><expr><name>compat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>do_extend</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Search through a couple of extra years past the obvious
		** 400, to avoid edge cases.  For example, suppose a non-POSIX
		** rule applies from 2012 onwards and has transitions in March
		** and September, plus some one-off transitions in November
		** 2013.  If zic looked only at the last 400 years, it would
		** set max_year=2413, with the intent that the 400 years 2014
		** through 2413 will be repeated.  The last transition listed
		** in the tzfile would be in 2413-09, less than 400 years
		** after the last one-off transition in 2013-11.  Two years
		** might be overkill, but with the kind of edge cases
		** available we're not sure that one year would suffice.
		*/</comment>
		<enum>enum <block>{ <decl><name>years_of_observations</name> <init>= <expr><name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl> }</block>;</enum>

		<if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;=</operator> <name>ZIC_MIN</name> <operator>+</operator> <name>years_of_observations</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_year</name> <operator>-=</operator> <name>years_of_observations</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>min_year</name> <operator>=</operator> <name>ZIC_MIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;=</operator> <name>ZIC_MAX</name> <operator>-</operator> <name>years_of_observations</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_year</name> <operator>+=</operator> <name>years_of_observations</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>	<expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>ZIC_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/*
		** Regardless of any of the above,
		** for a "proDSTic" zone which specifies that its rules
		** always have and always will be in effect,
		** we only need one cycle to define the zone.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>prodstic</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>min_year</name> <operator>=</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>max_year</name> <operator>=</operator> <name>min_year</name> <operator>+</operator> <name>years_of_observations</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>max_year</name> <operator>=</operator> <call><name>max</name><argument_list>(<argument><expr><name>max_year</name></expr></argument>, <argument><expr><operator>(</operator><name>redundant_time</name> <operator>/</operator> <operator>(</operator><name>SECSPERDAY</name> <operator>*</operator> <name>DAYSPERNYEAR</name><operator>)</operator>
				  <operator>+</operator> <name>EPOCH_YEAR</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_year0</name> <operator>=</operator> <name>max_year</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* For the benefit of older systems,
	     generate data from 1900 through 2038.  */</comment>
	  <if_stmt><if>if <condition>(<expr><name>min_year</name> <operator>&gt;</operator> <literal type="number">1900</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>min_year</name> <operator>=</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>max_year</name> <operator>&lt;</operator> <literal type="number">2038</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_year</name> <operator>=</operator> <literal type="number">2038</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>min_time</name> <operator>&lt;</operator> <name>lo_time</name> <operator>||</operator> <name>hi_time</name> <operator>&lt;</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>unspecifiedtype</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"-00"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>zonecount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>prevrp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		** A guess that may well be corrected later.
		*/</comment>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>save</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>zone</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>&amp;</operator><name><name>zpfirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>usestart</name> <init>= <expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>zp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>z_untiltime</name> <operator>&gt;</operator> <name>min_time</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>useuntil</name> <init>= <expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>zonecount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>stdoff</name> <init>= <expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>startoff</name> <init>= <expr><name>stdoff</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>prevktime</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>prevktime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name> <operator>&lt;=</operator> <name>min_time</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>startbuf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>save</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_save</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_isdst</name></name></expr></argument>, <argument><expr><name>save</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_isdst</name></name></expr></argument>, <argument><expr><name>startttisstd</name></expr></argument>,
				<argument><expr><name>startttisut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>usestart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>defaulttype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
		  <decl_stmt><decl><type><name>zic_t</name></type> <name>year</name></decl>;</decl_stmt>
		  <for>for <control>(<init><expr><name>year</name> <operator>=</operator> <name>min_year</name></expr>;</init> <condition><expr><name>year</name> <operator>&lt;=</operator> <name>max_year</name></expr>;</condition> <incr><expr><operator>++</operator><name>year</name></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name>year</name> <operator>&gt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_hiyear</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/*
			** Mark which rules to do in the current year.
			** For those to do, calculate rpytime(rp, year);
			** The former TYPE field was also considered here.
			*/</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><name>zic_t</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>zic_t</name></type> <name>y2038_boundary</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
				     <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filenum</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name> <operator>=</operator> <name>year</name> <operator>&gt;=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_loyear</name></name> <operator>&amp;&amp;</operator>
						<name>year</name> <operator>&lt;=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_temp</name></name> <operator>=</operator> <call><name>rpytime</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name>
					  <operator>=</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>r_temp</name></name> <operator>&lt;</operator> <name>y2038_boundary</name>
					     <operator>||</operator> <name>year</name> <operator>&lt;=</operator> <name>max_year0</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>register</specifier> <name>ptrdiff_t</name></type> <name>k</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>jtime</name></decl>, <decl><type ref="prev"/><name>ktime</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>offset</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>ktime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>useuntil</name></expr>)</condition> <block>{<block_content>
					<comment type="block">/*
					** Turn untiltime into UT
					** assuming the current stdoff and
					** save values.
					*/</comment>
					<expr_stmt><expr><name>untiltime</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisut</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>untiltime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>,
								 <argument><expr><operator>-</operator><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisstd</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>untiltime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>untiltime</name></expr></argument>,
								 <argument><expr><operator>-</operator><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/*
				** Find the rule (of those to do, if any)
				** that takes effect earliest in the year.
				*/</comment>
				<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_nrules</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>r_todo</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
					     <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_filenum</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <ternary><condition><expr><name><name>r</name><operator>-&gt;</operator><name>r_todisut</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>stdoff</name></expr></else></ternary></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>r_todisstd</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>jtime</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>r_temp</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>jtime</name> <operator>==</operator> <name>min_time</name> <operator>||</operator>
						<name>jtime</name> <operator>==</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>jtime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>jtime</name></expr></argument>, <argument><expr><operator>-</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>jtime</name> <operator>&lt;</operator> <name>ktime</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>ktime</name> <operator>=</operator> <name>jtime</name></expr>;</expr_stmt>
					</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>jtime</name> <operator>==</operator> <name>ktime</name></expr>)</condition> <block>{<block_content>
					  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>dup_rules_msg</name> <init>=
					    <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"two rules for same instant"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					  <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
					       <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_filenum</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>dup_rules_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
					  <expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
					       <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_filenum</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>dup_rules_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* go on to next year */</comment>
				<expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z_rules</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>useuntil</name> <operator>&amp;&amp;</operator> <name>ktime</name> <operator>&gt;=</operator> <name>untiltime</name></expr>)</condition> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>startbuf</name>
					    <operator>&amp;&amp;</operator> <operator>(</operator><call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>)</argument_list></call>
						<operator>==</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					  <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
						 <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>save</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>usestart</name> <operator>&amp;&amp;</operator> <name>ktime</name> <operator>==</operator> <name>starttime</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>usestart</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition> <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>ktime</name> <operator>&lt;</operator> <name>starttime</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>,
								<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>,
							<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
							<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>,
							<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal>
					    <operator>&amp;&amp;</operator> <name>startoff</name> <operator>==</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>,
								<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>,
								<argument><expr><name>zp</name></expr></argument>,
								<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
								<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>,
								<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>eats</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>,
				     <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_filenum</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>ab</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_abbrvar</name></name></expr></argument>,
				       <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_save</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>want_bloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>useuntil</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>do_extend</name>
				    <operator>&amp;&amp;</operator> <name>prevrp</name> <operator>&amp;&amp;</operator> <name>lo_time</name> <operator>&lt;=</operator> <name>prevktime</name>
				    <operator>&amp;&amp;</operator> <name>redundant_time</name> <operator>&lt;=</operator> <name>ktime</name>
				    <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <name>ZIC_MAX</name>
				    <operator>&amp;&amp;</operator> <name><name>prevrp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <name>ZIC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				  <break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>addtype</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ab</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr></argument>,
					<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisstd</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_todisut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defaulttype</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rp</name><operator>-&gt;</operator><name>r_isdst</name></name></expr>)</condition><block type="pseudo"><block_content>
				  <expr_stmt><expr><name>defaulttype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_hiyear</name></name> <operator>==</operator> <name>ZIC_MAX</name>
				    <operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>lastatmax</name>
					  <operator>&amp;&amp;</operator> <name>ktime</name> <operator>&lt;</operator> <name><name>attypes</name><index>[<expr><name>lastatmax</name></expr>]</index></name><operator>.</operator><name>at</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				  <expr_stmt><expr><name>lastatmax</name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>ktime</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>prevrp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prevktime</name> <operator>=</operator> <name>ktime</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		  </block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>usestart</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>isdst</name> <init>= <expr><name>startoff</name> <operator>!=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_stdoff</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_format</name></name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><call><name>doabbr</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>, <argument><expr><name>disable_percent_s</name></expr></argument>,
				 <argument><expr><name>isdst</name></expr></argument>, <argument><expr><name>save</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>eat</name><argument_list>(<argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_filenum</name></name></expr></argument>, <argument><expr><name><name>zp</name><operator>-&gt;</operator><name>z_linenum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>startbuf</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"can't determine time zone abbreviation to use just after until time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
			  <decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>addtype</name><argument_list>(<argument><expr><name>startoff</name></expr></argument>, <argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>isdst</name></expr></argument>,
					     <argument><expr><name>startttisstd</name></expr></argument>, <argument><expr><name>startttisut</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			  <if_stmt><if>if <condition>(<expr><name>defaulttype</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isdst</name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>defaulttype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			  <expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		** Now we may get to set starttime for the next zone line.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>useuntil</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>startttisstd</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisstd</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startttisut</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untilrule</name><operator>.</operator><name>r_todisut</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>starttime</name> <operator>=</operator> <name><name>zp</name><operator>-&gt;</operator><name>z_untiltime</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startttisstd</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><operator>-</operator><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startttisut</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><operator>-</operator><name>stdoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>defaulttype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>defaulttype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>lastatmax</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>attypes</name><index>[<expr><name>lastatmax</name></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>do_extend</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** If we're extending the explicitly listed observations
		** for 400 years because we can't fill the POSIX-TZ field,
		** check whether we actually ended up explicitly listing
		** observations through that period.  If there aren't any
		** near the end of the 400-year period, add a redundant
		** one at the end of the final year, to make it clear
		** that we are claiming to have definite knowledge of
		** the lack of transitions up to that point.
		*/</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>xr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>attype</name></name> <modifier>*</modifier></type><name>lastat</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_month</name></name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_dycode</name></name> <operator>=</operator> <name>DC_DOM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_dayofmonth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xr</name><operator>.</operator><name>r_tod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>lastat</name> <operator>=</operator> <name>attypes</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>&gt;</operator> <name><name>lastat</name><operator>-&gt;</operator><name>at</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastat</name> <operator>=</operator> <operator>&amp;</operator><name><name>attypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lastat</name> <operator>||</operator> <name><name>lastat</name><operator>-&gt;</operator><name>at</name></name> <operator>&lt;</operator> <call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xr</name></expr></argument>, <argument><expr><name>max_year</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>addtt</name><argument_list>(<argument><expr><call><name>rpytime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xr</name></expr></argument>, <argument><expr><name>max_year</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><ternary><condition><expr><name>lastat</name></expr> ?</condition><then> <expr><name><name>lastat</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><name>defaulttype</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>writezone</name><argument_list>(<argument><expr><name><name>zpfirst</name><operator>-&gt;</operator><name>z_name</name></name></expr></argument>, <argument><expr><name>envvar</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>defaulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addtt</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>starttime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>attypes</name> <operator>=</operator> <call><name>growalloc</name><argument_list>(<argument><expr><name>attypes</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>attypes</name></expr></argument>, <argument><expr><name>timecnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timecnt_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>at</name> <operator>=</operator> <name>starttime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>dontmerge</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attypes</name><index>[<expr><name>timecnt</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name>timecnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>addtype</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>utoff</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ttisstd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ttisut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><operator>-</operator><literal type="number">1L</literal> <operator>-</operator> <literal type="number">2147483647L</literal> <operator>&lt;=</operator> <name>utoff</name> <operator>&amp;&amp;</operator> <name>utoff</name> <operator>&lt;=</operator> <literal type="number">2147483647L</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"UT offset out of range"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>want_bloat</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ttisstd</name> <operator>=</operator> <name>ttisut</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>charcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>abbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>newabbr</name><argument_list>(<argument><expr><name>abbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
	  <comment type="block">/* If there's already an entry, return its index.  */</comment>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>typecnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name>utoff</name> <operator>==</operator> <name><name>utoffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>isdst</name> <operator>==</operator> <name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name><name>desigidx</name><index>[<expr><name>i</name></expr>]</index></name>
		<operator>&amp;&amp;</operator> <name>ttisstd</name> <operator>==</operator> <name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>ttisut</name> <operator>==</operator> <name><name>ttisuts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/*
	** There isn't one; add a new one, unless there are already too
	** many.
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>typecnt</name> <operator>&gt;=</operator> <name>TZ_MAX_TYPES</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many local time types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>typecnt</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>utoffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>utoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>isdsts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ttisstds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ttisstd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ttisuts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ttisut</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desigidx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>leapadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>correction</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rolling</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TZ_MAX_LEAPS</name> <operator>&lt;=</operator> <name>leapcnt</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many leap seconds"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rolling</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lo_time</name> <operator>!=</operator> <name>min_time</name> <operator>||</operator> <name>hi_time</name> <operator>!=</operator> <name>max_time</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rolling leap seconds not supported with -r"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>leapcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;=</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>leapcnt</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>corr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>leapcnt</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>corr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>roll</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>roll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>leapcnt</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>roll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>correction</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>roll</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rolling</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name>leapcnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjleap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>prevtrans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	** propagate leap seconds forward
	*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>leapcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>prevtrans</name> <operator>&lt;</operator> <literal type="number">28</literal> <operator>*</operator> <name>SECSPERDAY</name></expr>)</condition> <block>{<block_content>
		  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Leap seconds too close together"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prevtrans</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tadd</name><argument_list>(<argument><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>corr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>last</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>leapexpires</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>leapexpires</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>leapexpires</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>leapcnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>trans</name><index>[<expr><name>leapcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>leapexpires</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"last Leap time does not precede Expires time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Is A a space character in the C locale?  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_space</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>a</name></expr>)</condition> <block>{<block_content>
	  <default>default:</default>
		<return>return <expr><name>false</name></expr>;</return>
	  <case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Is A an alphabetic character in the C locale?  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_alpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>a</name></expr>)</condition> <block>{<block_content>
	  <default>default:</default>
		<return>return <expr><name>false</name></expr>;</return>
	  <case>case <expr><literal type="char">'A'</literal></expr>:</case> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <case>case <expr><literal type="char">'C'</literal></expr>:</case> <case>case <expr><literal type="char">'D'</literal></expr>:</case> <case>case <expr><literal type="char">'E'</literal></expr>:</case> <case>case <expr><literal type="char">'F'</literal></expr>:</case> <case>case <expr><literal type="char">'G'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'H'</literal></expr>:</case> <case>case <expr><literal type="char">'I'</literal></expr>:</case> <case>case <expr><literal type="char">'J'</literal></expr>:</case> <case>case <expr><literal type="char">'K'</literal></expr>:</case> <case>case <expr><literal type="char">'L'</literal></expr>:</case> <case>case <expr><literal type="char">'M'</literal></expr>:</case> <case>case <expr><literal type="char">'N'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'O'</literal></expr>:</case> <case>case <expr><literal type="char">'P'</literal></expr>:</case> <case>case <expr><literal type="char">'Q'</literal></expr>:</case> <case>case <expr><literal type="char">'R'</literal></expr>:</case> <case>case <expr><literal type="char">'S'</literal></expr>:</case> <case>case <expr><literal type="char">'T'</literal></expr>:</case> <case>case <expr><literal type="char">'U'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'V'</literal></expr>:</case> <case>case <expr><literal type="char">'W'</literal></expr>:</case> <case>case <expr><literal type="char">'X'</literal></expr>:</case> <case>case <expr><literal type="char">'Y'</literal></expr>:</case> <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'a'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <case>case <expr><literal type="char">'c'</literal></expr>:</case> <case>case <expr><literal type="char">'d'</literal></expr>:</case> <case>case <expr><literal type="char">'e'</literal></expr>:</case> <case>case <expr><literal type="char">'f'</literal></expr>:</case> <case>case <expr><literal type="char">'g'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'h'</literal></expr>:</case> <case>case <expr><literal type="char">'i'</literal></expr>:</case> <case>case <expr><literal type="char">'j'</literal></expr>:</case> <case>case <expr><literal type="char">'k'</literal></expr>:</case> <case>case <expr><literal type="char">'l'</literal></expr>:</case> <case>case <expr><literal type="char">'m'</literal></expr>:</case> <case>case <expr><literal type="char">'n'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'o'</literal></expr>:</case> <case>case <expr><literal type="char">'p'</literal></expr>:</case> <case>case <expr><literal type="char">'q'</literal></expr>:</case> <case>case <expr><literal type="char">'r'</literal></expr>:</case> <case>case <expr><literal type="char">'s'</literal></expr>:</case> <case>case <expr><literal type="char">'t'</literal></expr>:</case> <case>case <expr><literal type="char">'u'</literal></expr>:</case>
	  <case>case <expr><literal type="char">'v'</literal></expr>:</case> <case>case <expr><literal type="char">'w'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'y'</literal></expr>:</case> <case>case <expr><literal type="char">'z'</literal></expr>:</case>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* If A is an uppercase character in the C locale, return its lowercase
   counterpart.  Otherwise, return A.  */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>lowerit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>a</name></expr>)</condition> <block>{<block_content>
	  <default>default:</default> <return>return <expr><name>a</name></expr>;</return>
	  <case>case <expr><literal type="char">'A'</literal></expr>:</case> <return>return <expr><literal type="char">'a'</literal></expr>;</return> <case>case <expr><literal type="char">'B'</literal></expr>:</case> <return>return <expr><literal type="char">'b'</literal></expr>;</return> <case>case <expr><literal type="char">'C'</literal></expr>:</case> <return>return <expr><literal type="char">'c'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'D'</literal></expr>:</case> <return>return <expr><literal type="char">'d'</literal></expr>;</return> <case>case <expr><literal type="char">'E'</literal></expr>:</case> <return>return <expr><literal type="char">'e'</literal></expr>;</return> <case>case <expr><literal type="char">'F'</literal></expr>:</case> <return>return <expr><literal type="char">'f'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'G'</literal></expr>:</case> <return>return <expr><literal type="char">'g'</literal></expr>;</return> <case>case <expr><literal type="char">'H'</literal></expr>:</case> <return>return <expr><literal type="char">'h'</literal></expr>;</return> <case>case <expr><literal type="char">'I'</literal></expr>:</case> <return>return <expr><literal type="char">'i'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'J'</literal></expr>:</case> <return>return <expr><literal type="char">'j'</literal></expr>;</return> <case>case <expr><literal type="char">'K'</literal></expr>:</case> <return>return <expr><literal type="char">'k'</literal></expr>;</return> <case>case <expr><literal type="char">'L'</literal></expr>:</case> <return>return <expr><literal type="char">'l'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'M'</literal></expr>:</case> <return>return <expr><literal type="char">'m'</literal></expr>;</return> <case>case <expr><literal type="char">'N'</literal></expr>:</case> <return>return <expr><literal type="char">'n'</literal></expr>;</return> <case>case <expr><literal type="char">'O'</literal></expr>:</case> <return>return <expr><literal type="char">'o'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'P'</literal></expr>:</case> <return>return <expr><literal type="char">'p'</literal></expr>;</return> <case>case <expr><literal type="char">'Q'</literal></expr>:</case> <return>return <expr><literal type="char">'q'</literal></expr>;</return> <case>case <expr><literal type="char">'R'</literal></expr>:</case> <return>return <expr><literal type="char">'r'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'S'</literal></expr>:</case> <return>return <expr><literal type="char">'s'</literal></expr>;</return> <case>case <expr><literal type="char">'T'</literal></expr>:</case> <return>return <expr><literal type="char">'t'</literal></expr>;</return> <case>case <expr><literal type="char">'U'</literal></expr>:</case> <return>return <expr><literal type="char">'u'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'V'</literal></expr>:</case> <return>return <expr><literal type="char">'v'</literal></expr>;</return> <case>case <expr><literal type="char">'W'</literal></expr>:</case> <return>return <expr><literal type="char">'w'</literal></expr>;</return> <case>case <expr><literal type="char">'X'</literal></expr>:</case> <return>return <expr><literal type="char">'x'</literal></expr>;</return>
	  <case>case <expr><literal type="char">'Y'</literal></expr>:</case> <return>return <expr><literal type="char">'y'</literal></expr>;</return> <case>case <expr><literal type="char">'Z'</literal></expr>:</case> <return>return <expr><literal type="char">'z'</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* case-insensitive equality */</comment>
<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>bool</name></type>
<name>ciequal</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>ap</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ap</name><operator>++</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>bool</name></type>
<name>itsabbr</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>abbr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>word</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>++</operator><name>word</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>abbr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<do>do <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>word</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>abbr</name></expr></argument>)</argument_list></call></expr>)</condition>;</do></block_content></block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if ABBR is an initial prefix of WORD, ignoring ASCII case.  */</comment>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>bool</name></type>
<name>ciprefix</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>abbr</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <do>do<block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>abbr</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block>
  while <condition>(<expr><call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>abbr</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lowerit</name><argument_list>(<argument><expr><operator>*</operator><name>word</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>
<name>byword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>	<name>foundlp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name><name>struct</name> <name>lookup</name></name> <modifier>*</modifier></type>	<name>lp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>word</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If TABLE is LASTS and the word starts with "last" followed
	   by a non-'-', skip the "last" and look in WDAY_NAMES instead.
	   Warn about any usage of the undocumented prefix "last-".  */</comment>
	<if_stmt><if>if <condition>(<expr><name>table</name> <operator>==</operator> <name>lasts</name> <operator>&amp;&amp;</operator> <call><name>ciprefix</name><argument_list>(<argument><expr><literal type="string">"last"</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is undocumented; use \"last%s\" instead"</literal></expr></argument>)</argument_list></call></expr></argument>,
		    <argument><expr><name>word</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else <block>{<block_content>
	    <expr_stmt><expr><name>word</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><name>table</name> <operator>=</operator> <name>wday_names</name></expr>;</expr_stmt>
	  </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	** Look for exact match.
	*/</comment>
	<for>for <control>(<init><expr><name>lp</name> <operator>=</operator> <name>table</name></expr>;</init> <condition><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>lp</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ciequal</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>lp</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	<comment type="block">/*
	** Look for inexact match.
	*/</comment>
	<expr_stmt><expr><name>foundlp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>lp</name> <operator>=</operator> <name>table</name></expr>;</init> <condition><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>lp</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ciprefix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>foundlp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>foundlp</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>	<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* multiple inexact matches */</comment>
		</block_content>}</block></if></if_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>foundlp</name> <operator>&amp;&amp;</operator> <name>noise</name></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Warn about any backward-compatibility issue with pre-2017c zic.  */</comment>
	  <decl_stmt><decl><type><name>bool</name></type> <name>pre_2017c_match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	  <for>for <control>(<init><expr><name>lp</name> <operator>=</operator> <name>table</name></expr>;</init> <condition><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr>;</condition> <incr><expr><name>lp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><call><name>itsabbr</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>l_word</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>pre_2017c_match</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is ambiguous in pre-2017c zic"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block></if></if_stmt>
	      <expr_stmt><expr><name>pre_2017c_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>foundlp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getfields</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arrayelts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type>		<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>		<name>nsubs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsubs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>( <init>;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dstart</name></decl>;</decl_stmt>
		<while>while <condition>(<expr><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dstart</name> <operator>=</operator> <name>dp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
		<do>do <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>dp</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content> <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>dp</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>++</operator><name>dp</name></expr>;</expr_stmt></block_content></block></if>
				<else>else <block>{<block_content>
				  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Odd number of quotation marks"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt></block_content></block></while></block_content></block></else></if_stmt>
		</block_content>}</block> while <condition>(<expr><operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<if_stmt><if>if <condition>(<expr><call><name>is_space</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nsubs</name> <operator>==</operator> <name>arrayelts</name></expr>)</condition> <block>{<block_content>
		  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Too many input fields"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>array</name><index>[<expr><name>nsubs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>dstart</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>dstart</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>dp</name> <operator>==</operator> <name>dstart</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>nsubs</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_NORETURN</name> <specifier>static</specifier> <name>void</name></type>
<name>time_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"time overflow"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>zic_t</name></type>
<name>oadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
  <decl_stmt><decl><type><name>zic_t</name></type> <name>sum</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sum</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>t1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ZIC_MIN</name> <operator>-</operator> <name>t1</name> <operator>&lt;=</operator> <name>t2</name></expr> </then><else>: <expr><name>t2</name> <operator>&lt;=</operator> <name>ZIC_MAX</name> <operator>-</operator> <name>t1</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>t1</name> <operator>+</operator> <name>t2</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>time_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ATTRIBUTE_REPRODUCIBLE</name> <specifier>static</specifier> <name>zic_t</name></type>
<name>tadd</name><parameter_list>(<parameter><decl><type><name>zic_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ckd_add</name></cpp:ifdef>
  <decl_stmt><decl><type><name>zic_t</name></type> <name>sum</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ckd_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>min_time</name> <operator>&lt;=</operator> <name>sum</name> <operator>&amp;&amp;</operator> <name>sum</name> <operator>&lt;=</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sum</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>t1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>min_time</name> <operator>-</operator> <name>t1</name> <operator>&lt;=</operator> <name>t2</name></expr> </then><else>: <expr><name>t2</name> <operator>&lt;=</operator> <name>max_time</name> <operator>-</operator> <name>t1</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>t1</name> <operator>+</operator> <name>t2</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>t1</name> <operator>==</operator> <name>min_time</name> <operator>||</operator> <name>t1</name> <operator>==</operator> <name>max_time</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>t1</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>time_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Given a rule, and a year, compute the date (in seconds since January 1,
** 1970, 00:00 LOCAL time) in that year that the rule refers to.
*/</comment>

<function><type><specifier>static</specifier> <name>zic_t</name></type>
<name>rpytime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>zic_t</name></type> <name>wantedy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>m</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>dayoff</name></decl>;</decl_stmt>			<comment type="block">/* with a nod to Margaret O. */</comment>
	<decl_stmt><decl><type><specifier>register</specifier> <name>zic_t</name></type>	<name>t</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>yrem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>wantedy</name> <operator>==</operator> <name>ZIC_MIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>min_time</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>wantedy</name> <operator>==</operator> <name>ZIC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>max_time</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <name>TM_JANUARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>

	<comment type="block">/* dayoff = floor((wantedy - y) / YEARSPERREPEAT) * DAYSPERREPEAT,
	   sans overflow.  */</comment>
	<expr_stmt><expr><name>yrem</name> <operator>=</operator> <name>wantedy</name> <operator>%</operator> <name>YEARSPERREPEAT</name> <operator>-</operator> <name>y</name> <operator>%</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>wantedy</name> <operator>/</operator> <name>YEARSPERREPEAT</name> <operator>-</operator> <name>y</name> <operator>/</operator> <name>YEARSPERREPEAT</name>
		   <operator>+</operator> <name>yrem</name> <operator>/</operator> <name>YEARSPERREPEAT</name> <operator>-</operator> <operator>(</operator><name>yrem</name> <operator>%</operator> <name>YEARSPERREPEAT</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator>
		  <operator>*</operator> <name>DAYSPERREPEAT</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* wantedy = y + ((wantedy - y) mod YEARSPERREPEAT), sans overflow.  */</comment>
	<expr_stmt><expr><name>wantedy</name> <operator>=</operator> <name>y</name> <operator>+</operator> <operator>(</operator><name>yrem</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>YEARSPERREPEAT</name><operator>)</operator> <operator>%</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>wantedy</name> <operator>!=</operator> <name>y</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_years</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>m</name> <operator>!=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_month</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>m</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>m</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dayofmonth</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>TM_FEBRUARY</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <literal type="number">29</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt></block_content></block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"use of 2/29 in non leap-year"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWLEQ</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		** Don't trust mod of negative numbers.
		*/</comment>
		<decl_stmt><decl><type><name>zic_t</name></type> <name>wday</name> <init>= <expr><operator>(</operator><operator>(</operator><name>EPOCH_WDAY</name> <operator>+</operator> <name>dayoff</name> <operator>%</operator> <name>DAYSPERWEEK</name> <operator>+</operator> <name>DAYSPERWEEK</name><operator>)</operator>
			      <operator>%</operator> <name>DAYSPERWEEK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>wday</name> <operator>!=</operator> <name><name>rp</name><operator>-&gt;</operator><name>r_wday</name></name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>r_dycode</name></name> <operator>==</operator> <name>DC_DOWGEQ</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>wday</name> <operator>&gt;=</operator> <name>DAYSPERWEEK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>wday</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>dayoff</name> <operator>=</operator> <call><name>oadd</name><argument_list>(<argument><expr><name>dayoff</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>--</operator><name>wday</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>wday</name> <operator>=</operator> <name>DAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name><name>len_months</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>m</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noise</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"rule goes past start/end of month; \
will not work with pre-2004 versions of zic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&lt;</operator> <name>min_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>min_time</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dayoff</name> <operator>&gt;</operator> <name>max_time</name> <operator>/</operator> <name>SECSPERDAY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>max_time</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>zic_t</name><operator>)</operator> <name>dayoff</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<return>return <expr><call><name>tadd</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>r_tod</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>newabbr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>GRANDPARENTED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>	<name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>		<name>mp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>is_alpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><literal type="char">'0'</literal> <operator>&lt;=</operator> <operator>*</operator><name>cp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator>
		       <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><name>noise</name> <operator>&amp;&amp;</operator> <name>cp</name> <operator>-</operator> <name>string</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation has fewer than 3 characters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>-</operator> <name>string</name> <operator>&gt;</operator> <name>ZIC_MAX_ABBR_LEN_WO_WARN</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation has too many characters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"time zone abbreviation differs from POSIX standard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>mp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"%s (%s)"</literal></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>charcnt</name> <operator>+</operator> <name>i</name> <operator>&gt;</operator> <name>TZ_MAX_CHARS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many, or too long, time zone abbreviations"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chars</name><index>[<expr><name>charcnt</name></expr>]</index></name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>charcnt</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Ensure that the directories of ARGNAME exist, by making any missing
   ones.  If ANCESTORS, do this only for ARGNAME's ancestors; otherwise,
   do it for ARGNAME too.  Exit with failure if there is trouble.
   Do not consider an existing file to be trouble.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mkdirs</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>argname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ancestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>estrdup</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* On MS-Windows systems, do not worry about drive letters or
	   backslashes, as this should suffice in practice.  Time zone
	   names do not use drive letters and backslashes.  If the -d
	   option of zic does not name an already-existing directory,
	   it can use slashes to separate the already-existing
	   ancestor prefix from the to-be-created subdirectories.  */</comment>

	<comment type="block">/* Do not mkdir a root directory, as it must exist.  */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<while>while <condition>(<expr><name>cp</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>!</operator><name>ancestors</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/*
		** Try to create it.  It's OK if creation fails because
		** the directory already exists, perhaps because some
		** other process just created it.  For simplicity do
		** not check first whether it already exists, as that
		** is checked anyway if the mkdir fails.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MKDIR_UMASK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Do not report an error if err == EEXIST, because
			   some other process might have made the directory
			   in the meantime.  Likewise for ENOSYS, because
			   Solaris 10 mkdir fails with ENOSYS if the
			   directory is an automounted mount point.
			   Likewise for EACCES, since mkdir can fail
			   with EACCES merely because the parent directory
			   is unwritable.  Likewise for most other error
			   numbers.  */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>ELOOP</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ENAMETOOLONG</name>
			    <operator>||</operator> <name>err</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ENOTDIR</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Can't create directory %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				      <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
