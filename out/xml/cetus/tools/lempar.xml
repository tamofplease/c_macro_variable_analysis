<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/cetus/tools/lempar.c"><comment type="block">/*
** 2000-05-29
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Driver template for the LEMON parser generator.
**
** The "lemon" program processes an LALR(1) input grammar file, then uses
** this template to construct a parser.  The "lemon" program inserts text
** at each "%%" line.  Also, any "P-a-r-s-e" identifer prefix (without the
** interstitial "-" characters) contained in this template is changed into
** the value of the %name directive from the grammar.  Otherwise, the content
** of this template is copied straight through into the generate parser
** source file.
**
** The following is the concatenation of all %include directives from the
** input grammar file:
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<comment type="block" format="doxygen">/************ Begin %include sections from the grammar ************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/**************** End of %include directives **********************************/</comment>
<comment type="block">/* These constants specify the various numeric values for terminal symbols
** in a format understandable to "makeheaders".  This section is blank unless
** "lemon" is run with the "-m" command-line option.
***************** Begin makeheaders token definitions *************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/**************** End makeheaders token definitions ***************************/</comment>

<comment type="block">/* The next sections is a series of control #defines.
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used to store the integer codes
**                       that represent terminal and non-terminal symbols.
**                       "unsigned char" is used if there are fewer than
**                       256 symbols.  Larger types otherwise.
**    YYNOCODE           is a number of type YYCODETYPE that is not used for
**                       any terminal or nonterminal symbol.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       (also known as: "terminal symbols") have fall-back
**                       values which should be used if the original symbol
**                       would not parse.  This permits keywords to sometimes
**                       be used as identifiers, for example.
**    YYACTIONTYPE       is the data type used for "action codes" - numbers
**                       that indicate what to do in response to the next
**                       token.
**    ParseTOKENTYPE     is the data type used for minor type for terminal
**                       symbols.  Background: A "minor type" is a semantic
**                       value associated with a terminal or non-terminal
**                       symbols.  For example, for an "ID" terminal symbol,
**                       the minor type might be the name of the identifier.
**                       Each non-terminal can have a different minor type.
**                       Terminal symbols all have the same minor type, though.
**                       This macros defines the minor type for terminal 
**                       symbols.
**    YYMINORTYPE        is the data type used for all minor types.
**                       This is typically a union of many types, one of
**                       which is ParseTOKENTYPE.  The entry in the union
**                       for terminal symbols is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    ParseARG_SDECL     A static variable declaration for the %extra_argument
**    ParseARG_PDECL     A parameter declaration for the %extra_argument
**    ParseARG_STORE     Code to store %extra_argument into yypParser
**    ParseARG_FETCH     Code to extract %extra_argument from yypParser
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YY_MAX_SHIFT       Maximum value for shift actions
**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
**    YY_MIN_REDUCE      Maximum value for reduce actions
**    YY_ERROR_ACTION    The yy_action[] code for syntax error
**    YY_ACCEPT_ACTION   The yy_action[] code for accept
**    YY_NO_ACTION       The yy_action[] code for no-op
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INTERFACE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INTERFACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/************* Begin control #defines *****************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************* End control #defines *******************************************/</comment>

<comment type="block">/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yytestcase</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>yytestcase</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 &lt;= N &lt;= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
**
**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
**     and YY_MAX_REDUCE

**   N == YY_ERROR_ACTION               A syntax error has occurred.
**
**   N == YY_ACCEPT_ACTION              The parser accepts its input.
**
**   N == YY_NO_ACTION                  No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as
**
**      yy_action[ yy_shift_ofst[S] + X ]
**
** If the index value yy_shift_ofst[S]+X is out of range or if the value
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
** and that yy_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
** YY_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
**
*********** Begin parsing tables **********************************************/</comment>
<operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/********** End of lemon-generated parsing tables *****************************/</comment>

<comment type="block">/* The next table maps tokens (terminal symbols) into fallback tokens.  
** If a construct like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
**
** This feature can be used, for example, to cause some keywords in a language
** to revert to identifiers if they keyword does not apply in the context where
** it appears.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
<specifier>static</specifier> <specifier>const</specifier> <name>YYCODETYPE</name> <name><name>yyFallback</name><index>[]</index></name> <operator>=</operator> <block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYFALLBACK */</comment>

<comment type="block">/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
**
** After the "shift" half of a SHIFTREDUCE action, the stateno field
** actually contains the reduce action for the second half of the
** SHIFTREDUCE.
*/</comment>
<struct>struct <name>yyStackEntry</name> <block>{
  <decl_stmt><decl><type><name>YYACTIONTYPE</name></type> <name>stateno</name></decl>;</decl_stmt>  <comment type="block">/* The state-number, or reduce action in SHIFTREDUCE */</comment>
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>major</name></decl>;</decl_stmt>      <comment type="block">/* The major token value.  This is the code
                         ** number for the token at this stack level */</comment>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>minor</name></decl>;</decl_stmt>     <comment type="block">/* The user-supplied minor token value.  This
                         ** is the value of the token  */</comment>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyStackEntry</name></name></type> <name>yyStackEntry</name>;</typedef>

<comment type="block">/* The state of the parser is completely contained in an instance of
** the following structure */</comment>
<struct>struct <name>yyParser</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>yyidx</name></decl>;</decl_stmt>                    <comment type="block">/* Index of top element in stack */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyidxMax</name></decl>;</decl_stmt>                 <comment type="block">/* Maximum value of yyidx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrcnt</name></decl>;</decl_stmt>                 <comment type="block">/* Shifts left before out of the error */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>ParseARG_SDECL</name>                <comment type="block">/* A place to hold %extra_argument */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <name>int</name></type> <name>yystksz</name></decl>;</decl_stmt>                  <comment type="block">/* Current side of the stack */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yystack</name></decl>;</decl_stmt>        <comment type="block">/* The parser's stack */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>yyStackEntry</name></type> <name><name>yystack</name><index>[<expr><name>YYSTACKDEPTH</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* The parser's stack */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>yyParser</name></name></type> <name>yyParser</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>yyTraceFILE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>yyTracePrompt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* 
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL 
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A FILE *to which trace output should be written.
**      If NULL, then tracing is turned off.
** &lt;li&gt; A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>ParseTrace</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>TraceFILE</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zTracePrompt</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <name>TraceFILE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <name>zTracePrompt</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTracePrompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>yyTracePrompt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyTraceFILE</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyTokenName</name><index>[]</index></name> <init>= <expr><block>{ 
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* For tracing reduce actions, the names of all rules are required.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yyRuleName</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
** Try to increase the size of the parser stack.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyGrowStack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>newSize</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>, <argument><expr><name>newSize</name> <operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pNew</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack grows to %d entries!\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>yystksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Datatype of the argument to the memory allocated passed as the
** second argument to ParseAlloc() below.  This can be changed by
** putting an appropriate #define in the %include section of the input
** grammar.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYMALLOCARGTYPE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYMALLOCARGTYPE</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to Parse and ParseFree.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>ParseAlloc</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mallocProc</name>)<parameter_list>(<parameter><decl><type><name>YYMALLOCARGTYPE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name> <operator>*</operator><operator>)</operator><call>(<modifier>*</modifier><name>mallocProc</name>)<argument_list>( <argument><expr><operator>(</operator><name>YYMALLOCARGTYPE</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyParser</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pParser</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidxMax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pParser</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The following function deletes the "minor type" or semantic value
** associated with a symbol.  The symbol can be either a terminal
** or nonterminal. "yymajor" is the symbol code, and "yypminor" is
** a pointer to the value to be deleted.  The code used to do the 
** deletions is derived from the %destructor and/or %token_destructor
** directives of the input grammar.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_destructor</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,    <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>yymajor</name></decl></parameter>,     <comment type="block">/* Type code for object to destroy */</comment>
  <parameter><decl><type><name>YYMINORTYPE</name> <modifier>*</modifier></type><name>yypminor</name></decl></parameter>   <comment type="block">/* The object to be destroyed */</comment>
)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
  <switch>switch<condition>(<expr><name>yymajor</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are *not *used
    ** inside the C code.
    */</comment>
<comment type="block" format="doxygen">/********* Begin destructor definitions ***************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
<comment type="block" format="doxygen">/********* End destructor definitions *****************************************/</comment>
    <default>default:</default>  <break>break;</break>   <comment type="block">/* If no destructor action specified: do nothing */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_parser_stack</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yytos</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>--</operator></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sPopping %s\n"</literal></expr></argument>,
      <argument><expr><name>yyTracePrompt</name></expr></argument>,
      <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>, <argument><expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>yytos</name><operator>-&gt;</operator><name>minor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Deallocate and destroy a parser.  Destructors are called for
** all stack elements before shutting the parser down.
**
** If the YYPARSEFREENEVERNULL macro exists (for example because it
** is defined in a %include section of the input grammar) then it is
** assumed that the input pointer is never NULL.
*/</comment>
<function><type><name>void</name></type> <name>ParseFree</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                    <comment type="block">/* The parser to be deleted */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>freeProc</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>     <comment type="block">/* Function used to reclaim memory */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYPARSEFREENEVERNULL</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>pParser</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>(<expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call>(<modifier>*</modifier><name>freeProc</name>)<argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the peak depth of the stack for a parser.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
<function><type><name>int</name></type> <name>ParseStackPeak</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name> <init>= <expr><operator>(</operator><name>yyParser</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidxMax</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>yy_find_shift_action</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>pParser</name></decl></parameter>,        <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>     <comment type="block">/* The look-ahead token */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stateno</name> <init>= <expr><name><name>pParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>pParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></init></decl>;</decl_stmt>
 
  <if_stmt><if>if <condition>(<expr><name>stateno</name><operator>&gt;=</operator><name>YY_MIN_REDUCE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>stateno</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>stateno</name> <operator>&lt;=</operator> <name>YY_SHIFT_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_shift_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>YY_SHIFT_USE_DFLT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>YY_ACTTAB_COUNT</name> <operator>||</operator> <name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>iLookAhead</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYFALLBACK</name></cpp:ifdef>
        <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>iFallback</name></decl>;</decl_stmt>            <comment type="block">/* Fallback token */</comment>
        <if_stmt><if>if <condition>(<expr><name>iLookAhead</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyFallback</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyFallback</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof>
               <operator>&amp;&amp;</operator> <operator>(</operator><name>iFallback</name> <operator>=</operator> <name><name>yyFallback</name><index>[<expr><name>iLookAhead</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
          <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sFALLBACK %s =&gt; %s\n"</literal></expr></argument>,
               <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iFallback</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yyFallback</name><index>[<expr><name>iFallback</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Fallback loop must terminate */</comment>
          <expr_stmt><expr><name>iLookAhead</name> <operator>=</operator> <name>iFallback</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYWILDCARD</name></cpp:ifdef>
        <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> <operator>-</operator> <name>iLookAhead</name> <operator>+</operator> <name>YYWILDCARD</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_SHIFT_MIN</name><operator>+</operator><name>YYWILDCARD</name><operator>&lt;</operator><literal type="number">0</literal></expr></cpp:if>
            <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_SHIFT_MAX</name><operator>+</operator><name>YYWILDCARD</name><operator>&gt;=</operator><name>YY_ACTTAB_COUNT</name></expr></cpp:if>
            <name>j</name><operator>&lt;</operator><name>YY_ACTTAB_COUNT</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <name><name>yy_lookahead</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>YYWILDCARD</name></expr>
          )</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
            <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sWILDCARD %s =&gt; %s\n"</literal></expr></argument>,
                 <argument><expr><name>yyTracePrompt</name></expr></argument>, <argument><expr><name><name>yyTokenName</name><index>[<expr><name>iLookAhead</name></expr>]</index></name></expr></argument>,
                 <argument><expr><name><name>yyTokenName</name><index>[<expr><name>YYWILDCARD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>
            <return>return <expr><name><name>yy_action</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYWILDCARD */</comment>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if> <else>else<block>{<block_content>
      <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_find_reduce_action</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>stateno</name></decl></parameter>,              <comment type="block">/* Current state number */</comment>
  <parameter><decl><type><name>YYCODETYPE</name></type> <name>iLookAhead</name></decl></parameter>     <comment type="block">/* The look-ahead token */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>stateno</name><operator>&gt;</operator><name>YY_REDUCE_COUNT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>stateno</name><operator>&lt;=</operator><name>YY_REDUCE_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>yy_reduce_ofst</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><name>YY_REDUCE_USE_DFLT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLookAhead</name><operator>!=</operator><name>YYNOCODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>iLookAhead</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <name>YY_ACTTAB_COUNT</name> <operator>||</operator> <name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>iLookAhead</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>yy_default</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>YY_ACTTAB_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>yy_lookahead</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>iLookAhead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name><name>yy_action</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following routine is called if the stack overflows.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyStackOverflow</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>)</parameter_list> <block>{<block_content>
   <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
   <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
   <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sStack Overflow!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <while>while<condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
   <comment type="block">/* Here code is inserted which will execute if the parser
   ** stack every overflows */</comment>
<comment type="block" format="doxygen">/******** Begin %stack_overflow code ******************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/******** End %stack_overflow code ********************************************/</comment>
   <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument var */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Print tracing information for a SHIFT action
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yyTraceShift</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yyNewState</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>yyNewState</name><operator>&lt;</operator><name>YYNSTATE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sShift '%s', go to state %d\n"</literal></expr></argument>,
         <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>major</name></expr>]</index></name></expr></argument>,
         <argument><expr><name>yyNewState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sShift '%s'\n"</literal></expr></argument>,
         <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>major</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>yyTraceShift</name><parameter_list>(<parameter><type><name>X</name></type></parameter>,<parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Perform a shift action.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_shift</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,          <comment type="block">/* The parser to be shifted */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyNewState</name></decl></parameter>,               <comment type="block">/* The new state to shift in */</comment>
  <parameter><decl><type><name>int</name></type> <name>yyMajor</name></decl></parameter>,                  <comment type="block">/* The major token to shift in */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name></type> <name>yyMinor</name></decl></parameter>        <comment type="block">/* The minor token to shift in */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yytos</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> 
  <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name>YYSTACKDEPTH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>yytos</name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <operator>(</operator><name>YYACTIONTYPE</name><operator>)</operator><name>yyNewState</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yyMajor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yytos</name><operator>-&gt;</operator><name>minor</name><operator>.</operator><name>yy0</name></name> <operator>=</operator> <name>yyMinor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>yyTraceShift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yyNewState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The following table contains information about every rule that
** is used during the reduce.
*/</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
  <decl_stmt><decl><type><name>YYCODETYPE</name></type> <name>lhs</name></decl>;</decl_stmt>         <comment type="block">/* Symbol on the left-hand side of the rule */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>nrhs</name></decl>;</decl_stmt>     <comment type="block">/* Number of right-hand side symbols in the rule */</comment>
}</block> <decl><name><name>yyRuleInfo</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>%</operator><operator>%</operator></expr>
}</block></expr></init></decl>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(<parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Forward Declaration */</comment>

<comment type="block">/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_reduce</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,         <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>yyruleno</name></decl></parameter>        <comment type="block">/* Number of the rule by which to reduce */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>yygoto</name></decl>;</decl_stmt>                     <comment type="block">/* The next state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yyact</name></decl>;</decl_stmt>                      <comment type="block">/* The next action */</comment>
  <decl_stmt><decl><type><name>yyStackEntry</name> <modifier>*</modifier></type><name>yymsp</name></decl>;</decl_stmt>            <comment type="block">/* The top of the parser's stack */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yysize</name></decl>;</decl_stmt>                     <comment type="block">/* Amount to pop the stack */</comment>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yymsp</name> <operator>=</operator> <operator>&amp;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name> <operator>&amp;&amp;</operator> <name>yyruleno</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleName</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>nrhs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>, <argument><expr><literal type="string">"%sReduce [%s], go to state %d.\n"</literal></expr></argument>, <argument><expr><name>yyTracePrompt</name></expr></argument>,
      <argument><expr><name><name>yyRuleName</name><index>[<expr><name>yyruleno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>yymsp</name><index>[<expr><operator>-</operator><name>yysize</name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

  <comment type="block">/* Check that the stack is large enough to grow by a single entry
  ** if the RHS of the rule is empty.  This ensures that there is room
  ** enough on the stack to push the LHS value */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>nrhs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYTRACKMAXSTACKDEPTH</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidxMax</name></name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if> 
    <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name>YYSTACKDEPTH</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>yyGrowStack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <switch>switch<condition>(<expr><name>yyruleno</name></expr>)</condition> <block>{<block_content>
  <comment type="block">/* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line &lt;lineno&gt; &lt;grammarfile&gt;
  **     { ... }           // User supplied code
  **  #line &lt;lineno&gt; &lt;thisfile&gt;
  **     break;
  */</comment>
<comment type="block" format="doxygen">/********** Begin reduce actions **********************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator></expr></expr_stmt>
<comment type="block" format="doxygen">/********** End reduce actions ************************************************/</comment>
  </block_content>}</block></switch><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyruleno</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>yyRuleInfo</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>yyRuleInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yygoto</name> <operator>=</operator> <name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>lhs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name><name>yyRuleInfo</name><index>[<expr><name>yyruleno</name></expr>]</index></name><operator>.</operator><name>nrhs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(<argument><expr><name><name>yymsp</name><index>[<expr><operator>-</operator><name>yysize</name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>yyact</name> <operator>&lt;=</operator> <name>YY_MAX_SHIFTREDUCE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>yyact</name><operator>&gt;</operator><name>YY_MAX_SHIFT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyact</name> <operator>+=</operator> <name>YY_MIN_REDUCE</name> <operator>-</operator> <name>YY_MIN_SHIFTREDUCE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>-=</operator> <name>yysize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>yymsp</name> <operator>-=</operator> <name>yysize</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>stateno</name></name> <operator>=</operator> <operator>(</operator><name>YYACTIONTYPE</name><operator>)</operator><name>yyact</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yymsp</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yygoto</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yyTraceShift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><name>yyact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name> <operator>==</operator> <name>YY_ACCEPT_ACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>-=</operator> <name>yysize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yy_accept</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following code executes when the parse fails
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_parse_failed</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sFail!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser fails */</comment>
<comment type="block" format="doxygen">/************ Begin %parse_failure code ***************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************ End %parse_failure code *****************************************/</comment>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYNOERRORRECOVERY */</comment>

<comment type="block">/*
** The following code executes when a syntax error first occurs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_syntax_error</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>,           <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                   <comment type="block">/* The major type of the error token */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name></type> <name>yyminor</name></decl></parameter>         <comment type="block">/* The minor type of the error token */</comment>
)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN</name></cpp:macro> <cpp:value>yyminor</cpp:value></cpp:define>
<comment type="block" format="doxygen">/************ Begin %syntax_error code ****************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/************ End %syntax_error code ******************************************/</comment>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>

<comment type="block">/*
** The following is executed when the parser accepts
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_accept</name><parameter_list>(
  <parameter><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl></parameter>           <comment type="block">/* The parser */</comment>
)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>ParseARG_FETCH</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sAccept!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while<condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <comment type="block">/* Here code is inserted which will be executed whenever the
  ** parser accepts */</comment>
<comment type="block" format="doxygen">/*********** Begin %parse_accept code *****************************************/</comment>
<expr_stmt><expr><operator>%</operator><operator>%</operator>
<comment type="block" format="doxygen">/*********** End %parse_accept code *******************************************/</comment>
  <name>ParseARG_STORE</name></expr>;</expr_stmt> <comment type="block">/* Suppress warning about unused %extra_argument variable */</comment>
</block_content>}</block></function>

<comment type="block">/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "ParseAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** &lt;ul&gt;
** &lt;li&gt; A pointer to the parser (an opaque structure.)
** &lt;li&gt; The major token number.
** &lt;li&gt; The minor token number.
** &lt;li&gt; An option argument of a grammar-specified type.
** &lt;/ul&gt;
**
** Outputs:
** None.
*/</comment>
<function><type><name>void</name></type> <name>Parse</name><parameter_list>(
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>yyp</name></decl></parameter>,                   <comment type="block">/* The parser */</comment>
  <parameter><decl><type><name>int</name></type> <name>yymajor</name></decl></parameter>,                 <comment type="block">/* The major token code number */</comment>
  <parameter><decl><type><name>ParseTOKENTYPE</name> <name>yyminor</name></type>       <comment type="block">/* The value for the token */</comment>
  <name>ParseARG_PDECL</name></decl></parameter>               <comment type="block">/* Optional %extra_argument parameter */</comment>
)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>YYMINORTYPE</name></type> <name>yyminorunion</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>yyact</name></decl>;</decl_stmt>   <comment type="block">/* The parser action. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>yyendofinput</name></decl>;</decl_stmt>     <comment type="block">/* True if we are at the end of input */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>yyerrorhit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* True if yymajor has invoked an error */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>yyParser</name> <modifier>*</modifier></type><name>yypParser</name></decl>;</decl_stmt>  <comment type="block">/* The parser */</comment>

  <comment type="block">/* (re)initialize the parser, if necessary */</comment>
  <expr_stmt><expr><name>yypParser</name> <operator>=</operator> <operator>(</operator><name>yyParser</name> <operator>*</operator><operator>)</operator><name>yyp</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYSTACKDEPTH</name><operator>&lt;=</operator><literal type="number">0</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystksz</name></name> <operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>yyStackOverflow</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>stateno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>major</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sInitialize. Empty stack. State 0\n"</literal></expr></argument>,
              <argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>yyendofinput</name> <operator>=</operator> <operator>(</operator><name>yymajor</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>ParseARG_STORE</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sInput '%s'\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>yyact</name> <operator>=</operator> <call><name>yy_find_shift_action</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>yyact</name> <operator>&lt;=</operator> <name>YY_MAX_SHIFTREDUCE</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>yyact</name> <operator>&gt;</operator> <name>YY_MAX_SHIFT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yyact</name> <operator>+=</operator> <name>YY_MIN_REDUCE</name> <operator>-</operator> <name>YY_MIN_SHIFTREDUCE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYNOERRORRECOVERY</name></cpp:ifndef>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>yyact</name> <operator>&lt;=</operator> <name>YY_MAX_REDUCE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>yy_reduce</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name><operator>-</operator><name>YY_MIN_REDUCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>yyact</name> <operator>==</operator> <name>YY_ERROR_ACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yyminorunion</name><operator>.</operator><name>yy0</name></name> <operator>=</operator> <name>yyminor</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <decl_stmt><decl><type><name>int</name></type> <name>yymx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sSyntax Error!\n"</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERRORSYMBOL</name></cpp:ifdef>
      <comment type="block">/* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yymx</name> <operator>=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>major</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>yymx</name> <operator>==</operator> <name>YYERRORSYMBOL</name> <operator>||</operator> <name>yyerrorhit</name></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sDiscard input token %s\n"</literal></expr></argument>,
             <argument><expr><name>yyTracePrompt</name></expr></argument>,<argument><expr><name><name>yyTokenName</name><index>[<expr><name>yymajor</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>, <argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else<block>{<block_content>
        <while>while<condition>(
          <expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name>yymx</name> <operator>!=</operator> <name>YYERRORSYMBOL</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>yyact</name> <operator>=</operator> <call><name>yy_find_reduce_action</name><argument_list>(
                        <argument><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>]</index></name><operator>.</operator><name>stateno</name></expr></argument>,
                        <argument><expr><name>YYERRORSYMBOL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <name>YY_MIN_REDUCE</name></expr>
        )</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>yy_pop_parser_stack</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>yymajor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>yymx</name><operator>!=</operator><name>YYERRORSYMBOL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>yy_shift</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yyact</name></expr></argument>,<argument><expr><name>YYERRORSYMBOL</name></expr></argument>,<argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>yyerrorhit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYNOERRORRECOVERY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <comment type="block">/* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */</comment>
      <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>, <argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
      
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* YYERRORSYMBOL is not defined */</comment>
      <comment type="block">/* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yy_syntax_error</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><name>yymajor</name></expr></argument>, <argument><expr><name>yyminor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>yypParser</name><operator>-&gt;</operator><name>yyerrcnt</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_destructor</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>,<argument><expr><operator>(</operator><name>YYCODETYPE</name><operator>)</operator><name>yymajor</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>yyminorunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>yyendofinput</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>yy_parse_failed</name><argument_list>(<argument><expr><name>yypParser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>yymajor</name> <operator>=</operator> <name>YYNOCODE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>while<condition>(<expr><name>yymajor</name><operator>!=</operator><name>YYNOCODE</name> <operator>&amp;&amp;</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition>;</do>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyTraceFILE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%sReturn. Stack="</literal></expr></argument>,<argument><expr><name>yyTracePrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>yypParser</name><operator>-&gt;</operator><name>yyidx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"%c%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="char">'['</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>, 
              <argument><expr><name><name>yyTokenName</name><index>[<expr><name><name>yypParser</name><operator>-&gt;</operator><name>yystack</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>major</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>yyTraceFILE</name></expr></argument>,<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return;</return>
</block_content>}</block></function>
</unit>
