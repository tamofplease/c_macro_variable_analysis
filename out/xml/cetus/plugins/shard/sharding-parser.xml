<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/cetus/plugins/shard/sharding-parser.c"><comment type="block">/* $%BEGINLICENSE%$
 Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; version 2 of the
 License.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 02110-1301  USA

 $%ENDLICENSE%$ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sharding-parser.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"glib-ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sql-expression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sql-construction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sql-property.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sharding-config.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>is_compare_op</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>op</name> <operator>==</operator> <name>TK_EQ</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_NE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_LT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_LE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_GT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_GE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>is_logical_op</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>op</name> <operator>==</operator> <name>TK_AND</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_OR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_NOT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>is_arithmetic_op</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>op</name> <operator>==</operator> <name>TK_PLUS</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_MINUS</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_STAR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_SLASH</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>TK_REM</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>expr_is_sharding_key</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sql_src_item_t</name> <modifier>*</modifier></type><name>tb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name></expr>)</condition> <block>{<block_content>      <comment type="block">/* table.colmun or db.table.col */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* db.table.col */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>dbname</name></name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
                <operator>&amp;&amp;</operator> <call><name>sql_expr_is_dotted_name</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>token_text</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>table_alias</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>table_alias</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_ID</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>expr_is_compound_value</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_FUNCTION</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_SELECT</name> <operator>||</operator>    <comment type="block">/* subquery */</comment>
        <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_ID</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name> <operator>||</operator>    <comment type="block">/* col, tbl.col */</comment>
        <call><name>is_arithmetic_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</return>    <comment type="block">/* 1+1, 3%2, 4 * 5, etc */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>supplemental_hash</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp1</name> <init>= <expr><name>value</name> <operator>&gt;&gt;</operator> <literal type="number">20</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp2</name> <init>= <expr><name>value</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp3</name> <init>= <expr><name>tmp1</name> <operator>^</operator> <name>tmp2</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><name>value</name> <operator>^</operator> <name>tmp3</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name>tmp1</name> <operator>^</operator> <name>tmp2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name> <operator>^</operator> <name>tmp3</name></expr>;</expr_stmt>
    <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>cetus_str_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hashcode_head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>hashcode_head</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashcode_head</name> <operator>+=</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hashcode_tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name>hashcode_tail</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashcode_tail</name> <operator>+=</operator> <name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name>supplemental_hash</name><argument_list>(<argument><expr><name>hashcode_head</name> <operator>^</operator> <name>hashcode_tail</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>supplemental_hash</name><argument_list>(<argument><expr><name>hashcode_head</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_for_sql_modify_limit</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>guint64</name> <modifier>*</modifier></type><name>orig_limit</name></decl></parameter>, <parameter><decl><type><name>guint64</name> <modifier>*</modifier></type><name>orig_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>offset</name></name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>offset</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_INTEGER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>orig_offset</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>offset</name><operator>-&gt;</operator><name>num_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>offset</name><operator>-&gt;</operator><name>num_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_INTEGER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>orig_limit</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>num_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>num_value</name></name> <operator>+=</operator> <operator>*</operator><name>orig_offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_for_sql_modify_orderby</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_column_list_t</name> <modifier>*</modifier></type><name>orderby</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>orderby</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>columns</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>mcol</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>mcol</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_ORDER_BY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>mcol</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>TK_FUNCTION</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sql_column_t</name> <modifier>*</modifier></type><name>ordcol</name> <init>= <expr><call><name>sql_column_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>ordcol</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>sql_expr_dup</name><argument_list>(<argument><expr><name>mcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>ordcol</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>alias</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>ordcol</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>TK_ID</name></expr>;</expr_stmt>
                    <comment type="block">/* borrow text from alias */</comment>
                    <expr_stmt><expr><name><name>ordcol</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>token_text</name></name> <operator>=</operator> <name><name>ordcol</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>orderby</name> <operator>=</operator> <call><name>sql_column_list_append</name><argument_list>(<argument><expr><name>orderby</name></expr></argument>, <argument><expr><name>ordcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name> <operator>=</operator> <name>orderby</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GString</name> <modifier>*</modifier></type>
<name>modify_select</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>having_condition_t</name> <modifier>*</modifier></type><name>hav_condi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_groupby_need_reconstruct</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>having</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>having</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_compare_op</name><argument_list>(<argument><expr><name><name>having</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_expr_t</name><modifier>*</modifier></type> <name>hav_name</name> <init>= <expr><name><name>having</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>column_index</name></name> <operator>=</operator>
                <call><name>sql_expr_list_find_exact_aggregate</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>,
                        <argument><expr><name><name>hav_name</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,
                        <argument><expr><name><name>hav_name</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>hav_name</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>rel_type</name></name> <operator>=</operator> <name><name>having</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>having</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>hav_condi</name><operator>-&gt;</operator><name>condition_value</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>condition_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>condition_value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val_str</name> <init>= <expr><call><name>g_strndup</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>val</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sql_string_dequote</name><argument_list>(<argument><expr><name>val_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>condition_value</name></name> <operator>=</operator> <name>val_str</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_UMINUS</name> <operator>||</operator> <name><name>val</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_UPLUS</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <name>TK_INTEGER</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>hav_condi</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>   <comment type="block">/* temporarily remove HAVING */</comment>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>gboolean</name></type> <name>need_reconstruct</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>guint64</name></type> <name>orig_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>guint64</name></type> <name>orig_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* (LIMIT a, b) ==&gt; (LIMIT 0, a+b) */</comment>
    <if_stmt><if>if <condition>(<expr><name>groups</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>offset</name></name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>offset</name><operator>-&gt;</operator><name>num_value</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>prepare_for_sql_modify_limit</name><argument_list>(<argument><expr><name>select</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_limit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_reconstruct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_groupby_need_reconstruct</name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SF_REWRITE_ORDERBY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SF_REWRITE_ORDERBY</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>prepare_for_sql_modify_orderby</name><argument_list>(<argument><expr><name>select</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>^</operator> <name>SF_REWRITE_ORDERBY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_reconstruct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>new_sql</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>having</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>need_reconstruct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>need_reconstruct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>need_reconstruct</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>new_sql</name> <operator>=</operator> <call><name>sql_construct_select</name><argument_list>(<argument><expr><name>select</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>explain</name></name> <operator>==</operator> <name>TK_EXPLAIN</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_string_append_c</name><argument_list>(<argument><expr><name>new_sql</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>orig_offset</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>orig_limit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>num_value</name></name> <operator>=</operator> <name>orig_limit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>offset</name><operator>-&gt;</operator><name>num_value</name></name> <operator>=</operator> <name>orig_offset</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>new_sql</name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>sub_select</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>union_sql</name> <init>= <expr><call><name>g_string_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>sub_select</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>sql_construct_select</name><argument_list>(<argument><expr><name>sub_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name>union_sql</name></expr></argument>, <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name>union_sql</name></expr></argument>, <argument><expr><literal type="string">" UNION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_string_free</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sub_select</name> <operator>=</operator> <name><name>sub_select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name>union_sql</name></expr></argument>, <argument><expr><name><name>new_sql</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_string_free</name><argument_list>(<argument><expr><name>new_sql</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new_sql</name> <operator>=</operator> <name>union_sql</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name></name> <operator>=</operator> <name>having</name></expr>;</expr_stmt> <comment type="block">/* get HAVING back */</comment>

    <return>return <expr><name>new_sql</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GString</name> <modifier>*</modifier></type>
<name>sharding_modify_sql</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>having_condition_t</name> <modifier>*</modifier></type><name>hav_condi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_groupby_need_reconstruct</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partition_mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_mode</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>stmt_type</name></name> <operator>==</operator> <name>STMT_SELECT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name>modify_select</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>hav_condi</name></expr></argument>, <argument><expr><name>is_groupby_need_reconstruct</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>stmt_type</name></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>STMT_SELECT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition> <block>{<block_content>
                    <return>return <expr><call><name>modify_select</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>hav_condi</name></expr></argument>, <argument><expr><name>is_groupby_need_reconstruct</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>STMT_UPDATE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition> <block>{<block_content>
                    <return>return <expr><call><name>sql_construct_update</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>STMT_DELETE</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition> <block>{<block_content>
                    <return>return <expr><call><name>sql_construct_delete</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><name>STMT_INSERT</name></expr>:</case> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>g_string_sized_new</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>sql_construct_insert</name><argument_list>(<argument><expr><name>partition_mode</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>s</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>sql_select_contains_sharding_table</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>current_db</name></decl></parameter> <comment type="block">/* in_out */</comment> , <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>table</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>*</operator><name>current_db</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sources</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>current_db</name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>table</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr>;</expr_stmt>
                    <return>return <expr><name>TRUE</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>select</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>condition_t</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <union>union <block>{
        <decl_stmt><decl><type><name>gint64</name></type> <name>num</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
    }</block> <decl><name>v</name></decl>;</union>
}</block>;</struct>

<comment type="block" format="doxygen">/**
 * ! we don't handle negative `b`
 */</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>modulo</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>r</name> <init>= <expr><name>a</name> <operator>%</operator> <name>b</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>r</name> <operator>+</operator> <name>b</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * check if the group satisfies an inequation
 *   suppose condition is "Greater Than 42", (op = TK_GT, v.num = 42)
 *   if exists X -&gt; (low, high] that satifies X &gt; 42, return true
 *   if it doesn't exist such an X, return false;
 */</comment>
<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>partition_satisfies</name><parameter_list>(<parameter><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>partition</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* partition value -&gt; (low, high] */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>method</name></name> <operator>==</operator> <name>SHARD_METHOD_HASH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>hash_value</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>partition</name><operator>-&gt;</operator><name>key_type</name></name> <operator>==</operator> <name>SHARD_DATA_TYPE_STR</name><operator>)</operator></expr>
            ?</condition><then> <expr><call><name>cetus_str_hash</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>cond</name><operator>.</operator><name>v</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>cond</name><operator>.</operator><name>v</name><operator>.</operator><name>num</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type> <name>hash_mod</name> <init>= <expr><call><name>modulo</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name><name>partition</name><operator>-&gt;</operator><name>hash_count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cond</name><operator>.</operator><name>op</name></name> <operator>==</operator> <name>TK_EQ</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name>sharding_partition_contain_hash</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>hash_mod</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><name>TRUE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* vvv SHARD_METHOD_RANGE vvv */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>key_type</name></name> <operator>==</operator> <name>SHARD_DATA_TYPE_STR</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>low</name> <init>= <expr><name><name>partition</name><operator>-&gt;</operator><name>low_value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>high</name> <init>= <expr><name><name>partition</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>    <comment type="line">// high is NULL means unlimited</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>cond</name><operator>.</operator><name>v</name><operator>.</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>cond</name><operator>.</operator><name>op</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TK_EQ</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>low</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>low</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>high</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
        <case>case <expr><name>TK_GT</name></expr>:</case>
            <return>return <expr><name>high</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>TK_LT</name></expr>:</case>
            <return>return <expr><name>low</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>low</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>TK_GE</name></expr>:</case>
            <return>return <expr><name>high</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>TK_LE</name></expr>:</case>
            <return>return <expr><name>low</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>low</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>TK_NE</name></expr>:</case>
            <return>return <expr><name>TRUE</name></expr>;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":error condition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if> <else>else <block>{<block_content>                    <comment type="block">/* int and datetime */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>low</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>partition</name><operator>-&gt;</operator><name>low_value</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>high</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>partition</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* high range OR hash value */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>val</name> <init>= <expr><name><name>cond</name><operator>.</operator><name>v</name><operator>.</operator><name>num</name></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>cond</name><operator>.</operator><name>op</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TK_EQ</name></expr>:</case>
            <return>return <expr><name>val</name> <operator>&gt;</operator> <name>low</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>&lt;=</operator> <name>high</name></expr>;</return>
        <case>case <expr><name>TK_GT</name></expr>:</case>
            <return>return <expr><name>val</name> <operator>&lt;</operator> <name>high</name></expr>;</return>
        <case>case <expr><name>TK_LT</name></expr>:</case>
            <return>return <expr><name>val</name> <operator>&gt;</operator> <name>low</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
        <case>case <expr><name>TK_GE</name></expr>:</case>
            <return>return <expr><name>val</name> <operator>&lt;=</operator> <name>high</name></expr>;</return>
        <case>case <expr><name>TK_LE</name></expr>:</case>
            <return>return <expr><name>val</name> <operator>&gt;</operator> <name>low</name></expr>;</return>
        <case>case <expr><name>TK_NE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>high</name> <operator>&amp;&amp;</operator> <name>high</name> <operator>==</operator> <operator>(</operator><name>low</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>FALSE</name></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        <default>default:</default>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":error condition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":error reach here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* filter out those which not satisfy cond */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>partitions_filter</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partitions</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>partition_satisfies</name><argument_list>(<argument><expr><name>gp</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_remove_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* collect those which satisfy cond */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>partitions_collect</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>from_partitions</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>to_partitions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>from_partitions</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>from_partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>partition_satisfies</name><argument_list>(<argument><expr><name>gp</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>to_partitions</name></expr></argument>, <argument><expr><name>gp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* get first group that satisfies cond */</comment>
<function><type><name>sharding_partition_t</name> <modifier>*</modifier></type>
<name>partitions_get</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>from_partitions</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>from_partitions</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>from_partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>partition_satisfies</name><argument_list>(<argument><expr><name>gp</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>gp</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>partitions_merge</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>other</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>gp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* duplication check is performed later */</comment>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GPtrArray</name> <modifier>*</modifier></type>
<name>partitions_dup</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>dup</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partitions</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>gp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * parse cond.v from a string
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>string_to_sharding_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expected</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>expected</name> <operator>==</operator> <name>SHARD_DATA_TYPE_STR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>expected</name> <operator>==</operator> <name>SHARD_DATA_TYPE_DATE</name> <operator>||</operator> <name>expected</name> <operator>==</operator> <name>SHARD_DATA_TYPE_DATETIME</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>gboolean</name></type> <name>ok</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>chassis_epoch_from_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":error datetime format: %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PARSE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>expected</name> <operator>==</operator> <name>SHARD_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>num</name></name> <operator>=</operator> <call><name>g_ascii_strtoll</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":too large for int: %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PARSE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>endptr</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":cannot get INT from string token: %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PARSE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unexpected key string: %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PARSE_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>PARSE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * parse cond.v from sql expression
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>expr_parse_sharding_value</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expected</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>condition_t</name></name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>gint64</name></type> <name>intval</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sql_expr_get_int</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intval</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>expected</name> <operator>==</operator> <name>SHARD_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>intval</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_STRING</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>string_to_sharding_value</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>expr_is_compound_value</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":compound value, use all shard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PARSE_UNRECOGNIZED</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unexpected token type: %d, %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PARSE_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>PARSE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>partitions_filter_inequation_expr</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>partitions</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>gp</name> <operator>=</operator> <call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PARSE_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>partitions_filter</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PARSE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>partitions_filter_BETWEEN_expr</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>partitions</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>gp</name> <operator>=</operator> <call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PARSE_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>btlist</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>list</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>btlist</name> <operator>&amp;&amp;</operator> <name><name>btlist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>low</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>btlist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>high</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>btlist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_GE</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name>low</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>partitions_filter</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_LE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name>high</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>partitions_filter</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>PARSE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>partitions_collect_IN_expr</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sharding_partition_t</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>partitions</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>part</name> <operator>=</operator> <call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PARSE_OK</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>list</name></name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>list</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>collected</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>list</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>args</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>cond</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>TK_EQ</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>collected</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>rc</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>partitions_collect</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>collected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* transfer collected to partitions as output */</comment>
        <expr_stmt><expr><call><name>g_ptr_array_remove_range</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>partitions</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>collected</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>gpointer</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>collected</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>grp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>collected</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PARSE_OK</name></expr>;</return>

    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>PARSE_UNRECOGNIZED</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>partitions_filter_expr</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>partitions</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>PARSE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GQueue</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>g_queue_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>PARSE_OK</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* for each condition in where clause */</comment>
    <while>while <condition>(<expr><operator>!</operator><call><name>g_queue_is_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* TODO: NOT op is not supported */</comment>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>g_queue_pop_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_OR</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>new_partitions</name> <init>= <expr><call><name>partitions_dup</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_filter_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>new_partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_filter_expr</name><argument_list>(<argument><expr><name>new_partitions</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>new_partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>partitions_merge</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>new_partitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>new_partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_AND</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_SHARD_COND</name></expr>)</condition> <block>{<block_content> <comment type="block">/* HACK: SHARD_COND under TK_NOT is skipped */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>is_compare_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_JOIN_LINK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_filter_inequation_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_BETWEEN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_filter_BETWEEN_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_IN</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_collect_IN_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>g_queue_free</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>flip_compare_op</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>                               <comment type="block">/* flip horizontally */</comment>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_LE</name></expr>:</case>
        <return>return <expr><name>TK_GE</name></expr>;</return>
    <case>case <expr><name>TK_GE</name></expr>:</case>
        <return>return <expr><name>TK_LE</name></expr>;</return>
    <case>case <expr><name>TK_LT</name></expr>:</case>
        <return>return <expr><name>TK_GT</name></expr>;</return>
    <case>case <expr><name>TK_GT</name></expr>:</case>
        <return>return <expr><name>TK_LT</name></expr>;</return>
    <default>default:</default>
        <return>return <expr><name>op</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 *  1.mark conditions that contains sharding key
 *  2.switch const field to right side ( 3&lt;x --&gt; x&gt;3)
 *  //3.check if we can handle the value of sharding key
 * @param src the sharding table
 * @param field the sharding column name
 * @return number of occurance of sharding key
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>optimize_sharding_condition</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>where</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>GQueue</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>g_queue_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>gboolean</name></type> <name>key_occur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name>g_queue_is_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* TODO: NOT op is not supported */</comment>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>g_queue_pop_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_logical_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_compare_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_JOIN_LINK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* the key might be on either side, unify as field = CONST */</comment>
            <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rhs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_ID</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>lhs</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rhs</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_ID</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>lhs</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rhs</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":both sides aren't ID, neglect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>lhs</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>lhs</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>rhs</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <call><name>flip_compare_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_SHARD_COND</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>key_occur</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_BETWEEN</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_SHARD_COND</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>key_occur</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_IN</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_SHARD_COND</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>key_occur</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>g_queue_free</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>key_occur</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>partitions_get_group_names</name><parameter_list>(<parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partitions</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * find out which 2 tables are connected by expression 'p', then
 * 1. record it in linkage array
 * 2. mark the expression 'p' as EP_JOIN_LINK;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_linkage</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GPtrArray</name> <modifier>*</modifier></type><name>tables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GPtrArray</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>gint8</name> <modifier>*</modifier></type> <name>linkage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><name><name>tables</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key1</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>tables</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key2</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_JOIN_LINK</name></expr>;</expr_stmt>
                <comment type="block">/* only record linkage from lower index to higher index */</comment>
                <expr_stmt><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>j</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>linkage</name><index>[<expr><name>i</name> <operator>*</operator> <name>N</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name><name>linkage</name><index>[<expr><name>j</name> <operator>*</operator> <name>N</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * 1.check if all the tables belong to same VDB
 * 2.check if there exists tableA.key = tableB.key,
 * 3.and mark that equation with EP_JOIN_LINK
 */</comment>
<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>join_on_sharding_key</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>sharding_tables</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>first_vdb_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>sharding_keys</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>   <comment type="block">/* array&lt;const char *&gt; */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>tinfo</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tinfo</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_keys</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">"%s.%s is not sharding table"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>first_vdb_id</name> <operator>=</operator> <name><name>tinfo</name><operator>-&gt;</operator><name>vdb_id</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>tinfo</name><operator>-&gt;</operator><name>vdb_id</name></name> <operator>!=</operator> <name>first_vdb_id</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_keys</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>sharding_keys</name></expr></argument>, <argument><expr><name><name>tinfo</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* 2-d array of table linkage */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gint8</name> <modifier>*</modifier></type><name>linkage</name> <init>= <expr><call><name>g_new0</name><argument_list>(<argument><expr><name>gint8</name></expr></argument>, <argument><expr><name>N</name> <operator>*</operator> <name>N</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* for each equation in WHERE clause */</comment>
    <decl_stmt><decl><type><name>GQueue</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>g_queue_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>where</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* for each equation in ON clause */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>on_clause</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>on_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <while>while <condition>(<expr><operator>!</operator><call><name>g_queue_is_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* TODO: NOT op is not supported */</comment>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>g_queue_pop_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_logical_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_EQ</name> <operator>&amp;&amp;</operator> <call><name>sql_expr_is_field_name</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call>
            <operator>&amp;&amp;</operator> <call><name>sql_expr_is_field_name</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>find_linkage</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>sharding_keys</name></expr></argument>, <argument><expr><name>linkage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>g_queue_free</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>num_linkage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name> <operator>*</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>num_linkage</name> <operator>+=</operator> <name><name>linkage</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>linkage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_keys</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>num_linkage</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sql_expr_find_subqueries</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>GList</name> <modifier>*</modifier><modifier>*</modifier></type><name>queries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>where</name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>GQueue</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>g_queue_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name>g_queue_is_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* TODO: NOT op is not supported */</comment>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>g_queue_pop_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_logical_op</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_IN</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_EXISTS</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>select</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>queries</name> <operator>=</operator> <call><name>g_list_append</name><argument_list>(<argument><expr><operator>*</operator><name>queries</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>select</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>g_queue_free</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_select_get_single_tables</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>current_db</name></decl></parameter>, <parameter><decl><type><name>GList</name> <modifier>*</modifier><modifier>*</modifier></type><name>single_tables</name></decl></parameter> <comment type="block">/*out */</comment> )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>current_db</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sources</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>single_tables</name> <operator>=</operator> <call><name>g_list_append</name><argument_list>(<argument><expr><operator>*</operator><name>single_tables</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>select</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dup_groups</name><parameter_list>(<parameter><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>table</name></expr></init></decl>;</decl_stmt>
   <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
       <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr>)</condition> <block>{<block_content>
           <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
           <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> 
           <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sources</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
               <expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           </block_content>}</block></for>
           <return>return;</return>
       </block_content>}</block></if> <else>else <block>{<block_content>
           <return>return;</return>
       </block_content>}</block></else></if_stmt>
   </block_content>}</block></if></if_stmt>

   <expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>groups</name></name> <operator>=</operator> <call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>groups</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>groups</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>sql_select_check_and_set_shard_table</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>current_db</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>current_db</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> 
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sources</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>where</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>where</name><operator>-&gt;</operator><name>modify_flag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>select</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>sql_select_has_single_table</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>current_db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>current_db</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sources</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>select</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dup_groups_for_partition</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name></decl></parameter>, <parameter><decl><type><name>GList</name> <modifier>*</modifier></type><name>subqueries</name></decl></parameter>,
        <parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type> <name>prior</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sources</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>groups</name></name>  <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>src</name><operator>-&gt;</operator><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>subqueries</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>sql_select_check_and_set_shard_table</name><argument_list>(<argument><expr><name>where</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>prior</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sql_select_check_and_set_shard_table</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prior</name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>routing_select</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>guint32</name></type> <name>fixture</name></decl></parameter>, <parameter><decl><type><name>query_stats_t</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter> <comment type="block">/* out */</comment>, <parameter><decl><type><name>int</name></type> <name>partition_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>sources</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sources</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name>partition_mode</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>subqueries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sql_expr_find_subqueries</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>sharding_tables</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>single_tables</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sources</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>default_db</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name> <operator>&amp;&amp;</operator> <call><name>sql_select_contains_sharding_table</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sharding_filter_sql</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* sharding table inside sub-query, should be filterd */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>rc</name></name> <operator>==</operator> <name>PARSE_NOT_SUPPORT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dup_groups_for_partition</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>sources</name></expr></argument>, <argument><expr><name>subqueries</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_ALL_SHARDINGS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_mode</name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr>)</condition> <block>{<block_content>      <comment type="block">/* subquery not contain sharding table, try to find single table */</comment>
            <expr_stmt><expr><call><name>sql_select_get_single_tables</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>single_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>db</name> <operator>=</operator> <ternary><condition><expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_add</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>partition_mode</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>single_tables</name> <operator>=</operator> <call><name>g_list_append</name><argument_list>(<argument><expr><name>single_tables</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* handle single table */</comment>
    <if_stmt><if>if <condition>(<expr><name>single_tables</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>single_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(cetus) JOIN single-table WITH sharding-table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>single_tables</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>shard_conf_get_single_table_distinct_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>single_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(cetus)JOIN multiple single-tables not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>single_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* handle subquery in where clause */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_mode</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>subqueries</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>sql_select_has_single_table</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(cetus) Found single-table in subquery, not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name>partition_mode</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_on_sharding_key</name><argument_list>(<argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)JOIN must inside VDB and have explicit join-on condition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>gboolean</name></type> <name>has_sharding_key</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>shard_table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>shard_info</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>shard_table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* join tables have same sharding key, we are graunteed tableA.key = tableB.key
           so tableA.key = x also applies to tableB */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>optimize_sharding_condition</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>shard_table</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>has_sharding_key</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>has_sharding_key</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* GPtrArray&lt;sharding_partition_t *&gt; */</comment>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>shard_table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>shard_table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>partitions_filter_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PARSE_ERROR</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unrecognized key ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)sharding key parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PARSE_UNRECOGNIZED</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>shard_table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>dup_groups_for_partition</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>sources</name></expr></argument>, <argument><expr><name>subqueries</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>USE_ALL_SHARDINGS</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>partitions_get_group_names</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>shard_table</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dup_groups_for_partition</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subqueries</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_SHARDING</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* has sharding table, but no sharding key
           OR sharding key filter out all groups */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharding_tables</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>shard_table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>shard_table</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>shard_table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>shard_table</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>sharding_tables</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>partition_mode</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dup_groups_for_partition</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subqueries</name></expr></argument>, <argument><expr><name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>subqueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>USE_ALL_SHARDINGS</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>expr_same_with_sharding_cond</name><parameter_list>(<parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>equation</name></decl></parameter>, <parameter><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GQueue</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>g_queue_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>gboolean</name></type> <name>is_same</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* for each condition in where clause */</comment>
    <while>while <condition>(<expr><operator>!</operator><call><name>g_queue_is_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>g_queue_pop_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_OR</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_AND</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>g_queue_push_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* HACK: SHARD_COND under TK_NOT is skipped */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_SHARD_COND</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_EQ</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>sql_expr_equals</name><argument_list>(<argument><expr><name><name>equation</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call>
                <operator>&amp;&amp;</operator> <call><name>sql_expr_equals</name><argument_list>(<argument><expr><name><name>equation</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>is_same</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>g_queue_free</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>is_same</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>routing_update</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sql_update_t</name> <modifier>*</modifier></type><name>update</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>, <parameter><decl><type><name>guint32</name></type> <name>fixture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>default_db</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>tables</name> <init>= <expr><name><name>update</name><operator>-&gt;</operator><name>table_reference</name><operator>-&gt;</operator><name>table_list</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>tables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_group</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><call><name>partition_get_super_group</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SINGLE_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>shard_conf_get_single_table_distinct_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>shard_conf_get_all_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SHARDED_TABLE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>shard_info</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>key_occur</name> <init>= <expr><call><name>optimize_sharding_condition</name><argument_list>(<argument><expr><name><name>update</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>,
                                                <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* update sharding key is not allowed */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>update</name><operator>-&gt;</operator><name>set_list</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>update</name><operator>-&gt;</operator><name>set_list</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>equation</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>update</name><operator>-&gt;</operator><name>set_list</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>equation</name> <operator>||</operator> <operator>!</operator><name><name>equation</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>expr_is_sharding_key</name><argument_list>(<argument><expr><name><name>equation</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>key_occur</name> <operator>==</operator> <literal type="number">1</literal>    <comment type="block">/* "update set k = 1 where k = 1" is legal */</comment>
                  <operator>&amp;&amp;</operator> <call><name>expr_same_with_sharding_cond</name><argument_list>(<argument><expr><name>equation</name></expr></argument>, <argument><expr><name><name>update</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)update of sharding key is not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>key_occur</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>partitions_filter_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name><name>update</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PARSE_ERROR</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>PARSE_UNRECOGNIZED</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unrecognized key ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)sharding key parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>partitions_get_group_names</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>USE_DIS_TRAN</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>USE_SHARDING</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>group_insert_values</name><parameter_list>(<parameter><decl><type><name>GHashTable</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>, <parameter><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>new_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>g_hash_table_lookup</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>values</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>new_values</name><operator>-&gt;</operator><name>prior</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_hash_table_insert</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>new_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>g_hash_table_insert</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>new_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sql_select_t</name> <modifier>*</modifier></type>
<name>merge_insert_values</name><parameter_list>(<parameter><decl><type><name>GHashTable</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>, <parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>residual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>merged_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>values_list</name> <init>= <expr><call><name>g_hash_table_get_values</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>residual</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>values_list</name> <operator>=</operator> <call><name>g_list_append</name><argument_list>(<argument><expr><name>values_list</name></expr></argument>, <argument><expr><name>residual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>values_list</name></expr>;</init> <condition><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name><name>tail</name><operator>-&gt;</operator><name>prior</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>tail</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>merged_values</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>tail</name><operator>-&gt;</operator><name>prior</name></name> <operator>=</operator> <name>merged_values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>merged_values</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>merged_values</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name>values_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>merged_values</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>insert_multi_value</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sql_insert_t</name> <modifier>*</modifier></type><name>insert</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,
                   <parameter><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>shard_info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shard_key_index</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GHashTable</name> <modifier>*</modifier></type><name>value_groups</name> <init>= <expr><call><name>g_hash_table_new</name><argument_list>(<argument><expr><name>g_direct_hash</name></expr></argument>, <argument><expr><name>g_direct_equal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* take away from insert AST */</comment>

    <while>while <condition>(<expr><name>values</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>values</name><operator>-&gt;</operator><name>columns</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name>shard_key_index</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:col list values not match"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)no sharding key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>ERROR_UNPARSABLE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><name>TK_EQ</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>values</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>shard_key_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>shard_key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)sharding key parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>ERROR_UNPARSABLE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><call><name>partitions_get</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>part</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>ERROR_UNPARSABLE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>values</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>values</name> <operator>=</operator> <name><name>values</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prior</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* must be single values node */</comment>
        <expr_stmt><expr><call><name>group_insert_values</name><argument_list>(<argument><expr><name>value_groups</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <decl_stmt><decl><type><name>GHashTableIter</name></type> <name>iter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sharding_partition_t</name> <modifier>*</modifier></type><name>part</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>values_list</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_hash_table_iter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>value_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>g_hash_table_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>part</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>values_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>g_string_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name> <operator>=</operator> <name>values_list</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_construct_insert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>insert</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_group_sql</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>group_name</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name><name>plan</name><operator>-&gt;</operator><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>USE_DIS_TRAN</name></expr> </then><else>: <expr><name>USE_NON_SHARDING_TABLE</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>is_sql_rewrite_completely</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <label><name>out</name>:</label>
    <comment type="block">/* restore the INSERT-AST */</comment>
    <expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name> <operator>=</operator> <call><name>merge_insert_values</name><argument_list>(<argument><expr><name>value_groups</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>g_hash_table_destroy</name><argument_list>(<argument><expr><name>value_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>routing_insert</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sql_insert_t</name> <modifier>*</modifier></type><name>insert</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>guint32</name></type> <name>fixture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>src_list</name> <init>= <expr><name><name>insert</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src_list</name> <operator>&amp;&amp;</operator> <name><name>src_list</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>src_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><ternary><condition><expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> ?</condition><then> <expr><name><name>src</name><operator>-&gt;</operator><name>dbname</name></name></expr> </then><else>: <expr><name>default_db</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>table_name</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":db:%s, table:%s"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>shard_info</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>shard_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_group</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><call><name>partition_get_super_group</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_single_table_distinct_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SINGLE_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gboolean</name></type> <name>is_success</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>from</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>default_db</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>is_success</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>is_success</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>is_success</name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:unsupported INSERT format"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy) unsupported INSERT format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>shard_conf_get_all_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SHARDED_TABLE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sql_id_list_t</name> <modifier>*</modifier></type><name>cols</name> <init>= <expr><name><name>insert</name><operator>-&gt;</operator><name>columns</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cols</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:unsupported INSERT format"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)INSERT must use explicit column names"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shard_key</name> <init>= <expr><name><name>shard_info</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shard_key_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cols</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>shard_key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>shard_key_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>shard_key_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":cannot find sharding colomn %s"</literal></expr></argument>, <argument><expr><name>shard_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)INSERTion into sharding table must use sharding key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>sel_val</name> <init>= <expr><name><name>insert</name><operator>-&gt;</operator><name>sel_val</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sel_val</name> <operator>||</operator> <operator>!</operator><name><name>sel_val</name><operator>-&gt;</operator><name>columns</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:could not find insert values"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)no VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>sel_val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SF_MULTI_VALUE</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>insert_multi_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>insert</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>shard_info</name></expr></argument>, <argument><expr><name>shard_key_index</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* SINGLE VALUE */</comment>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>sel_val</name><operator>-&gt;</operator><name>columns</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>values</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name>shard_key_index</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:col list values not match"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)no sharding key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><name>TK_EQ</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>shard_key_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>expr_parse_sharding_value</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>shard_key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)sharding key parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>partitions_filter</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>partitions_get_group_names</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* TODO: return code when pkey out of range; */</comment>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>   <comment type="block">/* can't happen */</comment>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>USE_SHARDING</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>routing_delete</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sql_delete_t</name> <modifier>*</modifier></type><name>delete</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter>, <parameter><decl><type><name>guint32</name></type> <name>fixture</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>delete</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":delete ast error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)no ast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>default_db</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name><name>delete</name><operator>-&gt;</operator><name>from_src</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_group</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><call><name>partition_get_super_group</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_single_table_distinct_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SINGLE_TABLE</name></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>shard_conf_get_all_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>GLOBAL_TABLE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>table_type</name></name> <operator>=</operator> <name>SHARDED_TABLE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>delete</name><operator>-&gt;</operator><name>where_clause</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>USE_SHARDING</name></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>shard_info</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>gboolean</name></type> <name>has_sharding_key</name> <init>= <expr><call><name>optimize_sharding_condition</name><argument_list>(<argument><expr><name><name>delete</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>shard_info</name><operator>-&gt;</operator><name>pkey</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>PARSE_OK</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>has_sharding_key</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>partitions_filter_expr</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name><name>delete</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PARSE_ERROR</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>PARSE_UNRECOGNIZED</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unrecognized key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)sharding key parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>partitions_get_group_names</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>USE_DIS_TRAN</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>USE_SHARDING</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_get_table_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>dup_groups</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>check_property_has_groups</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_property_t</name> <modifier>*</modifier></type><name>property</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>property</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>property</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sql_property_is_valid</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>property</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>routing_by_property</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sql_property_t</name> <modifier>*</modifier></type><name>property</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>property</name><operator>-&gt;</operator><name>table</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>default_db</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>property</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* check for dotted name "db.table" */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name><name>property</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>property</name><operator>-&gt;</operator><name>table</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>table</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>shard_conf_table_partitions</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>property</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>condition_t</name></name></type> <name>cond</name> <init>= <expr><block>{ <expr><name>TK_EQ</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sharding_table_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>shard_conf_get_info</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>info</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(cetus)no such table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>string_to_sharding_value</name><argument_list>(<argument><expr><name><name>property</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>shard_key_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSE_OK</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)comment error: key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>partitions_filter</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>partitions_get_group_names</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>partitions</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>enum</name> <name>sql_clause_flag_t</name></name></type> <name>f</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rw_flag</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>CF_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>CF_DDL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>USE_SHARDING</name></expr>;</return>

    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>property</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>shard_conf_find_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name><name>property</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>enum</name> <name>sql_clause_flag_t</name></name></type> <name>f</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rw_flag</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>CF_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>f</name> <operator>&amp;</operator> <name>CF_DDL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <return>return <expr><name>USE_DIS_TRAN</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>USE_SHARDING</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><literal type="string">"no group: %s for db: %s"</literal></expr></argument>, <argument><expr><name><name>property</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>default_db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sql_context_append_msg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"(proxy)comment error, unknown property"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>sharding_parse_groups_by_property</name><parameter_list>(<parameter><decl><type><name>GString</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>routing_by_property</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>property</name></name></expr></argument>, <argument><expr><name><name>default_db</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>sharding_parse_groups</name><parameter_list>(<parameter><decl><type><name>GString</name> <modifier>*</modifier></type><name>default_db</name></decl></parameter>, <parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>query_stats_t</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
                      <parameter><decl><type><name>guint64</name></type> <name>fixture</name></decl></parameter>, <parameter><decl><type><name>sharding_plan_t</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GPtrArray</name> <modifier>*</modifier></type><name>groups</name> <init>= <expr><call><name>g_ptr_array_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><literal type="string">"%s:sql is not parsed"</literal></expr></argument>, <argument><expr><name>G_STRLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sql_needs_reconstruct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>default_db</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":default db:%s"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>sql_context_has_sharding_property</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>routing_by_property</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>property</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rc</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>ERROR_UNPARSABLE</name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>stmt_type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>STMT_SELECT</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>select</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>routing_select</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>select</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>select</name> <operator>=</operator> <name><name>select</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt> <comment type="block">/* select-&gt;prior UNION select */</comment>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>==</operator> <name>USE_SHARDING</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>USE_ALL_SHARDINGS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>groups</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sharding_filter_sql</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* only filter queries with sharding table */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>rc</name></name> <operator>==</operator> <name>PARSE_NOT_SUPPORT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sharding_plan_clear_group</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>rc</name></expr>;</return>              <comment type="block">/* TODO: result of first select */</comment>
    </block_content>}</block>
    <case>case <expr><name>STMT_UPDATE</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>routing_update</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    <case>case <expr><name>STMT_INSERT</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>routing_insert</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    <case>case <expr><name>STMT_DELETE</name></expr>:</case>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>routing_delete</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    <case>case <expr><name>STMT_SHOW_WARNINGS</name></expr>:</case>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_PREVIOUS_WARNING_CONN</name></expr>;</return>
    <case>case <expr><name>STMT_SHOW_COLUMNS</name></expr>:</case>
    <case>case <expr><name>STMT_SHOW_CREATE</name></expr>:</case>
    <case>case <expr><name>STMT_EXPLAIN_TABLE</name></expr>:</case><block>{<block_content>  <comment type="block">/* DESCRIBE tablename; */</comment>
        <decl_stmt><decl><type><name>sql_src_list_t</name> <modifier>*</modifier></type><name>tables</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src_item</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>tables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>src_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>src_item</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>src_item</name><operator>-&gt;</operator><name>dbname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>shard_conf_is_shard_table</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src_item</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_any_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src_item</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_ANY_SHARDINGS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>shard_conf_is_single_table</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src_item</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_single_table_distinct_group</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>src_item</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>STMT_SET</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><call><name>sql_context_is_autocommit_on</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_SAME</name></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>sql_context_is_autocommit_off</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_NONE</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_all_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_ALL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    <case>case <expr><name>STMT_START</name></expr>:</case>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NONE</name></expr>;</return>
    <case>case <expr><name>STMT_COMMIT</name></expr>:</case>
    <case>case <expr><name>STMT_ROLLBACK</name></expr>:</case>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_PREVIOUS_TRAN_CONNS</name></expr>;</return>
    <case>case <expr><name>STMT_CALL</name></expr>:</case>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    <case>case <expr><name>STMT_DROP_DATABASE</name></expr>:</case>
    <case>case <expr><name>STMT_COMMON_DDL</name></expr>:</case>      <comment type="block">/* ddl without comments sent to all */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>, <argument><expr><literal type="string">"(cetus) DDL is not allowed for partition until now"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ERROR_UNPARSABLE</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>shard_conf_get_all_groups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>USE_ALL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    <case>case <expr><name>STMT_SHOW</name></expr>:</case>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    <default>default:</default>
        <expr_stmt><expr><call><name>g_debug</name><argument_list>(<argument><expr><literal type="string">"unrecognized query, using default master db, sql:%s"</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>orig_sql</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shard_conf_get_fixed_group</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>is_partition_mode</name></name></expr></argument>, <argument><expr><name>groups</name></expr></argument>, <argument><expr><name>fixture</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sharding_plan_add_groups</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_ptr_array_free</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>USE_NON_SHARDING_TABLE</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* is ORDERBY column a subset of SELECT column */</comment>
<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_compare_orderby</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_column_list_t</name> <modifier>*</modifier></type><name>ord_cols</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ord_cols</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>mcol</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mcol</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_STAR</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FALSE</name></expr>;</return>       <comment type="block">/* reject: select DISTINCT *where .. */</comment>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mcol</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_DOT</name> <operator>&amp;&amp;</operator> <name><name>mcol</name><operator>-&gt;</operator><name>right</name></name> <operator>&amp;&amp;</operator> <name><name>mcol</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_STAR</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FALSE</name></expr>;</return>       <comment type="block">/* reject: select DISTINCT t.* where .. */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SF_REWRITE_ORDERBY</name></expr>;</expr_stmt>
        <return>return <expr><name>TRUE</name></expr>;</return>            <comment type="block">/* accept: select DISTINCT a, b where .., rewrite later */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>columns</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <name><name>ord_cols</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ord_cols</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_column_t</name> <modifier>*</modifier></type><name>ordcol</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>ord_cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>ord</name> <init>= <expr><name><name>ordcol</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>sql_expr_is_id</name><argument_list>(<argument><expr><name>ord</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><call><name>sql_expr_list_find</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name><name>ord</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_ORDER_BY</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return>   <comment type="block">/* reject: select DISTINCT a,b,c ORDER BY x,y */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>sql_expr_is_dotted_name</name><argument_list>(<argument><expr><name>ord</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><call><name>sql_expr_list_find_fullname</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>ord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EP_ORDER_BY</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <return>return <expr><name>FALSE</name></expr>;</return>   <comment type="block">/* reject: select DISTINCT a,b,c ORDER BY x,y */</comment>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>g_warning</name><argument_list>(<argument><expr><name>G_STRLOC</name> <literal type="string">":unrecognized order by column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>FALSE</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name><name>columns</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>ord_cols</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SF_REWRITE_ORDERBY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>TRUE</name></expr>;</return>            <comment type="block">/* accept: 1) select DISTINCT a,b,c,d ORDER BY b,c,a. rewrite later */</comment>
        <comment type="block">/*         2) select DISTINCT a,b,c,d ORDER BY a,c,b,d. no rewrite */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>               <comment type="block">/* reject: DISTINCT a ORDER BY a,b,c. might be syntax error */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_check_HAVING_column</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>having</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>having</name> <operator>&amp;&amp;</operator> <name><name>having</name><operator>-&gt;</operator><name>left</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>    <comment type="block">/* no HAVING is alright */</comment>
        <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>having_func</name> <init>= <expr><name><name>having</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>token_text</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>having_func</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* find having cond in columns */</comment>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>sql_expr_list_find_exact_aggregate</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name><name>having</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,
                                       <argument><expr><name><name>having</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>having</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_has_distincted_aggregate</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_subquery</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>aggr_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>select</name><operator>-&gt;</operator><name>columns</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_DISTINCT</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
                <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"avg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>aggr_name</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr>;</expr_stmt>
                <return>return <expr><name>TRUE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>has_subquery</name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>select</name><operator>-&gt;</operator><name>from_src</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>select_has_distincted_aggregate</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>aggr_name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_has_sub_select_aggregate</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_analyze</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_analyze</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>select</name><operator>-&gt;</operator><name>columns</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_AGGREGATE</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
                        <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"avg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <return>return <expr><name>TRUE</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>select</name><operator>-&gt;</operator><name>from_src</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_src_item_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>from_src</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>select_has_sub_select_aggregate</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>select</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_has_AVG</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>select</name><operator>-&gt;</operator><name>columns</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_FUNCTION</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EP_AGGREGATE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><literal type="string">"avg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* group by &amp; order by have only 1 column, and they are same */</comment>
<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>select_groupby_orderby_have_same_column</name><parameter_list>(<parameter><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sql_column_list_t</name> <modifier>*</modifier></type><name>ord</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>grp</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>ord</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>grp</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>grp_expr</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>grp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>sql_column_t</name> <modifier>*</modifier></type><name>ord_col</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>ord</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>g_strcmp0</name><argument_list>(<argument><expr><name><name>ord_col</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>, <argument><expr><name><name>grp_expr</name><operator>-&gt;</operator><name>token_text</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>sharding_filter_sql</name><parameter_list>(<parameter><decl><type><name>sql_context_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>                               <comment type="block">/* TODO:should be in sql-operations.c */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>stmt_type</name></name> <operator>==</operator> <name>STMT_SELECT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>sql_select_t</name> <modifier>*</modifier></type><name>select</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SF_DISTINCT</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gboolean</name></type> <name>same</name> <init>= <expr><call><name>select_compare_orderby</name><argument_list>(<argument><expr><name>select</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>same</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                      <argument><expr><literal type="string">"(proxy)ORDER BY columns must be a subset of DISTINCT columns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* grauntee HAVING condition show up in column */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_compare_op</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>having_clause</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>, <argument><expr><literal type="string">"(cetus) Only support simple HAVING condition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>select_check_HAVING_column</name><argument_list>(<argument><expr><name>select</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                      <argument><expr><literal type="string">"(cetus) HAVING condition must show up in column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                      <argument><expr><literal type="string">"(cetus) Only support HAVING condition without limit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sql_expr_list_t</name> <modifier>*</modifier></type><name>groupby</name> <init>= <expr><name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>groupby</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sql_expr_t</name> <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>g_ptr_array_index</name><argument_list>(<argument><expr><name>groupby</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>col</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>TK_CASE</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>, <argument><expr><literal type="string">"(proxy) group by CASE-WHEN not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>clause_flags</name></name> <operator>&amp;</operator> <name>CF_AGGREGATE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>select_has_AVG</name><argument_list>(<argument><expr><name>select</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                      <argument><expr><literal type="string">"(cetus)this AVG would be routed to multiple shards, not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* if we can't find simple aggregates, it's inside complex expressions */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>sql_expr_list_find_aggregate</name><argument_list>(<argument><expr><name><name>select</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                      <argument><expr><literal type="string">"(cetus) Complex aggregate function not allowed on sharded sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>select</name><operator>-&gt;</operator><name>groupby_clause</name></name> <operator>&amp;&amp;</operator> <name><name>select</name><operator>-&gt;</operator><name>orderby_clause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>select_groupby_orderby_have_same_column</name><argument_list>(<argument><expr><name>select</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>,
                                  <argument><expr><literal type="string">"(cetus) can't ORDER BY and GROUP BY different columns on sharded sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* reject SELECT COUNT(DISTINCT) / SUM(DISTINCT) / AVG(DISTINCT) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>clause_flags</name></name> <operator>&amp;</operator> <name>CF_DISTINCT_AGGR</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aggr_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>subquery</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>clause_flags</name></name> <operator>&amp;</operator> <name>CF_SUBQUERY</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>select_has_distincted_aggregate</name><argument_list>(<argument><expr><name>select</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggr_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="string">"(proxy) %s(DISTINCT ...) not supported"</literal></expr></argument>, <argument><expr><name>aggr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>allow_subquery_nesting</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>clause_flags</name></name> <operator>&amp;</operator> <name>CF_SUBQUERY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>select_has_sub_select_aggregate</name><argument_list>(<argument><expr><name>select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>TRUE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>sql_context_set_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>PARSE_NOT_SUPPORT</name></expr></argument>, <argument><expr><literal type="string">"(proxy) sub select aggregate functions not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
