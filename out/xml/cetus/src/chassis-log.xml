<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/cetus/src/chassis-log.c"><comment type="block">/* $%BEGINLICENSE%$
 Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; version 2 of the
 License.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 02110-1301  USA

 $%ENDLICENSE%$ */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>             <comment type="block">/* close */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVENTLOG_ERROR_TYPE</name></cpp:macro>	<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVENTLOG_WARNING_TYPE</name></cpp:macro>	<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVENTLOG_INFORMATION_TYPE</name></cpp:macro>	<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;glib.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* placeholder values for platforms not having syslog support */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_USER</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>           <comment type="block">/* placeholder for user-level syslog facility */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_CRIT</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_ERR</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_WARNING</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_NOTICE</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_INFO</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_DEBUG</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sys-pedantic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chassis-log.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUF_LEN</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_MAX_LEN</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cetus_cpymem</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>s</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((char *) memcpy(d, (void *) s, l)) + (l))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x-&gt;str, x-&gt;len</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>pid_t</name></type>       <name>cetus_pid</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**
 * the mapping of our internal log levels various log systems
 *
 * Attention: this needs to be adjusted should glib ever 
 * change its log level ordering 
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G_LOG_ERROR_POSITION</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<struct><specifier>const</specifier> struct <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GLogLevelFlags</name></type> <name>lvl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>syslog_lvl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>win_evtype</name></decl>;</decl_stmt>
}</block> <decl><name><name>log_lvl_map</name><index>[]</index></name> <init>= <expr><block>{             <comment type="block">/* syslog levels are different to the glib ones */</comment>
    <expr><block>{
    <expr><literal type="string">"error"</literal></expr>, <expr><name>G_LOG_LEVEL_ERROR</name></expr>, <expr><name>LOG_CRIT</name></expr>, <expr><name>EVENTLOG_ERROR_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><literal type="string">"critical"</literal></expr>, <expr><name>G_LOG_LEVEL_CRITICAL</name></expr>, <expr><name>LOG_ERR</name></expr>, <expr><name>EVENTLOG_ERROR_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><literal type="string">"warning"</literal></expr>, <expr><name>G_LOG_LEVEL_WARNING</name></expr>, <expr><name>LOG_WARNING</name></expr>, <expr><name>EVENTLOG_WARNING_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><literal type="string">"message"</literal></expr>, <expr><name>G_LOG_LEVEL_MESSAGE</name></expr>, <expr><name>LOG_NOTICE</name></expr>, <expr><name>EVENTLOG_INFORMATION_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><literal type="string">"info"</literal></expr>, <expr><name>G_LOG_LEVEL_INFO</name></expr>, <expr><name>LOG_INFO</name></expr>, <expr><name>EVENTLOG_INFORMATION_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><literal type="string">"debug"</literal></expr>, <expr><name>G_LOG_LEVEL_DEBUG</name></expr>, <expr><name>LOG_DEBUG</name></expr>, <expr><name>EVENTLOG_INFORMATION_TYPE</name></expr>}</block></expr>, <expr><block>{
    <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function_decl><type><specifier>static</specifier> <name>gboolean</name></type>
 <name>chassis_log_rotate_reopen</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>gpointer</name></type> <name>userdata</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>gerr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>chassis_log</name> <modifier>*</modifier></type>
<name>chassis_log_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>log</name> <operator>=</operator> <call><name>g_new0</name><argument_list>(<argument><expr><name>chassis_log</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name> <operator>=</operator> <call><name>g_string_sized_new</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"2004-01-01T00:00:00.000Z"</literal></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_resolution</name></name> <operator>=</operator> <name>CHASSIS_RESOLUTION_DEFAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>min_lvl</name></name> <operator>=</operator> <name>G_LOG_LEVEL_CRITICAL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg</name></name> <operator>=</operator> <call><name>g_string_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_ts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>chassis_log_set_rotate_func</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>chassis_log_rotate_reopen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>log</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>chassis_log_set_level</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gint</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>min_lvl</name></name> <operator>=</operator> <name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lvl</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * open the log-file
 *
 * open the log-file set in log-&gt;log_filename
 * if no log-filename is set, returns TRUE
 *
 * FIXME: the return value is not following 'unix'-style (0 on success, -1 on error),
 *        nor does it say it is a gboolean. Has to be fixed in 0.9.0
 *
 * @return TRUE on success, FALSE on error
 */</comment>
<function><type><name>int</name></type>
<name>chassis_log_open</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>log</name><operator>-&gt;</operator><name>log_filename</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_filename</name></name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_APPEND</name></expr></argument>, <argument><expr><literal type="number">0660</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * close the log-file
 *
 * @return 0 on success
 *
 * @see chassis_log_open
 */</comment>
<function><type><name>int</name></type>
<name>chassis_log_close</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>chassis_log_free</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>chassis_log_close</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_string_free</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>g_string_free</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>log_filename</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data_destroy</name></name> <operator>&amp;&amp;</operator> <name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data_destroy</name></name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chassis_log_update_timestamp</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GTimeVal</name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GString</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>g_get_current_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>strftime</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>allocated_len</name></name></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_resolution</name></name> <operator>==</operator> <name>CHASSIS_RESOLUTION_MS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>g_string_append_printf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">".%.3d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chassis_log_write</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_level</name></decl></parameter>, <parameter><decl><type><name>GString</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MAX_BUF_LEN</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>int</name></type> <name>log_fd</name> <init>= <expr><name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"(pid=%d) "</literal></expr></argument>, <argument><expr><name>cetus_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>LOG_MAX_LEN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>cetus_cpymem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>cetus_cpymem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>LOG_MAX_LEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * skip the 'top_srcdir' from a string starting with G_STRLOC or 
 * __FILE__ if it is absolute
 *
 * &lt;absolute-path&gt;/src/chassis-log.c will become src/chassis-log.c
 *
 * NOTE: the code assumes it is located in src/ or src\. i
 *       If it gets moves somewhere else
 *       it won't crash, but strip too much of pathname
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>chassis_log_skip_topsrcdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_filename</name> <init>= <expr><name>__FILE__</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ndx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * we want to strip everything that is before the src/ 
     * in the above example. If we don't get the srcdir name passed down
     * as part of the __FILE__, don't try to parse it out
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>g_path_is_absolute</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>message</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* usually the message start with G_STRLOC which may contain a rather 
     * long, absolute path. If
     * it matches the TOP_SRCDIR, we filter it out
     *
     * - strip what is the same as our __FILE__
     * - don't strip our own sub-path 'src/'
     */</comment>
    <for>for <control>(<init><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>message</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ndx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>message</name> <operator>+</operator> <name>ndx</name></expr></argument>, <argument><expr><literal type="string">"src"</literal> <name>G_DIR_SEPARATOR_S</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"src"</literal> <name>G_DIR_SEPARATOR_S</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>message</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>!=</operator> <name><name>my_filename</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>message</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>message</name> <operator>+=</operator> <name>ndx</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>message</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * chassis_log_rotate_reopen:
 * @log: a #chassis_log
 * @userdata: ...
 * @gerr: ...
 *
 * default log-rotate function
 *
 * assumes that:
 * - log-file is moved to new name
 * - SIGHUP is sent to process to announce log-file rotation
 * - we reopen the log-file
 *
 * Returns: %TRUE
 */</comment>
<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>chassis_log_rotate_reopen</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>gpointer</name></type> <name>userdata</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>gerr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>chassis_log_close</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>chassis_log_open</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * chassis_log_rotate:
 * @log: a #chassis_log
 *
 * rotate the logfile
 *
 * calls the rotation function provided by the user 
 * (or the default log-rotation function)
 *
 * Returns: %TRUE if the log-file was rotated, %FALSE on error
 */</comment>
<function><type><name>gboolean</name></type>
<name>chassis_log_rotate</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>gerr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>log</name><operator>-&gt;</operator><name>rotate_func</name></name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name></expr></argument>, <argument><expr><name>gerr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * chassis_log_set_rotate_func:
 * @log: a #chassis_log
 * @rotate_func: (allow-none): log-file rotation function
 * @userdata: (allow-none): userdata that is passed to @rotate_func
 * @userdata_free: (allow-none): a #GDestroyNotify that is called 
 *                               when the rotate-function gets unset
 *   
 * set a rotate function that is called when logfile rotate is requested
 *
 * if @rotate_func is %NULL, the default log-rotation function is set
 */</comment>
<function><type><name>void</name></type>
<name>chassis_log_set_rotate_func</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>, <parameter><decl><type><name>chassis_log_rotate_func</name></type> <name>rotate_func</name></decl></parameter>,
                            <parameter><decl><type><name>gpointer</name></type> <name>userdata</name></decl></parameter>, <parameter><decl><type><name>GDestroyNotify</name></type> <name>userdata_free</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name> <operator>&amp;&amp;</operator> <name><name>log</name><operator>-&gt;</operator><name>rotate_func_data_destroy</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data_destroy</name></name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rotate_func</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func</name></name> <operator>=</operator> <name>chassis_log_rotate_reopen</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func</name></name> <operator>=</operator> <name>rotate_func</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data</name></name> <operator>=</operator> <name>userdata</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_func_data_destroy</name></name> <operator>=</operator> <name>userdata_free</name></expr>;</expr_stmt>

    <return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>chassis_log_func_locked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>gchar</name> <name>G_GNUC_UNUSED</name> <modifier>*</modifier></type><name>log_domain</name></decl></parameter>, <parameter><decl><type><name>GLogLevelFlags</name></type> <name>log_level</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>gpointer</name></type> <name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name> <init>= <expr><name>user_data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>log_lvl_name</name> <init>= <expr><literal type="string">"(error)"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gboolean</name></type> <name>is_duplicate</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stripped_message</name> <init>= <expr><call><name>chassis_log_skip_topsrcdir</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/**
     * rotate logs straight away if log-&gt;rotate_logs is true
     * we do this before ignoring any log levels, so that rotation 
     * happens straight away - see Bug#55711 
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>!=</operator> <name><name>log</name><operator>-&gt;</operator><name>log_file_fd</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>rotate_logs</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gboolean</name></type> <name>is_rotated</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>is_rotated</name> <operator>=</operator> <call><name>chassis_log_rotate</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_logs</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

            <comment type="block">/* -&gt;is_rotated stays set until the first message is logged
             * again to make sure we don't hide it as duplicate
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>is_rotated</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator> <name>is_rotated</name> <operator>==</operator> <name>TRUE</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>is_rotated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* ignore the verbose log-levels */</comment>
    <if_stmt><if>if <condition>(<expr><name>log_level</name> <operator>&gt;</operator> <name><name>log</name><operator>-&gt;</operator><name>min_lvl</name></name></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lvl</name> <operator>==</operator> <name>log_level</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>log_lvl_name</name> <operator>=</operator> <name><name>log_lvl_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>last_msg</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>stripped_message</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_duplicate</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block" format="doxygen">/**
     * if the log has been rotated, we always dump the last message even if it 
     * was a duplicate. Otherwise, do not print duplicates unless they have been
     * ignored at least 100 times, or they were last printed greater than 
     * 30 seconds ago.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>is_rotated</name></name> <operator>||</operator> <operator>!</operator><name>is_duplicate</name> <operator>||</operator> <name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name> <operator>&gt;</operator> <literal type="number">100</literal> <operator>||</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>log</name><operator>-&gt;</operator><name>last_msg_ts</name></name> <operator>&gt;</operator> <literal type="number">30</literal></expr>)</condition> <block>{<block_content>

        <comment type="block">/* if we lave the last message repeating, log it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>chassis_log_update_timestamp</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_string_append_printf</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><literal type="string">": (%s) last message repeated %d times"</literal></expr></argument>,
                                   <argument><expr><name>log_lvl_name</name></expr></argument>, <argument><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>chassis_log_write</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>chassis_log_update_timestamp</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><literal type="string">": ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><name>log_lvl_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>g_string_append</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>, <argument><expr><name>stripped_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* reset the last-logged message */</comment>
        <expr_stmt><expr><call><name>g_string_assign</name><argument_list>(<argument><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg</name></name></expr></argument>, <argument><expr><name>stripped_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_ts</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>chassis_log_write</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name><name>log</name><operator>-&gt;</operator><name>log_ts_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>last_msg_count</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>is_rotated</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>chassis_log_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>log_domain</name></decl></parameter>, <parameter><decl><type><name>GLogLevelFlags</name></type> <name>log_level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>gpointer</name></type> <name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>chassis_log_func_locked</name><argument_list>(<argument><expr><name>log_domain</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>chassis_log_set_logrotate</name><parameter_list>(<parameter><decl><type><name>chassis_log</name> <modifier>*</modifier></type><name>log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>log</name><operator>-&gt;</operator><name>rotate_logs</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
