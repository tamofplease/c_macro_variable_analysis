<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/cetus/src/chassis-options.c"><comment type="block">/* $%BEGINLICENSE%$
 Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; version 2 of the
 License.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 02110-1301  USA

 $%ENDLICENSE%$ */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;glib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chassis-options.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**
 * create a command-line option
 */</comment>
<function><type><name>chassis_option_t</name> <modifier>*</modifier></type>
<name>chassis_option_new</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>g_slice_new0</name><argument_list>(<argument><expr><name>chassis_option_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>opt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * free the option
 */</comment>
<function><type><name>void</name></type>
<name>chassis_option_free</name><parameter_list>(<parameter><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>g_slice_free</name><argument_list>(<argument><expr><name>chassis_option_t</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * add a option
 *
 * GOptionEntry
 */</comment>
<function><type><name>int</name></type>
<name>chassis_option_set</name><parameter_list>(<parameter><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_name</name></decl></parameter>,
                   <parameter><decl><type><name>gchar</name></type> <name>short_name</name></decl></parameter>,
                   <parameter><decl><type><name>gint</name></type> <name>flags</name></decl></parameter>,
                   <parameter><decl><type><name><name>enum</name> <name>option_type</name></name></type> <name>arg</name></decl></parameter>,
                   <parameter><decl><type><name>gpointer</name></type> <name>arg_data</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_desc</name></decl></parameter>,
                   <parameter><decl><type><name>chas_opt_assign_hook</name></type> <name>assign_hook</name></decl></parameter>, <parameter><decl><type><name>chas_opt_show_hook</name></type> <name>show_hook</name></decl></parameter>, <parameter><decl><type><name>gint</name></type> <name>opt_property</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name> <operator>=</operator> <name>long_name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>short_name</name></name> <operator>=</operator> <name>short_name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>arg_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>description</name></name> <operator>=</operator> <name>description</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>arg_description</name></name> <operator>=</operator> <name>arg_desc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>opt_property</name></name> <operator>=</operator> <name>opt_property</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * create a command-line option
 */</comment>
<function><type><name>chassis_options_t</name> <modifier>*</modifier></type>
<name>chassis_options_new</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>g_slice_new0</name><argument_list>(<argument><expr><name>chassis_options_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>opt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * add a option
 *
 * GOptionEntry
 */</comment>
<function><type><name>int</name></type>
<name>chassis_options_add_option</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>g_list_append</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>chassis_options_add_options</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>GList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>opts</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>g_list_concat</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>chassis_options_add</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_name</name></decl></parameter>,
                    <parameter><decl><type><name>gchar</name></type> <name>short_name</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                    <parameter><decl><type><name><name>enum</name> <name>option_type</name></name></type> <name>arg</name></decl></parameter>,
                    <parameter><decl><type><name>gpointer</name></type> <name>arg_data</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_desc</name></decl></parameter>,
                    <parameter><decl><type><name>chas_opt_assign_hook</name></type> <name>assign_hook</name></decl></parameter>, <parameter><decl><type><name>chas_opt_show_hook</name></type> <name>show_hook</name></decl></parameter>, <parameter><decl><type><name>gint</name></type> <name>opt_property</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><call><name>chassis_option_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>chassis_option_set</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,
                                <argument><expr><name>long_name</name></expr></argument>,
                                <argument><expr><name>short_name</name></expr></argument>,
                                <argument><expr><name>flags</name></expr></argument>,
                                <argument><expr><name>arg</name></expr></argument>,
                                <argument><expr><name>arg_data</name></expr></argument>,
                                <argument><expr><name>description</name></expr></argument>,
                                <argument><expr><name>arg_desc</name></expr></argument>, <argument><expr><name>assign_hook</name></expr></argument>, <argument><expr><name>show_hook</name></expr></argument>, <argument><expr><name>opt_property</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">0</literal> <operator>!=</operator> <call><name>chassis_options_add_option</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>chassis_option_free</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_ARG</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((entry)-&gt;arg == OPTION_ARG_NONE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIONAL_ARG</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>

<struct>struct <name>opt_change</name> <block>{
    <decl_stmt><decl><type><name><name>enum</name> <name>option_type</name></name></type> <name>arg_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gpointer</name></type> <name>arg_data</name></decl>;</decl_stmt>
    <union>union <block>{
        <decl_stmt><decl><type><name>gboolean</name></type> <name>bool</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gint</name></type> <name>integer</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gdouble</name></type> <name>dbl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gint64</name></type> <name>int64</name></decl>;</decl_stmt>
    }</block> <decl><name>prev</name></decl>;</union>
    <union>union <block>{
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
        <struct>struct <block>{
            <decl_stmt><decl><type><name>gint</name></type> <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
        }</block> <decl><name>array</name></decl>;</struct>
    }</block> <decl><name>allocated</name></decl>;</union>
}</block>;</struct>

<struct>struct <name>pending_null</name> <block>{
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>context_has_h_entry</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>short_name</name></name> <operator>==</operator> <literal type="char">'h'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_help</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>max_length</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"%s\n  %s"</literal></expr></argument>, <argument><expr><literal type="string">"Usage:"</literal></expr></argument>, <argument><expr><call><name>g_get_prgname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"[OPTION...]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"\n\nHelp Options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>token</name> <init>= <expr><ternary><condition><expr><call><name>context_has_h_entry</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="char">'?'</literal></expr> </then><else>: <expr><literal type="char">'h'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"  -%c, --%-*s %s\n"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>max_length</name> <operator>-</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"help"</literal></expr></argument>, <argument><expr><literal type="string">"Show help options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"\n\nApplication Options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>short_name</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"  -%c, --%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>short_name</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"  --%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>arg_description</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"=%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_print</name><argument_list>(<argument><expr><literal type="string">"%*s %s\n"</literal></expr></argument>, <argument><expr><name>max_length</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>description</name></name></expr> ?</condition><then> <expr><name><name>entry</name><operator>-&gt;</operator><name>description</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>glong</name></type> <name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Cannot parse integer value '%s' for %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>!=</operator> <name>tmp</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Integer value '%s' for %s out of range"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>gdouble</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gdouble</name></type> <name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>g_strtod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Cannot parse double value '%s' for %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Double value '%s' for %s out of range"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>gint64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gint64</name></type> <name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>g_ascii_strtoll</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Cannot parse integer value '%s' for %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                    <argument><expr><literal type="string">"Integer value '%s' for %s out of range"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>opt_change</name></name> <modifier>*</modifier></type>
<name>get_change</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>option_type</name></name></type> <name>arg_type</name></decl></parameter>, <parameter><decl><type><name>gpointer</name></type> <name>arg_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>opt_change</name></name> <modifier>*</modifier></type><name>change</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>list</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>changes</name></name></expr>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>change</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>==</operator> <name>arg_data</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>g_new0</name><argument_list>(<argument><expr>struct <name>opt_change</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>arg_type</name></name> <operator>=</operator> <name>arg_type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>arg_data</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>changes</name></name> <operator>=</operator> <call><name>g_list_prepend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>found</name>:</label>
    <return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_pending_null</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>pending_null</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>g_new0</name><argument_list>(<argument><expr>struct <name>pending_null</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>pending_nulls</name></name> <operator>=</operator> <call><name>g_list_prepend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pending_nulls</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_arg</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
          <parameter><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gchar</name> <modifier>*</modifier></type><name>option_name</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>opt_change</name></name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>g_assert</name><argument_list>(<argument><expr><name>value</name> <operator>||</operator> <call><name>OPTIONAL_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NO_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OPTION_ARG_NONE</name></expr>:</case><block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_NONE</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gboolean</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPTION_FLAG_REVERSE</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPTION_ARG_STRING</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>g_locale_to_utf8</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_STRING</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>str</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPTION_ARG_STRING_ARRAY</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>g_locale_to_utf8</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_STRING_ARRAY</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>array</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name></name> <operator>=</operator> <call><name>g_new</name><argument_list>(<argument><expr><name>gchar</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name></name> <operator>=</operator>
                <call><name>g_renew</name><argument_list>(<argument><expr><name>gchar</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name><index>[<expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name><index>[<expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPTION_ARG_INT</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>gint</name></type> <name>data</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_INT</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>gint</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gint</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPTION_ARG_DOUBLE</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>gdouble</name></type> <name>data</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_double</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_DOUBLE</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>dbl</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>gdouble</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gdouble</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPTION_ARG_INT64</name></expr>:</case><block>{<block_content>
        <decl_stmt><decl><type><name>gint64</name></type> <name>data</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int64</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>get_change</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>OPTION_ARG_INT64</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>int64</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>gint64</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gint64</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
        <expr_stmt><expr><call><name>g_assert_not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPTION_FLAG_CMDLINE</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_short_option</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                   <parameter><decl><type><name>gint</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>new_idx</name></decl></parameter>, <parameter><decl><type><name>gchar</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>, <parameter><decl><type><name>gboolean</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>short_name</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>option_name</name> <init>= <expr><call><name>g_strdup_printf</name><argument_list>(<argument><expr><literal type="string">"-%c"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>short_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>NO_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>new_idx</name> <operator>&gt;</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_FAILED</name></expr></argument>, <argument><expr><literal type="string">"Error parsing option %s"</literal></expr></argument>, <argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>FALSE</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OPTIONAL_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>*</operator><name>new_idx</name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><operator>*</operator><name>new_idx</name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <operator>*</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>OPTIONAL_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                                <argument><expr><literal type="string">"Missing argument for %s"</literal></expr></argument>, <argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>FALSE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>FALSE</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_long_option</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                  <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>gboolean</name></type> <name>aliased</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>, <parameter><decl><type><name>gboolean</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>idx</name> <operator>&gt;=</operator> <operator>*</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>NO_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>option_name</name> <init>= <expr><call><name>g_strconcat</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>gboolean</name></type> <name>retval</name> <init>= <expr><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

            <return>return <expr><name>retval</name></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>gint</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>arg</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>||</operator> <name><name>arg</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>option_name</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>option_name</name> <operator>=</operator> <call><name>g_strconcat</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>arg</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>idx</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OPTIONAL_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>idx</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></if> <else>else <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
                            <decl_stmt><decl><type><name>gboolean</name></type> <name>retval</name> <init>= <expr><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>retval</name></expr>;</return>
                        </block_content>}</block></if> <else>else <block>{<block_content>
                            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>idx</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>idx</name> <operator>&gt;=</operator> <operator>*</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>OPTIONAL_ARG</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>gboolean</name></type> <name>retval</name> <init>= <expr><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>retval</name></expr>;</return>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_BAD_VALUE</name></expr></argument>,
                                <argument><expr><literal type="string">"Missing argument for %s"</literal></expr></argument>, <argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>FALSE</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>option_name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>FALSE</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>option_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>gboolean</name></type>
<name>parse_remaining_arg</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>gint</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>, <parameter><decl><type><name>gchar</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>, <parameter><decl><type><name>gboolean</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>idx</name> <operator>&gt;=</operator> <operator>*</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>long_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>g_return_val_if_fail</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>OPTION_ARG_STRING_ARRAY</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>idx</name></expr>]</index></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>parsed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></for>
    <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_changes_list</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>gboolean</name></type> <name>revert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>list</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>changes</name></name></expr>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>opt_change</name></name> <modifier>*</modifier></type><name>change</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>revert</name></expr>)</condition> <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>arg_type</name></name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>OPTION_ARG_NONE</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gboolean</name> <operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>bool</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPTION_ARG_INT</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gint</name> <operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>integer</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPTION_ARG_STRING</name></expr>:</case>
                <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPTION_ARG_STRING_ARRAY</name></expr>:</case>
                <expr_stmt><expr><call><name>g_strfreev</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>allocated</name><operator>.</operator><name>array</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gchar</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>array</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPTION_ARG_DOUBLE</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gdouble</name> <operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>dbl</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>OPTION_ARG_INT64</name></expr>:</case>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name>gint64</name> <operator>*</operator><operator>)</operator><name><name>change</name><operator>-&gt;</operator><name>arg_data</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>prev</name><operator>.</operator><name>int64</name></name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>g_assert_not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>changes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_pending_nulls</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>gboolean</name></type> <name>perform_nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>list</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>pending_nulls</name></name></expr>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>pending_null</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>perform_nulls</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* Copy back the short options */</comment>
                <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name><name>n</name><operator>-&gt;</operator><name>ptr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name><name>n</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>g_list_free</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pending_nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>pending_nulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * free the option context
 */</comment>
<function><type><name>void</name></type>
<name>chassis_options_free</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>context</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>g_list_free_full</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>(</operator><name>GDestroyNotify</name><operator>)</operator> <name>chassis_option_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_changes_list</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_pending_nulls</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>g_slice_free</name><argument_list>(<argument><expr><name>chassis_options_t</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>gboolean</name></type>
<name>chassis_options_parse_cmdline</name><parameter_list>(<parameter><decl><type><name>chassis_options_t</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>GError</name> <modifier>*</modifier><modifier>*</modifier></type><name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>argc</name> <operator>||</operator> <operator>!</operator><name>argv</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Set program name */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>g_get_prgname</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>argc</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>prgname</name> <init>= <expr><call><name>g_path_get_basename</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>g_set_prgname</name><argument_list>(<argument><expr><ternary><condition><expr><name>prgname</name></expr> ?</condition><then> <expr><name>prgname</name></expr> </then><else>: <expr><literal type="string">"&lt;unknown&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>g_free</name><argument_list>(<argument><expr><name>prgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>gboolean</name></type> <name>stop_parsing</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gboolean</name></type> <name>has_unknown</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gint</name></type> <name>separator_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gboolean</name></type> <name>parsed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>stop_parsing</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
                <comment type="block">/* -- option */</comment>

                <expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

                <comment type="block">/* '--' terminates list of arguments */</comment>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>separator_pos</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>stop_parsing</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Handle help options */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>help_enabled</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>print_help</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_long_option</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>parsed</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ignore_unknown</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>            <comment type="block">/* short option */</comment>
                <decl_stmt><decl><type><name>gint</name></type> <name>new_i</name> <init>= <expr><name>i</name></expr></init></decl>, <decl><type ref="prev"/><name>arg_length</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>gboolean</name> <modifier>*</modifier></type><name>nulled_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>gboolean</name></type> <name>has_h_entry</name> <init>= <expr><call><name>context_has_h_entry</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>arg_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nulled_out</name> <operator>=</operator> <call><name>g_newa</name><argument_list>(<argument><expr><name>gboolean</name></expr></argument>, <argument><expr><name>arg_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulled_out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>gboolean</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>arg_length</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>help_enabled</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <operator>(</operator><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_h_entry</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>print_help</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>parsed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_short_option</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_i</name></expr></argument>, <argument><expr><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ignore_unknown</name></name> <operator>&amp;&amp;</operator> <name>parsed</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>nulled_out</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ignore_unknown</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>parsed</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <comment type="block">/* !context-&gt;ignore_unknown &amp;&amp; parsed */</comment>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ignore_unknown</name></name></expr>)</condition> <block>{<block_content>
                    <decl_stmt><decl><type><name>gchar</name> <modifier>*</modifier></type><name>new_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>gint</name></type> <name>arg_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>arg_length</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulled_out</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_arg</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>new_arg</name> <operator>=</operator> <call><name>g_malloc</name><argument_list>(<argument><expr><name>arg_length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <expr_stmt><expr><name><name>new_arg</name><index>[<expr><name>arg_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <if_stmt><if>if <condition>(<expr><name>new_arg</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>new_arg</name><index>[<expr><name>arg_index</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>new_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>new_i</name></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>parsed</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>new_i</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsed</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>has_unknown</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>ignore_unknown</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>g_set_error</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR</name></expr></argument>, <argument><expr><name>G_OPTION_ERROR_UNKNOWN_OPTION</name></expr></argument>, <argument><expr><literal type="string">"Unknown option %s"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>fail</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">//if (context-&gt;strict_posix)</comment>
            <expr_stmt><expr><name>stop_parsing</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

            <comment type="block">/* Collect remaining args */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_remaining_arg</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>has_unknown</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>separator_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>separator_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>add_pending_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>separator_pos</name></expr>]</index><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&amp;&amp;</operator> <name>argv</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free_pending_nulls</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>k</name></expr>]</index> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

            <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>i</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>k</name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>k</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>j</name> <operator>-</operator> <name>k</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><operator>*</operator><name>argc</name> <operator>-=</operator> <name>k</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>

  <label><name>fail</name>:</label>
    <expr_stmt><expr><call><name>free_changes_list</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_pending_nulls</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>chassis_options_get</name><parameter_list>(<parameter><decl><type><name>GList</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>opts</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>opts</name></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>chassis_option_t</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><name>long_name</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>opt</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
