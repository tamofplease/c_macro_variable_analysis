<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/cetus/libev/ev.c"><comment type="block">/*
 * libev event processing core, watcher management
 *
 * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann &lt;libev@schmorp.de&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modifica-
 * tion, are permitted provided that the following conditions are met:
 *
 *   1.  Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
 * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
 * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
 * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License ("GPL") version 2 or any later version,
 * in which case the provisions of the GPL are applicable instead of
 * the above. If you wish to allow the use of your version of this file
 * only under the terms of the GPL and not to allow others to use your
 * version of this file under the BSD license, indicate your decision
 * by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL. If you do not delete the
 * provisions above, a recipient may use your version of this file under
 * either the BSD or the GPL.
 */</comment>

<comment type="block">/* this big block deduces configuration from config.h */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_STANDALONE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>EV_CONFIG_H</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> EV_CONFIG_H</cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_FLOOR</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_FLOOR</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_FLOOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_CLOCK_SYSCALL</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><operator>!</operator><name>defined</name> <name>EV_USE_CLOCK_SYSCALL</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_CLOCK_GETTIME</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_NANOSLEEP</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#   <cpp:directive>undef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:undef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_SELECT</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_SELECT_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_SELECT</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_SELECT</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_POLL</name> <operator>&amp;&amp;</operator> <name>HAVE_POLL_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_POLL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_POLL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
   
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_EPOLL_CTL</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_EPOLL_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
   
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_KQUEUE</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_EVENT_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
   
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_PORT_H</name> <operator>&amp;&amp;</operator> <name>HAVE_PORT_CREATE</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_PORT</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_PORT</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_INOTIFY_INIT</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_INOTIFY_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_SIGNALFD</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_SIGNALFD_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_EVENTFD</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EV_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> EV_H</cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>EV_NO_THREADS</name></expr></condition></ternary></expr></cpp:if>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_NO_SMP</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NO_SMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>ECB_NO_THREADS</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NO_THREADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>EV_NO_SMP</name></expr></condition></ternary></expr></cpp:if>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_NO_SMP</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NO_SMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* OS X, in its infinite idiocy, actually HARDCODES
 * a limit of 1024 into their select. Where people have brains,
 * OS X engineers apparently have a vacuum. Or maybe they were
 * ordered to have a vacuum, or they do anything for money.
 * This might help. Or not.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DARWIN_UNLIMITED_SELECT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* this block tries to deduce configuration from header-defined symbols and defaults */</comment>

<comment type="block">/* try to deduce the maximum number of signals on this platform */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>EV_NSIG</name></expr></condition></ternary></expr></cpp:if>
<comment type="block">/* use what's provided */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>NSIG</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(NSIG)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>_NSIG</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_NSIG)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>SIGMAX</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIGMAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>SIG_MAX</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIG_MAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>_SIG_MAX</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_SIG_MAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>MAXSIG</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(MAXSIG+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>MAX_SIG</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(MAX_SIG+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>SIGARRAYSIZE</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIGARRAYSIZE)</cpp:value></cpp:define> <comment type="block">/* Assume ary[SIGARRAYSIZE] */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>_sys_nsig</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_sys_nsig)</cpp:value></cpp:define> <comment type="block">/* Solaris 2.5 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(8 * sizeof (sigset_t) + 1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_FLOOR</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_FLOOR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&lt;</operator> <literal type="number">17</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><operator>!</operator><operator>(</operator><name>_POSIX_TIMERS</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>_POSIX_MONOTONIC_CLOCK</name> <operator>&amp;&amp;</operator> <name>_POSIX_MONOTONIC_CLOCK</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>!EV_USE_CLOCK_SYSCALL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>_POSIX_C_SOURCE</name> <operator>&gt;=</operator> <literal type="number">199309L</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_SELECT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_POLL</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_PORT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_PID_HASHSIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_PID_HASHSIZE</name></cpp:macro> <cpp:value>EV_FEATURE_DATA ? 16 : 1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_INOTIFY_HASHSIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INOTIFY_HASHSIZE</name></cpp:macro> <cpp:value>EV_FEATURE_DATA ? 16 : 1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* debugging */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_VERIFY</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_4HEAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_HEAP_CACHE_AT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_VERIFY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_VERIFY</name></cpp:macro> <cpp:value>(EV_FEATURE_API ? 1 : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_4HEAP</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_4HEAP</name></cpp:macro> <cpp:value>EV_FEATURE_DATA</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_HEAP_CACHE_AT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_HEAP_CACHE_AT</name></cpp:macro> <cpp:value>EV_FEATURE_DATA</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ANDROID</name></cpp:ifdef>
<comment type="block">/* supposedly, android doesn't typedef fd_mask */</comment>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_SELECT</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* supposedly, we need to include syscall.h, not sys/syscall.h, so just disable */</comment>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* aix's poll.h seems to cause lots of trouble */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
<comment type="block">/* AIX has a completely broken poll.h header */</comment>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_POLL</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* on linux, we can use a (slow) syscall to avoid a dependency on pthread, */</comment>
<comment type="block">/* which makes programs even slower. might work on other unices, too. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_CLOCK_SYSCALL</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/syscall.h&gt;</cpp:file></cpp:include>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>SYS_clock_gettime</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>clock_gettime</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>ts</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>syscall (SYS_clock_gettime, (id), (ts))</cpp:value></cpp:define>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* this block fixes any misconfiguration where we know we run into trouble otherwise */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CLOCK_MONOTONIC</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CLOCK_REALTIME</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>EV_STAT_ENABLE</name></expr></cpp:if>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>EV_USE_NANOSLEEP</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statfs.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/inotify.h&gt;</cpp:file></cpp:include>
<comment type="block">/* some very old inotify.h headers don't have IN_DONT_FOLLOW */</comment>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>IN_DONT_FOLLOW</name></cpp:ifndef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
<comment type="block">/* our minimum requirement is glibc 2.7 which has the stub, but not the header */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EFD_NONBLOCK</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_NONBLOCK</name></cpp:macro> <cpp:value>O_NONBLOCK</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EFD_CLOEXEC</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_CLOEXEC</name></cpp:macro> <cpp:value>O_CLOEXEC</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_CLOEXEC</name></cpp:macro> <cpp:value>02000000</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EV_CPP</name><argument_list>(<argument>extern <literal type="string">"C"</literal></argument>)</argument_list></macro> <function_decl><type><name>int</name></type> (<name>eventfd</name>) <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>initval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
<comment type="block">/* our minimum requirement is glibc 2.7 which has the stub, but not the header */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SFD_NONBLOCK</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_NONBLOCK</name></cpp:macro> <cpp:value>O_NONBLOCK</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SFD_CLOEXEC</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_CLOEXEC</name></cpp:macro> <cpp:value>O_CLOEXEC</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_CLOEXEC</name></cpp:macro> <cpp:value>02000000</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>EV_CPP</name> <argument_list>(<argument>extern <literal type="string">"C"</literal></argument>)</argument_list></macro> <function_decl><type><name>int</name></type> <name>signalfd</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sigset_t</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>signalfd_siginfo</name>
<block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ssi_signo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>pad</name><index>[<expr><literal type="number">128</literal> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FREQUENT_CHECK</name></cpp:macro> <cpp:value>ev_verify (EV_A)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FREQUENT_CHECK</name></cpp:macro> <cpp:value>do { } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * This is used to work around floating point rounding problems.
 * This value is good at least till the year 4000.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_INTERVAL</name></cpp:macro>  <cpp:value>0.0001220703125</cpp:value></cpp:define> <comment type="block">/* 1/2**13, good till 4000 */</comment>
<comment type="block">/*#define MIN_INTERVAL  0.00000095367431640625 /* 1/2**20, good till 2200 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_TIMEJUMP</name></cpp:macro>  <cpp:value>1.</cpp:value></cpp:define> <comment type="block">/* minimum timejump that gets detected (if monotonic clock available) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BLOCKTIME</name></cpp:macro> <cpp:value>59.743</cpp:value></cpp:define> <comment type="block">/* never wait longer than this time (to detect time jumps) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_TV_SET</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tv.tv_sec = (long)t; tv.tv_usec = (long)((t - tv.tv_sec) * 1e6); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_TS_SET</name><parameter_list>(<parameter><type><name>ts</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ts.tv_sec = (long)t; ts.tv_nsec = (long)((t - ts.tv_sec) * 1e9); } while (0)</cpp:value></cpp:define>

<comment type="block">/* the following is ecb.h embedded into libev - use update_ev_c to update from an external copy */</comment>
<comment type="block">/* ECB.H BEGIN */</comment>
<comment type="block">/*
 * libecb - http://software.schmorp.de/pkg/libecb
 *
 * Copyright (Â©) 2009-2015 Marc Alexander Lehmann &lt;libecb@schmorp.de&gt;
 * Copyright (Â©) 2011 Emanuele Giaquinta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modifica-
 * tion, are permitted provided that the following conditions are met:
 *
 *   1.  Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
 * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
 * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
 * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License ("GPL") version 2 or any later version,
 * in which case the provisions of the GPL are applicable instead of
 * the above. If you wish to allow the use of your version of this file
 * only under the terms of the GPL and not to allow others to use your
 * version of this file under the BSD license, indicate your decision
 * by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL. If you do not delete the
 * provisions above, a recipient may use your version of this file under
 * either the BSD or the GPL.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_H</name></cpp:macro></cpp:define>

<comment type="block">/* 16 bits major, 16 bits minor */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_VERSION</name></cpp:macro> <cpp:value>0x00010005</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>INTPTR_MAX</name> <operator>?</operator> <name>INTPTR_MAX</name> : <name>ULONG_MAX</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0xffffffffU</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_PTRSIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_PTRSIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_GCC_AMD64</name></cpp:macro> <cpp:value>(__amd64 || __amd64__ || __x86_64 || __x86_64__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MSVC_AMD64</name></cpp:macro> <cpp:value>(_M_AMD64 || _M_X64)</cpp:value></cpp:define>

<comment type="block">/* work around x32 idiocy by defining proper macros */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_GCC_AMD64</name> <operator>||</operator> <name>ECB_MSVC_AMD64</name></expr></cpp:if>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_ILP32</name></expr></cpp:if>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_AMD64_X32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_AMD64</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* many compilers define _GNUC_ to some versions but then only implement
 * what their idiot authors think are the "more important" extensions,
 * causing enormous grief in return for some better fake benchmark numbers.
 * or so.
 * we try to detect these and simply assume they are not gcc - if they have
 * an issue with that they should have done it right in the first place.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>__GNUC_MINOR__</name> <operator>||</operator> <name>defined</name> <name>__INTEL_COMPILER</name> <operator>||</operator> <name>defined</name> <name>__SUNPRO_C</name> <operator>||</operator> <name>defined</name> <name>__SUNPRO_CC</name> <operator>||</operator> <name>defined</name> <name>__llvm__</name> <operator>||</operator> <name>defined</name> <name>__clang__</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_GCC_VERSION</name><parameter_list>(<parameter><type><name>major</name></type></parameter>,<parameter><type><name>minor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_GCC_VERSION</name><parameter_list>(<parameter><type><name>major</name></type></parameter>,<parameter><type><name>minor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__GNUC__ &gt; (major) || (__GNUC__ == (major) &amp;&amp; __GNUC_MINOR__ &gt;= (minor)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CLANG_VERSION</name><parameter_list>(<parameter><type><name>major</name></type></parameter>,<parameter><type><name>minor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__clang_major__ &gt; (major) || (__clang_major__ == (major) &amp;&amp; __clang_minor__ &gt;= (minor)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__clang__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__has_builtin</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CLANG_BUILTIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__has_builtin (x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CLANG_BUILTIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__clang__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__has_extension</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CLANG_EXTENSION</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__has_extension (x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CLANG_EXTENSION</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CPP</name></cpp:macro>   <cpp:value>(__cplusplus+0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CPP11</name></cpp:macro> <cpp:value>(__cplusplus &gt;= 201103L)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_CPP</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_C</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STDC_VERSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_C</name></cpp:macro>            <cpp:value>1</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STDC_VERSION</name></cpp:macro> <cpp:value>__STDC_VERSION__</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_C99</name></cpp:macro>   <cpp:value>(ECB_STDC_VERSION &gt;= 199901L)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_C11</name></cpp:macro>   <cpp:value>(ECB_STDC_VERSION &gt;= 201112L)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_CPP</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C</name></cpp:macro> <cpp:value>extern "C"</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C_BEG</name></cpp:macro> <cpp:value>ECB_EXTERN_C {</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C_END</name></cpp:macro> <cpp:value>}</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C</name></cpp:macro> <cpp:value>extern</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C_BEG</name></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_EXTERN_C_END</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/* ECB_NO_THREADS - ecb is not used by multiple threads, ever */</comment>
<comment type="block">/* ECB_NO_SMP     - ecb might be used in multiple threads, but only on a single cpu */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_NO_THREADS</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NO_SMP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_NO_SMP</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro> <cpp:value>do { } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* http://www-01.ibm.com/support/knowledgecenter/SSGH3R_13.1.0/com.ibm.xlcpp131.aix.doc/compiler_ref/compiler_builtins.html */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__xlC__</name> <operator>&amp;&amp;</operator> <name>ECB_CPP</name></expr></cpp:if>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;builtins.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1400</literal> <operator>&lt;=</operator> <name>_MSC_VER</name></expr></cpp:if>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include> <comment type="block">/* fence functions _ReadBarrier, also bit search functions _BitScanReverse */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_MEMORY_FENCE</name></cpp:ifndef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>defined</name> <name>__INTEL_COMPILER</name> <operator>||</operator> <operator>(</operator><name>__llvm__</name> <operator>&amp;&amp;</operator> <name>__GNUC__</name><operator>)</operator> <operator>||</operator> <name>__SUNPRO_C</name> <operator>&gt;=</operator> <literal type="number">0x5110</literal> <operator>||</operator> <name>__SUNPRO_CC</name> <operator>&gt;=</operator> <literal type="number">0x5110</literal></expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386</name> <operator>||</operator> <name>__i386__</name></expr></cpp:if>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("lock; orb $0, -1(%%esp)" : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__asm__ __volatile__ (""                        : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__asm__ __volatile__ ("")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>ECB_GCC_AMD64</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("mfence"   : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__asm__ __volatile__ (""         : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__asm__ __volatile__ ("")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__powerpc__</name> <operator>||</operator> <name>__ppc__</name> <operator>||</operator> <name>__powerpc64__</name> <operator>||</operator> <name>__ppc64__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("sync"     : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__ARM_ARCH_2__</name> \
      <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_3__</name>  <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_3M__</name>  \
      <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_4__</name>  <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_4T__</name>  \
      <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_5__</name>  <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_5E__</name>  \
      <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_5T__</name> <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_5TE__</name> \
      <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_5TEJ__</name></expr></cpp:elif>
      <comment type="block">/* should not need any, unless running old code on newer cpu - arm doesn't support that */</comment>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__ARM_ARCH_6__</name>  <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_6J__</name>  \
       <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_6K__</name> <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_6ZK__</name> \
       <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_6T2__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("mcr p15,0,%0,c7,c10,5" : : "r" (0) : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__ARM_ARCH_7__</name>  <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_7A__</name>  \
       <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_7R__</name> <operator>||</operator> <name>defined</name> <name>__ARM_ARCH_7M__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("dmb"      : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__aarch64__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("dmb ish"  : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>__sparc</name> <operator>||</operator> <name>__sparc__</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>__sparc_v8__</name> <operator>||</operator> <name>defined</name> <name>__sparcv8</name><operator>)</operator></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("membar #LoadStore | #LoadLoad | #StoreStore | #StoreLoad" : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__asm__ __volatile__ ("membar #LoadStore | #LoadLoad"                            : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__asm__ __volatile__ ("membar #LoadStore             | #StoreStore")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__s390__</name> <operator>||</operator> <name>defined</name> <name>__s390x__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("bcr 15,0" : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__mips__</name></expr></cpp:elif>
      <comment type="block">/* GNU/Linux emulates sync on mips1 architectures, so we force its use */</comment>
      <comment type="block">/* anybody else who still uses mips1 is supposed to send in their version, with detection code. */</comment>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ (".set mips2; sync; .set mips0" : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__alpha__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("mb"       : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__hppa__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ (""         : : : "memory")</cpp:value></cpp:define>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__asm__ __volatile__ ("")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__ia64__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("mf"       : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__m68k__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ (""         : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__m88k__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ ("tb1 0,%%r0,128" : : : "memory")</cpp:value></cpp:define>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__sh__</name></expr></cpp:elif>
      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__asm__ __volatile__ (""         : : : "memory")</cpp:value></cpp:define>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_MEMORY_FENCE</name></cpp:ifndef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* see comment below (stdatomic.h) about the C11 memory model. */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__atomic_thread_fence (__ATOMIC_SEQ_CST)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__atomic_thread_fence (__ATOMIC_ACQUIRE)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__atomic_thread_fence (__ATOMIC_RELEASE)</cpp:value></cpp:define>

  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>ECB_CLANG_EXTENSION</name><argument_list>(<argument><expr><name>c_atomic</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="block">/* see comment below (stdatomic.h) about the C11 memory model. */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__c11_atomic_thread_fence (__ATOMIC_SEQ_CST)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__c11_atomic_thread_fence (__ATOMIC_ACQUIRE)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__c11_atomic_thread_fence (__ATOMIC_RELEASE)</cpp:value></cpp:define>

  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>defined</name> <name>__INTEL_COMPILER</name> <operator>||</operator> <name>defined</name> <name>__clang__</name></expr></cpp:elif>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__sync_synchronize ()</cpp:value></cpp:define>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1500</literal></expr></cpp:elif> <comment type="block">/* VC++ 2008 */</comment>
    <comment type="block">/* apparently, microsoft broke all the memory barrier stuff in Visual Studio 2008... */</comment>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_ReadBarrier</name><name>,</name><name>_WriteBarrier</name><name>,</name><name>_ReadWriteBarrier</name><name>)</name></cpp:pragma>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>_ReadWriteBarrier (); MemoryBarrier()</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>_ReadWriteBarrier (); MemoryBarrier()</cpp:value></cpp:define> <comment type="block">/* according to msdn, _ReadBarrier is not a load fence */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>_WriteBarrier (); MemoryBarrier()</cpp:value></cpp:define>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal></expr></cpp:elif> <comment type="block">/* VC++ 2005 */</comment>
    <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_ReadBarrier</name><name>,</name><name>_WriteBarrier</name><name>,</name><name>_ReadWriteBarrier</name><name>)</name></cpp:pragma>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>_ReadWriteBarrier ()</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>_ReadWriteBarrier ()</cpp:value></cpp:define> <comment type="block">/* according to msdn, _ReadBarrier is not a load fence */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>_WriteBarrier ()</cpp:value></cpp:define>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__SUNPRO_C</name> <operator>&gt;=</operator> <literal type="number">0x5110</literal> <operator>||</operator> <name>__SUNPRO_CC</name> <operator>&gt;=</operator> <literal type="number">0x5110</literal></expr></cpp:elif>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mbarrier.h&gt;</cpp:file></cpp:include>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__machine_rw_barrier ()</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>__machine_r_barrier  ()</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>__machine_w_barrier  ()</cpp:value></cpp:define>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__xlC__</name></expr></cpp:elif>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>__sync ()</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_MEMORY_FENCE</name></cpp:ifndef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_C11</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>__STDC_NO_ATOMICS__</name></expr></cpp:if>
    <comment type="block">/* we assume that these memory fences work on all variables/all memory accesses, */</comment>
    <comment type="block">/* not just C11 atomics and atomic accesses */</comment>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdatomic.h&gt;</cpp:file></cpp:include>
    <comment type="block">/* Unfortunately, neither gcc 4.7 nor clang 3.1 generate any instructions for */</comment>
    <comment type="block">/* any fence other than seq_cst, which isn't very efficient for us. */</comment>
    <comment type="block">/* Why that is, we don't know - either the C11 memory model is quite useless */</comment>
    <comment type="block">/* for most usages, or gcc and clang have a bug */</comment>
    <comment type="block">/* I *currently* lean towards the latter, and inefficiently implement */</comment>
    <comment type="block">/* all three of ecb's fences as a seq_cst fence */</comment>
    <comment type="block">/* Update, gcc-4.8 generates mfence for all c++ fences, but nothing */</comment>
    <comment type="block">/* for all __atomic_thread_fence's except seq_cst */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro>         <cpp:value>atomic_thread_fence (memory_order_seq_cst)</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_MEMORY_FENCE</name></cpp:ifndef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ECB_AVOID_PTHREADS</name></expr></cpp:if>
    <comment type="block">/*
     * if you get undefined symbol references to pthread_mutex_lock,
     * or failure to find pthread.h, then you should implement
     * the ECB_MEMORY_FENCE operations for your cpu/compiler
     * OR provide pthread.h and link against the posix thread library
     * of your system.
     */</comment>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NEEDS_PTHREADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_NEEDS_PTHREADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

    <decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>ecb_mf_lock</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro> <cpp:value>do { pthread_mutex_lock (&amp;ecb_mf_lock); pthread_mutex_unlock (&amp;ecb_mf_lock); } while (0)</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>ECB_MEMORY_FENCE_ACQUIRE</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>ECB_MEMORY_FENCE</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>ECB_MEMORY_FENCE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>ECB_MEMORY_FENCE_RELEASE</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>ECB_MEMORY_FENCE</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>ECB_MEMORY_FENCE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_CPP</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_inline</name></cpp:macro> <cpp:value>static inline</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_inline</name></cpp:macro> <cpp:value>static __inline__</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>ECB_C99</name></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_inline</name></cpp:macro> <cpp:value>static inline</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_inline</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_restrict</name></cpp:macro> <cpp:value>__restrict__</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>ECB_C99</name></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_restrict</name></cpp:macro> <cpp:value>restrict</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_restrict</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>int</name></type> <name>ecb_bool</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CONCAT_</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a ## b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_CONCAT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ECB_CONCAT_(a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STRINGIFY_</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value># a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STRINGIFY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ECB_STRINGIFY_(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STRINGIFY_EXPR</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((expr), ECB_STRINGIFY_ (expr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_function_</name></cpp:macro> <cpp:value>ecb_inline</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_VERSION</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_attribute</name><parameter_list>(<parameter><type><name>attrlist</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>__attribute__ (attrlist)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_attribute</name><parameter_list>(<parameter><type><name>attrlist</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_constant_p</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_is_constant</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>__builtin_constant_p (expr)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* possible C11 impl for integral types
  typedef struct ecb_is_constant_struct ecb_is_constant_struct;
  #define ecb_is_constant(expr)          _Generic ((1 ? (struct ecb_is_constant_struct *)0 : (void *)((expr) - (expr)), ecb_is_constant_struct *: 0, default: 1)) */</comment>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_is_constant</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_expect</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>__builtin_expect ((expr),(value))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>(expr)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_prefetch</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_prefetch</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>,<parameter><type><name>rw</name></type></parameter>,<parameter><type><name>locality</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_prefetch (addr, rw, locality)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_prefetch</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>,<parameter><type><name>rw</name></type></parameter>,<parameter><type><name>locality</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* no emulation for ecb_decltype */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_CPP11</name></expr></cpp:if>
  <comment type="line">// older implementations might have problems with decltype(x)::type, work around it</comment>
  <macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>T</name><operator>&gt;</operator> struct <name>ecb_decltype_t</name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_decltype</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_decltype_t&lt;decltype (x)&gt;::type</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_VERSION</name><argument_list>(<argument><expr><literal type="number">2</literal><operator>,</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_decltype</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__typeof__ (x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1300</literal></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_deprecated</name></cpp:macro> <cpp:value>__declspec (deprecated)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_deprecated</name></cpp:macro> <cpp:value>ecb_attribute ((__deprecated__))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1500</literal></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_deprecated_message</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__declspec (deprecated (msg))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_deprecated_message</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_attribute ((__deprecated__ (msg))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_deprecated_message</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_deprecated</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noinline</name></cpp:macro> <cpp:value>__declspec (noinline)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noinline</name></cpp:macro> <cpp:value>ecb_attribute ((__noinline__))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_unused</name></cpp:macro>     <cpp:value>ecb_attribute ((__unused__))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_const</name></cpp:macro>      <cpp:value>ecb_attribute ((__const__))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_pure</name></cpp:macro>       <cpp:value>ecb_attribute ((__pure__))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_C11</name> <operator>||</operator> <name>__IBMC_NORETURN</name></expr></cpp:if>
  <comment type="block">/* http://www-01.ibm.com/support/knowledgecenter/SSGH3R_13.1.0/com.ibm.xlcpp131.aix.doc/language_ref/noreturn.html */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noreturn</name></cpp:macro>   <cpp:value>_Noreturn</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>ECB_CPP11</name></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noreturn</name></cpp:macro>   <cpp:value>[[noreturn]]</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1200</literal></expr></cpp:elif>
  <comment type="block">/* http://msdn.microsoft.com/en-us/library/k6ktzx3s.aspx */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noreturn</name></cpp:macro>   <cpp:value>__declspec (noreturn)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_noreturn</name></cpp:macro>   <cpp:value>ecb_attribute ((__noreturn__))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_artificial</name></cpp:macro> <cpp:value>ecb_attribute ((__artificial__))</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_hot</name></cpp:macro>        <cpp:value>ecb_attribute ((__hot__))</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_cold</name></cpp:macro>       <cpp:value>ecb_attribute ((__cold__))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_artificial</name></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_hot</name></cpp:macro></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_cold</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* put around conditional expressions if you are very sure that the  */</comment>
<comment type="block">/* expression is mostly true or mostly false. note that these return */</comment>
<comment type="block">/* booleans, not the expression.                                     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_expect_false</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_expect (!!(expr), 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_expect_true</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>ecb_expect (!!(expr), 1)</cpp:value></cpp:define>
<comment type="block">/* for compatibility to the rest of the world */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_likely</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>ecb_expect_true  (expr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_unlikely</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_expect_false (expr)</cpp:value></cpp:define>

<comment type="block">/* count trailing zero bits and count # of one bits */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> \
    <operator>||</operator> <operator>(</operator><call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_clz</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_clzll</name></expr></argument>)</argument_list></call> \
        <operator>&amp;&amp;</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_ctz</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_ctzll</name></expr></argument>)</argument_list></call> \
        <operator>&amp;&amp;</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_popcount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <comment type="block">/* we assume int == 32 bit, long == 32 or 64 bit and long long == 64 bit */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ld32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(__builtin_clz      (x) ^ 31)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ld64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(__builtin_clzll    (x) ^ 63)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ctz32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>__builtin_ctz      (x)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ctz64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>__builtin_ctzll    (x)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_popcount32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_popcount (x)</cpp:value></cpp:define>
  <comment type="block">/* no popcountll */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ctz32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type>
  <name>ecb_ctz32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1400</literal> <operator>&lt;=</operator> <name>_MSC_VER</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>_M_IX86</name> <operator>||</operator> <name>_M_X64</name> <operator>||</operator> <name>_M_IA64</name> <operator>||</operator> <name>_M_ARM</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>_BitScanForward</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <operator>~</operator><name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* this isolates the lowest bit */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_branchless_on_i386</name></expr></cpp:if>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xaaaaaaaa</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xcccccccc</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xf0f0f0f0</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xff00ff00</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xffff0000</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xaaaaaaaa</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xcccccccc</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xf0f0f0f0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xff00ff00</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xffff0000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>r</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ctz64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type>
  <name>ecb_ctz64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1400</literal> <operator>&lt;=</operator> <name>_MSC_VER</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>_M_X64</name> <operator>||</operator> <name>_M_IA64</name> <operator>||</operator> <name>_M_ARM</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>_BitScanForward64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>shift</name> <init>= <expr><ternary><condition><expr><name>x</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ecb_ctz32</name> <argument_list>(<argument><expr><name>x</name> <operator>&gt;&gt;</operator> <name>shift</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>shift</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_popcount32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type>
  <name>ecb_popcount32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>-=</operator>  <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x55555555</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name>  <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name>  <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>x</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> <operator>*=</operator> <literal type="number">0x01010101</literal></expr>;</expr_stmt>

    <return>return <expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</return>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ld32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ld32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1400</literal> <operator>&lt;=</operator> <name>_MSC_VER</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>_M_IX86</name> <operator>||</operator> <name>_M_X64</name> <operator>||</operator> <name>_M_IA64</name> <operator>||</operator> <name>_M_ARM</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>_BitScanReverse</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">8</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator>  <literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">4</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator>  <literal type="number">4</literal></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">2</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator>  <literal type="number">2</literal></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">1</literal></expr>)</condition> <block>{<block_content>           <expr_stmt><expr><name>r</name> <operator>+=</operator>  <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

    <return>return <expr><name>r</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ld64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_ld64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1400</literal> <operator>&lt;=</operator> <name>_MSC_VER</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>_M_X64</name> <operator>||</operator> <name>_M_IA64</name> <operator>||</operator> <name>_M_ARM</name><operator>)</operator></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>_BitScanReverse64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">32</literal></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">32</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

    <return>return <expr><name>r</name> <operator>+</operator> <call><name>ecb_ld32</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_is_pot32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_is_pot32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_is_pot64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_is_pot64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_bitrev8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_bitrev8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator>  <operator>(</operator><name>x</name> <operator>*</operator> <literal type="number">0x0802U</literal> <operator>&amp;</operator> <literal type="number">0x22110U</literal><operator>)</operator>
          <operator>|</operator> <operator>(</operator><name>x</name> <operator>*</operator> <literal type="number">0x8020U</literal> <operator>&amp;</operator> <literal type="number">0x88440U</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">0x10101U</literal> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_bitrev16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_bitrev16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator>     <literal type="number">0x5555</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator>     <literal type="number">0x5555</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator>     <literal type="number">0x3333</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator>     <literal type="number">0x3333</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator>     <literal type="number">0x0f0f</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator>     <literal type="number">0x0f0f</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator> <name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">8</literal>              <operator>)</operator> <operator>|</operator> <operator>(</operator> <name>x</name>               <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_bitrev32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_bitrev32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00ff00ff</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x00ff00ff</literal><operator>)</operator> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator> <name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal>              <operator>)</operator> <operator>|</operator> <operator>(</operator> <name>x</name>               <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* popcount64 is only available on 64 bit cpus as gcc builtin */</comment>
<comment type="block">/* so for this version we are lazy */</comment>
<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type> <name>ecb_popcount64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>int</name></type>
<name>ecb_popcount64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>ecb_popcount32</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ecb_popcount32</name> <argument_list>(<argument><expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_rotl8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_rotr8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_rotl16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_rotr16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_rotl32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_rotr32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_rotl64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_rotr64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_rotl8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator> <literal type="number">8</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint8_t</name></type>  <name>ecb_rotr8</name>  <parameter_list>(<parameter><decl><type><name>uint8_t</name></type>  <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <operator>(</operator> <literal type="number">8</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_rotl16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">16</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_rotr16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">16</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_rotl32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_rotr32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_rotl64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_rotr64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>count</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <name>count</name><operator>)</operator></expr>;</return> </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_bswap32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_bswap64</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_bswap16</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>__builtin_bswap16 (x)</cpp:value></cpp:define>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__builtin_bswap32 (x) &gt;&gt; 16)</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>__builtin_bswap32 (x)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>__builtin_bswap64 (x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name></expr></cpp:elif>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint16_t)_byteswap_ushort ((uint16_t)(x)))</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint32_t)_byteswap_ulong  ((uint32_t)(x)))</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_bswap64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint64_t)_byteswap_uint64 ((uint64_t)(x)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_bswap16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type>
  <name>ecb_bswap16</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><call><name>ecb_rotl16</name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_bswap32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type>
  <name>ecb_bswap32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>ecb_bswap16</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <call><name>ecb_bswap16</name> <argument_list>(<argument><expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_bswap64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint64_t</name></type>
  <name>ecb_bswap64</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>ecb_bswap32</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>ecb_bswap32</name> <argument_list>(<argument><expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ECB_CLANG_BUILTIN</name><argument_list>(<argument><expr><name>__builtin_unreachable</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_unreachable</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>__builtin_unreachable ()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* this seems to work fine, but gcc always emits a warning for it :/ */</comment>
  <function_decl><type><name>ecb_inline</name> <name>ecb_noreturn</name> <name>void</name></type> <name>ecb_unreachable</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_inline</name> <name>ecb_noreturn</name> <name>void</name></type> <name>ecb_unreachable</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* try to tell the compiler that some condition is definitely true */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_assume</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (!(cond)) ecb_unreachable (); else 0</cpp:value></cpp:define>

<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_byteorder_helper</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>uint32_t</name></type>
<name>ecb_byteorder_helper</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* the union code still generates code under pressure in gcc, */</comment>
  <comment type="block">/* but less than using pointers, and always seems to */</comment>
  <comment type="block">/* successfully return a constant. */</comment>
  <comment type="block">/* the reason why we have this horrible preprocessor mess */</comment>
  <comment type="block">/* is to avoid it in all cases, at least on common architectures */</comment>
  <comment type="block">/* or when using a recent enough gcc version (&gt;= 4.6) */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>__BYTE_ORDER__</name> <operator>&amp;&amp;</operator> <name>__BYTE_ORDER__</name> <operator>==</operator> <name>__ORDER_LITTLE_ENDIAN__</name><operator>)</operator> \
    <operator>||</operator> <operator>(</operator><operator>(</operator><name>__i386</name> <operator>||</operator> <name>__i386__</name> <operator>||</operator> <name>_M_IX86</name> <operator>||</operator> <name>ECB_GCC_AMD64</name> <operator>||</operator> <name>ECB_MSVC_AMD64</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>__VOS__</name><operator>)</operator></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_LITTLE_ENDIAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <return>return <expr><literal type="number">0x44332211</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>__BYTE_ORDER__</name> <operator>&amp;&amp;</operator> <name>__BYTE_ORDER__</name> <operator>==</operator> <name>__ORDER_BIG_ENDIAN__</name><operator>)</operator> \
      <operator>||</operator> <operator>(</operator><operator>(</operator><name>__AARCH64EB__</name> <operator>||</operator> <name>__MIPSEB__</name> <operator>||</operator> <name>__ARMEB__</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>__VOS__</name><operator>)</operator></expr></cpp:elif>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_BIG_ENDIAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <return>return <expr><literal type="number">0x11223344</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <union>union
  <block>{
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name></decl>;</decl_stmt>
  }</block> <decl><name>u</name> <init>= <expr><block>{ <expr><literal type="number">0x11</literal></expr>, <expr><literal type="number">0x22</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0x44</literal></expr> }</block></expr></init></decl>;</union>
  <return>return <expr><name><name>u</name><operator>.</operator><name>u</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_big_endian</name>    <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_big_endian</name>    <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>ecb_byteorder_helper</name> <argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0x11223344</literal></expr>;</return> </block_content>}</block></function>
<function_decl><type><name>ecb_inline</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_little_endian</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_inline</name> <name>ecb_const</name> <name>ecb_bool</name></type> <name>ecb_little_endian</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>ecb_byteorder_helper</name> <argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0x44332211</literal></expr>;</return> </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>ECB_GCC_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>ECB_C99</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_mod</name><parameter_list>(<parameter><type><name>m</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((m) % (n) + ((m) % (n) &lt; 0 ? (n) : 0))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_mod</name><parameter_list>(<parameter><type><name>m</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((m) &lt; 0 ? ((n) - 1 - ((-1 - (m)) % (n))) : ((m) % (n)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_CPP</name></expr></cpp:if>
  <function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
  <specifier>static</specifier> <specifier>inline</specifier> <name>T</name></type> <name>ecb_div_rd</name> <parameter_list>(<parameter><decl><type><name>T</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>div</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator> <operator>(</operator><operator>(</operator><operator>-</operator><name>val</name> <operator>+</operator> <name>div</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>div</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>val</name>          <operator>)</operator> <operator>/</operator> <name>div</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></function>
  <function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
  <specifier>static</specifier> <specifier>inline</specifier> <name>T</name></type> <name>ecb_div_ru</name> <parameter_list>(<parameter><decl><type><name>T</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>div</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator> <operator>(</operator><operator>(</operator><operator>-</operator><name>val</name>          <operator>)</operator> <operator>/</operator> <name>div</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>val</name> <operator>+</operator> <name>div</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>div</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_div_rd</name><parameter_list>(<parameter><type><name>val</name></type></parameter>,<parameter><type><name>div</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((val) &lt; 0 ? - ((-(val) + (div) - 1) / (div)) : ((val)            ) / (div))</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_div_ru</name><parameter_list>(<parameter><type><name>val</name></type></parameter>,<parameter><type><name>div</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((val) &lt; 0 ? - ((-(val)            ) / (div)) : ((val) + (div) - 1) / (div))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ecb_cplusplus_does_not_suck</name></expr></cpp:if>
  <comment type="block">/* does not work for local types (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm) */</comment>
  <decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>int</name> <name>N</name></expr></argument>&gt;</argument_list></name>
  <specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ecb_array_length</name> <argument_list>(<argument><expr><specifier>const</specifier> <call><name>T</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>)</argument_list>
  <block>{<block_content>
    <return>return <expr><name>N</name></expr>;</return>
  </block_content>}</block></decl></decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_array_length</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof (name) / sizeof (name [0]))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_binary16_to_binary32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type>
<name>ecb_binary16_to_binary32</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>s</name> <init>= <expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x8000</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">31</literal> <operator>-</operator> <literal type="number">15</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>          <name>e</name> <init>= <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x001f</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name> <init>=  <expr><name>x</name>        <operator>&amp;</operator> <literal type="number">0x03ff</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_false</name> <argument_list>(<argument><expr><name>e</name> <operator>==</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <comment type="block">/* infinity or NaN */</comment>
    <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">255</literal> <operator>-</operator> <operator>(</operator><literal type="number">127</literal> <operator>-</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>ecb_expect_false</name> <argument_list>(<argument><expr><operator>!</operator><name>e</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* zero, handled by code below by forcing e to 0 */</comment>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal> <operator>-</operator> <operator>(</operator><literal type="number">127</literal> <operator>-</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
          <comment type="block">/* subnormal, renormalise */</comment>
          <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>s</name> <init>= <expr><literal type="number">10</literal> <operator>-</operator> <call><name>ecb_ld32</name> <argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>m</name> <operator>&lt;&lt;</operator> <name>s</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3ff</literal></expr>;</expr_stmt> <comment type="block">/* mask implicit bit */</comment>
          <expr_stmt><expr><name>e</name> <operator>-=</operator> <name>s</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* e and m now are normalised, or zero, (or inf or nan) */</comment>
  <expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">127</literal> <operator>-</operator> <literal type="number">15</literal></expr>;</expr_stmt>

  <return>return <expr><name>s</name> <operator>|</operator> <operator>(</operator><name>e</name> <operator>&lt;&lt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>m</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">23</literal> <operator>-</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_binary32_to_binary16</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type>
<name>ecb_binary32_to_binary16</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>s</name> <init>=  <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00008000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* sign bit, the easy part */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e</name> <init>= <expr><operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x000000ff</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">127</literal> <operator>-</operator> <literal type="number">15</literal><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* the desired exponent */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name> <init>=   <expr><name>x</name>        <operator>&amp;</operator> <literal type="number">0x007fffff</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>

  <comment type="block">/* if it's within range of binary16 normals, use fast path */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_true</name> <argument_list>(<argument><expr><literal type="number">0x38800000</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;=</operator> <literal type="number">0x477fefff</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* mantissa round-to-even */</comment>
      <expr_stmt><expr><name>m</name> <operator>+=</operator> <literal type="number">0x00000fff</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>m</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">23</literal> <operator>-</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

      <comment type="block">/* handle overflow */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_false</name> <argument_list>(<argument><expr><name>m</name> <operator>&gt;=</operator> <literal type="number">0x00800000</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>e</name> <operator>+=</operator>  <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <return>return <expr><name>s</name> <operator>|</operator> <operator>(</operator><name>e</name> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>m</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">23</literal> <operator>-</operator> <literal type="number">10</literal><operator>)</operator><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* handle large numbers and infinity */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_true</name> <argument_list>(<argument><expr><literal type="number">0x477fefff</literal> <operator>&lt;</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;=</operator> <literal type="number">0x7f800000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>s</name> <operator>|</operator> <literal type="number">0x7c00</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* handle zero, subnormals and small numbers */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_true</name> <argument_list>(<argument><expr><name>x</name> <operator>&lt;</operator> <literal type="number">0x38800000</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* zero */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ecb_expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>s</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* handle subnormals */</comment>

      <comment type="block">/* too small, will be zero */</comment>
      <if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">14</literal> <operator>-</operator> <literal type="number">24</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* might not be sharp, but is good enough */</comment>
        <return>return <expr><name>s</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>m</name> <operator>|=</operator> <literal type="number">0x00800000</literal></expr>;</expr_stmt> <comment type="block">/* make implicit bit explicit */</comment>

      <comment type="block">/* very tricky - we need to round to the nearest e (+10) bit value */</comment>
      <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bits</name> <init>= <expr><literal type="number">14</literal> <operator>-</operator> <name>e</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>half</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>even</name> <init>= <expr><operator>(</operator><name>m</name> <operator>&gt;&gt;</operator> <name>bits</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* if this overflows, we will end up with a normalised number */</comment>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>m</name> <operator>+</operator> <name>half</name> <operator>+</operator> <name>even</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>bits</name></expr>;</expr_stmt>
      </block_content>}</block>

      <return>return <expr><name>s</name> <operator>|</operator> <name>m</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* handle NaNs, preserve leftmost nan bits, but make sure we don't turn them into infinities */</comment>
  <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <literal type="number">13</literal></expr>;</expr_stmt>

  <return>return <expr><name>s</name> <operator>|</operator> <literal type="number">0x7c00</literal> <operator>|</operator> <name>m</name> <operator>|</operator> <operator>!</operator><name>m</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************************/</comment>
<comment type="block">/* floating point stuff, can be disabled by defining ECB_NO_LIBM */</comment>

<comment type="block">/* basically, everything uses "ieee pure-endian" floating point numbers */</comment>
<comment type="block">/* the only noteworthy exception is ancient armle, which uses order 43218765 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal> \
    <operator>||</operator> <name>__i386</name> <operator>||</operator> <name>__i386__</name> \
    <operator>||</operator> <name>ECB_GCC_AMD64</name> \
    <operator>||</operator> <name>__powerpc__</name> <operator>||</operator> <name>__ppc__</name> <operator>||</operator> <name>__powerpc64__</name> <operator>||</operator> <name>__ppc64__</name> \
    <operator>||</operator> <name>defined</name> <name>__s390__</name> <operator>||</operator> <name>defined</name> <name>__s390x__</name> \
    <operator>||</operator> <name>defined</name> <name>__mips__</name> \
    <operator>||</operator> <name>defined</name> <name>__alpha__</name> \
    <operator>||</operator> <name>defined</name> <name>__hppa__</name> \
    <operator>||</operator> <name>defined</name> <name>__ia64__</name> \
    <operator>||</operator> <name>defined</name> <name>__m68k__</name> \
    <operator>||</operator> <name>defined</name> <name>__m88k__</name> \
    <operator>||</operator> <name>defined</name> <name>__sh__</name> \
    <operator>||</operator> <name>defined</name> <name>_M_IX86</name> <operator>||</operator> <name>defined</name> <name>ECB_MSVC_AMD64</name> <operator>||</operator> <name>defined</name> <name>_M_IA64</name> \
    <operator>||</operator> <operator>(</operator><name>defined</name> <name>__arm__</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>defined</name> <name>__ARM_EABI__</name> <operator>||</operator> <name>defined</name> <name>__EABI__</name> <operator>||</operator> <name>defined</name> <name>__VFP_FP__</name> <operator>||</operator> <name>defined</name> <name>_WIN32_WCE</name> <operator>||</operator> <name>defined</name> <name>__ANDROID__</name><operator>)</operator><operator>)</operator> \
    <operator>||</operator> <name>defined</name> <name>__aarch64__</name></expr></cpp:if>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STDFP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include> <comment type="block">/* for memcpy */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_STDFP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_NO_LIBM</name></cpp:ifndef>

  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include> <comment type="block">/* for frexp*, ldexp*, INFINITY, NAN */</comment>

  <comment type="block">/* only the oldest of old doesn't have this one. solaris. */</comment>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFINITY</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_INFINITY</name></cpp:macro> <cpp:value>INFINITY</cpp:value></cpp:define>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_INFINITY</name></cpp:macro> <cpp:value>HUGE_VAL</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NAN</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NAN</name></cpp:macro> <cpp:value>NAN</cpp:value></cpp:define>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_NAN</name></cpp:macro> <cpp:value>ECB_INFINITY</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_C99</name> <operator>||</operator> <name>_XOPEN_VERSION</name> <operator>&gt;=</operator> <literal type="number">600</literal> <operator>||</operator> <name>_POSIX_VERSION</name> <operator>&gt;=</operator> <literal type="number">200112L</literal></expr></cpp:if>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ldexpf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ldexpf ((x), (e))</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_frexpf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>frexpf ((x), (e))</cpp:value></cpp:define>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_ldexpf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(float) ldexp ((double) (x), (e))</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ecb_frexpf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(float) frexp ((double) (x), (e))</cpp:value></cpp:define>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* convert a float to ieee single/binary32 */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type> <name>ecb_float_to_binary32</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint32_t</name></type>
  <name>ecb_float_to_binary32</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_STDFP</name></expr></cpp:if>
      <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* slow emulation, works for anything but -0 */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>m</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0e0f</literal></expr>                    )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x00000000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <operator>+</operator><literal type="number">3.40282346638528860e+38f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x7f800000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">3.40282346638528860e+38f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0xff800000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>x</name></expr>                       )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x7fbfffffU</literal></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>ecb_frexpf</name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0x1000000U</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>r</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <literal type="number">0x80000000U</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><name>m</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">126</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>m</name> <operator>&amp;=</operator> <literal type="number">0xffffffU</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <operator>(</operator><operator>-</operator><literal type="number">125</literal> <operator>-</operator> <name>e</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>-</operator><literal type="number">126</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><name>e</name> <operator>+</operator> <literal type="number">126</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">23</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <literal type="number">0x7fffffU</literal></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* converts an ieee single/binary32 to a float */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>float</name></type> <name>ecb_binary32_to_float</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>float</name></type>
  <name>ecb_binary32_to_float</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <decl_stmt><decl><type><name>float</name></type> <name>r</name></decl>;</decl_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_STDFP</name></expr></cpp:if>
      <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* emulation, only works for normals and subnormals and +0 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffU</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <literal type="number">0x7fffffU</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>x</name> <operator>|=</operator> <literal type="number">0x800000U</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <comment type="block">/* we distrust ldexpf a bit and do the 2**-24 scaling by an extra multiply */</comment>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ecb_ldexpf</name> <argument_list>(<argument><expr><name>x</name> <operator>*</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>/</operator> <literal type="number">0x800000U</literal><operator>)</operator></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <literal type="number">126</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>r</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><name>r</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* convert a double to ieee double/binary64 */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint64_t</name></type> <name>ecb_double_to_binary64</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint64_t</name></type>
  <name>ecb_double_to_binary64</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>r</name></decl>;</decl_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_STDFP</name></expr></cpp:if>
      <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* slow emulation, works for anything but -0 */</comment>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>m</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0e0</literal></expr>                     )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x0000000000000000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <operator>+</operator><literal type="number">1.79769313486231470e+308</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0x7ff0000000000000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1.79769313486231470e+308</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0xfff0000000000000U</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>x</name></expr>                       )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0X7ff7ffffffffffffU</literal></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>frexp</name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0x20000000000000U</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>r</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <literal type="number">0x8000000000000000</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><name>m</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">1022</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>m</name> <operator>&amp;=</operator> <literal type="number">0x1fffffffffffffU</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>m</name> <operator>&gt;&gt;=</operator> <operator>(</operator><operator>-</operator><literal type="number">1021</literal> <operator>-</operator> <name>e</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>-</operator><literal type="number">1022</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>+</operator> <literal type="number">1022</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <literal type="number">0xfffffffffffffU</literal></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* converts an ieee double/binary64 to a double */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>double</name></type> <name>ecb_binary64_to_double</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>double</name></type>
  <name>ecb_binary64_to_double</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_STDFP</name></expr></cpp:if>
      <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* emulation, only works for normals and subnormals and +0 */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7ffU</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <literal type="number">0xfffffffffffffU</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>x</name> <operator>|=</operator> <literal type="number">0x10000000000000U</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <comment type="block">/* we distrust ldexp a bit and do the 2**-53 scaling by an extra multiply */</comment>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldexp</name> <argument_list>(<argument><expr><name>x</name> <operator>*</operator> <operator>(</operator><literal type="number">0.5</literal> <operator>/</operator> <literal type="number">0x10000000000000U</literal><operator>)</operator></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <literal type="number">1022</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>r</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><name>r</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* convert a float to ieee half/binary16 */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type> <name>ecb_float_to_binary16</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>uint16_t</name></type>
  <name>ecb_float_to_binary16</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><call><name>ecb_binary32_to_binary16</name> <argument_list>(<argument><expr><call><name>ecb_float_to_binary32</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block">/* convert an ieee half/binary16 to float */</comment>
  <function_decl><type><name>ecb_function_</name> <name>ecb_const</name> <name>float</name></type> <name>ecb_binary16_to_float</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
  <function><type><name>ecb_function_</name> <name>ecb_const</name> <name>float</name></type>
  <name>ecb_binary16_to_float</name> <parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
  <block>{<block_content>
    <return>return <expr><call><name>ecb_binary32_to_float</name> <argument_list>(<argument><expr><call><name>ecb_binary16_to_binary32</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ECB.H END */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ECB_MEMORY_FENCE_NEEDS_PTHREADS</name></expr></cpp:if>
<comment type="block">/* if your architecture doesn't need memory fences, e.g. because it is
 * single-cpu/core, or if you use libev in a project that doesn't use libev
 * from multiple threads, then you can define ECB_AVOID_PTHREADS when compiling
 * libev, in which cases the memory fences become nops.
 * alternatively, you can remove this #error and link against libpthread,
 * which will then provide the memory fences.
 */</comment>
<cpp:error># <cpp:directive>error</cpp:directive> <cpp:literal>"memory fences not defined for your architecture, please report"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECB_MEMORY_FENCE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE</name></cpp:macro> <cpp:value>do { } while (0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_ACQUIRE</name></cpp:macro> <cpp:value>ECB_MEMORY_FENCE</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ECB_MEMORY_FENCE_RELEASE</name></cpp:macro> <cpp:value>ECB_MEMORY_FENCE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expect_false</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ecb_expect_false (cond)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expect_true</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>ecb_expect_true  (cond)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>noinline</name></cpp:macro>           <cpp:value>ecb_noinline</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inline_size</name></cpp:macro>        <cpp:value>ecb_inline</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_CODE</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>inline_speed</name></cpp:macro>      <cpp:value>ecb_inline</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>inline_speed</name></cpp:macro>      <cpp:value>noinline static</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMPRI</name></cpp:macro> <cpp:value>(EV_MAXPRI - EV_MINPRI + 1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MINPRI</name> <operator>==</operator> <name>EV_MAXPRI</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ABSPRI</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((W)w), 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ABSPRI</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((W)w)-&gt;priority - EV_MINPRI)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY</name></cpp:macro></cpp:define>       <comment type="block">/* required for microsofts broken pseudo-c compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* used to suppress some warnings */</comment>

<typedef>typedef <type><name>ev_watcher</name> <modifier>*</modifier></type><name>W</name>;</typedef>
<typedef>typedef <type><name>ev_watcher_list</name> <modifier>*</modifier></type><name>WL</name>;</typedef>
<typedef>typedef <type><name>ev_watcher_time</name> <modifier>*</modifier></type><name>WT</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_active</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((W)(w))-&gt;active</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_at</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((WT)(w))-&gt;at</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>
<comment type="block">/* sig_atomic_t is used to avoid per-thread variables or locking but still */</comment>
<comment type="block">/* giving it a reasonably high chance of working on typical architectures */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>EV_ATOMIC_T</name></type> <name>have_realtime</name></decl>;</decl_stmt> <comment type="block">/* did clock_gettime (CLOCK_REALTIME) work? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>EV_ATOMIC_T</name></type> <name>have_monotonic</name></decl>;</decl_stmt> <comment type="block">/* did clock_gettime (CLOCK_MONOTONIC) work? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_FD_TO_WIN32_HANDLE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FD_TO_WIN32_HANDLE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_get_osfhandle (fd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_WIN32_HANDLE_TO_FD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_WIN32_HANDLE_TO_FD</name><parameter_list>(<parameter><type><name>handle</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_open_osfhandle (handle, 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_WIN32_CLOSE_FD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_WIN32_CLOSE_FD</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>close (fd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/* define a suitable floor function (only used by periodics atm) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_FLOOR</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ev_floor</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>floor (v)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<comment type="block">/* a floor() replacement function, should be independent of ev_tstamp type */</comment>
<function><type><name>noinline</name>
<specifier>static</specifier> <name>ev_tstamp</name></type>
<name>ev_floor</name> <parameter_list>(<parameter><decl><type><name>ev_tstamp</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* the choice of shift factor is not terribly important */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FLT_RADIX</name> <operator>!=</operator> <literal type="number">2</literal></expr></cpp:if> <comment type="block">/* assume FLT_RADIX == 10 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>ev_tstamp</name></type> <name>shift</name> <init>= <expr><ternary><condition><expr>sizeof <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">10000000000000000000.</literal></expr> </then><else>: <expr><literal type="number">1000000000.</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>const</specifier> <name>ev_tstamp</name></type> <name>shift</name> <init>= <expr><ternary><condition><expr>sizeof <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">18446744073709551616.</literal></expr> </then><else>: <expr><literal type="number">4294967296.</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* argument too large for an unsigned long? */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>v</name> <operator>&gt;=</operator> <name>shift</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>f</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>v</name> <operator>-</operator> <literal type="number">1.</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* very large number */</comment>

      <expr_stmt><expr><name>f</name> <operator>=</operator> <name>shift</name> <operator>*</operator> <call><name>ev_floor</name> <argument_list>(<argument><expr><name>v</name> <operator>*</operator> <operator>(</operator><literal type="number">1.</literal> <operator>/</operator> <name>shift</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>f</name> <operator>+</operator> <call><name>ev_floor</name> <argument_list>(<argument><expr><name>v</name> <operator>-</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* special treatment for negative args? */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>v</name> <operator>&lt;</operator> <literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>f</name> <init>= <expr><operator>-</operator><call><name>ev_floor</name> <argument_list>(<argument><expr><operator>-</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <return>return <expr><name>f</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>f</name> <operator>==</operator> <name>v</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* fits into an unsigned long */</comment>
  <return>return <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>v</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>ev_linux_version</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>release</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>uname</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>--</operator><name>i</name></expr>;</condition> <incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
              <expr_stmt><expr><name>p</name> <operator>+=</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

      <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></for>

  <return>return <expr><name>v</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>ev_printerr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>write</name> <argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*syserr_cb</argument>)</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><name>msg</name><operator>)</operator> <name>EV_THROW</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ecb_cold</name>
<name>void</name></type>
<name>ev_set_syserr_cb</name> <argument_list>(<argument><expr><macro><name>void</name> <argument_list>(<argument>*cb</argument>)</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><name>msg</name><operator>)</operator> <name>EV_THROW</name></expr></argument>)</argument_list> <name>EV_THROW</name>
<block>{<block_content>
  <expr_stmt><expr><name>syserr_cb</name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>ev_syserr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"(libev) system error"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>syserr_cb</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>syserr_cb</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
      <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>ev_realloc_emul</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <comment type="block">/* some systems, notably openbsd and darwin, fail to properly
   * implement realloc (x, 0) (as required by both ansi c-89 and
   * the single unix specification, so work around them here.
   * recently, also (at least) fedora and debian started breaking it,
   * despite documenting it otherwise.
   */</comment>

  <if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <name>void</name> <operator>*</operator><operator>(</operator><operator>*</operator><name>alloc</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><name>ptr</name><operator>,</operator> <name>long</name> <name>size</name><operator>)</operator> <name>EV_THROW</name> <operator>=</operator> <name>ev_realloc_emul</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ecb_cold</name>
<name>void</name></type>
<name>ev_set_allocator</name> <argument_list>(<argument><expr><name>void</name> <operator>*</operator><operator>(</operator><operator>*</operator><name>cb</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><name>ptr</name><operator>,</operator> <name>long</name> <name>size</name><operator>)</operator> <name>EV_THROW</name></expr></argument>)</argument_list> <name>EV_THROW</name>
<block>{<block_content>
  <expr_stmt><expr><name>alloc</name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>inline_speed</name> <name>void</name> <modifier>*</modifier></type>
<name>ev_realloc</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>alloc</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>&amp;&amp;</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
      <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">"(libev) memory allocation failed, aborting.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(libev) cannot allocate %ld bytes, aborting."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_malloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ev_realloc (0, (size))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>ev_realloc ((ptr), 0)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/* set in reify when reification needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ANFD_REIFY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* file descriptor info structure */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <decl_stmt><decl><type><name>WL</name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>events</name></decl>;</decl_stmt> <comment type="block">/* the events watched for */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>reify</name></decl>;</decl_stmt>  <comment type="block">/* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>emask</name></decl>;</decl_stmt>  <comment type="block">/* the epoll backend stores the actual kernel mask in here */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>unused</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>egen</name></decl>;</decl_stmt>    <comment type="block">/* generation counter to counter epoll bugs */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SELECT_IS_WINSOCKET</name> <operator>||</operator> <name>EV_USE_IOCP</name></expr></cpp:if>
  <decl_stmt><decl><type><name>SOCKET</name></type> <name>handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_IOCP</name></expr></cpp:if>
  <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>or</name></decl>, <name>ow</name>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ANFD</name>;</typedef>

<comment type="block">/* stores the pending event set for a given watcher */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <decl_stmt><decl><type><name>W</name></type> <name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>events</name></decl>;</decl_stmt> <comment type="block">/* the pending event set for the given watcher */</comment>
}</block></struct></type> <name>ANPENDING</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
<comment type="block">/* hash table entry per inotify-id */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <decl_stmt><decl><type><name>WL</name></type> <name>head</name></decl>;</decl_stmt>
}</block></struct></type> <name>ANFS</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Heap Entry */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_HEAP_CACHE_AT</name></expr></cpp:if>
  <comment type="block">/* a heap element */</comment>
  <typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>at</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WT</name></type> <name>w</name></decl>;</decl_stmt>
  }</block></struct></type> <name>ANHE</name>;</typedef>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_w</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(he).w</cpp:value></cpp:define>     <comment type="block">/* access watcher, read-write */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(he).at</cpp:value></cpp:define>    <comment type="block">/* access cached at, read-only */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at_cache</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(he).at = (he).w-&gt;at</cpp:value></cpp:define> <comment type="block">/* update at from watcher */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* a heap element */</comment>
  <typedef>typedef <type><name>WT</name></type> <name>ANHE</name>;</typedef>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_w</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(he)</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(he)-&gt;at</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at_cache</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

  <struct>struct <name>ev_loop</name>
  <block>{
    <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>ev_rt_now</name></decl>;</decl_stmt>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_rt_now</name></cpp:macro> <cpp:value>((loop)-&gt;ev_rt_now)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>decl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>decl;</cpp:value></cpp:define>
      <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_vars.h"</cpp:file></cpp:include>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VAR</name></cpp:undef>
  }</block>;</struct>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_wrap.h"</cpp:file></cpp:include>

  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>ev_loop</name></name></type> <name>default_loop_struct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>ev_loop</name></name> <modifier>*</modifier></type><name>ev_default_loop_ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* needs to be initialised to make it a definition despite extern */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <decl_stmt><decl><type><name>EV_API_DECL</name> <name>ev_tstamp</name></type> <name>ev_rt_now</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* needs to be initialised to make it a definition despite extern */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>decl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static decl;</cpp:value></cpp:define>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_vars.h"</cpp:file></cpp:include>
  <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VAR</name></cpp:undef>

  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ev_default_loop_ptr</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_RELEASE_CB</name></cpp:macro> <cpp:value>if (expect_false (release_cb)) release_cb (EV_A)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ACQUIRE_CB</name></cpp:macro> <cpp:value>if (expect_false (acquire_cb)) acquire_cb (EV_A)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INVOKE_PENDING</name></cpp:macro> <cpp:value>invoke_cb (EV_A)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_RELEASE_CB</name></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ACQUIRE_CB</name></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INVOKE_PENDING</name></cpp:macro> <cpp:value>ev_invoke_pending (EV_A)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVBREAK_RECURSE</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_HAVE_EV_TIME</name></cpp:ifndef>
<function><type><name>ev_tstamp</name></type>
<name>ev_time</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_realtime</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>*</operator> <literal type="number">1e-9</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>gettimeofday</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1e-6</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>inline_size</name> <name>ev_tstamp</name></type>
<name>get_clock</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_monotonic</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>*</operator> <literal type="number">1e-9</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
<function><type><name>ev_tstamp</name></type>
<name>ev_now</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>ev_rt_now</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ev_sleep</name> <parameter_list>(<parameter><decl><type><name>ev_tstamp</name></type> <name>delay</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <literal type="number">0.</literal></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_NANOSLEEP</name></expr></cpp:if>
      <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>EV_TS_SET</name> <argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nanosleep</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

      <comment type="block">/* here we rely on sys/time.h + sys/types.h + unistd.h providing select */</comment>
      <comment type="block">/* something not guaranteed by newer posix versions, but guaranteed */</comment>
      <comment type="block">/* by older ones */</comment>
      <expr_stmt><expr><call><name>EV_TV_SET</name> <argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>select</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ROUND</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define> <comment type="block">/* prefer to allocate in chunks of this size, must be 2**n and &gt;&gt; 4 longs */</comment>

<comment type="block">/* find a suitable new size for the given array, */</comment>
<comment type="block">/* hopefully by rounding to a nice-to-malloc size */</comment>
<function><type><name>inline_size</name> <name>int</name></type>
<name>array_nextsize</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ncur</name> <init>= <expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <do>do<block type="pseudo"><block_content>
    <expr_stmt><expr><name>ncur</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block>
  while <condition>(<expr><name>cnt</name> <operator>&gt;</operator> <name>ncur</name></expr>)</condition>;</do>

  <comment type="block">/* if size is large, round to MALLOC_ROUND - 4 * longs to accommodate malloc overhead */</comment>
  <if_stmt><if>if <condition>(<expr><name>elem</name> <operator>*</operator> <name>ncur</name> <operator>&gt;</operator> <name>MALLOC_ROUND</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>ncur</name> <operator>*=</operator> <name>elem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ncur</name> <operator>=</operator> <operator>(</operator><name>ncur</name> <operator>+</operator> <name>elem</name> <operator>+</operator> <operator>(</operator><name>MALLOC_ROUND</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MALLOC_ROUND</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ncur</name> <operator>=</operator> <name>ncur</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>ncur</name> <operator>/=</operator> <name>elem</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><name>ncur</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>array_realloc</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <call><name>array_nextsize</name> <argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>*</operator><name>cur</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ev_realloc</name> <argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>elem</name> <operator>*</operator> <operator>*</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_init_zero</name><parameter_list>(<parameter><type><name>base</name></type></parameter>,<parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro>	\
  <cpp:value>memset ((void *)(base), 0, sizeof (*(base)) * (count))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_needsize</name><parameter_list>(<parameter><type><name>type</name></type></parameter>,<parameter><type><name>base</name></type></parameter>,<parameter><type><name>cur</name></type></parameter>,<parameter><type><name>cnt</name></type></parameter>,<parameter><type><name>init</name></type></parameter>)</parameter_list></cpp:macro>			\
  <cpp:value>if (expect_false ((cnt) &gt; (cur)))				\
    {								\
      ecb_unused int ocur_ = (cur);				\
      (base) = (type *)array_realloc				\
         (sizeof (type), (base), &amp;(cur), (cnt));		\
      init ((base) + (ocur_), (cur) - ocur_);			\
    }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_slim</name><parameter_list>(<parameter><type><name>type</name></type></parameter>,<parameter><type><name>stem</name></type></parameter>)</parameter_list></cpp:macro>					\
  <cpp:value>if (stem ## max &lt; array_roundsize (stem ## cnt &gt;&gt; 2))		\
    {								\
      stem ## max = array_roundsize (stem ## cnt &gt;&gt; 1);		\
      base = (type *)ev_realloc (base, sizeof (type) * (stem ## max));\
      fprintf (stderr, "slimmed down " # stem " to %d\n", stem ## max);<comment type="block">/*D*/</comment>\
    }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_free</name><parameter_list>(<parameter><type><name>stem</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>ev_free (stem ## s idx); stem ## cnt idx = stem ## max idx = 0; stem ## s idx = 0</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/* dummy callback for pending events */</comment>
<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>pendingcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_feed_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>W</name></type> <name>w_</name> <init>= <expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pri</name> <init>= <expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>revents</name></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <operator>++</operator><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANPENDING</name></expr></argument>, <argument><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pendingmax</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name>      <operator>=</operator> <name>w_</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>revents</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>pendingpri</name> <operator>=</operator> <name>NUMPRI</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_speed</name> <name>void</name></type>
<name>feed_reverse</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>W</name></expr></argument>, <argument><expr><name>rfeeds</name></expr></argument>, <argument><expr><name>rfeedmax</name></expr></argument>, <argument><expr><name>rfeedcnt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rfeeds</name> <index>[<expr><name>rfeedcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>feed_reverse_done</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <do>do<block type="pseudo"><block_content>
    <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ rfeeds [--rfeedcnt]</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block>
  while <condition>(<expr><name>rfeedcnt</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><name>inline_speed</name> <name>void</name></type>
<name>queue_events</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eventcnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>eventcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
    <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ events [i]</argument>, <argument>type</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<function><type><name>inline_speed</name> <name>void</name></type>
<name>fd_event_nocheck</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ANFD</name> <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfd</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ev</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>revents</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>ev</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* do not submit kernel events for fds that have reify set */</comment>
<comment type="block">/* because that means they changed while we were polling for new events */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>fd_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ANFD</name> <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <macro><name>fd_event_nocheck</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_feed_fd_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>)</condition><block type="pseudo"><block_content>
    <macro><name>fd_event_nocheck</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* make sure the external fd watch events are in-sync */</comment>
<comment type="block">/* with the kernel/libev internal state */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>fd_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SELECT_IS_WINSOCKET</name> <operator>||</operator> <name>EV_USE_IOCP</name></expr></cpp:if>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fdchangecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>fdchanges</name> <index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ANFD</name> <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name> <operator>&amp;</operator> <name>EV__IOFDSET</name> <operator>&amp;&amp;</operator> <name><name>anfd</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>SOCKET</name></type> <name>handle</name> <init>= <expr><call><name>EV_FD_TO_WIN32_HANDLE</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>!=</operator> <name><name>anfd</name><operator>-&gt;</operator><name>handle</name></name></expr>)</condition>
            <block>{<block_content>
              <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>arg</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: only socket fds supported in this configuration"</literal><operator>,</operator> <call><name>ioctlsocket</name> <argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* handle changed, but fd didn't - we need to do it in two steps */</comment>
              <macro><name>backend_modify</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>anfd-&gt;events</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
              <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fdchangecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>fdchanges</name> <index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ANFD</name> <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>o_events</name> <init>= <expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>o_reify</name>  <init>= <expr><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/*if (expect_true (o_reify &amp; EV_ANFD_REIFY)) probably a deoptimisation */</comment>
        <block>{<block_content>
          <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

          <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfd</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>w</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt></block_content></block></for>

          <if_stmt><if>if <condition>(<expr><name>o_events</name> <operator>!=</operator> <name><name>anfd</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>o_reify</name> <operator>=</operator> <name>EV__IOFDSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* actually |= */</comment>
        </block_content>}</block>

      <if_stmt><if>if <condition>(<expr><name>o_reify</name> <operator>&amp;</operator> <name>EV__IOFDSET</name></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>backend_modify</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>o_events</argument>, <argument>anfd-&gt;events</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><name>fdchangecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* something about the given fd changed */</comment>
<function><type><name>inline_size</name>
<name>void</name></type>
<name>fd_change</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>reify</name> <init>= <expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>reify</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>reify</name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name>reify</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>fdchangecnt</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>fdchanges</name></expr></argument>, <argument><expr><name>fdchangemax</name></expr></argument>, <argument><expr><name>fdchangecnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fdchanges</name> <index>[<expr><name>fdchangecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* the given fd is invalid/unusable, so make sure it doesn't hurt us anymore */</comment>
<function><type><name>inline_speed</name> <name>ecb_cold</name> <name>void</name></type>
<name>fd_kill</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>head</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <macro><name>ev_io_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_ERROR</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* check whether the given fd is actually valid, for error recovery */</comment>
<function><type><name>inline_size</name> <name>ecb_cold</name> <name>int</name></type>
<name>fd_valid</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* called on EBADF to verify fds */</comment>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>fd_ebadf</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>fd</name></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fd_valid</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>fd_kill</name> <argument_list>(<argument>EV_A_ fd</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* called on ENOMEM in select/poll to kill some fds and retry */</comment>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>fd_enomem</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <name>anfdmax</name></expr>;</init> <condition><expr><name>fd</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition>
      <block>{<block_content>
        <macro><name>fd_kill</name> <argument_list>(<argument>EV_A_ fd</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* usually called after fork if backend needs to re-arm all fds from scratch */</comment>
<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>fd_rearm_all</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>fd</name></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>emask</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>EV__IOFDSET | EV_ANFD_REIFY</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* used to prepare libev internal fd's */</comment>
<comment type="block">/* this is not fork-safe */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>fd_intern</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/*
 * the heap functions want a real array index. array index 0 is guaranteed to not
 * be in-use at any time. the first heap entry is at array [HEAP0]. DHEAP gives
 * the branching factor of the d-tree.
 */</comment>

<comment type="block">/*
 * at the moment we allow libev the luxury of two heaps,
 * a small-code-size 2-heap one and a ~1.5kb larger 4-heap
 * which is more cache-efficient.
 * the difference is about 5% with 50000+ watchers.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_4HEAP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DHEAP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP0</name></cpp:macro> <cpp:value>(DHEAP - 1)</cpp:value></cpp:define> <comment type="block">/* index of first element in heap */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HPARENT</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((k) - HEAP0 - 1) / DHEAP) + HEAP0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPHEAP_DONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) == (k))</cpp:value></cpp:define>

<comment type="block">/* away from the root */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>downheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ANHE</name></type> <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><name>heap</name> <operator>+</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>minat</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>minpos</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>pos</name> <init>= <expr><name>heap</name> <operator>+</operator> <name>DHEAP</name> <operator>*</operator> <operator>(</operator><name>k</name> <operator>-</operator> <name>HEAP0</name><operator>)</operator> <operator>+</operator> <name>HEAP0</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* find minimum child */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <name>DHEAP</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>E</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* fast path */</comment>                               <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>E</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* slow path */</comment>                               <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <break>break;</break></block_content></block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>minpos</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>minpos</name> <operator>-</operator> <name>heap</name></expr>;</expr_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* 4HEAP */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP0</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HPARENT</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((k) &gt;&gt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPHEAP_DONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!(p))</cpp:value></cpp:define>

<comment type="block">/* away from the root */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>downheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ANHE</name></type> <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name>k</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>c</name> <operator>+=</operator> <ternary><condition><expr><name>c</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
           ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* towards the root */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>upheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ANHE</name></type> <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>UPHEAP_DONE</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name> <index>[<expr><name>p</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* move an element suitably so it is in a correct place */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>adjustheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>HEAP0</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* rebuild the heap: this function is used only once and executed rarely */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>reheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */</comment>
  <comment type="block">/* also, this is easy to implement and correct for both 2-heaps and 4-heaps */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<comment type="block">/* associate signal watchers to a signal signal */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <decl_stmt><decl><type><name>EV_ATOMIC_T</name></type> <name>pending</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <expr_stmt><expr><name>EV_P</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>WL</name></type> <name>head</name></decl>;</decl_stmt>
}</block></struct></type> <name>ANSIG</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ANSIG</name></type> <name><name>signals</name> <index>[<expr><name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>evpipe_init</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name><name>fds</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
      <expr_stmt><expr><name><name>fds</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>eventfd</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EFD_NONBLOCK</name> <operator>|</operator> <name>EFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>eventfd</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <while>while <condition>(<expr><call><name>pipe</name> <argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_syserr</name> <argument_list>(<argument><expr><literal type="string">"(libev) error creating signal/async pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

          <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name><name>fds</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>fds</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* first call, set write fd */</comment>
      <else>else
        <block>{<block_content>
          <comment type="block">/* on subsequent calls, do not change evpipe [1] */</comment>
          <comment type="block">/* so that evpipe_write can always rely on its value. */</comment>
          <comment type="block">/* this branch does not do anything sensible on windows, */</comment>
          <comment type="block">/* so must not be executed on windows */</comment>

          <expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name><name>fds</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* watcher should not keep loop alive */</comment>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>inline_speed</name> <name>void</name></type>
<name>evpipe_write</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>EV_ATOMIC_T</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt> <comment type="block">/* push out the write before this function was called, acquire flag */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>*</operator><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>flag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ECB_MEMORY_FENCE_RELEASE</name></expr>;</expr_stmt> <comment type="block">/* make sure flag is visible before the wakeup */</comment>

  <expr_stmt><expr><name>pipe_write_skipped</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt> <comment type="block">/* make sure pipe_write_skipped is visible before we check pipe_write_wanted */</comment>

  <if_stmt><if>if <condition>(<expr><name>pipe_write_wanted</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>old_errno</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>pipe_write_skipped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>ECB_MEMORY_FENCE_RELEASE</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>old_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt> <comment type="block">/* save errno because write will clobber it */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>uint64_t</name></type> <name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>write</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>counter</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <expr_stmt><expr><call><name>write</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>old_errno</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* called whenever the libev signal pipe */</comment>
<comment type="block">/* got some events (signal, async) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pipecb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>iow</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>revents</name> <operator>&amp;</operator> <name>EV_READ</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>uint64_t</name></type> <name>counter</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>read</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>counter</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>dummy</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>read</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pipe_write_skipped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt> <comment type="block">/* push out skipped, acquire flags */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>sig_pending</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>sig_pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>signals</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pending</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <macro><name>ev_feed_signal_event</name> <argument_list>(<argument>EV_A_ i + <literal type="number">1</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>async_pending</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>async_pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>asynccnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>asyncs</name> <index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sent</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ECB_MEMORY_FENCE_RELEASE</name></expr>;</expr_stmt>
            <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ asyncs [i]</argument>, <argument>EV_ASYNC</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
          </block_content>}</block></if></if_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<function><type><name>void</name></type>
<name>ev_feed_signal</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <expr_stmt><expr><name>EV_P</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ECB_MEMORY_FENCE_ACQUIRE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>EV_A</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>signum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>EV_A</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>signals</name> <index>[<expr><name>signum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pending</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>evpipe_write</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>sig_pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ev_sighandler</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>ev_feed_signal</name> <argument_list>(<argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_feed_signal_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>WL</name></type> <name>w</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>signum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>signum</name> <operator>&gt;=</operator> <name>EV_NSIG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>--</operator><name>signum</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <comment type="block">/* it is permissible to try to feed a signal to the wrong loop */</comment>
  <comment type="block">/* or, likely more useful, feeding a signal nobody is waiting for */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>loop</name> <operator>!=</operator> <name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ECB_MEMORY_FENCE_RELEASE</name></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigfdcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>iow</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>signalfd_siginfo</name></name></type> <name><name>si</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sip</name></decl>;</decl_stmt> <comment type="block">/* these structs are big */</comment>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ssize_t</name></type> <name>res</name> <init>= <expr><call><name>read</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* not ISO-C, as res might be -1, but works with SuS */</comment>
      <for>for <control>(<init><expr><name>sip</name> <operator>=</operator> <name>si</name></expr>;</init> <condition><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>sip</name> <operator>&lt;</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>si</name> <operator>+</operator> <name>res</name></expr>;</condition> <incr><expr><operator>++</operator><name>sip</name></expr></incr>)</control><block type="pseudo"><block_content>
        <macro><name>ev_feed_signal_event</name> <argument_list>(<argument>EV_A_ sip-&gt;ssi_signo</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for>

      <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><sizeof>sizeof <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>WL</name></type> <name><name>childs</name> <index>[<expr><name>EV_PID_HASHSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ev_signal</name></type> <name>childev</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIFCONTINUED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WIFCONTINUED</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* handle a single child status event */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>child_reap</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>chain</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_child</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>traced</name> <init>= <expr><call><name>WIFSTOPPED</name> <argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>WIFCONTINUED</name> <argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_child</name> <operator>*</operator><operator>)</operator><name><name>childs</name> <index>[<expr><name>chain</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_child</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name> <operator>||</operator> <operator>!</operator><name><name>w</name><operator>-&gt;</operator><name>pid</name></name><operator>)</operator>
          <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>traced</name> <operator>||</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* need to do it *now*, this *must* be the same prio as the signal watcher itself */</comment>
          <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>rpid</name></name>    <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>rstatus</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WCONTINUED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WCONTINUED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* called on sigchld etc., calls waitpid */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>childcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>sw</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>

  <comment type="block">/* some systems define WCONTINUED but then fail to support it (linux 2.4) */</comment>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;=</operator> <operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>WNOHANG</name> <operator>|</operator> <name>WUNTRACED</name> <operator>|</operator> <name>WCONTINUED</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>WCONTINUED</name>
        <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>EINVAL</name>
        <operator>||</operator> <literal type="number">0</literal> <operator>&gt;=</operator> <operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>WNOHANG</name> <operator>|</operator> <name>WUNTRACED</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* make sure we are called again until all children have been reaped */</comment>
  <comment type="block">/* we need to do it this way so that the callback gets called before we continue */</comment>
  <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>sw</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>child_reap</name> <argument_list>(<argument>EV_A_ pid</argument>, <argument>pid</argument>, <argument>status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>child_reap</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">0</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* this might trigger a watcher twice, but feed_event catches that */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_IOCP</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_iocp.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_PORT</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_port.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_KQUEUE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_kqueue.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_epoll.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_POLL</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_poll.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_select.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>ecb_cold</name> <name>int</name></type>
<name>ev_version_major</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>EV_VERSION_MAJOR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ecb_cold</name> <name>int</name></type>
<name>ev_version_minor</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>EV_VERSION_MINOR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return true if we are running with elevated privileges and should ignore env variables */</comment>
<function><type><name>inline_size</name> <name>ecb_cold</name> <name>int</name></type>
<name>enable_secure</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>getuid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <call><name>geteuid</name> <argument_list>()</argument_list></call>
      <operator>||</operator> <call><name>getgid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <call><name>getegid</name> <argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ecb_cold</name>
<name>unsigned</name> <name>int</name></type>
<name>ev_supported_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>EV_USE_PORT</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_PORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>EV_USE_KQUEUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>EV_USE_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_EPOLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>EV_USE_POLL</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_POLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>EV_USE_SELECT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_SELECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ecb_cold</name>
<name>unsigned</name> <name>int</name></type>
<name>ev_recommended_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><call><name>ev_supported_backends</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__NetBSD__</name></cpp:ifndef>
  <comment type="block">/* kqueue is borked on everything but netbsd apparently */</comment>
  <comment type="block">/* it usually doesn't work correctly on anything but sockets and pipes */</comment>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
  <comment type="block">/* only select works correctly on that "unix-certified" platform */</comment>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt> <comment type="block">/* horribly broken, even for sockets */</comment>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_POLL</name></expr>;</expr_stmt>   <comment type="block">/* poll is based on kqueue from 10.5 onwards */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FreeBSD__</name></cpp:ifdef>
  <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_POLL</name></expr>;</expr_stmt>   <comment type="block">/* poll return value is unusable (http://forums.freebsd.org/archive/index.php/t-10270.html) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ecb_cold</name>
<name>unsigned</name> <name>int</name></type>
<name>ev_embeddable_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>EVBACKEND_EPOLL</name> <operator>|</operator> <name>EVBACKEND_KQUEUE</name> <operator>|</operator> <name>EVBACKEND_PORT</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* epoll embeddability broken on all linux versions up to at least 2.6.23 */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ev_linux_version</name> <argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0x020620</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* disable it on linux &lt; 2.6.32 */</comment>
    <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_EPOLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ev_backend</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>backend</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
<function><type><name>unsigned</name> <name>int</name></type>
<name>ev_iteration</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>loop_count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ev_depth</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>loop_depth</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_set_io_collect_interval</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>interval</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>io_blocktime</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_set_timeout_collect_interval</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>interval</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>timeout_blocktime</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_set_userdata</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>userdata</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>ev_userdata</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><name>userdata</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_set_invoke_pending_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_loop_callback</name></type> <name>invoke_pending_cb</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>invoke_cb</name> <operator>=</operator> <name>invoke_pending_cb</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type>
<name>ev_set_loop_release_cb</name> <argument_list>(<argument><expr><name>EV_P_</name> <macro><name>void</name> <argument_list>(<argument>*release</argument>)</argument_list></macro><operator>(</operator><name>EV_P</name><operator>)</operator> <name>EV_THROW</name></expr></argument>, <argument><expr><macro><name>void</name> <argument_list>(<argument>*acquire</argument>)</argument_list></macro><operator>(</operator><name>EV_P</name><operator>)</operator> <name>EV_THROW</name></expr></argument>)</argument_list> <name>EV_THROW</name>
<block>{<block_content>
  <expr_stmt><expr><name>release_cb</name> <operator>=</operator> <name>release</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>acquire_cb</name> <operator>=</operator> <name>acquire</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* initialise a loop structure, must be zero-initialised */</comment>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>loop_init</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>origflags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_realtime</name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>have_realtime</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_monotonic</name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>have_monotonic</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* pid check not overridable via env */</comment>
      <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_FORKCHECK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>curpid</name> <operator>=</operator> <call><name>getpid</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_NOENV</name><operator>)</operator>
          <operator>&amp;&amp;</operator> <operator>!</operator><call><name>enable_secure</name> <argument_list>()</argument_list></call>
          <operator>&amp;&amp;</operator> <call><name>getenv</name> <argument_list>(<argument><expr><literal type="string">"LIBEV_FLAGS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><call><name>getenv</name> <argument_list>(<argument><expr><literal type="string">"LIBEV_FLAGS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>ev_rt_now</name>          <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mn_now</name>             <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>now_floor</name>          <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rtmn_diff</name>          <operator>=</operator> <name>ev_rt_now</name> <operator>-</operator> <name>mn_now</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
      <expr_stmt><expr><name>invoke_cb</name>          <operator>=</operator> <name>ev_invoke_pending</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>io_blocktime</name>       <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>timeout_blocktime</name>  <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>backend</name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>backend_fd</name>         <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>sig_pending</name>        <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><name>async_pending</name>      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>pipe_write_skipped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pipe_write_wanted</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name>         <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name>         <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
      <expr_stmt><expr><name>fs_fd</name>              <operator>=</operator> <ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_NOINOTIFY</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
      <expr_stmt><expr><name>sigfd</name>              <operator>=</operator> <ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_SIGNALFD</name></expr>  ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_MASK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>ev_recommended_backends</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_IOCP</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_IOCP</name>  <operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>iocp_init</name>   <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_PORT</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_PORT</name>  <operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>port_init</name>   <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_KQUEUE</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_KQUEUE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>kqueue_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_EPOLL</name> <operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>epoll_init</name>  <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_POLL</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_POLL</name>  <operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>poll_init</name>   <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_SELECT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>select_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><call><name>ev_prepare_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pending_w</name></expr></argument>, <argument><expr><name>pendingcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>pipecb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* free up a loop structure */</comment>
<function><type><name>ecb_cold</name>
<name>void</name></type>
<name>ev_loop_destroy</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <comment type="block">/* mimic free (0) */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>EV_A</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
  <comment type="block">/* queue cleanup watchers (and execute them) */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>, <argument><expr><name>EV_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_default_loop</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* child watcher */</comment>
      <expr_stmt><expr><call><name>ev_signal_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>childev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*ev_ref (EV_A);*/</comment>
      <comment type="block">/*ev_io_stop (EV_A_ &amp;pipe_w);*/</comment>

      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>backend_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>backend_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_IOCP</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_IOCP</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>iocp_destroy</name>   <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_PORT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_PORT</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>port_destroy</name>   <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_KQUEUE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_KQUEUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>kqueue_destroy</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>epoll_destroy</name>  <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_POLL</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_POLL</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>poll_destroy</name>   <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_SELECT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>select_destroy</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>pending</name></expr></argument>, <argument><expr><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>idle</name></expr></argument>, <argument><expr><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

  <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>anfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>anfds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name>anfdmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* have to use the microsoft-never-gets-it-right macro */</comment>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>rfeed</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>fdchange</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>timer</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>periodic</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>fork</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>cleanup</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>prepare</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>async</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>backend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_default_loop</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>ev_default_loop_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
<function_decl><type><name>inline_size</name> <name>void</name></type> <name>infy_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>inline_size</name> <name>void</name></type>
<name>loop_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_PORT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_PORT</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>port_fork</name>   <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_KQUEUE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_KQUEUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>kqueue_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>epoll_fork</name>  <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
  <expr_stmt><expr><call><name>infy_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>postfork</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* pipe_write_wanted must be false now, so modifying fd vars should be safe */</comment>

      <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* iterate over everything, in case we missed something before */</comment>
      <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>EV_CUSTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

<function><type><name>ecb_cold</name>
<name><name>struct</name> <name>ev_loop</name></name> <modifier>*</modifier></type>
<name>ev_loop_new</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <operator>(</operator>struct <name>ev_loop</name> <operator>*</operator><operator>)</operator><call><name>ev_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_loop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_loop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>loop_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ev_backend</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EV_A</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* multiplicity */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name></expr></cpp:if>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>verify_watcher</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: watcher has invalid priority"</literal><operator>,</operator> <call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NUMPRI</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: pending watcher not on pending queue"</literal><operator>,</operator> <name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name> <operator>==</operator> <name>w</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>verify_heap</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: active index mismatch in heap"</literal><operator>,</operator> <call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: heap condition violated"</literal><operator>,</operator> <name>i</name> <operator>==</operator> <name>HEAP0</name> <operator>||</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: heap at cache mismatch"</literal><operator>,</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ev_at</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>verify_watcher</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>array_verify</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name> <modifier>*</modifier></type><name>ws</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><name>cnt</name><operator>--</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: active index mismatch"</literal><operator>,</operator> <call><name>ev_active</name> <argument_list>(<argument><expr><name><name>ws</name> <index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cnt</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <macro><name>verify_watcher</name> <argument_list>(<argument>EV_A_ ws [cnt]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
<function><type><name>void</name> <name>ecb_cold</name></type>
<name>ev_verify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WL</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>w2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>activecnt</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>fdchangemax</name> <operator>&gt;=</operator> <name>fdchangecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fdchangecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: negative fd in fdchanges"</literal><operator>,</operator> <name><name>fdchanges</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>anfdmax</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <name>w2</name> <operator>=</operator> <name><name>anfds</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
          <expr_stmt><expr><call><name>verify_watcher</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>j</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
              <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: io watcher list contains a loop"</literal><operator>,</operator> <name>w</name> <operator>!=</operator> <name>w2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>w2</name> <operator>=</operator> <name><name>w2</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: inactive fd watcher on anfd list"</literal><operator>,</operator> <call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: fd mismatch between watcher and anfd"</literal><operator>,</operator> <operator>(</operator><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>fd</name> <operator>==</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>timermax</name> <operator>&gt;=</operator> <name>timercnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>verify_heap</name> <argument_list>(<argument>EV_A_ timers</argument>, <argument>timercnt</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>periodicmax</name> <operator>&gt;=</operator> <name>periodiccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>verify_heap</name> <argument_list>(<argument>EV_A_ periodics</argument>, <argument>periodiccnt</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>pendingmax</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>pendingcnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>idleall</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>idlemax</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>idlecnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name><name>idles</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlecnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>forkmax</name> <operator>&gt;=</operator> <name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>forks</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>cleanupmax</name> <operator>&gt;=</operator> <name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>asyncmax</name> <operator>&gt;=</operator> <name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>asyncs</name></expr></argument>, <argument><expr><name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>preparemax</name> <operator>&gt;=</operator> <name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>prepares</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>checkmax</name> <operator>&gt;=</operator> <name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>checks</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
  for (w = (ev_child *)childs [chain &amp; ((EV_PID_HASHSIZE) - 1)]; w; w = (ev_child *)((WL)w)-&gt;next)
  for (signum = EV_NSIG; signum--; ) if (signals [signum].pending)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
<function><type><name>ecb_cold</name>
<name><name>struct</name> <name>ev_loop</name></name> <modifier>*</modifier>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>int</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>ev_default_loop</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ev_default_loop_ptr</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
      <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name>ev_default_loop_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>default_loop_struct</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>ev_default_loop_ptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <macro><name>loop_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>ev_backend</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
          <expr_stmt><expr><call><name>ev_signal_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>, <argument><expr><name>childcb</name></expr></argument>, <argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_signal_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>childev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* child watcher should not keep loop alive */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ev_default_loop_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><name>ev_default_loop_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_loop_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<function><type><name>void</name></type>
<name>ev_invoke</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>EV_CB_INVOKE</name> <argument_list>(<argument><expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></argument>, <argument><expr><name>revents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ev_pending_count</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>pri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>pri</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

  <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_invoke_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>pendingpri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>pendingpri</name></expr>)</condition> <comment type="block">/* pendingpri possibly gets modified in the inner loop */</comment>
    <block>{<block_content>
      <expr_stmt><expr><operator>--</operator><name>pendingpri</name></expr>;</expr_stmt>

      <while>while <condition>(<expr><name><name>pendingcnt</name> <index>[<expr><name>pendingpri</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>ANPENDING</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pendings</name> <index>[<expr><name>pendingpri</name></expr>]</index></name> <operator>+</operator> <operator>--</operator><name><name>pendingcnt</name> <index>[<expr><name>pendingpri</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>EV_CB_INVOKE</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
<comment type="block">/* make idle watchers pending. this handles the "call-idle */</comment>
<comment type="block">/* only when higher priorities are idle" logic */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>idle_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>idleall</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>pri</name></decl>;</decl_stmt>

      <for>for <control>(<init><expr><name>pri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>pri</name><operator>--</operator></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name><name>idlecnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
              <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name><name>idles</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlecnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name>EV_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* make timers pending */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>timers_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>timercnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition>
    <block>{<block_content>
      <do>do
        <block>{<block_content>
          <decl_stmt><decl><type><name>ev_timer</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_timer</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/*assert (("libev: inactive timer on timer heap detected", ev_is_active (w)));*/</comment>

          <comment type="block">/* first reschedule or stop timer */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition>
            <block>{<block_content>
              <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

              <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: negative ev_timer repeat value found while processing timers"</literal><operator>,</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name> <operator>&gt;</operator> <literal type="number">0.</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
            <macro><name>ev_timer_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> <comment type="block">/* nonrepeating: stop timer */</comment>

          <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>feed_reverse</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
      while <condition>(<expr><name>timercnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition>;</do>

      <macro><name>feed_reverse_done</name> <argument_list>(<argument>EV_A_ EV_TIMER</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>

<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>periodic_recalc</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>interval</name> <init>= <expr><ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>&gt;</operator> <name>MIN_INTERVAL</name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>MIN_INTERVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>at</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>interval</name> <operator>*</operator> <call><name>ev_floor</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_rt_now</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>/</operator> <name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* the above almost always errs on the low side */</comment>
  <while>while <condition>(<expr><name>at</name> <operator>&lt;=</operator> <name>ev_rt_now</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>nat</name> <init>= <expr><name>at</name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* when resolution fails us, we use ev_rt_now */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>nat</name> <operator>==</operator> <name>at</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>at</name> <operator>=</operator> <name>ev_rt_now</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>at</name> <operator>=</operator> <name>nat</name></expr>;</expr_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* make periodics pending */</comment>
<function><type><name>inline_size</name> <name>void</name></type>
<name>periodics_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>periodiccnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ev_rt_now</name></expr>)</condition>
    <block>{<block_content>
      <do>do
        <block>{<block_content>
          <decl_stmt><decl><type><name>ev_periodic</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_periodic</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/*assert (("libev: inactive timer on periodic heap detected", ev_is_active (w)));*/</comment>

          <comment type="block">/* first reschedule or stop timer */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition>
            <block>{<block_content>
              <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_periodic reschedule callback returned time in the past"</literal><operator>,</operator> <call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>ev_rt_now</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition>
            <block>{<block_content>
              <macro><name>periodic_recalc</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
              <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
            <macro><name>ev_periodic_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> <comment type="block">/* nonrepeating: stop timer */</comment>

          <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>feed_reverse</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
      while <condition>(<expr><name>periodiccnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ev_rt_now</name></expr>)</condition>;</do>

      <macro><name>feed_reverse_done</name> <argument_list>(<argument>EV_A_ EV_PERIODIC</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* simply recalculate all periodics */</comment>
<comment type="block">/* TODO: maybe ensure that at least one event happens when jumping forward? */</comment>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>periodics_reschedule</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* adjust periodics after time jump */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ev_periodic</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_periodic</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>periodic_recalc</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><call><name>reheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* adjust all timers by a given offset */</comment>
<function><type><name>noinline</name> <name>ecb_cold</name>
<specifier>static</specifier> <name>void</name></type>
<name>timers_reschedule</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>adjust</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timercnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><name>timers</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>HEAP0</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>at</name> <operator>+=</operator> <name>adjust</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* fetch new monotonic and realtime times from the kernel */</comment>
<comment type="block">/* also detect if there was a timejump, and act accordingly */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>time_update</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>max_block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_monotonic</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>odiff</name> <init>= <expr><name>rtmn_diff</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>mn_now</name> <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* only fetch the realtime clock every 0.5*MIN_TIMEJUMP seconds */</comment>
      <comment type="block">/* interpolate in the meantime */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>mn_now</name> <operator>-</operator> <name>now_floor</name> <operator>&lt;</operator> <name>MIN_TIMEJUMP</name> <operator>*</operator> <literal type="number">.5</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <name>rtmn_diff</name> <operator>+</operator> <name>mn_now</name></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>now_floor</name> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* loop a few times, before making important decisions.
       * on the choice of "4": one iteration isn't enough,
       * in case we get preempted during the calls to
       * ev_time and get_clock. a second call is almost guaranteed
       * to succeed in that case, though. and looping a few more times
       * doesn't hurt either as we only do this on time-jumps or
       * in the unlikely event of having been preempted here.
       */</comment>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><operator>--</operator><name>i</name></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>diff</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rtmn_diff</name> <operator>=</operator> <name>ev_rt_now</name> <operator>-</operator> <name>mn_now</name></expr>;</expr_stmt>

          <expr_stmt><expr><name>diff</name> <operator>=</operator> <name>odiff</name> <operator>-</operator> <name>rtmn_diff</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0.</literal></expr> ?</condition><then> <expr><operator>-</operator><name>diff</name></expr> </then><else>: <expr><name>diff</name></expr></else></ternary><operator>)</operator> <operator>&lt;</operator> <name>MIN_TIMEJUMP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* all is well */</comment>

          <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mn_now</name>    <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>now_floor</name> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
        </block_content>}</block></for>

      <comment type="block">/* no timer adjustment, as the monotonic clock doesn't jump */</comment>
      <comment type="block">/* timers_reschedule (EV_A_ rtmn_diff - odiff) */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>mn_now</name> <operator>&gt;</operator> <name>ev_rt_now</name> <operator>||</operator> <name>ev_rt_now</name> <operator>&gt;</operator> <name>mn_now</name> <operator>+</operator> <name>max_block</name> <operator>+</operator> <name>MIN_TIMEJUMP</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* adjust timers. this is easy, as the offset is the same for all of them */</comment>
          <macro><name>timers_reschedule</name> <argument_list>(<argument>EV_A_ ev_rt_now - mn_now</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
          <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>mn_now</name> <operator>=</operator> <name>ev_rt_now</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ev_run</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
  <expr_stmt><expr><operator>++</operator><name>loop_depth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_loop recursion during release detected"</literal><operator>,</operator> <name>loop_done</name> <operator>!=</operator> <name>EVBREAK_RECURSE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt> <comment type="block">/* in case we recurse, ensure ordering stays nice and clean */</comment>

  <do>do
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>ev_verify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>curpid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* penalise the forking check even more */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>getpid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <name>curpid</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
              <expr_stmt><expr><name>curpid</name> <operator>=</operator> <call><name>getpid</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
      <comment type="block">/* we might have forked, so queue fork handlers */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>postfork</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>forkcnt</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>forks</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>, <argument><expr><name>EV_FORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
      <comment type="block">/* queue prepare watchers (and execute them) */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>preparecnt</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>prepares</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>, <argument><expr><name>EV_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>loop_done</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* we might have forked, so reify kernel state if necessary */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>postfork</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>loop_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* update fd-related kernel structures */</comment>
      <expr_stmt><expr><call><name>fd_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* calculate blocking time */</comment>
      <block>{<block_content>
        <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>waittime</name>  <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>sleeptime</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* remember old timestamp for io_blocktime calculation */</comment>
        <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>prev_mn_now</name> <init>= <expr><name>mn_now</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* update time to cancel out callback processing overhead */</comment>
        <expr_stmt><expr><call><name>time_update</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">1e100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* from now on, we want a pipe-wake-up */</comment>
        <expr_stmt><expr><name>pipe_write_wanted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>ECB_MEMORY_FENCE</name></expr>;</expr_stmt> <comment type="block">/* make sure pipe_write_wanted is visible before we check for potential skips */</comment>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVRUN_NOWAIT</name> <operator>||</operator> <name>idleall</name> <operator>||</operator> <operator>!</operator><name>activecnt</name> <operator>||</operator> <name>pipe_write_skipped</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>MAX_BLOCKTIME</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>timercnt</name></expr>)</condition>
              <block>{<block_content>
                <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>to</name> <init>= <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>mn_now</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>waittime</name> <operator>&gt;</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>periodiccnt</name></expr>)</condition>
              <block>{<block_content>
                <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>to</name> <init>= <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ev_rt_now</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>waittime</name> <operator>&gt;</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* don't let timeouts decrease the waittime below timeout_blocktime */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>waittime</name> <operator>&lt;</operator> <name>timeout_blocktime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>timeout_blocktime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* at this point, we NEED to wait, so we have to ensure */</comment>
            <comment type="block">/* to pass a minimum nonzero value to the backend */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>waittime</name> <operator>&lt;</operator> <name>backend_mintime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>backend_mintime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* extra check because io_blocktime is commonly 0 */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>io_blocktime</name></expr></argument>)</argument_list></call></expr>)</condition>
              <block>{<block_content>
                <expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>io_blocktime</name> <operator>-</operator> <operator>(</operator><name>mn_now</name> <operator>-</operator> <name>prev_mn_now</name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>sleeptime</name> <operator>&gt;</operator> <name>waittime</name> <operator>-</operator> <name>backend_mintime</name></expr>)</condition><block type="pseudo"><block_content>
                  <expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>waittime</name> <operator>-</operator> <name>backend_mintime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>sleeptime</name> <operator>&gt;</operator> <literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>)</condition>
                  <block>{<block_content>
                    <expr_stmt><expr><call><name>ev_sleep</name> <argument_list>(<argument><expr><name>sleeptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>waittime</name> <operator>-=</operator> <name>sleeptime</name></expr>;</expr_stmt>
                  </block_content>}</block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
        <expr_stmt><expr><operator>++</operator><name>loop_count</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><name>loop_done</name> <operator>=</operator> <name>EVBREAK_RECURSE</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assert for side effect */</comment>
        <macro><name>backend_poll</name> <argument_list>(<argument>EV_A_ waittime</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assert for side effect */</comment>

        <expr_stmt><expr><name>pipe_write_wanted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* just an optimisation, no fence needed */</comment>

        <expr_stmt><expr><name>ECB_MEMORY_FENCE_ACQUIRE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pipe_write_skipped</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: pipe_w not active, but pipe not written"</literal><operator>,</operator> <call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>EV_CUSTOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>


        <comment type="block">/* update ev_rt_now, do magic */</comment>
        <macro><name>time_update</name> <argument_list>(<argument>EV_A_ waittime + sleeptime</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block>

      <comment type="block">/* queue pending timers and reschedule them */</comment>
      <expr_stmt><expr><call><name>timers_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* relative timers called last */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>periodics_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* absolute timers called first */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
      <comment type="block">/* queue idle watchers unless other events are pending */</comment>
      <expr_stmt><expr><call><name>idle_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
      <comment type="block">/* queue check watchers, to be executed first */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>checkcnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>checks</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>, <argument><expr><name>EV_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><call><name>expect_true</name> <argument_list>(
    <argument><expr><name>activecnt</name>
    <operator>&amp;&amp;</operator> <operator>!</operator><name>loop_done</name>
    <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EVRUN_ONCE</name> <operator>|</operator> <name>EVRUN_NOWAIT</name><operator>)</operator><operator>)</operator></expr></argument>
  )</argument_list></call></expr>)</condition>;</do>

  <if_stmt><if>if <condition>(<expr><name>loop_done</name> <operator>==</operator> <name>EVBREAK_ONE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
  <expr_stmt><expr><operator>--</operator><name>loop_depth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>activecnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_break</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>how</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>how</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_ref</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><operator>++</operator><name>activecnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_unref</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><operator>--</operator><name>activecnt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_now_update</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>time_update</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">1e100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_suspend</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>ev_now_update</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_resume</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_tstamp</name></type> <name>mn_prev</name> <init>= <expr><name>mn_now</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ev_now_update</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>timers_reschedule</name> <argument_list>(<argument>EV_A_ mn_now - mn_prev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
  <comment type="block">/* TODO: really do this? */</comment>
  <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>
<comment type="block">/* singly-linked list management, used when the expected list length is short */</comment>

<function><type><name>inline_size</name> <name>void</name></type>
<name>wlist_add</name> <parameter_list>(<parameter><decl><type><name>WL</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>WL</name></type> <name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>head</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>head</name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>wlist_del</name> <parameter_list>(<parameter><decl><type><name>WL</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>WL</name></type> <name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><operator>*</operator><name>head</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>*</operator><name>head</name> <operator>==</operator> <name>elem</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>head</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>head</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>head</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* internal, faster, version of ev_clear_pending */</comment>
<function><type><name>inline_speed</name> <name>void</name></type>
<name>clear_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name> <operator>=</operator> <operator>(</operator><name>W</name><operator>)</operator><operator>&amp;</operator><name>pending_w</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ev_clear_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>W</name></type> <name>w_</name> <init>= <expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pending</name> <init>= <expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>ANPENDING</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w_</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>+</operator> <name>pending</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <operator>(</operator><name>W</name><operator>)</operator><operator>&amp;</operator><name>pending_w</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>events</name></name></expr>;</return>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>pri_adjust</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pri</name> <init>= <expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pri</name> <operator>=</operator> <ternary><condition><expr><name>pri</name> <operator>&lt;</operator> <name>EV_MINPRI</name></expr> ?</condition><then> <expr><name>EV_MINPRI</name></expr> </then><else>: <expr><name>pri</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>pri</name> <operator>=</operator> <ternary><condition><expr><name>pri</name> <operator>&gt;</operator> <name>EV_MAXPRI</name></expr> ?</condition><then> <expr><name>EV_MAXPRI</name></expr> </then><else>: <expr><name>pri</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>pri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_speed</name> <name>void</name></type>
<name>ev_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>active</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <macro><name>pri_adjust</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>ev_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_io_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_start called with negative fd"</literal><operator>,</operator> <name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_start called with illegal event mask"</literal><operator>,</operator> <operator>!</operator><operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>EV__IOFDSET</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANFD</name></expr></argument>, <argument><expr><name>anfds</name></expr></argument>, <argument><expr><name>anfdmax</name></expr></argument>, <argument><expr><name>fd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>array_init_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>anfds</name><index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* common bug, apparently */</comment>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_start called with corrupted watcher"</literal><operator>,</operator> <operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name> <operator>!=</operator> <operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;=</operator> <operator>~</operator><name>EV__IOFDSET</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_io_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_stop called with illegal fd (must stay constant after start!)"</literal><operator>,</operator> <name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <name>anfdmax</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ w-&gt;fd</argument>, <argument>EV_ANFD_REIFY</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_timer_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>mn_now</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_timer_start called with negative timer repeat value"</literal><operator>,</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name> <operator>&gt;=</operator> <literal type="number">0.</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>++</operator><name>timercnt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>timercnt</name> <operator>+</operator> <name>HEAP0</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANHE</name></expr></argument>, <argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timermax</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <comment type="block">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</comment>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_timer_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: internal timer heap corruption"</literal><operator>,</operator> <call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>active</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>--</operator><name>timercnt</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>active</name> <operator>&lt;</operator> <name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>timers</name> <index>[<expr><name>active</name></expr>]</index></name> <operator>=</operator> <name><name>timers</name> <index>[<expr><name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>mn_now</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_timer_again</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>mn_now</name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <macro><name>ev_timer_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>
      <macro><name>ev_timer_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ev_tstamp</name></type>
<name>ev_timer_remaining</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <return>return <expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><ternary><condition><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>mn_now</name></expr> </then><else>: <expr><literal type="number">0.</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_periodic_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_periodic_start called with negative interval value"</literal><operator>,</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>&gt;=</operator> <literal type="number">0.</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <macro><name>periodic_recalc</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>++</operator><name>periodiccnt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANHE</name></expr></argument>, <argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodicmax</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <comment type="block">/*assert (("libev: internal periodic heap corruption", ANHE_w (periodics [ev_active (w)]) == (WT)w));*/</comment>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_periodic_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: internal periodic heap corruption"</literal><operator>,</operator> <call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>active</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>--</operator><name>periodiccnt</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>active</name> <operator>&lt;</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>periodics</name> <index>[<expr><name>active</name></expr>]</index></name> <operator>=</operator> <name><name>periodics</name> <index>[<expr><name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_periodic_again</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <comment type="block">/* TODO: use adjustheap and recalculation */</comment>
  <macro><name>ev_periodic_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <macro><name>ev_periodic_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SA_RESTART</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SA_RESTART</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name></expr></cpp:if>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_signal_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_signal_start called with illegal signal number"</literal><operator>,</operator> <name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>&lt;</operator> <name>EV_NSIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: a signal must not be attached to two different loops"</literal><operator>,</operator>
           <operator>!</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>||</operator> <name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>==</operator> <name>loop</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>=</operator> <name>EV_A</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ECB_MEMORY_FENCE_RELEASE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>sigfd</name> <operator>=</operator> <call><name>signalfd</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name>SFD_NONBLOCK</name> <operator>|</operator> <name>SFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sigfd</name> <operator>=</operator> <call><name>signalfd</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* retry without flags */</comment>

      <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* doing it twice will not hurt */</comment>

          <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>, <argument><expr><name>sigfdcb</name></expr></argument>, <argument><expr><name>sigfd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>sigfd_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* signalfd watcher should not keep loop alive */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* TODO: check .head */</comment>
      <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>signalfd</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/*TODO*/</comment>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sa</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>ev_sighandler</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sigfillset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_RESTART</name></expr>;</expr_stmt> <comment type="block">/* if restarting works we save one iteration */</comment>
        <expr_stmt><expr><call><name>sigaction</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>origflags</name> <operator>&amp;</operator> <name>EVFLAG_NOSIGMASK</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_signal_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
      <expr_stmt><expr><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* unattach from signal */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>sigset_t</name></type> <name>ss</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sigdelset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>signalfd</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>

<function><type><name>void</name></type>
<name>ev_child_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_child</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: child watchers are only supported in the default loop"</literal><operator>,</operator> <name>loop</name> <operator>==</operator> <name>ev_default_loop_ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>childs</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_child_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_child</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>childs</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_STAT_ENABLE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_STAT_INTERVAL</name></cpp:macro>  <cpp:value>5.0074891</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NFS_STAT_INTERVAL</name></cpp:macro> <cpp:value>30.1074891</cpp:value></cpp:define> <comment type="block">/* for filesystems potentially failing inotify */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_STAT_INTERVAL</name></cpp:macro>  <cpp:value>0.1074891</cpp:value></cpp:define>

<function_decl><type><name>noinline</name> <specifier>static</specifier> <name>void</name></type> <name>stat_timer_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w_</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>

<comment type="block">/* the * 2 is to allow for alignment padding, which for some reason is &gt;&gt; 8 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INOTIFY_BUFSIZE</name></cpp:macro> <cpp:value>(sizeof (struct inotify_event) * 2 + NAME_MAX)</cpp:value></cpp:define>

<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>infy_add</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
                             <argument><expr><name>IN_ATTRIB</name> <operator>|</operator> <name>IN_DELETE_SELF</name> <operator>|</operator> <name>IN_MOVE_SELF</name> <operator>|</operator> <name>IN_MODIFY</name>
                             <operator>|</operator> <name>IN_CREATE</name> <operator>|</operator> <name>IN_DELETE</name> <operator>|</operator> <name>IN_MOVED_FROM</name> <operator>|</operator> <name>IN_MOVED_TO</name>
                             <operator>|</operator> <name>IN_DONT_FOLLOW</name> <operator>|</operator> <name>IN_MASK_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type> <name>sfs</name></decl>;</decl_stmt>

      <comment type="block">/* now local changes will be tracked by inotify, but remote changes won't */</comment>
      <comment type="block">/* unless the filesystem is known to be local, we therefore still poll */</comment>
      <comment type="block">/* also do poll on &lt;2.6.25, but with normal frequency */</comment>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fs_2625</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>statfs</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sfs</name></expr></argument>)</argument_list></call>
               <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x1373</literal> <comment type="block">/* devfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x4006</literal> <comment type="block">/* fat */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x4d44</literal> <comment type="block">/* msdos */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0xEF53</literal> <comment type="block">/* ext2/3 */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x72b6</literal> <comment type="block">/* jffs2 */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x858458f6</literal> <comment type="block">/* ramfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x5346544e</literal> <comment type="block">/* ntfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x3153464a</literal> <comment type="block">/* jfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x9123683e</literal> <comment type="block">/* btrfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x52654973</literal> <comment type="block">/* reiser3 */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x01021994</literal> <comment type="block">/* tmpfs */</comment>
                   <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x58465342</literal> <comment type="block">/* xfs */</comment><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* filesystem is local, kernel new enough */</comment>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>NFS_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* remote, use reduced frequency */</comment>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <comment type="block">/* can't use inotify, continue to stat */</comment>
      <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* if path is not there, monitor some parent directory for speedup hints */</comment>
      <comment type="block">/* note that exceeding the hardcoded path limit is not a correctness issue, */</comment>
      <comment type="block">/* but an efficiency issue only */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>path</name> <index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <do>do
            <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><name>IN_MASK_ADD</name> <operator>|</operator> <name>IN_DELETE_SELF</name> <operator>|</operator> <name>IN_MOVE_SELF</name>
                       <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr> ?</condition><then> <expr><name>IN_ATTRIB</name></expr> </then><else>: <expr><name>IN_CREATE</name> <operator>|</operator> <name>IN_MOVED_TO</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

              <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><call><name>strrchr</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pend</name> <operator>||</operator> <name>pend</name> <operator>==</operator> <name>path</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

              <expr_stmt><expr><operator>*</operator><name>pend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
          while <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* now re-arm timer, if required */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>infy_del</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wd</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>wd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>slot</name> <operator>=</operator> <name>wd</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* remove this watcher, if others are watching it, they will rearm */</comment>
  <expr_stmt><expr><call><name>inotify_rm_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>wd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>infy_wd</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>inotify_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <comment type="block">/* overflow, need to check for all hash slots */</comment>
    <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>slot</name></expr></incr>)</control><block type="pseudo"><block_content>
      <macro><name>infy_wd</name> <argument_list>(<argument>EV_A_ slot</argument>, <argument>wd</argument>, <argument>ev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if>
  <else>else
    <block>{<block_content>
      <decl_stmt><decl><type><name>WL</name></type> <name>w_</name></decl>;</decl_stmt>

      <for>for <control>(<init><expr><name>w_</name> <operator>=</operator> <name><name>fs_hash</name> <index>[<expr><name>slot</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w_</name></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <decl_stmt><decl><type><name>ev_stat</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><name>w_</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>w_</name> <operator>=</operator> <name><name>w_</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> <comment type="block">/* lets us remove this watcher and all before it */</comment>

          <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <name>wd</name> <operator>||</operator> <name>wd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>IN_IGNORED</name> <operator>|</operator> <name>IN_UNMOUNT</name> <operator>|</operator> <name>IN_DELETE_SELF</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                  <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name>slot</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                  <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> <comment type="block">/* re-add, no matter what */</comment>
                </block_content>}</block></if></if_stmt>

              <expr_stmt><expr><call><name>stat_timer_cb</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>infy_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name> <index>[<expr><name>EV_INOTIFY_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>read</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>ofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ofs</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr/>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>inotify_event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><operator>(</operator>struct <name>inotify_event</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name> <operator>+</operator> <name>ofs</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <macro><name>infy_wd</name> <argument_list>(<argument>EV_A_ ev-&gt;wd</argument>, <argument>ev-&gt;wd</argument>, <argument>ev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>inotify_event</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>ev</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>ecb_cold</name>
<name>void</name></type>
<name>ev_check_2625</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* kernels &lt; 2.6.25 are borked
   * http://www.ussg.indiana.edu/hypermail/linux/kernel/0711.3/1208.html
   */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ev_linux_version</name> <argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0x020619</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>fs_2625</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>int</name></type>
<name>infy_newfd</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>IN_CLOEXEC</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>IN_NONBLOCK</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>inotify_init1</name> <argument_list>(<argument><expr><name>IN_CLOEXEC</name> <operator>|</operator> <name>IN_NONBLOCK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>fd</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>inotify_init</name> <argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>infy_init</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_check_2625</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <call><name>infy_newfd</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>infy_cb</name></expr></argument>, <argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>inline_size</name> <name>void</name></type>
<name>infy_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_io_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <call><name>infy_newfd</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>slot</name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>WL</name></type> <name>w_</name> <init>= <expr><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <while>while <condition>(<expr><name>w_</name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>ev_stat</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><name>w_</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>w_</name> <operator>=</operator> <name><name>w_</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> <comment type="block">/* lets us add this watcher */</comment>

          <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if> <comment type="block">/* re-add, no matter what */</comment>
          <else>else
            <block>{<block_content>
              <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_LSTAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lstat (p, b)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>ev_stat_stat</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lstat</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>noinline</name>
<specifier>static</specifier> <name>void</name></type>
<name>stat_timer_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w_</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_stat</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w_</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_stat</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>ev_statdata</name></type> <name>prev</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>
  <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/* memcmp doesn't work on netbsd, they.... do stuff to their struct stat */</comment>
  <if_stmt><if>if <condition>(
    <expr><name><name>prev</name><operator>.</operator><name>st_dev</name></name>      <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_dev</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_ino</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_ino</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_mode</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_mode</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_nlink</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_uid</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_uid</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_gid</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_gid</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_rdev</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_rdev</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_size</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_size</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_atime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_atime</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_mtime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_mtime</name></name>
    <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_ctime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_ctime</name></name></expr>
  )</condition> <block>{<block_content>
      <comment type="block">/* we only update w-&gt;prev on actual differences */</comment>
      <comment type="block">/* in case we test more often than invoke the callback, */</comment>
      <comment type="block">/* to ensure that prev is always different to attr */</comment>
      <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
            <macro><name>infy_del</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> <comment type="block">/* avoid race... */</comment>
          </block_content>}</block></if></if_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ w</argument>, <argument>EV_STAT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_stat_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>&lt;</operator> <name>MIN_STAT_INTERVAL</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <name>MIN_STAT_INTERVAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_timer_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><name>stat_timer_cb</name></expr></argument>, <argument><expr><literal type="number">0.</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
  <expr_stmt><expr><call><name>infy_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_stat_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
  <macro><name>infy_del</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_timer_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_idle_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_idle</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>pri_adjust</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><operator>++</operator><name><name>idlecnt</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>++</operator><name>idleall</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_idle</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlemax</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_idle_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_idle</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><operator>--</operator><name><name>idlecnt</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>--</operator><name>idleall</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_prepare_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_prepare</name> <operator>*</operator></expr></argument>, <argument><expr><name>prepares</name></expr></argument>, <argument><expr><name>preparemax</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>prepares</name> <index>[<expr><name>preparecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_prepare_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>prepares</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>prepares</name> <index>[<expr><operator>--</operator><name>preparecnt</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>prepares</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_check_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_check</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_check</name> <operator>*</operator></expr></argument>, <argument><expr><name>checks</name></expr></argument>, <argument><expr><name>checkmax</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>checks</name> <index>[<expr><name>checkcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_check_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_check</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>checks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>checks</name> <index>[<expr><operator>--</operator><name>checkcnt</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>checks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>
<function><type><name>noinline</name>
<name>void</name></type>
<name>ev_embed_sweep</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>ev_run</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr></argument>, <argument><expr><name>EVRUN_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>embed_io_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_embed</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>io</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_EMBED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ev_run</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr></argument>, <argument><expr><name>EVRUN_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>embed_prepare_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>prepare</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_embed</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>prepare</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>prepare</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <block>{<block_content>
    <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>fdchangecnt</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>fd_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>ev_run</name> <argument_list>(<argument>EV_A_ EVRUN_NOWAIT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block></while>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>embed_fork_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>fork_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ev_embed</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fork_w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <macro><name>ev_embed_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <block>{<block_content>
    <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ev_loop_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>ev_run</name> <argument_list>(<argument>EV_A_ EVRUN_NOWAIT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  </block_content>}</block>

  <macro><name>ev_embed_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
embed_idle_cb (EV_P_ ev_idle *idle, int revents)
{
  ev_idle_stop (EV_A_ idle);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ev_embed_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <block>{<block_content>
    <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: loop to be embedded is not embeddable"</literal><operator>,</operator> <name>backend</name> <operator>&amp;</operator> <call><name>ev_embeddable_backends</name> <argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>embed_io_cb</name></expr></argument>, <argument><expr><name>backend_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_prepare_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>, <argument><expr><name>embed_prepare_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>, <argument><expr><name>EV_MINPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_prepare_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_fork_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>, <argument><expr><name>embed_fork_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_fork_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*ev_idle_init (&amp;w-&gt;idle, e,bed_idle_cb);*/</comment>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_embed_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_io_stop</name>      <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_prepare_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_fork_stop</name>    <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_fork_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_fork</name> <operator>*</operator></expr></argument>, <argument><expr><name>forks</name></expr></argument>, <argument><expr><name>forkmax</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>forks</name> <index>[<expr><name>forkcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_fork_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>forks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>forks</name> <index>[<expr><operator>--</operator><name>forkcnt</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>forks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_cleanup_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_cleanup</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_cleanup</name> <operator>*</operator></expr></argument>, <argument><expr><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupmax</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cleanups</name> <index>[<expr><name>cleanupcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

  <comment type="block">/* cleanup watchers should never keep a refcount on the loop */</comment>
  <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_cleanup_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_cleanup</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cleanups</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cleanups</name> <index>[<expr><operator>--</operator><name>cleanupcnt</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>cleanups</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>ev_async_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_async</name> <operator>*</operator></expr></argument>, <argument><expr><name>asyncs</name></expr></argument>, <argument><expr><name>asyncmax</name></expr></argument>, <argument><expr><name>asynccnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>asynccnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_async_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>asyncs</name> <index>[<expr><operator>--</operator><name>asynccnt</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>asyncs</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_async_send</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>sent</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>evpipe_write</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name>async_pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<struct>struct <name>ev_once</name>
<block>{
  <decl_stmt><decl><type><name>ev_io</name></type> <name>io</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ev_timer</name></type> <name>to</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>once_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name><name>struct</name> <name>ev_once</name></name> <modifier>*</modifier></type><name>once</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <init>= <expr><name><name>once</name><operator>-&gt;</operator><name>cb</name></name></expr></init>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>once</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ev_io_stop</name>    <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_timer_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>revents</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>once_cb_io</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name> <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <macro><name>once_cb</name> <argument_list>(<argument>EV_A_ once</argument>, <argument>revents | ev_clear_pending (EV_A_ &amp;once-&gt;to)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>once_cb_to</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name> <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <macro><name>once_cb</name> <argument_list>(<argument>EV_A_ once</argument>, <argument>revents | ev_clear_pending (EV_A_ &amp;once-&gt;io)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ev_once</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>ev_tstamp</name></type> <name>timeout</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name> <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><call><name>ev_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><name>once</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>EV_ERROR</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name> <operator>|</operator> <name>EV_TIMER</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>once</name><operator>-&gt;</operator><name>cb</name></name>  <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>once</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>once_cb_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>once_cb_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;=</operator> <literal type="number">0.</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ev_timer_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ev_timer_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_WALK_ENABLE</name></expr></cpp:if>
<function><type><name>ecb_cold</name>
<name>void</name></type>
<name>ev_walk</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>types</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> EV_THROW
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ev_watcher_list</name> <modifier>*</modifier></type><name>wl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wn</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <operator>(</operator><name>EV_IO</name> <operator>|</operator> <name>EV_EMBED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
      <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>anfds</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>embed_io_cb</name></expr>)</condition>
            <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_EMBED</name></expr>)</condition><block type="pseudo"><block_content>
                <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_EMBED</argument>, <argument>((char *)wl) - offsetof (struct ev_embed, io)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
          <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
          if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>infy_cb</name></expr>)</condition><block type="pseudo"><block_content>
            <empty_stmt>;</empty_stmt></block_content></block></if>
          <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          if <condition>(<expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name> <operator>!=</operator> <operator>&amp;</operator><name>pipe_w</name></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_IO</name></expr>)</condition><block type="pseudo"><block_content>
              <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_IO</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

          <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
        </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <operator>(</operator><name>EV_TIMER</name> <operator>|</operator> <name>EV_STAT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <name>HEAP0</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_STAT_ENABLE</name></expr></cpp:if>
      <comment type="block">/*TODO: timer is not always active*/</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_timer</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>stat_timer_cb</name></expr>)</condition>
        <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_STAT</name></expr>)</condition><block type="pseudo"><block_content>
            <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_STAT</argument>, <argument>((char *)ANHE_w (timers [i])) - offsetof (struct ev_stat, timer)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_TIMER</name></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_TIMER</argument>, <argument>ANHE_w (timers [i])</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_PERIODIC</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <name>HEAP0</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_PERIODIC</argument>, <argument>ANHE_w (periodics [i])</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>j</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>idlecnt</name> <index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_IDLE</argument>, <argument>idles [j][i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_FORK</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>forkcnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name><name>forks</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>embed_fork_cb</name></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_FORK</argument>, <argument>forks [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_ASYNC</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>asynccnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_ASYNC</argument>, <argument>asyncs [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_PREPARE</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>preparecnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name><name>prepares</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>embed_prepare_cb</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_PREPARE</argument>, <argument>prepares [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>checkcnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_CHECK</argument>, <argument>checks [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_SIGNAL</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
      <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
          <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_SIGNAL</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
          <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
        </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_CHILD</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
      <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>childs</name> <index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control>
        <block>{<block_content>
          <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
          <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_CHILD</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
          <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
        </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* EV_STAT     0x00001000 /* stat data changed */</comment>
<comment type="block">/* EV_EMBED    0x00010000 /* embedded event loop needs sweep */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_wrap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
