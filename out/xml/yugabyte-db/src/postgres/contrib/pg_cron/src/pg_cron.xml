<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/pg_cron/src/pg_cron.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * src/pg_cron.c
 *
 * Implementation of the pg_cron task scheduler.
 * Wording:
 *     - A job is a scheduling definition of a task
 *     - A task is what is actually executed within the database engine
 *
 * Copyright (c) 2016, Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>

<comment type="block">/* these are always necessary for a bgworker */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_mq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_toc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>

<comment type="block">/* these headers are used by this particular worker's code */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAIN_PROGRAM</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cron.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_cron.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"task_states.h"</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sys/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqmq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>table_open</name><parameter_list>(<parameter><type><name>r</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>heap_open(r, l)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>table_close</name><parameter_list>(<parameter><type><name>r</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>heap_close(r, l)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAXINT8LEN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINT8LEN</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Table-of-contents constants for our dynamic shared memory segment. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_MAGIC</name></cpp:macro>      <cpp:value>0x51028080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_KEY_DATABASE</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_KEY_USERNAME</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_KEY_COMMAND</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_KEY_QUEUE</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CRON_NKEYS</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* ways in which the clock can change between main loop iterations */</comment>
<typedef>typedef <type><enum>enum
<block>{
  <decl><name>CLOCK_JUMP_BACKWARD</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>CLOCK_PROGRESSED</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>CLOCK_JUMP_FORWARD</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <decl><name>CLOCK_CHANGE</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>ClockProgress</name>;</typedef>

<comment type="block">/* forward declarations */</comment>
<function_decl><type><name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_cron_sigterm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_cron_sighup</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_cron_background_worker_sigterm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PgCronLauncherMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CronBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartAllPendingRuns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartPendingRuns</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ClockProgress</name></type> <name>clockProgress</name></decl></parameter>,
               <parameter><decl><type><name>TimestampTz</name></type> <name>lastMinute</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>MinutesPassed</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stopTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>SecondsPassed</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stopTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>TimestampMinuteStart</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>TimestampMinuteEnd</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRunTask</name><parameter_list>(<parameter><decl><type><name>entry</name> <modifier>*</modifier></type><name>schedule</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentMinute</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>doWild</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doNonWild</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForCronTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForLatch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>timeoutMs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PollForTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanStartTask</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ManageCronTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ManageCronTask</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteSqlString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetTaskFeedback</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetBgwTaskFeedback</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl></parameter>, <parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>running</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>jobCanceled</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>jobStartupTimeout</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>pg_cron_cmdTuples</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bgw_generate_returned_message</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>display_msg</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name></type> <name>edata</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckForLeaderStateChange</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>prevLeaderState</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>, <parameter><decl><type><name>List</name><modifier>*</modifier></type> <name>task_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ManageCronTaskWaiting</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateKnownNodesAndWorkload</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckTimedOutTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* global settings */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>CronTableDatabaseName</name> <init>= <expr><literal type="string">"system_platform"</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// maximum length of c-string nodenames including the null character</comment>
<comment type="line">// necessary because HTAB requires a fixed key size to allocate space for the</comment>
<comment type="line">// storing the key.</comment>
<comment type="line">// MODIFY worker_load.h IF YOU CHANGE THIS VALUE</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>MaxNodenameLength</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// time in seconds between queries for the available nodes in the cluster and</comment>
<comment type="line">// the cluster load</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ClusterStatusQueryPeriod</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// time in seconds between queries for the leader state of this cron worker</comment>
<decl_stmt><decl><type><name>int</name></type> <name>LeaderStatusQueryPeriod</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// nodename used to identify this cron worker. same as the one given</comment>
<comment type="line">// to the tserver associated with our parent postgres process</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>MyNodeName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>UseBackgroundWorkers</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CronLogStatement</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CronLogRun</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>CronReloadConfig</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* flags set by signal handlers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_sigterm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* global variables */</comment>
<comment type="block">/* maximum connection time and time for bgw slot to be available in ms */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>CronTaskStartTimeout</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>
<comment type="line">// maximum time in s to wait for job completion not including</comment>
<comment type="line">// CronTaskStartTimeout</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MaxJobCompletionDelay</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MaxWait</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* maximum time in ms that poll() can block */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RebootJobsScheduled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Number of jobs running in the cluster. For now we are not updating this */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>RunningTaskCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>MaxRunningTasks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>CronLogMinMessages</name> <init>= <expr><name>WARNING</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>cron_message_level_options</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"fatal"</literal></expr>, <expr><name>FATAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"panic"</literal></expr>, <expr><name>PANIC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cron_error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * _PG_init gets called when the extension is loaded.
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
  <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_cron can only be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>,</operator>
            <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add pg_cron to the shared_preload_libraries "</literal>
                <literal type="string">"configuration variable in postgresql.conf."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.database_name"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Database in which pg_cron metadata is kept."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>CronTableDatabaseName</name></expr></argument>,
    <argument><expr><literal type="string">"system_platform"</literal></expr></argument>,
    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.log_statement"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Log all cron statements prior to execution."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>CronLogStatement</name></expr></argument>,
    <argument><expr><name>true</name></expr></argument>,
    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// We always log runs because we use the job_run_details to inform</comment>
  <comment type="line">// other workers about what work they need to do</comment>
  <comment type="line">// DefineCustomBoolVariable(</comment>
  <comment type="line">//   "cron.log_run",</comment>
  <comment type="line">//   gettext_noop("Log all jobs runs into the job_run_details table"),</comment>
  <comment type="line">//   NULL,</comment>
  <comment type="line">//   &amp;CronLogRun,</comment>
  <comment type="line">//   true,</comment>
  <comment type="line">//   PGC_POSTMASTER,</comment>
  <comment type="line">//   GUC_SUPERUSER_ONLY,</comment>
  <comment type="line">//   NULL, NULL, NULL);</comment>

  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.enable_superuser_jobs"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow jobs to be scheduled as superuser"</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>EnableSuperuserJobs</name></expr></argument>,
    <argument><expr><name>true</name></expr></argument>,
    <argument><expr><name>PGC_USERSET</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// For now, we will only support background workers so this setting will not be used.</comment>
  <comment type="line">// DefineCustomStringVariable(</comment>
  <comment type="line">//   "cron.host",</comment>
  <comment type="line">//   gettext_noop("Hostname to connect to postgres."),</comment>
  <comment type="line">//   gettext_noop("This setting has no effect when background workers are used."),</comment>
  <comment type="line">//   &amp;CronHost,</comment>
  <comment type="line">//   "localhost",</comment>
  <comment type="line">//   PGC_POSTMASTER,</comment>
  <comment type="line">//   GUC_SUPERUSER_ONLY,</comment>
  <comment type="line">//   NULL, NULL, NULL);</comment>

  <expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.cluster_status_query_period"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Seconds between queries for available nodes in the cluster."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>ClusterStatusQueryPeriod</name></expr></argument>,
    <argument><expr><literal type="number">30</literal></expr></argument>,
    <argument><expr><literal type="number">0</literal></expr></argument>,
    <argument><expr><literal type="number">60</literal></expr></argument>,
    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.leader_status_query_period"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Seconds between queries for the leader status of the node."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>LeaderStatusQueryPeriod</name></expr></argument>,
    <argument><expr><literal type="number">30</literal></expr></argument>,
    <argument><expr><literal type="number">0</literal></expr></argument>,
    <argument><expr><literal type="number">60</literal></expr></argument>,
    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.use_background_workers"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Use background workers instead of client sessions."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>UseBackgroundWorkers</name></expr></argument>,
    <argument><expr><name>true</name></expr></argument>,
    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>UseBackgroundWorkers</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(
      <argument><expr><literal type="string">"cron.max_running_jobs"</literal></expr></argument>,
      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of jobs that can run concurrently."</literal></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>MaxRunningTasks</name></expr></argument>,
      <argument><expr><ternary><condition><expr><operator>(</operator><name>MaxConnections</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr> ?</condition><then> <expr><name>MaxConnections</name></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></argument>,
      <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><name>MaxConnections</name></expr></argument>,
      <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
      <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(
      <argument><expr><literal type="string">"cron.max_running_jobs"</literal></expr></argument>,
      <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of jobs that can run concurrently."</literal></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>MaxRunningTasks</name></expr></argument>,
      <argument><expr><ternary><condition><expr><operator>(</operator><name>max_worker_processes</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr> ?</condition><then> <expr><name>max_worker_processes</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">5</literal></expr></else></ternary></expr></argument>,
      <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><name>max_worker_processes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
      <argument><expr><name>PGC_POSTMASTER</name></expr></argument>,
      <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>DefineCustomEnumVariable</name><argument_list>(
    <argument><expr><literal type="string">"cron.log_min_messages"</literal></expr></argument>,
    <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"log_min_messages for the launcher bgworker."</literal></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>CronLogMinMessages</name></expr></argument>,
    <argument><expr><name>WARNING</name></expr></argument>,
    <argument><expr><name>cron_message_level_options</name></expr></argument>,
    <argument><expr><name>PGC_SIGHUP</name></expr></argument>,
    <argument><expr><name>GUC_SUPERUSER_ONLY</name></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* set up common data for all our workers */</comment>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_RecoveryFinished</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main</name></name> <operator>=</operator> <name>PgCronLauncherMain</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_cron"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><literal type="string">"PgCronLauncherMain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"pg_cron launcher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"pg_cron launcher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>MyNodeName</name> <operator>=</operator> <call><name>YBGetCurrentMetricNodeName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyNodeName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RegisterBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Signal handler for SIGTERM
 *    Set a flag to let the main loop to terminate, and set our latch to wake
 *    it up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_cron_sigterm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>got_sigterm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Signal handler for SIGHUP
 *    Set a flag to tell the main loop to reload the cron jobs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_cron_sighup</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>CronJobCacheValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>CronReloadConfig</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_cron_cmdTuples -
 *      mainly copy/pasted from PQcmdTuples
 *      If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *      a string containing the number of inserted/affected tuples. If not,
 *      return "".
 *
 *      XXX: this should probably return an int
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_cron_cmdTuples</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"INSERT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>msg</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                <comment type="block">/* INSERT: skip oid and space */</comment>
                <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* no space? */</comment>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                         <call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"DELETE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                         <call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"UPDATE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>msg</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"FETCH "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>msg</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"MOVE "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                         <call><name>strncmp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"COPY "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>p</name> <operator>=</operator> <name>msg</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
                <return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></else></if_stmt>

        <comment type="block">/* check that we have an integer (at least one digit, nothing else) */</comment>
        <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><operator>*</operator><name>c</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>interpret_error</name>;</goto></block_content></block></if></if_stmt>

        <return>return <expr><name>p</name></expr>;</return>

<label><name>interpret_error</name>:</label>
  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not interpret result from server: %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cron_error_severity --- get string representing elevel
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>cron_error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elevel_char</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>DEBUG1</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"DEBUG1"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DEBUG2</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"DEBUG2"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DEBUG3</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"DEBUG3"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DEBUG4</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"DEBUG4"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>DEBUG5</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"DEBUG5"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LOG</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"LOG"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>INFO</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"INFO"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>NOTICE</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"NOTICE"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>WARNING</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"WARNING"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ERROR</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"ERROR"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FATAL</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"FATAL"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>PANIC</name></expr>:</case>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"PANIC"</literal></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>elevel_char</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>elevel_char</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bgw_generate_returned_message -
 *      generates the message to be inserted into the job_run_details table
 *      first part is comming from error_severity (elog.c)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgw_generate_returned_message</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>display_msg</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name></type> <name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name><name>edata</name><operator>.</operator><name>elevel</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>DEBUG1</name></expr>:</case>
    <case>case <expr><name>DEBUG2</name></expr>:</case>
    <case>case <expr><name>DEBUG3</name></expr>:</case>
    <case>case <expr><name>DEBUG4</name></expr>:</case>
    <case>case <expr><name>DEBUG5</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LOG</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal><operator>)</operator></expr></cpp:if>
    <case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"LOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>INFO</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>NOTICE</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>WARNING</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ERROR</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FATAL</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>PANIC</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PANIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>detail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nDETAIL: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>hint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nHINT: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nCONTEXT: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Signal handler for SIGTERM for background workers
 *     When we receive a SIGTERM, we set InterruptPending and ProcDiePending
 *     just like a normal backend.  The next CHECK_FOR_INTERRUPTS() will do the
 *     right thing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_cron_background_worker_sigterm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PgCronLauncherMain is the main entry-point for the background worker
 * that performs tasks.
 */</comment>
<function><type><name>void</name></type>
<name>PgCronLauncherMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>CronLoopContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>limit</name></decl>;</decl_stmt>

  <comment type="block">/* Establish signal handlers before unblocking signals. */</comment>
  <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>pg_cron_sighup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>pg_cron_sigterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We're now ready to receive signals */</comment>
  <expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Connect to our database */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">110000</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>CronTableDatabaseName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>CronTableDatabaseName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make pg_cron recognisable in pg_stat_activity */</comment>
  <expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><literal type="string">"pg_cron scheduler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Mark anything that was in progress before the database restarted as
   * failed.
   */</comment>
  <expr_stmt><expr><call><name>MarkPendingRunsAsFailed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine how many tasks we can run concurrently */</comment>
  <if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>&lt;</operator> <name>MaxRunningTasks</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>MaxRunningTasks</name> <operator>=</operator> <name>MaxConnections</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>max_files_per_process</name> <operator>&lt;</operator> <name>MaxRunningTasks</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>MaxRunningTasks</name> <operator>=</operator> <name>max_files_per_process</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <name><name>limit</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>MaxRunningTasks</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>MaxRunningTasks</name> <operator>=</operator> <name><name>limit</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>UseBackgroundWorkers</name> <operator>&amp;&amp;</operator> <name>max_worker_processes</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>MaxRunningTasks</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>MaxRunningTasks</name> <operator>=</operator> <name>max_worker_processes</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>MaxRunningTasks</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>MaxRunningTasks</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


  <expr_stmt><expr><name>CronLoopContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                        <argument><expr><literal type="string">"pg_cron loop context"</literal></expr></argument>,
                        <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                        <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                        <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>InitializeJobMetadataCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>InitializeTaskStateHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_cron scheduler started"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* set the desired log_min_messages */</comment>
  <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><call><name>cron_error_severity</name><argument_list>(<argument><expr><name>CronLogMinMessages</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CronLoopContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>amILeader</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>!</operator><name>got_sigterm</name></expr>)</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>CronJobCacheValid</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cron Table Changed!"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RefreshTaskHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>CronReloadConfig</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* set the desired log_min_messages */</comment>
      <expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><call><name>cron_error_severity</name><argument_list>(<argument><expr><name>CronLogMinMessages</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>CronReloadConfig</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>CurrentTaskList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Currently, there are 2 possible reasons why we are signalled</comment>
    <comment type="line">// that the job run table changed:</comment>
    <comment type="line">// 1. This cron worker was assigned a job. We expect the job run</comment>
    <comment type="line">// table to contain rows with status == 'starting' and</comment>
    <comment type="line">// nodename == MyNodeName.</comment>
    <comment type="line">// 2. If we are the leader, a cron worker (including ourselves) might</comment>
    <comment type="line">// have completed their assigned task. We need to be informed of this</comment>
    <comment type="line">// so that if necessary, we can launch another job run that has been</comment>
    <comment type="line">// queued up. See StartAllPendingRuns for how this could happen</comment>
    <if_stmt><if>if <condition>(<expr><name>CronJobRunTableChanged</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cron Run Table Changed!"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ProcessNewJobs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>amILeader</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>UpdateJobRunStatus</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>CronJobRunTableChanged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// TODO: perhaps we can avoid the dual meaning of CronJobRunTableChanged</comment>
    <comment type="line">// flag being set by introducing a third kind of relation invalidation</comment>
    <comment type="line">// message. If we can reserve a 3rd relation id that we invalidate,</comment>
    <comment type="line">// we can use that to create another flag which can be individually set.</comment>
    <comment type="line">// Note that because postgres processes normally ignore foreign</comment>
    <comment type="line">// invalidation messages that come from different pids other than the</comment>
    <comment type="line">// postgres process itself, other postgres processes shouldn't get</comment>
    <comment type="line">// the new relation invalidation message.</comment>

    <comment type="line">// Check periodically for a leader state change</comment>
    <expr_stmt><expr><name>amILeader</name> <operator>=</operator> <call><name>CheckForLeaderStateChange</name><argument_list>(<argument><expr><name>amILeader</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>amILeader</name></expr>)</condition>
    <block>{<block_content>
      <comment type="line">// Determine which workers are available and the current load</comment>
      <expr_stmt><expr><call><name>UpdateKnownNodesAndWorkload</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Check if any jobs are scheduled to run now</comment>
      <expr_stmt><expr><call><name>StartAllPendingRuns</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Start and monitor tasks</comment>
    <expr_stmt><expr><call><name>WaitForCronTasks</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ManageCronTasks</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>amILeader</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// If necessary deal with tasks that have not started / are</comment>
      <comment type="line">// still running</comment>
      <expr_stmt><expr><call><name>CheckTimedOutTasks</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>CronLoopContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_cron scheduler shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateKnownNodesAndWorkload periodically queries master for the set
 * of active tservers (by extension postgres cron workers) and queries
 * for the number of jobs assigned to each worker. force option
 * allows for an immediate refresh of known nodes and workload.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateKnownNodesAndWorkload</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>lastQueryTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>secondsPassed</name> <init>= <expr><call><name>SecondsPassed</name><argument_list>(<argument><expr><name>lastQueryTime</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>secondsPassed</name> <operator>&lt;</operator> <name>ClusterStatusQueryPeriod</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* wait for next query */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>lastQueryTime</name> <operator>=</operator> <name>currentTime</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * StartPendingRuns goes through the list of tasks and kicks of
 * runs for tasks that should start, taking clock changes into
 * into consideration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartAllPendingRuns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>lastMinute</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>minutesPassed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ClockProgress</name></type> <name>clockProgress</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>RebootJobsScheduled</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* find jobs with @reboot as a schedule */</comment>
    <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
    <block>{<block_content>
      <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name> <init>= <expr><call><name>GetCronJob</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>entry</name> <modifier>*</modifier></type><name>schedule</name> <init>= <expr><operator>&amp;</operator><name><name>cronJob</name><operator>-&gt;</operator><name>schedule</name></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>schedule</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>WHEN_REBOOT</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>RebootJobsScheduled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>lastMinute</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>lastMinute</name> <operator>=</operator> <call><name>TimestampMinuteStart</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>minutesPassed</name> <operator>=</operator> <call><name>MinutesPassed</name><argument_list>(<argument><expr><name>lastMinute</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>minutesPassed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* wait for new minute */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* use Vixie cron logic for clock jumps */</comment>
  <if_stmt><if>if <condition>(<expr><name>minutesPassed</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">3</literal><operator>*</operator><name>MINUTE_COUNT</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* clock jumped forward by more than 3 hours */</comment>
    <expr_stmt><expr><name>clockProgress</name> <operator>=</operator> <name>CLOCK_CHANGE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>minutesPassed</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* clock went forward by more than 5 minutes (DST?) */</comment>
    <expr_stmt><expr><name>clockProgress</name> <operator>=</operator> <name>CLOCK_JUMP_FORWARD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>minutesPassed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* clock went forward by 1-5 minutes */</comment>
    <expr_stmt><expr><name>clockProgress</name> <operator>=</operator> <name>CLOCK_PROGRESSED</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>minutesPassed</name> <operator>&gt;</operator> <operator>-</operator><operator>(</operator><literal type="number">3</literal><operator>*</operator><name>MINUTE_COUNT</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* clock jumped backwards by less than 3 hours (DST?) */</comment>
    <expr_stmt><expr><name>clockProgress</name> <operator>=</operator> <name>CLOCK_JUMP_BACKWARD</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* clock jumped backwards 3 hours or more */</comment>
    <expr_stmt><expr><name>clockProgress</name> <operator>=</operator> <name>CLOCK_CHANGE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*
       * The job has been unscheduled, so we should not schedule
       * new runs. The task will be safely removed on the next call
       * to ManageCronTask.
       */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>StartPendingRuns</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>clockProgress</name></expr></argument>, <argument><expr><name>lastMinute</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>

  <comment type="block">/*
   * If the clock jump backwards then we avoid repeating the fixed-time
   * tasks by preserving the last minute from before the clock jump,
   * until the clock has caught up (clockProgress will be
   * CLOCK_JUMP_BACKWARD until then).
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>clockProgress</name> <operator>!=</operator> <name>CLOCK_JUMP_BACKWARD</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>lastMinute</name> <operator>=</operator> <call><name>TimestampMinuteStart</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartPendingRuns kicks off pending runs for a task if it
 * should start, taking clock changes into consideration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartPendingRuns</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ClockProgress</name></type> <name>clockProgress</name></decl></parameter>,
         <parameter><decl><type><name>TimestampTz</name></type> <name>lastMinute</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name> <init>= <expr><call><name>GetCronJob</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>entry</name> <modifier>*</modifier></type><name>schedule</name> <init>= <expr><operator>&amp;</operator><name><name>cronJob</name><operator>-&gt;</operator><name>schedule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>virtualTime</name> <init>= <expr><name>lastMinute</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentMinute</name> <init>= <expr><call><name>TimestampMinuteStart</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>clockProgress</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>CLOCK_PROGRESSED</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/*
       * case 1: minutesPassed is a small positive number
       * run jobs for each virtual minute until caught up.
       */</comment>

      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>virtualTime</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>virtualTime</name></expr></argument>,
                              <argument><expr><literal type="number">60</literal><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ShouldRunTask</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>virtualTime</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><name>virtualTime</name> <operator>&lt;</operator> <name>currentMinute</name></expr>)</condition>;</do>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CLOCK_JUMP_FORWARD</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/*
       * case 2: minutesPassed is a medium-sized positive number,
       * for example because we went to DST run wildcard
       * jobs once, then run any fixed-time jobs that would
       * otherwise be skipped if we use up our minute
       * (possible, if there are a lot of jobs to run) go
       * around the loop again so that wildcard jobs have
       * a chance to run, and we do our housekeeping
       */</comment>

      <comment type="block">/* run fixed-time jobs for each minute missed */</comment>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>virtualTime</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>virtualTime</name></expr></argument>,
                              <argument><expr><literal type="number">60</literal><operator>*</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ShouldRunTask</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>virtualTime</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      </block_content>}</block> while <condition>(<expr><name>virtualTime</name> <operator>&lt;</operator> <name>currentMinute</name></expr>)</condition>;</do>

      <comment type="block">/* run wildcard jobs for current minute */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ShouldRunTask</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>currentMinute</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CLOCK_JUMP_BACKWARD</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/*
       * case 3: timeDiff is a small or medium-sized
       * negative num, eg. because of DST ending just run
       * the wildcard jobs. The fixed-time jobs probably
       * have already run, and should not be repeated
       * virtual time does not change until we are caught up
       */</comment>

      <if_stmt><if>if <condition>(<expr><call><name>ShouldRunTask</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>currentMinute</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
    <block>{<block_content>
      <comment type="block">/*
       * other: time has changed a *lot*, skip over any
       * intermediate fixed-time jobs and go back to
       * normal operation.
       */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ShouldRunTask</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>currentMinute</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * MinutesPassed returns the number of minutes between startTime and
 * stopTime rounded down to the closest integer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>MinutesPassed</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stopTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>SecondsPassed</name><argument_list>(<argument><expr><name>startTime</name></expr></argument>, <argument><expr><name>stopTime</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">60</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SecondsPassed returns the number of seconds between startTime and
 * stopTime rounded down to the closest integer.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SecondsPassed</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stopTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>microsPassed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>secondsPassed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>startTime</name></expr></argument>, <argument><expr><name>stopTime</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>secondsPassed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsPassed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>secondsPassed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TimestampMinuteEnd returns the timestamp at the start of the
 * current minute for the given time.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>TimestampMinuteStart</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <name>time</name> <operator>-</operator> <name>time</name> <operator>%</operator> <literal type="number">60000000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>time</name> <operator>-</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>time</name> <operator>%</operator> <literal type="number">60</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TimestampMinuteEnd returns the timestamp at the start of the
 * next minute from the given time.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>TimestampMinuteEnd</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name> <init>= <expr><call><name>TimestampMinuteStart</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
  <expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">60000000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">60</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRunTask returns whether a job should run in the current
 * minute according to its schedule.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRunTask</name><parameter_list>(<parameter><decl><type><name>entry</name> <modifier>*</modifier></type><name>schedule</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doWild</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>doNonWild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>time_t</name></type> <name>currentTime_t</name> <init>= <expr><call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentTime_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>minute</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>-</operator><name>FIRST_MINUTE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hour</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>-</operator><name>FIRST_HOUR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dayOfMonth</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator><name>FIRST_DOM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>month</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator><literal type="number">1</literal> <operator>-</operator><name>FIRST_MONTH</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dayOfWeek</name> <init>= <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>-</operator><name>FIRST_DOW</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><name>minute</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><name>hour</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>month</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>schedule</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DOM_STAR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>schedule</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DOW_STAR</name><operator>)</operator><operator>)</operator></expr>
        ?</condition><then> <expr><operator>(</operator><call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>,<argument><expr><name>dayOfWeek</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>,<argument><expr><name>dayOfMonth</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
        </then><else>: <expr><operator>(</operator><call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>,<argument><expr><name>dayOfWeek</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bit_test</name><argument_list>(<argument><expr><name><name>schedule</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>,<argument><expr><name>dayOfMonth</name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>doNonWild</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>schedule</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MIN_STAR</name><operator>|</operator><name>HR_STAR</name><operator>)</operator><operator>)</operator><operator>)</operator>
        <operator>||</operator> <operator>(</operator><name>doWild</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>schedule</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MIN_STAR</name><operator>|</operator><name>HR_STAR</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForCronTasks blocks waiting for any active task for at most
 * 1 second.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForCronTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>taskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>taskCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>PollForTasks</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>WaitForLatch</name><argument_list>(<argument><expr><name>MaxWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForLatch waits for the given number of milliseconds unless a signal
 * is received or postmaster shuts down.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForLatch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>timeoutMs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>waitFlags</name> <init>= <expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* nothing to do, wait for new jobs */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>waitFlags</name></expr></argument>, <argument><expr><name>timeoutMs</name></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>waitFlags</name></expr></argument>, <argument><expr><name>timeoutMs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* postmaster died and we should bail out immediately */</comment>
    <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PollForTasks calls poll() for the sockets of all tasks. It checks for
 * read or write events based on the pollingStatus of the task.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PollForTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>nextEventTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pollTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>waitSeconds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>waitMicros</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier><modifier>*</modifier></type><name>polledTasks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pollFDs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pollResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>taskIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>taskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>activeTaskCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>polledTasks</name> <operator>=</operator> <operator>(</operator><name>CronTask</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>taskCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CronTask</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pollFDs</name> <operator>=</operator> <operator>(</operator>struct <name>pollfd</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>taskCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>currentTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * At the latest, wake up when the next minute starts.
   */</comment>
  <expr_stmt><expr><name>nextEventTime</name> <operator>=</operator> <call><name>TimestampMinuteEnd</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollingStatus</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pollFileDescriptor</name> <init>= <expr><operator>&amp;</operator><name><name>pollFDs</name><index>[<expr><name>activeTaskCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>activeTaskCount</name> <operator>&gt;=</operator> <name>MaxRunningTasks</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* already polling the maximum number of tasks */</comment>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_ERROR</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_DONE</name> <operator>||</operator>
      <call><name>CanStartTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* there is work to be done, don't wait */</comment>
      <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polledTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_WAITING</name> <operator>&amp;&amp;</operator> <name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* don't poll idle tasks */</comment>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_CONNECTING</name> <operator>||</operator>
      <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_SENDING</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*
       * We need to wake up when a timeout expires.
       * Take the minimum of nextEventTime and task-&gt;startDeadline.
       */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name></expr></argument>, <argument><expr><name>nextEventTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>nextEventTime</name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* we plan to poll this task */</comment>
    <expr_stmt><expr><name>pollFileDescriptor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pollFDs</name><index>[<expr><name>activeTaskCount</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>polledTasks</name><index>[<expr><name>activeTaskCount</name></expr>]</index></name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_CONNECTING</name> <operator>||</operator>
      <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_SENDING</name> <operator>||</operator>
      <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_BGW_RUNNING</name> <operator>||</operator>
      <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_RUNNING</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>pollEventMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/*
       * Set the appropriate mask for poll, based on the current polling
       * status of the task, controlled by ManageCronTask.
       */</comment>

      <if_stmt><if>if <condition>(<expr><name>pollingStatus</name> <operator>==</operator> <name>PGRES_POLLING_READING</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>pollEventMask</name> <operator>=</operator> <name>POLLERR</name> <operator>|</operator> <name>POLLIN</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>pollingStatus</name> <operator>==</operator> <name>PGRES_POLLING_WRITING</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>pollEventMask</name> <operator>=</operator> <name>POLLERR</name> <operator>|</operator> <name>POLLOUT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>pollEventMask</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/*
       * Task is not running.
       */</comment>

      <expr_stmt><expr><name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>activeTaskCount</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>

  <comment type="block">/*
   * Find the first time-based event, which is either the start of a new
   * minute or a timeout.
   */</comment>
  <expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>, <argument><expr><name>nextEventTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitSeconds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitMicros</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pollTimeout</name> <operator>=</operator> <name>waitSeconds</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>waitMicros</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pollTimeout</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polledTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>pollTimeout</name> <operator>&gt;</operator> <name>MaxWait</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*
     * We never wait more than 1 second, this gives us a chance to react
     * to external events like a TERM signal and job changes.
     */</comment>

    <expr_stmt><expr><name>pollTimeout</name> <operator>=</operator> <name>MaxWait</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>activeTaskCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* turns out there's nothing to do, just wait for something to happen */</comment>
    <expr_stmt><expr><call><name>WaitForLatch</name><argument_list>(<argument><expr><name>pollTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polledTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pollResult</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>, <argument><expr><name>activeTaskCount</name></expr></argument>, <argument><expr><name>pollTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pollResult</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*
     * This typically happens in case of a signal, though we should
     * probably check errno in case something bad happened.
     */</comment>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polledTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><expr><name>taskIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>taskIndex</name> <operator>&lt;</operator> <name>activeTaskCount</name></expr>;</condition> <incr><expr><name>taskIndex</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>polledTasks</name><index>[<expr><name>taskIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>pollFileDescriptor</name> <init>= <expr><operator>&amp;</operator><name><name>pollFDs</name><index>[<expr><name>taskIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name> <operator>=</operator> <name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>revents</name></name> <operator>&amp;</operator>
                <name><name>pollFileDescriptor</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polledTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pollFDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CanStartTask determines whether a task is ready to be started because
 * it has pending runs and we are running less than MaxRunningTasks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanStartTask</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_WAITING</name> <operator>&amp;&amp;</operator> <name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
       <name>RunningTaskCount</name> <operator>&lt;</operator> <name>MaxRunningTasks</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ManageCronTasks proceeds the state machines of the given list of tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ManageCronTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Manage tasks with designated nodes first to load balance correctly.</comment>
  <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name> <init>= <expr><call><name>GetCronJob</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cronJob</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cronJob</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ManageCronTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name> <init>= <expr><call><name>GetCronJob</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cronJob</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cronJob</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ManageCronTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ManageCronTask implements the cron task state machine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ManageCronTask</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CronTaskState</name></type> <name>checkState</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name> <init>= <expr><call><name>GetCronJob</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ConnStatusType</name></type> <name>connectionStatus</name> <init>= <expr><name>CONNECTION_BAD</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>checkState</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>CRON_TASK_WAITING</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* check if job has been removed */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* remove task as well */</comment>
        <expr_stmt><expr><call><name>RemoveTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CanStartTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>ManageCronTaskWaiting</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>cronJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="line" format="doxygen">/////////////////////////////////</comment>

      <if_stmt><if>if <condition>(<expr><name>UseBackgroundWorkers</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_BGW_START</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_START</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <expr_stmt><expr><name>RunningTaskCount</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Add new entry to audit table. */</comment>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name> <operator>=</operator> <call><name>NextRunId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InsertJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cronJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
                    <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>,
                    <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>,
                    <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_STARTING</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_REMOTE_START</name></expr>:</case>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>CRON_TASK_REMOTE_RUNNING</name></expr>:</case>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>CRON_TASK_START</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* as there is no break at the end of the previous case
       * to not add an extra second, then do another check here
       */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>UseBackgroundWorkers</name></expr>)</condition>
      <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clientEncoding</name> <init>= <expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>nodePortString</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>startDeadline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keywordArray</name><index>[]</index></name> <init>= <expr><block>{
          <expr><literal type="string">"host"</literal></expr>,
          <expr><literal type="string">"port"</literal></expr>,
          <expr><literal type="string">"fallback_application_name"</literal></expr>,
          <expr><literal type="string">"client_encoding"</literal></expr>,
          <expr><literal type="string">"dbname"</literal></expr>,
          <expr><literal type="string">"user"</literal></expr>,
          <expr><name>NULL</name></expr>
          }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>valueArray</name><index>[]</index></name> <init>= <expr><block>{
          <expr><name><name>cronJob</name><operator>-&gt;</operator><name>nodeName</name></name></expr>,
          <expr><name>nodePortString</name></expr>,
          <expr><literal type="string">"pg_cron"</literal></expr>,
          <expr><name>clientEncoding</name></expr>,
          <expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr>,
          <expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr>,
          <expr><name>NULL</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>nodePortString</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keywordArray</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>valueArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>CronLogStatement</name></expr>)</condition>
        <block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" %s: %s"</literal></expr></argument>,
                   <argument><expr><name>jobId</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_STARTING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>PQconnectStartParams</name><argument_list>(<argument><expr><name>keywordArray</name></expr></argument>, <argument><expr><name>valueArray</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>connectionStatus</name> <operator>=</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>connectionStatus</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* make sure we call PQfinish on the connection */</comment>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"connection failed"</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>startDeadline</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>,
                      <argument><expr><name>CronTaskStartTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name> <operator>=</operator> <name>startDeadline</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <name>PGRES_POLLING_WRITING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_CONNECTING</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_CONNECTING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_BGW_START</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_toc_estimator</name></type> <name>e</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Size</name></type> <name>segsize</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>bool</name></type> <name>registered</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TimestampTz</name></type> <name>startDeadline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* break in the previous case has not been reached
       * checking just for extra precaution
       */</comment>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>UseBackgroundWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pg_cron_worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_SIZE</name></cpp:macro> <cpp:value>((Size) 65536)</cpp:value></cpp:define>

      <comment type="block">/*
       * Create the shared memory that we will pass to the background
       * worker process.  We use DSM_CREATE_NULL_IF_MAXSEGMENTS so that we
       * do not ERROR here.  This way, we can mark the job as failed and
       * keep the launcher process running normally.
       */</comment>
      <expr_stmt><expr><call><name>shm_toc_initialize_estimator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>PG_CRON_NKEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>shm_toc_estimate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>, <argument><expr><name>DSM_CREATE_NULL_IF_MAXSEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"unable to create a DSM segment; more "</literal>
                <literal type="string">"details may be available in the server log"</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
          <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"max number of DSM segments may has been reached"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_create</name><argument_list>(<argument><expr><name>PG_CRON_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_DATABASE</name></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_USERNAME</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_COMMAND</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_QUEUE</name></expr></argument>, <argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*
       * Attach the queue before launching a worker, so that we'll automatically
       * detach the queue if we error out.  (Otherwise, the worker might sit
       * there trying to write the queue long after we've gone away.)
       */</comment>
      <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*
       * Prepare the background worker.
       *
       */</comment>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_cron"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><literal type="string">"CronBackgroundWorker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"pg_cron"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"pg_cron worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

      <comment type="block">/*
       * Start the worker process.
       */</comment>
      <if_stmt><if>if <condition>(<expr><name>CronLogStatement</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" %s: %s"</literal></expr></argument>,
                     <argument><expr><name>jobId</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_STARTING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Update cron job status first so that if this node goes down,</comment>
      <comment type="line">// and this job run's status is "starting",</comment>
      <comment type="line">// the cron leader can be certain that they can safely reassign</comment>
      <comment type="line">// this job run to someone else.</comment>
      <comment type="line">// This covers the case where a bg worker spawns and completes the</comment>
      <comment type="line">// job and then this node goes down before the status is</comment>
      <comment type="line">// updated to "running" / "complete" / "failed"</comment>
      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_RUNNING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* If no no background worker slots are currently available
       * let's try until we reach jobStartupTimeout
       */</comment>
      <expr_stmt><expr><name>startDeadline</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>,
                    <argument><expr><name>CronTaskStartTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name> <operator>=</operator> <name>startDeadline</name></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>registered</name> <operator>=</operator> <call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
      while <condition>(<expr><operator>!</operator><name>registered</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>jobStartupTimeout</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>registered</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"could not start background process; more "</literal>
                   <literal type="string">"details may be available in the server log"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
          <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
          <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of background worker slots"</literal></expr></argument>)</argument_list></call><operator>,</operator>
          <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to increase max_worker_processes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <operator>*</operator><name>handle</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_STARTED</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>BGWH_STOPPED</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"could not start background process; more "</literal>
                   <literal type="string">"details may be available in the server log"</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Now update the pid once the bgworker has been created</comment>
      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_BGW_RUNNING</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_CONNECTING</name></expr>:</case>
    <block>{<block_content>
      <decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollingStatus</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>UseBackgroundWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* check if job has been removed */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobCanceled</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* check if timeout has been reached */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobStartupTimeout</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* check if connection is still alive */</comment>
      <expr_stmt><expr><name>connectionStatus</name> <operator>=</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>connectionStatus</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"connection failed"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* check if socket is ready to send */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name></expr>)</condition>
      <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* check whether a connection has been established */</comment>
      <expr_stmt><expr><name>pollingStatus</name> <operator>=</operator> <call><name>PQconnectPoll</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pollingStatus</name> <operator>==</operator> <name>PGRES_POLLING_OK</name></expr>)</condition>
      <block>{<block_content>
        <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
        <comment type="block">/* wait for socket to be ready to send a query */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <name>PGRES_POLLING_WRITING</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_SENDING</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <call><name>PQbackendPID</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_SENDING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>pollingStatus</name> <operator>==</operator> <name>PGRES_POLLING_FAILED</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"connection failed"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/*
         * Connection is still being established.
         *
         * On the next WaitForTasks round, we wait for reading or writing
         * based on the status returned by PQconnectPoll, see:
         * https://www.postgresql.org/docs/9.5/static/libpq-connect.html
         */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <name>pollingStatus</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_SENDING</name></expr>:</case>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sendResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>UseBackgroundWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* check if job has been removed */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobCanceled</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* check if timeout has been reached */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobStartupTimeout</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* check if socket is ready to send */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name></expr>)</condition>
      <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* check if connection is still alive */</comment>
      <expr_stmt><expr><name>connectionStatus</name> <operator>=</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>connectionStatus</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"connection lost"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>sendResult</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>sendResult</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* wait for socket to be ready to receive results */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <name>PGRES_POLLING_READING</name></expr>;</expr_stmt>

        <comment type="block">/* command is underway, stop using timeout */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_RUNNING</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_RUNNING</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* not yet ready to send */</comment>
      </block_content>}</block></else></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_RUNNING</name></expr>:</case>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>connectionBusy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>UseBackgroundWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* check if job has been removed */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobCanceled</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* check if connection is still alive */</comment>
      <expr_stmt><expr><name>connectionStatus</name> <operator>=</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>connectionStatus</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"connection lost"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* check if socket is ready to send */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name></expr>)</condition>
      <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>connectionBusy</name> <operator>=</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>connectionBusy</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* still waiting for results */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>GetTaskFeedback</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_DONE</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="line">// Workers don't manage their number of running tasks</comment>
        <comment type="line">// Only the leader is concerned of this.</comment>
        <expr_stmt><expr><name>RunningTaskCount</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_BGW_RUNNING</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>UseBackgroundWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* check if job has been removed */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>jobCanceled</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"job cancelled "</literal> <name>INT64_FORMAT</name> <literal type="string">" run "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WaitForBackgroundWorkerShutdown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>PG_CRON_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
        <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>responseq</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* still waiting for job to complete */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BGWH_STOPPED</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>GetBgwTaskFeedback</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>GetBgwTaskFeedback</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_DONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="line">// Workers don't manage their number of running tasks</comment>
        <comment type="line">// Only the leader is concerned of this.</comment>
        <expr_stmt><expr><name>RunningTaskCount</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_ERROR</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>RemoveTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" %s"</literal></expr></argument>,
                   <argument><expr><name>jobId</name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>freeErrorMessage</name></name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>jobId</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>isSocketReady</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_DONE</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <comment type="line">// Workers don't manage their number of running tasks</comment>
        <comment type="line">// Only the leader is concerned of this.</comment>
        <expr_stmt><expr><name>RunningTaskCount</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* fall through to CRON_TASK_DONE */</comment>
    </block_content>}</block>

    <case>case <expr><name>CRON_TASK_DONE</name></expr>:</case>
    <default>default:</default>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ResetTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ManageCronTaskWaiting handles jobs who are ready to be executed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ManageCronTaskWaiting</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CronJob</name> <modifier>*</modifier></type><name>cronJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"job "</literal> <name>INT64_FORMAT</name> <literal type="string">" runCount %d"</literal></expr></argument>,
             <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>nodename</name> <init>= <expr><name><name>cronJob</name><operator>-&gt;</operator><name>nodeName</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name> <operator>=</operator> <call><name>NextRunId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nodename</name></expr>)</condition>
  <block>{<block_content>
    <comment type="line">// Node that a job is designated for is currently unavailable</comment>
    <comment type="line">// Mark this job run as a failure</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>currTime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InsertJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cronJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>nodename</name></expr></argument>,
      <argument><expr><literal type="string">"Node was not available during assignment."</literal></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>currTime</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>currTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_DONE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// Job run can be executed on any node or node that a job is designated</comment>
    <comment type="line">// for exists. Assign this job run</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nodename</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InsertJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cronJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>database</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>,
      <argument><expr><name><name>cronJob</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_STARTING</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// We always consider all jobs (including job runs assigned to ourselves)</comment>
    <comment type="line">// to initially be remotely monitored (job is not executed by this</comment>
    <comment type="line">// process's child process). Once we have picked up the</comment>
    <comment type="line">// JobRunTableChangeCallback signal, runningLocal will switch to true</comment>
    <comment type="line">// and the state will move to CRON_TASK_START. See ProcessNewJobs</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_REMOTE_START</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ManageCronTask implements the cron task state machine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckTimedOutTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="line">// Check for tasks that have not completed once per minute</comment>
  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastMinute</name> <init>= <expr><call><name>TimestampMinuteStart</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>lastQueryMinute</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>lastQueryMinute</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>lastQueryMinute</name> <operator>=</operator> <name>lastMinute</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>lastQueryMinute</name> <operator>==</operator> <name>lastMinute</name></expr>)</condition>
  <block>{<block_content>
    <comment type="line">// Wait for next minute</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>secondsPassed</name> <init>= <expr><call><name>SecondsPassed</name><argument_list>(<argument><expr><name>lastMinute</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// CronTaskStartTimeout accounts for the time a worker might</comment>
  <comment type="line">// spend waiting for a bg worker slot to free up</comment>
  <comment type="line">// MaxJobCompletionDelay accounts for the time the worker spends updating</comment>
  <comment type="line">// the job run status</comment>
  <if_stmt><if>if <condition>(<expr><name>secondsPassed</name> <operator>&lt;</operator> <name>CronTaskStartTimeout</name> <operator>/</operator> <literal type="number">1000</literal> <operator>+</operator> <name>MaxJobCompletionDelay</name></expr>)</condition>
  <block>{<block_content>
    <comment type="line">// Allow some time before we take action for job runs</comment>
    <comment type="line">// that have not completed</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>lastQueryMinute</name> <operator>=</operator> <name>lastMinute</name></expr>;</expr_stmt>

  <comment type="line">// Update status of job runs that have not completed</comment>
  <expr_stmt><expr><call><name>UpdateJobRunStatus</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Ignore local worker status as it will naturally move towards</comment>
    <comment type="line">// CRON_TASK_DONE</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_REMOTE_START</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"job "</literal> <name>INT64_FORMAT</name> <literal type="string">" run "</literal>
            <name>INT64_FORMAT</name> <literal type="string">" has not started!"</literal></expr></argument>,
            <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if<condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_REMOTE_RUNNING</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"job "</literal> <name>INT64_FORMAT</name> <literal type="string">" run "</literal>
            <name>INT64_FORMAT</name> <literal type="string">" is still running!"</literal></expr></argument>,
            <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetTaskFeedback</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>end_time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExecStatusType</name></type> <name>executionStatus</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>executionStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>executionStatus</name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdStatus</name> <init>= <expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdTuples</name> <init>= <expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_SUCCEEDED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmdStatus</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogStatement</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" COMMAND completed: %s %s"</literal></expr></argument>,
                   <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name>cmdStatus</name></expr></argument>, <argument><expr><name>cmdTuples</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>PGRES_BAD_RESPONSE</name></expr>:</case>
    <case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
    <block>{<block_content>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>freeErrorMessage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return;</return>
    </block_content>}</block>

    <case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
    <case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
    <case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
    <block>{<block_content>
      <comment type="block">/* cannot handle COPY input/output */</comment>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"COPY not supported"</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return;</return>
    </block_content>}</block>

    <case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
    <case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
    <case>case <expr><name>PGRES_SINGLE_TUPLE</name></expr>:</case>
    <case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
    <default>default:</default>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>tupleCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rowString</name> <init>= <expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"row"</literal></expr></argument>, <argument><expr><literal type="string">"rows"</literal></expr></argument>,
                       <argument><expr><name>tupleCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type>  <name><name>rows</name><index>[<expr><name>MAXINT8LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type>  <name><name>outputrows</name><index>[<expr><name>MAXINT8LEN</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>pg_lltoa</name><argument_list>(<argument><expr><name>tupleCount</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>outputrows</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outputrows</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>rowString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_SUCCEEDED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outputrows</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>CronLogStatement</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" completed: "</literal>
                   <literal type="string">"%d %s"</literal></expr></argument>,
                   <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name>tupleCount</name></expr></argument>,
                   <argument><expr><name>rowString</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <break>break;</break>
    </block_content>}</block>

  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetBgwTaskFeedback</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl></parameter>, <parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>running</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <decl_stmt><decl><type><name>TimestampTz</name></type> <name>end_time</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Size</name></type>            <name>nbytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>            <name>msgtype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>shm_mq_result</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/*
   * Message-parsing routines operate on a null-terminated StringInfo,
   * so we must construct one.
   */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
    <comment type="block">/* Get next message. */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>data</name><index>[<expr><name>nbytes</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgtype</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>msgtype</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><literal type="char">'N'</literal></expr>:</case>
      <case>case <expr><literal type="char">'E'</literal></expr>:</case>
        <block>{<block_content>
          <decl_stmt><decl><type><name>ErrorData</name></type>  <name>edata</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>display_msg</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>pq_parse_errornotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>display_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>bgw_generate_returned_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>display_msg</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition>
          <block>{<block_content>

            <if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>elevel</name></name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_FAILED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>running</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_SUCCEEDED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">": %s"</literal></expr></argument>,
                   <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <break>break;</break>
        </block_content>}</block>
      <case>case <expr><literal type="char">'T'</literal></expr>:</case>
          <break>break;</break>
      <case>case <expr><literal type="char">'C'</literal></expr>:</case>
        <block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nonconst_tag</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdTuples</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>nonconst_tag</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>CronLogRun</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UpdateJobRunDetail</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>runId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCronStatus</name><argument_list>(<argument><expr><name>CRON_STATUS_SUCCEEDED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nonconst_tag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>CronLogStatement</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>cmdTuples</name> <operator>=</operator> <call><name>pg_cron_cmdTuples</name><argument_list>(<argument><expr><name>nonconst_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cron job "</literal> <name>INT64_FORMAT</name> <literal type="string">" COMMAND completed: %s %s"</literal></expr></argument>,
                       <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name>nonconst_tag</name></expr></argument>, <argument><expr><name>cmdTuples</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nonconst_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
      <case>case <expr><literal type="char">'A'</literal></expr>:</case>
      <case>case <expr><literal type="char">'D'</literal></expr>:</case>
      <case>case <expr><literal type="char">'G'</literal></expr>:</case>
      <case>case <expr><literal type="char">'H'</literal></expr>:</case>
      <case>case <expr><literal type="char">'W'</literal></expr>:</case>
      <case>case <expr><literal type="char">'Z'</literal></expr>:</case>
          <break>break;</break>
      <default>default:</default>
          <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unknown message type: %c (%zu bytes)"</literal></expr></argument>,
             <argument><expr><name><name>msg</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Background worker logic.
 */</comment>
<function><type><name>void</name></type>
<name>CronBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>pg_cron_background_worker_sigterm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set up a memory context and resource owner. */</comment>
  <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pg_cron"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                         <argument><expr><literal type="string">"pg_cron worker"</literal></expr></argument>,
                         <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                         <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                         <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set up a dynamic shared memory segment. */</comment>
  <expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to map dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>PG_CRON_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bad magic number in dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
    <expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_USERNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_QUEUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_DATABASE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_USERNAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_COMMAND</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PG_CRON_KEY_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>responseq</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pq_redirect_to_shm_mq</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>responseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">110000</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Prepare to execute the query. */</comment>
  <expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>StatementTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <comment type="block">/* Execute the query. */</comment>
  <expr_stmt><expr><call><name>ExecuteSqlString</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Post-execution cleanup. */</comment>
  <expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Signal that we are done. */</comment>
  <expr_stmt><expr><call><name>ReadyForQuery</name><argument_list>(<argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute given SQL string without SPI or a libpq session.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSqlString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>isTopLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>commands_remaining</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>parsecontext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

  <comment type="block">/*
   * Parse the SQL string into a list of raw parse trees.
   *
   * Because we allow statements that perform internal transaction control,
   * we can't do this in TopTransactionContext; the parse trees might get
   * blown away before we're done executing them.
   */</comment>
  <expr_stmt><expr><name>parsecontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                     <argument><expr><literal type="string">"pg_cron parse/plan"</literal></expr></argument>,
                     <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                     <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                     <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>commands_remaining</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isTopLevel</name> <operator>=</operator> <name>commands_remaining</name> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Do parse analysis, rule rewrite, planning, and execution for each raw
   * parsetree.  We must fully execute each query before beginning parse
   * analysis on the next one, since there may be interdependencies.
   */</comment>
  <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
  <block>{<block_content>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator>  <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><name>CommandTag</name></type> <name>commandTag</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>QueryCompletion</name></type> <name>qc</name></decl>;</decl_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>plantree_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Portal</name></type> <name>portal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>format</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't allow transaction-control commands like COMMIT and ABORT
     * here.  The entire SQL statement is executed as a single transaction
     * which commits if no errors are encountered.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
          <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
           <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction control statements are not allowed in pg_cron"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Get the command name for use in status display (it also becomes the
     * default completion tag, down inside PortalRun).  Set ps_status and
     * do any special start-of-SQL-command processing needed by the
     * destination.
     */</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
      <expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up a snapshot if parse analysis/planning will need one. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * OK to analyze, rewrite, and plan this query.
     *
     * As with parsing, we need to make sure this data outlives the
     * transaction, because of the possibility that the statement might
     * perform internal transaction control.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
      <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
      <expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Done with the snapshot used for parsing/planning */</comment>
    <if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Execute the query using the unnamed portal.
     */</comment>
    <expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Don't display the portal in pg_cursors */</comment>
    <expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>plantree_list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* binary format */</comment>

    <expr_stmt><expr><operator>--</operator><name>commands_remaining</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Only once the portal and destreceiver have been established can
     * we return to the transaction context.  All that stuff needs to
     * survive an internal commit inside PortalRun!
     */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Here's where we actually execute the command. */</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:elif>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>,<argument><expr><name>true</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clean up the receiver. */</comment>
    <expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Send a CommandComplete message even if we suppressed the query
     * results.  The user backend will report these in the absence of
     * any true query results.
     */</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Clean up the portal. */</comment>
    <expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>

  <comment type="block">/* Be sure to advance the command counter after the last script command */</comment>
  <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If a task is not marked as active, set an appropriate error state on the task
 * and return true. Note that this should only be called after a task has
 * already been launched.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>jobCanceled</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_CONNECTING</name> <operator>||</operator> \
            <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_SENDING</name> <operator>||</operator> \
            <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_BGW_RUNNING</name> <operator>||</operator> \
            <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_RUNNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Use the American spelling for consistency with PG code. */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"job canceled"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Technically, pollingStatus is only used by when UseBackgroundWorkers
         * is false, but no damage in setting it in both cases.
         */</comment>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If a task has hit it's startup deadline, set an appropriate error state on
 * the task and return true. Note that this should only be called after a task
 * has already been launched.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>jobStartupTimeout</name><parameter_list>(<parameter><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_CONNECTING</name> <operator>||</operator> \
            <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_SENDING</name> <operator>||</operator> \
            <name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CRON_TASK_BGW_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>startDeadline</name></name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <literal type="string">"job startup timeout"</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pollingStatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CRON_TASK_ERROR</name></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Periodically query for leader state and handle initializations for
 * switching between worker and leader status
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckForLeaderStateChange</name><parameter_list>(
  <parameter><decl><type><name>bool</name></type> <name>prevLeaderState</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>currentTime</name></decl></parameter>, <parameter><decl><type><name>List</name><modifier>*</modifier></type> <name>task_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>newLeaderState</name> <init>= <expr><name>prevLeaderState</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>lastCheck</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SecondsPassed</name><argument_list>(<argument><expr><name>lastCheck</name></expr></argument>, <argument><expr><name>currentTime</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>LeaderStatusQueryPeriod</name> <operator>||</operator>
    <name>lastCheck</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>lastCheck</name> <operator>=</operator> <name>currentTime</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newLeaderState</name> <operator>!=</operator> <name>prevLeaderState</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// State transition</comment>
      <if_stmt><if>if <condition>(<expr><name>newLeaderState</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// Worker to Leader</comment>
        <comment type="line">// Only need to know the available nodes and current cluster</comment>
        <comment type="line">// load in case we need to immediately start assigning job runs</comment>
        <expr_stmt><expr><call><name>UpdateKnownNodesAndWorkload</name><argument_list>(<argument><expr><name>currentTime</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// As a worker, we always expect pending runs to be 0.</comment>
        <comment type="line">// We accept losing any queued pending runs as it is not</comment>
        <comment type="line">// normal for runs to queue up. Occurs because time suddenly</comment>
        <comment type="line">// moved fw by several minutes or execution of a job takes</comment>
        <comment type="line">// longer than the scheduling period of the job (e.g. job takes</comment>
        <comment type="line">// 2 minutes to execute but is scheduled to run every minute).</comment>
        <comment type="line">// Any remote job runs we were monitoring should be forgotten</comment>
        <comment type="line">// so we reset the task.</comment>
        <comment type="line">// Any job runs where runningLocal is true implies the job run</comment>
        <comment type="line">// is being executed locally. These runs still need to be</comment>
        <comment type="line">// monitored.</comment>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>task_list</argument>)</argument_list></macro>
        <block>{<block_content>
          <decl_stmt><decl><type><name>CronTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>CronTask</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>pendingRunCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>runningLocal</name></name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><call><name>ResetTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Leader status %d"</literal></expr></argument>, <argument><expr><name>newLeaderState</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>newLeaderState</name></expr>;</return>
</block_content>}</block></function>
</unit>
