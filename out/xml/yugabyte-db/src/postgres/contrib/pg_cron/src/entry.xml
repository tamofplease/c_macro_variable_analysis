<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/pg_cron/src/entry.c"><comment type="block">/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * All rights reserved
 *
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
 *
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          &lt;paul@vix.com&gt;          uunet!decwrl!vixie!paul
 */</comment>

<comment type="block">/* marco 04sep16 [integrated into pg_cron]
 * vix 26jan87 [RCS'd; rest of log is in RCS file]
 * vix 01jan87 [added line-level error recovery]
 * vix 31dec86 [added /step to the from-to range, per bob@acornrc]
 * vix 30dec86 [written]
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cron.h"</cpp:file></cpp:include>


<typedef>typedef  <type><enum>enum <name>ecode</name> <block>{
  <decl><name>e_none</name></decl>, <decl><name>e_minute</name></decl>, <decl><name>e_hour</name></decl>, <decl><name>e_dom</name></decl>, <decl><name>e_month</name></decl>, <decl><name>e_dow</name></decl>,
  <decl><name>e_cmd</name></decl>, <decl><name>e_timespec</name></decl>, <decl><name>e_username</name></decl>, <decl><name>e_cmd_len</name></decl>
}</block></enum></type> <name>ecode_e</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>  <name>get_list</name><argument_list>(<argument><expr><name>bitstr_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><index>[]</index></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>FILE</name> <operator>*</operator></expr></argument>)</argument_list></decl>,
    <decl><type ref="prev"/><name>get_range</name><argument_list>(<argument><expr><name>bitstr_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><index>[]</index></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>FILE</name> <operator>*</operator></expr></argument>)</argument_list></decl>,
    <decl><type ref="prev"/><name>get_number</name><argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><index>[]</index></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>FILE</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>set_element</name><parameter_list>(<parameter><decl><type><name>bitstr_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type>
<name>free_entry</name><parameter_list>(<parameter><decl><type><name>entry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>cmd</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/* return NULL if eof or syntax error occurs;
 * otherwise return a pointer to a new entry.
 *
 * Note: This function is a modified version of load_entry in Vixie
 * cron. It only parses the schedule part of a cron entry and uses
 * an in-memry buffer.
 */</comment>
<function><type><name>entry</name> <modifier>*</modifier></type>
<name>parse_cron_entry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schedule</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* this function reads one crontab entry -- the next -- from a file.
   * it skips any leading blank lines, ignores comments, and returns
   * EOF if for any reason the entry can't be read and parsed.
   *
   * the entry is also parsed here.
   *
   * syntax:
   *   user crontab:
   *  minutes hours doms months dows cmd\n
   *   system crontab (/etc/crontab):
   *  minutes hours doms months dows USERNAME cmd\n
   */</comment>

  <decl_stmt><decl><type><name>ecode_e</name></type>  <name>ecode</name> <init>= <expr><name>e_none</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>entry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>entry</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>  <name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><name>MAX_COMMAND</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>file_buffer</name></type> <name>buffer</name> <init>= <expr><block>{<expr><block>{}</block></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><block>{}</block></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>scheduleLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>scheduleLength</name> <operator>&gt;=</operator> <name>MAX_FILE_BUFFER_LENGTH</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_cmd_len</name></expr>;</expr_stmt>
    <goto>goto <name>eof</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>schedule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>scheduleLength</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>pointer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <macro><name>Debug</name><argument_list>(<argument>DPARS</argument>, <argument>(<literal type="string">"load_entry()...about to eat comments\n"</literal>)</argument>)</argument_list></macro>

  <expr_stmt><expr><call><name>skip_comments</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>free_entry</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* ch is now the first useful character of a useful line.
   * it may be an @special or it may be the first character
   * of a list of minutes.
   */</comment>

  <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* all of these should be flagged and load-limited; i.e.,
     * instead of @hourly meaning "0 * * * *" it should mean
     * "close to the front of every hour but not 'til the
     * system load is low".  Problems are: how do you know
     * what "low" means? (save me from /etc/cron.conf!) and:
     * how to guarantee low variance (how low is low?), which
     * means how to we run roughly every hour -- seems like
     * we need to keep a history or let the first hour set
     * the schedule, which means we aren't load-limited
     * anymore.  too much for my overloaded brain. (vix, jan90)
     * HINT
     */</comment>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_string</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAX_COMMAND</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">" \t\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"reboot"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"restart"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>WHEN_REBOOT</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"yearly"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"annually"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOW</name><operator>-</operator><name>FIRST_DOW</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DOW_STAR</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"monthly"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_MONTH</name><operator>-</operator><name>FIRST_MONTH</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOW</name><operator>-</operator><name>FIRST_DOW</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DOW_STAR</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"weekly"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOM</name><operator>-</operator><name>FIRST_DOM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DOM_STAR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_MONTH</name><operator>-</operator><name>FIRST_MONTH</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"daily"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"midnight"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOM</name><operator>-</operator><name>FIRST_DOM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_MONTH</name><operator>-</operator><name>FIRST_MONTH</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOW</name><operator>-</operator><name>FIRST_DOW</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"hourly"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_HOUR</name><operator>-</operator><name>FIRST_HOUR</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOM</name><operator>-</operator><name>FIRST_DOM</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_MONTH</name><operator>-</operator><name>FIRST_MONTH</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bit_nset</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LAST_DOW</name><operator>-</operator><name>FIRST_DOW</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>HR_STAR</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_timespec</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <macro><name>Debug</name><argument_list>(<argument>DPARS</argument>, <argument>(<literal type="string">"load_entry()...about to parse numerics\n"</literal>)</argument>)</argument_list></macro>

    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MIN_STAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_list</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>minute</name></name></expr></argument>, <argument><expr><name>FIRST_MINUTE</name></expr></argument>, <argument><expr><name>LAST_MINUTE</name></expr></argument>,
            <argument><expr><name>PPC_NULL</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_minute</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* hours
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>HR_STAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_list</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hour</name></name></expr></argument>, <argument><expr><name>FIRST_HOUR</name></expr></argument>, <argument><expr><name>LAST_HOUR</name></expr></argument>,
            <argument><expr><name>PPC_NULL</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_hour</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* DOM (days of month)
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DOM_STAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_list</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dom</name></name></expr></argument>, <argument><expr><name>FIRST_DOM</name></expr></argument>, <argument><expr><name>LAST_DOM</name></expr></argument>,
            <argument><expr><name>PPC_NULL</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_dom</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* month
     */</comment>

    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_list</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>FIRST_MONTH</name></expr></argument>, <argument><expr><name>LAST_MONTH</name></expr></argument>,
            <argument><expr><name>MonthNames</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_month</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* DOW (days of week)
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DOW_STAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_list</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><name>FIRST_DOW</name></expr></argument>, <argument><expr><name>LAST_DOW</name></expr></argument>,
            <argument><expr><name>DowNames</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>e_month</name></expr>;</expr_stmt>
      <goto>goto <name>eof</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* make sundays equivalent */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>bit_test</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bit_test</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>dow</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* success, fini, return pointer to the entry we just created...
   */</comment>
  <return>return <expr><name>e</name></expr>;</return>

 <label><name>eof</name>:</label>
  <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to parse entry %d"</literal></expr></argument>, <argument><expr><name>ecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_entry</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>ch</name> <operator>!=</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name></type>
<name>get_list</name><parameter_list>(<parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>low</name></type></decl></parameter>, <parameter><decl><type><name>high</name></type></decl></parameter>, <parameter><decl><type><name>names</name></type></decl></parameter>, <parameter><decl><type><name>ch</name></type></decl></parameter>, <parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
  <decl_stmt><decl><type><name>bitstr_t</name>  <modifier>*</modifier></type><name>bits</name></decl>;</decl_stmt>    <comment type="block">/* one bit per flag, default=FALSE */</comment>
  <decl_stmt><decl><type><name>int</name></type>    <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>  <comment type="block">/* bounds, impl. offset for bitstr */</comment>
  <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name><name>names</name><index>[]</index></name></decl>;</decl_stmt>  <comment type="block">/* NULL or *[] of names for these elements */</comment>
  <decl_stmt><decl><type><name>int</name></type>    <name>ch</name></decl>;</decl_stmt>    <comment type="block">/* current character being processed */</comment>
  <decl_stmt><decl><type><name>FILE</name>    <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>    <comment type="block">/* file being read */</comment>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>  <name>done</name></decl>;</decl_stmt>

  <comment type="block">/* we know that we point to a non-blank character here;
   * must do a Skip_Blanks before we exit, so that the
   * next call (or the code that picks up the cmd) can
   * assume the same thing.
   */</comment>

  <macro><name>Debug</name><argument_list>(<argument>DPARS|DEXT</argument>, <argument>(<literal type="string">"get_list()...entered\n"</literal>)</argument>)</argument_list></macro>

  <comment type="block">/* list = range {"," range}
   */</comment>

  <comment type="block">/* clear the bit string, since the default is 'off'.
   */</comment>
  <expr_stmt><expr><call><name>bit_nclear</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>high</name><operator>-</operator><name>low</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* process all ranges
   */</comment>
  <expr_stmt><expr><name>done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_range</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* exiting.  skip to some blanks, then skip over the blanks.
   */</comment>
  <macro><name>Skip_Nonblanks</name><argument_list>(<argument>ch</argument>, <argument>file</argument>)</argument_list></macro>
  <macro><name>Skip_Blanks</name><argument_list>(<argument>ch</argument>, <argument>file</argument>)</argument_list></macro>

  <macro><name>Debug</name><argument_list>(<argument>DPARS|DEXT</argument>, <argument>(<literal type="string">"get_list()...exiting w/ %02x\n"</literal>, ch)</argument>)</argument_list></macro>

  <return>return <expr><name>ch</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name></type>
<name>get_range</name><parameter_list>(<parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>low</name></type></decl></parameter>, <parameter><decl><type><name>high</name></type></decl></parameter>, <parameter><decl><type><name>names</name></type></decl></parameter>, <parameter><decl><type><name>ch</name></type></decl></parameter>, <parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
  <decl_stmt><decl><type><name>bitstr_t</name>  <modifier>*</modifier></type><name>bits</name></decl>;</decl_stmt>    <comment type="block">/* one bit per flag, default=FALSE */</comment>
  <decl_stmt><decl><type><name>int</name></type>    <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>  <comment type="block">/* bounds, impl. offset for bitstr */</comment>
  <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name><name>names</name><index>[]</index></name></decl>;</decl_stmt>  <comment type="block">/* NULL or names of elements */</comment>
  <decl_stmt><decl><type><name>int</name></type>    <name>ch</name></decl>;</decl_stmt>    <comment type="block">/* current character being processed */</comment>
  <decl_stmt><decl><type><name>FILE</name>     <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>    <comment type="block">/* file being read */</comment>
<block>{<block_content>
  <comment type="block">/* range = number | number "-" number [ "/" number ]
   */</comment>

  <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type>  <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>auto</specifier> <name>int</name></type>  <name>num1</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>, <decl><type ref="prev"/><name>num3</name></decl>;</decl_stmt>

  <macro><name>Debug</name><argument_list>(<argument>DPARS|DEXT</argument>, <argument>(<literal type="string">"get_range()...entering, exit won't show\n"</literal>)</argument>)</argument_list></macro>

  <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* '*' means "first-last" but can still be modified by /step
     */</comment>
    <expr_stmt><expr><name>num1</name> <operator>=</operator> <name>low</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>num2</name> <operator>=</operator> <name>high</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <operator>(</operator><name>ch</name> <operator>=</operator> <call><name>get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num1</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* not a range, it's a single number.
       */</comment>

      <comment type="block">/* Unsupported syntax: Step specified without range,
         eg:   1/20 * * * * /bin/echo "this fails"
       */</comment>
      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <call><name>set_element</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><name>ch</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* eat the dash
       */</comment>
      <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* get the number following the dash
       */</comment>
      <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>names</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* check for step size
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* eat the slash
     */</comment>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* get the step size -- note: we don't pass the
     * names here, because the number is not an
     * element id, it's a step size.  'low' is
     * sent as a 0 since there is no offset either.
     */</comment>
    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PPC_NULL</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>num3</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* no step.  default==1.
     */</comment>
    <expr_stmt><expr><name>num3</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Explicitly check for sane values. Certain combinations of ranges and
   * steps which should return EOF don't get picked up by the code below,
   * eg:
   *  5-64/30 * * * *  touch /dev/null
   *
   * Code adapted from set_elements() where this error was probably intended
   * to be catched.
   */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>num1</name> <argument_list type="generic">&lt; <argument><expr><name>low</name> <operator>||</operator> <name>num1</name></expr></argument> &gt;</argument_list></name> <name>high</name> <operator>||</operator> <name><name>num2</name> <argument_list type="generic">&lt; <argument><expr><name>low</name> <operator>||</operator> <name>num2</name></expr></argument> &gt;</argument_list></name> <name>high</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* range. set all elements from num1 to num2, stepping
   * by num3.  (the step is a downward-compatible extension
   * proposed conceptually by bob@acornrc, syntactically
   * designed then implemented by paul vixie).
   */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num1</name></expr>;</init>  <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num2</name></expr>;</condition>  <incr><expr><name>i</name> <operator>+=</operator> <name>num3</name></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <call><name>set_element</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

  <return>return <expr><name>ch</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name></type>
<name>get_number</name><parameter_list>(<parameter><decl><type><name>numptr</name></type></decl></parameter>, <parameter><decl><type><name>low</name></type></decl></parameter>, <parameter><decl><type><name>names</name></type></decl></parameter>, <parameter><decl><type><name>ch</name></type></decl></parameter>, <parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
  <decl_stmt><decl><type><name>int</name>  <modifier>*</modifier></type><name>numptr</name></decl>;</decl_stmt>  <comment type="block">/* where does the result go? */</comment>
  <decl_stmt><decl><type><name>int</name></type>  <name>low</name></decl>;</decl_stmt>    <comment type="block">/* offset applied to result if symbolic enum used */</comment>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name><name>names</name><index>[]</index></name></decl>;</decl_stmt>  <comment type="block">/* symbolic names, if any, for enums */</comment>
  <decl_stmt><decl><type><name>int</name></type>  <name>ch</name></decl>;</decl_stmt>    <comment type="block">/* current character */</comment>
  <decl_stmt><decl><type><name>FILE</name>     <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>    <comment type="block">/* source */</comment>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type>  <name><name>temp</name><index>[<expr><name>MAX_TEMPSTR</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>  <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>all_digits</name></decl>;</decl_stmt>

  <comment type="block">/* collect alphanumerics into our fixed-size temp array
   */</comment>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>all_digits</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>len</name> <operator>&gt;=</operator> <name>MAX_TEMPSTR</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>pc</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>all_digits</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>get_char</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

  <comment type="block">/* try to find the name in the name list
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>names</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>  <condition><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition>  <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <macro><name>Debug</name><argument_list>(<argument>DPARS|DEXT</argument>,
        <argument>(<literal type="string">"get_num, compare(%s,%s)\n"</literal>, names[i], temp)</argument>)</argument_list></macro>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>numptr</name> <operator>=</operator> <name>i</name><operator>+</operator><name>low</name></expr>;</expr_stmt>
        <return>return <expr><name>ch</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* no name list specified, or there is one and our string isn't
   * in it.  either way: if it's all digits, use its magnitude.
   * otherwise, it's an error.
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>all_digits</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>numptr</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ch</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_element</name><parameter_list>(<parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>low</name></type></decl></parameter>, <parameter><decl><type><name>high</name></type></decl></parameter>, <parameter><decl><type><name>number</name></type></decl></parameter>)</parameter_list>
  <decl_stmt><decl><type><name>bitstr_t</name>  <modifier>*</modifier></type><name>bits</name></decl>;</decl_stmt>     <comment type="block">/* one bit per flag, default=FALSE */</comment>
  <decl_stmt><decl><type><name>int</name></type>    <name>low</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>    <name>high</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>    <name>number</name></decl>;</decl_stmt>
<block>{<block_content>
  <macro><name>Debug</name><argument_list>(<argument>DPARS|DEXT</argument>, <argument>(<literal type="string">"set_element(?,%d,%d,%d)\n"</literal>, low, high, number)</argument>)</argument_list></macro>

  <if_stmt><if>if <condition>(<expr><name><name>number</name> <argument_list type="generic">&lt; <argument><expr><name>low</name> <operator>||</operator> <name>number</name></expr></argument> &gt;</argument_list></name> <name>high</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>bit_set</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><operator>(</operator><name>number</name><operator>-</operator><name>low</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
