<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/pgrowlocks/pgrowlocks.c"><comment type="block">/*
 * contrib/pgrowlocks/pgrowlocks.c
 *
 * Copyright (c) 2005-2006	Tatsuo Ishii
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose, without fee, and without a
 * written agreement is hereby granted, provided that the above
 * copyright notice and this paragraph and the following two
 * paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS
 * IS" BASIS, AND THE AUTHOR HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
 * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pgrowlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ----------
 * pgrowlocks:
 * returns tids of rows being locked
 * ----------
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCHARS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
}</block></struct></type> <name>MyData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_tid</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_xmax</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_ismulti</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_xids</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_modes</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>Atnum_pids</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>pgrowlocks</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MyData</name>	   <modifier>*</modifier></type><name>mydata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relrv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build a tuple descriptor for our result type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <name>attinmeta</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relrv</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name>relrv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a partitioned table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partitioned tables do not contain rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * check permissions: must have SELECT on table or be in
		 * pg_stat_scan_tables
		 */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <ternary><condition><expr><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_STAT_SCAN_TABLES</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ACLCHECK_OK</name></expr> </then><else>: <expr><name>ACLCHECK_NO_PRIV</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mydata</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mydata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <name>scan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>mydata</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mydata</name> <operator>=</operator> <operator>(</operator><name>MyData</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>mydata</name><operator>-&gt;</operator><name>scan</name></name></expr>;</expr_stmt>

	<comment type="block">/* scan the relation */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>htsu</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask</name></decl>;</decl_stmt>

		<comment type="block">/* must hold a buffer lock to call HeapTupleSatisfiesUpdate */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>htsu</name> <operator>=</operator> <call><name>HeapTupleSatisfiesUpdate</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										<argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * A tuple is locked if HTSU returns BeingUpdated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>htsu</name> <operator>==</operator> <name>HeapTupleBeingUpdated</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>mydata</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_tid</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tidout</name></expr></argument>,
															 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_xmax</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xmax</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>allow_old</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_ismulti</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>allow_old</name> <operator>=</operator> <call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>allow_old</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name> <operator>=</operator> <literal type="string">"{0}"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name> <operator>=</operator> <literal type="string">"{transient upgrade status}"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name> <operator>=</operator> <literal type="string">"{0}"</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>NCHARS</name></expr>]</index></name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>members</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><name><name>members</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>status</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>MultiXactStatusUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"Update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>MultiXactStatusNoKeyUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"No Key Update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>MultiXactStatusForUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"For Update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>MultiXactStatusForNoKeyUpdate</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"For No Key Update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>MultiXactStatusForShare</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"Share"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>MultiXactStatusForKeyShare</name></expr>:</case>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"Key Share"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
						<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
								 <argument><expr><call><name>BackendXidGetPid</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></for>

					<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_ismulti</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_xids</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{%d}"</literal></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_LOCK_ONLY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_SHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{For Share}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{For Key Share}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{For Update}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{For No Key Update}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<comment type="block">/* neither keyshare nor exclusive bit it set */</comment>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>,
								 <argument><expr><literal type="string">"{transient upgrade status}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{Update}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_modes</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{No Key Update}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NCHARS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Atnum_pids</name></expr>]</index></name></expr></argument>, <argument><expr><name>NCHARS</name></expr></argument>, <argument><expr><literal type="string">"{%d}"</literal></expr></argument>,
						 <argument><expr><call><name>BackendXidGetPid</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* build a tuple */</comment>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* make the tuple into a datum */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * no need to pfree what we allocated; it's on a short-lived
			 * memory context anyway
			 */</comment>

			<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>mydata</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
