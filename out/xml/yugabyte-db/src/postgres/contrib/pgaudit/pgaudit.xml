<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/pgaudit/pgaudit.c"><comment type="block">/*------------------------------------------------------------------------------
 * pgaudit.c
 *
 * An audit logging extension for PostgreSQL. Provides detailed logging classes,
 * object level logging, and fully-qualified object names for all DML and DDL
 * statements where possible (See README.md for details).
 *
 * Copyright (c) 2014-2020, PostgreSQL Global Development Group
 *------------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/params.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/deparse_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pgaudit_ddl_command_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pgaudit_sql_drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Log Classes
 *
 * pgAudit categorizes actions into classes (eg: DDL, FUNCTION calls, READ
 * queries, WRITE queries).  A GUC is provided for the administrator to
 * configure which class (or classes) of actions to include in the
 * audit log.  We track the currently active set of classes using
 * auditLogBitmap.
 */</comment>

<comment type="block">/* Bits within auditLogBitmap, defines the classes we understand */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_DDL</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>      <comment type="block">/* CREATE/DROP/ALTER objects */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_FUNCTION</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define> <comment type="block">/* Functions and DO blocks */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_MISC</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>     <comment type="block">/* Statements not covered */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_READ</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>     <comment type="block">/* SELECTs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_ROLE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>     <comment type="block">/* GRANT/REVOKE, CREATE/ALTER/DROP ROLE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_WRITE</name></cpp:macro> <cpp:value>(1 &lt;&lt; 5)</cpp:value></cpp:define>    <comment type="block">/* INSERT, UPDATE, DELETE, TRUNCATE */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>           <comment type="block">/* nothing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_ALL</name></cpp:macro> <cpp:value>(0xFFFFFFFF)</cpp:value></cpp:define> <comment type="block">/* All */</comment>

<comment type="block">/* GUC variable for pgaudit.log, which defines the classes to log. */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>auditLog</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Bitmap of classes selected */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>auditLogBitmap</name> <init>= <expr><name>LOG_NONE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * String constants for log classes - used when processing tokens in the
 * pgaudit.log GUC.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_DDL</name></cpp:macro> <cpp:value>"DDL"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_FUNCTION</name></cpp:macro> <cpp:value>"FUNCTION"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_MISC</name></cpp:macro> <cpp:value>"MISC"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_READ</name></cpp:macro> <cpp:value>"READ"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_ROLE</name></cpp:macro> <cpp:value>"ROLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_WRITE</name></cpp:macro> <cpp:value>"WRITE"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_NONE</name></cpp:macro> <cpp:value>"NONE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_ALL</name></cpp:macro> <cpp:value>"ALL"</cpp:value></cpp:define>

<comment type="block">/*
 * GUC variable for pgaudit.log_catalog
 *
 * Administrators can choose to NOT log queries when all relations used in
 * the query are in pg_catalog.  Interactive sessions (eg: psql) can cause
 * a lot of noise in the logs which might be uninteresting.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>auditLogCatalog</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.log_client
 *
 * Specifies whether audit messages should be visible to the client.  This
 * setting should generally be left disabled but may be useful for debugging or
 * other purposes.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>auditLogClient</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.log_level
 *
 * Administrators can choose which log level the audit log is to be logged
 * at.  The default level is LOG, which goes into the server log but does
 * not go to the client.  Set to NOTICE in the regression tests.
 */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>auditLogLevelString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>auditLogLevel</name> <init>= <expr><name>LOG</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.log_parameter
 *
 * Administrators can choose if parameters passed into a statement are
 * included in the audit log.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>auditLogParameter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.log_relation
 *
 * Administrators can choose, in SESSION logging, to log each relation involved
 * in READ/WRITE class queries.  By default, SESSION logs include the query but
 * do not have a log entry for each relation.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>auditLogRelation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.log_statement_once
 *
 * Administrators can choose to have the statement run logged only once instead
 * of on every line.  By default, the statement is repeated on every line of
 * the audit log to facilitate searching, but this can cause the log to be
 * unnecessairly bloated in some environments.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>auditLogStatementOnce</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC variable for pgaudit.role
 *
 * Administrators can choose which role to base OBJECT auditing off of.
 * Object-level auditing uses the privileges which are granted to this role to
 * determine if a statement should be logged.
 */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>auditRole</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * String constants for the audit log fields.
 */</comment>

<comment type="block">/*
 * Audit type, which is responsbile for the log message
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUDIT_TYPE_OBJECT</name></cpp:macro> <cpp:value>"OBJECT"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUDIT_TYPE_SESSION</name></cpp:macro> <cpp:value>"SESSION"</cpp:value></cpp:define>

<comment type="block">/*
 * Command, used for SELECT/DML and function calls.
 *
 * We hook into the executor, but we do not have access to the parsetree there.
 * Therefore we can't simply call CreateCommandTag() to get the command and have
 * to build it ourselves based on what information we do have.
 *
 * These should be updated if new commands are added to what the exectuor
 * currently handles.  Note that most of the interesting commands do not go
 * through the executor but rather ProcessUtility, where we have the parsetree.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_SELECT</name></cpp:macro> <cpp:value>"SELECT"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_INSERT</name></cpp:macro> <cpp:value>"INSERT"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_UPDATE</name></cpp:macro> <cpp:value>"UPDATE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_DELETE</name></cpp:macro> <cpp:value>"DELETE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_EXECUTE</name></cpp:macro> <cpp:value>"EXECUTE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_UNKNOWN</name></cpp:macro> <cpp:value>"UNKNOWN"</cpp:value></cpp:define>

<comment type="block">/*
 * Object type, used for SELECT/DML statements and function calls.
 *
 * For relation objects, this is essentially relkind (though we do not have
 * access to a function which will just return a string given a relkind;
 * getRelationTypeDescription() comes close but is not public currently).
 *
 * We also handle functions, so it isn't quite as simple as just relkind.
 *
 * This should be kept consistent with what is returned from
 * pg_event_trigger_ddl_commands(), as that's what we use for DDL.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_TABLE</name></cpp:macro> <cpp:value>"TABLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_INDEX</name></cpp:macro> <cpp:value>"INDEX"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_SEQUENCE</name></cpp:macro> <cpp:value>"SEQUENCE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_TOASTVALUE</name></cpp:macro> <cpp:value>"TOAST TABLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_VIEW</name></cpp:macro> <cpp:value>"VIEW"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_MATVIEW</name></cpp:macro> <cpp:value>"MATERIALIZED VIEW"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_COMPOSITE_TYPE</name></cpp:macro> <cpp:value>"COMPOSITE TYPE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_FOREIGN_TABLE</name></cpp:macro> <cpp:value>"FOREIGN TABLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_FUNCTION</name></cpp:macro> <cpp:value>"FUNCTION"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJECT_TYPE_UNKNOWN</name></cpp:macro> <cpp:value>"UNKNOWN"</cpp:value></cpp:define>

<comment type="block">/*
 * String constants for testing role commands.  Rename and drop role statements
 * are assigned the nodeTag T_RenameStmt and T_DropStmt respectively.  This is
 * not very useful for classification, so we resort to comparing strings
 * against the result of CreateCommandTag(parsetree).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_ALTER_ROLE</name></cpp:macro> <cpp:value>"ALTER ROLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_DROP_ROLE</name></cpp:macro> <cpp:value>"DROP ROLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_GRANT</name></cpp:macro> <cpp:value>"GRANT"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_REVOKE</name></cpp:macro> <cpp:value>"REVOKE"</cpp:value></cpp:define>

<comment type="block">/*
 * An AuditEvent represents an operation that potentially affects a single
 * object.  If a statement affects multiple objects then multiple AuditEvents
 * are created to represent them.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>int64</name></type> <name>statementId</name></decl>;</decl_stmt>    <comment type="block">/* Simple counter */</comment>
  <decl_stmt><decl><type><name>int64</name></type> <name>substatementId</name></decl>;</decl_stmt> <comment type="block">/* Simple counter */</comment>

  <decl_stmt><decl><type><name>LogStmtLevel</name></type> <name>logStmtLevel</name></decl>;</decl_stmt> <comment type="block">/* From GetCommandLogLevel when possible,
                                generated when not. */</comment>
  <decl_stmt><decl><type><name>NodeTag</name></type> <name>commandTag</name></decl>;</decl_stmt>        <comment type="block">/* same here */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>       <comment type="block">/* same here */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objectType</name></decl>;</decl_stmt>    <comment type="block">/* From event trigger when possible,
                                generated when not. */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>objectName</name></decl>;</decl_stmt>          <comment type="block">/* Fully qualified object identification */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandText</name></decl>;</decl_stmt>   <comment type="block">/* sourceText / queryString */</comment>
  <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramList</name></decl>;</decl_stmt>   <comment type="block">/* QueryDesc/ProcessUtility parameters */</comment>

  <decl_stmt><decl><type><name>bool</name></type> <name>granted</name></decl>;</decl_stmt>         <comment type="block">/* Audit role has object permissions? */</comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>logged</name></decl>;</decl_stmt>          <comment type="block">/* Track if we have logged this event, used
                           post-ProcessUtility to make sure we log */</comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>statementLogged</name></decl>;</decl_stmt> <comment type="block">/* Track if we have logged the statement */</comment>
}</block></struct></type> <name>AuditEvent</name>;</typedef>

<comment type="block">/*
 * A simple FIFO queue to keep track of the current stack of audit events.
 */</comment>
<typedef>typedef <type><struct>struct <name>AuditEventStackItem</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>AuditEventStackItem</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>AuditEvent</name></type> <name>auditEvent</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64</name></type> <name>stackId</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextAudit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContextCallback</name></type> <name>contextCallback</name></decl>;</decl_stmt>
}</block></struct></type> <name>AuditEventStackItem</name>;</typedef>

<decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>auditEventStack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * pgAudit runs queries of its own when using the event trigger system.
 *
 * Track when we are running a query and don't log it.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>internalStatement</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Track running total for statements and substatements and whether or not
 * anything has been logged since the current statement began.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>statementTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>substatementTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>stackTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>statementLogged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Stack functions
 *
 * Audit events can go down to multiple levels so a stack is maintained to keep
 * track of them.
 */</comment>

<comment type="block">/*
 * Respond to callbacks registered with MemoryContextRegisterResetCallback().
 * Removes the event(s) off the stack that have become obsolete once the
 * MemoryContext has been freed.  The callback should always be freeing the top
 * of the stack, but the code is tolerant of out-of-order callbacks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stack_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>stackFree</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>nextItem</name> <init>= <expr><name>auditEventStack</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Only process if the stack contains items */</comment>
  <while>while <condition>(<expr><name>nextItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Check if this item matches the item to be freed */</comment>
    <if_stmt><if>if <condition>(<expr><name>nextItem</name> <operator>==</operator> <operator>(</operator><name>AuditEventStackItem</name> <operator>*</operator><operator>)</operator><name>stackFree</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Move top of stack to the item after the freed item */</comment>
      <expr_stmt><expr><name>auditEventStack</name> <operator>=</operator> <name><name>nextItem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

      <comment type="block">/* If the stack is not empty */</comment>
      <if_stmt><if>if <condition>(<expr><name>auditEventStack</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/*
         * Reset internal statement to false.  Normally this will be
         * reset but in case of an error it might be left set.
         */</comment>
        <expr_stmt><expr><name>internalStatement</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Reset sub statement total so the next statement will start
         * from 1.
         */</comment>
        <expr_stmt><expr><name>substatementTotal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Reset statement logged so that next statement will be
         * logged.
         */</comment>
        <expr_stmt><expr><name>statementLogged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nextItem</name> <operator>=</operator> <name><name>nextItem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Push a new audit event onto the stack and create a new memory context to
 * store it.
 */</comment>
<function><type><specifier>static</specifier> <name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stack_push</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextAudit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stackItem</name></decl>;</decl_stmt>

  <comment type="block">/*
   * Create a new memory context to contain the stack item.  This will be
   * free'd on stack_pop, or by our callback when the parent context is
   * destroyed.
   */</comment>
  <expr_stmt><expr><name>contextAudit</name> <operator>=</operator>
      <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"pgaudit stack context"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save the old context to switch back to at the end */</comment>
  <expr_stmt><expr><name>contextOld</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextAudit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create our new stack item in our context */</comment>
  <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AuditEventStackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>contextAudit</name></name> <operator>=</operator> <name>contextAudit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>stackId</name></name> <operator>=</operator> <operator>++</operator><name>stackTotal</name></expr>;</expr_stmt>

  <comment type="block">/*
   * Setup a callback in case an error happens.  stack_free() will truncate
   * the stack at this item.
   */</comment>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>contextCallback</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>stack_free</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>contextCallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>stackItem</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name>contextAudit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stackItem</name><operator>-&gt;</operator><name>contextCallback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Push new item onto the stack */</comment>
  <if_stmt><if>if <condition>(<expr><name>auditEventStack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>auditEventStack</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><name>auditEventStack</name> <operator>=</operator> <name>stackItem</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>stackItem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pop an audit event from the stack by deleting the memory context that
 * contains it.  The callback to stack_free() does the actual pop.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stack_pop</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>stackId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Make sure what we want to delete is at the top of the stack */</comment>
  <if_stmt><if>if <condition>(<expr><name>auditEventStack</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>auditEventStack</name><operator>-&gt;</operator><name>stackId</name></name> <operator>==</operator> <name>stackId</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>contextAudit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit stack item "</literal> <name>INT64_FORMAT</name> <literal type="string">" not found on top - cannot pop"</literal></expr></argument>, <argument><expr><name>stackId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that an item is on the stack.  If not, an error will be raised since
 * this is a bad state to be in and it might mean audit records are being lost.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stack_valid</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>stackId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>nextItem</name> <init>= <expr><name>auditEventStack</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look through the stack for the stack entry */</comment>
  <while>while <condition>(<expr><name>nextItem</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>nextItem</name><operator>-&gt;</operator><name>stackId</name></name> <operator>!=</operator> <name>stackId</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nextItem</name> <operator>=</operator> <name><name>nextItem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>

  <comment type="block">/* If we didn't find it, something went wrong. */</comment>
  <if_stmt><if>if <condition>(<expr><name>nextItem</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(
        <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit stack item "</literal> <name>INT64_FORMAT</name> <literal type="string">" not found - top of stack is "</literal> <name>INT64_FORMAT</name> <literal type="string">""</literal></expr></argument>,
        <argument><expr><name>stackId</name></expr></argument>, <argument><expr><ternary><condition><expr><name>auditEventStack</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>(</operator><name>int64</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>stackId</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Appends a properly quoted CSV field to StringInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append_valid_csv</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>appendStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pChar</name></decl>;</decl_stmt>

  <comment type="block">/*
   * If the append string is null then do nothing.  NULL fields are not
   * quoted in CSV.
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>appendStr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Only format for CSV if appendStr contains: ", comma, \n, \r */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>appendStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>appendStr</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>appendStr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
      <call><name>strstr</name><argument_list>(<argument><expr><name>appendStr</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>pChar</name> <operator>=</operator> <name>appendStr</name></expr>;</init> <condition><expr><operator>*</operator><name>pChar</name></expr>;</condition> <incr><expr><name>pChar</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pChar</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
        <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>*</operator><name>pChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>*</operator><name>pChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Else just append */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>appendStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Takes an AuditEvent, classifies it, then logs it if appropriate.
 *
 * Logging is decided based on if the statement is in one of the classes being
 * logged or if an object used has been marked for auditing.
 *
 * Objects are marked for auditing by the auditor role being granted access
 * to the object.  The kind of access (INSERT, UPDATE, etc) is also considered
 * and logging is only performed when the kind of access matches the granted
 * right on the object.
 *
 * This will need to be updated if new kinds of GRANTs are added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>log_audit_event</name><parameter_list>(<parameter><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stackItem</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* By default, put everything in the MISC class. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>class</name> <init>= <expr><name>LOG_MISC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>className</name> <init>= <expr><name>CLASS_MISC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringInfoData</name></type> <name>auditStr</name></decl>;</decl_stmt>

  <comment type="block">/* If this event has already been logged don't log it again */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Classify the statement using log stmt level and the command tag */</comment>
  <switch>switch <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* All mods go in WRITE class, except EXECUTE */</comment>
    <case>case <expr><name>LOGSTMT_MOD</name></expr>:</case>
      <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_WRITE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_WRITE</name></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Currently, only EXECUTE is different */</comment>
        <case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
          <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_MISC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_MISC</name></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>
      <break>break;</break>

    <comment type="block">/* These are DDL, unless they are ROLE */</comment>
    <case>case <expr><name>LOGSTMT_DDL</name></expr>:</case>
      <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_DDL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_DDL</name></expr>;</expr_stmt>

      <comment type="block">/* Identify role statements */</comment>
      <switch>switch <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* In the case of create and alter role redact all text in the
         * command after the password token for security.  This doesn't
         * cover all possible cases where passwords can be leaked but
         * should take care of the most common usage.
         */</comment>
        <case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>

          <if_stmt><if>if <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name> <operator>=</operator> <call><name>RedactPasswordIfExists</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Classify role statements */</comment>
        <case>case <expr><name>T_GrantStmt</name></expr>:</case>
        <case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
        <case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
          <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_ROLE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_ROLE</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/*
         * Rename and Drop are general and therefore we have to do
         * an additional check against the command string to see
         * if they are role or regular DDL.
         */</comment>
        <case>case <expr><name>T_RenameStmt</name></expr>:</case>
        <case>case <expr><name>T_DropStmt</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name></expr></argument>, <argument><expr><name>COMMAND_ALTER_ROLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
              <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name></expr></argument>, <argument><expr><name>COMMAND_DROP_ROLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_ROLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_ROLE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <break>break;</break>

        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>
      <break>break;</break>

    <comment type="block">/* Classify the rest */</comment>
    <case>case <expr><name>LOGSTMT_ALL</name></expr>:</case>
      <switch>switch <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* READ statements */</comment>
        <case>case <expr><name>T_CopyStmt</name></expr>:</case>
        <case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
        <case>case <expr><name>T_SelectStmt</name></expr>:</case>
        <case>case <expr><name>T_PrepareStmt</name></expr>:</case>
        <case>case <expr><name>T_PlannedStmt</name></expr>:</case>
          <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_READ</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_READ</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* FUNCTION statements */</comment>
        <case>case <expr><name>T_DoStmt</name></expr>:</case>
          <expr_stmt><expr><name>className</name> <operator>=</operator> <name>CLASS_FUNCTION</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_FUNCTION</name></expr>;</expr_stmt>
          <break>break;</break>

        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>
      <break>break;</break>

    <case>case <expr><name>LOGSTMT_NONE</name></expr>:</case>
      <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/*
   * Only log the statement if:
   *
   * 1. The object was selected for audit logging (granted), or
   * 2. The statement belongs to a class that is being logged
   *
   * If neither of these is true, return.
   */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>auditLogBitmap</name> <operator>&amp;</operator> <name>class</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/*
   * Use audit memory context in case something is not free'd while
   * appending strings and parameters.
   */</comment>
  <expr_stmt><expr><name>contextOld</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>contextAudit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set statement and substatement IDs */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>statementId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* If nothing has been logged yet then create a new statement Id */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>statementLogged</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>statementTotal</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>statementLogged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>statementId</name></name> <operator>=</operator> <name>statementTotal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>substatementId</name></name> <operator>=</operator> <operator>++</operator><name>substatementTotal</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
   * Create the audit substring
   *
   * The type-of-audit-log and statement/substatement ID are handled below,
   * this string is everything else.
   */</comment>
  <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * If auditLogStatmentOnce is true, then only log the statement and
   * parameters if they have not already been logged for this substatement.
   */</comment>
  <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>statementLogged</name></name> <operator>||</operator> <operator>!</operator><name>auditLogStatementOnce</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Handle parameter logging, if enabled. */</comment>
    <if_stmt><if>if <condition>(<expr><name>auditLogParameter</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>paramIdx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>numParams</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>StringInfoData</name></type> <name>paramStrResult</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramList</name> <init>= <expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>paramList</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>numParams</name> <operator>=</operator> <ternary><condition><expr><name>paramList</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>paramList</name><operator>-&gt;</operator><name>numParams</name></name></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* Create the param substring */</comment>
      <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramStrResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Iterate through all params */</comment>
      <for>for <control>(<init><expr><name>paramIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>paramIdx</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>paramIdx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramList</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>typeOutput</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>typeIsVarLena</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>paramStr</name></decl>;</decl_stmt>

        <comment type="block">/* Add a comma for each param */</comment>
        <if_stmt><if>if <condition>(<expr><name>paramIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramStrResult</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Skip if null or if oid is invalid */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Output the string */</comment>
        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIsVarLena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramStr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typeOutput</name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramStrResult</name></expr></argument>, <argument><expr><name>paramStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>paramStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="string">"&lt;none&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>append_valid_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><name><name>paramStrResult</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="string">"&lt;not logged&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>statementLogged</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
    <comment type="block">/* we were asked to not log it */</comment>
    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auditStr</name></expr></argument>, <argument><expr><literal type="string">"&lt;previously logged&gt;,&lt;previously logged&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <comment type="block">/*
   * Log the audit entry.  Note: use of INT64_FORMAT here is bad for
   * translatability, but we currently haven't got translation support in
   * pgaudit anyway.
   */</comment>
  <expr_stmt><expr><call><name>ereport</name><argument_list>(
      <argument><expr><ternary><condition><expr><name>auditLogClient</name></expr> ?</condition><then> <expr><name>auditLogLevel</name></expr> </then><else>: <expr><name>LOG_SERVER_ONLY</name></expr></else></ternary></expr></argument>,
      <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
           <argument><expr><literal type="string">"AUDIT: %s,"</literal> <name>INT64_FORMAT</name> <literal type="string">","</literal> <name>INT64_FORMAT</name> <literal type="string">",%s,%s"</literal></expr></argument>,
           <argument><expr><ternary><condition><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name></expr> ?</condition><then> <expr><name>AUDIT_TYPE_OBJECT</name></expr> </then><else>: <expr><name>AUDIT_TYPE_SESSION</name></expr></else></ternary></expr></argument>,
           <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>statementId</name></name></expr></argument>,
           <argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>substatementId</name></name></expr></argument>,
           <argument><expr><name>className</name></expr></argument>,
           <argument><expr><name><name>auditStr</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
       <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
       <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the role or any inherited role has any permission in the mask.  The
 * public role is excluded from this check and superuser permissions are not
 * considered.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>audit_on_acl</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>aclDatum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>auditOid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItemData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>aclIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>aclTotal</name></decl>;</decl_stmt>

  <comment type="block">/* Detoast column's ACL if necessary */</comment>
  <expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the acl list and total number of items */</comment>
  <expr_stmt><expr><name>aclTotal</name> <operator>=</operator> <call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aclItemData</name> <operator>=</operator> <call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check privileges granted directly to auditOid */</comment>
  <for>for <control>(<init><expr><name>aclIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aclIndex</name> <operator>&lt;</operator> <name>aclTotal</name></expr>;</condition> <incr><expr><name>aclIndex</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name> <init>= <expr><operator>&amp;</operator><name><name>aclItemData</name><index>[<expr><name>aclIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name> <operator>==</operator> <name>auditOid</name> <operator>&amp;&amp;</operator> <name><name>aclItem</name><operator>-&gt;</operator><name>ai_privs</name></name> <operator>&amp;</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/*
   * Check privileges granted indirectly via role memberships. We do this in
   * a separate pass to minimize expensive indirect membership tests.  In
   * particular, it's worth testing whether a given ACL entry grants any
   * privileges still of interest before we perform the has_privs_of_role
   * test.
   */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>aclIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aclIndex</name> <operator>&lt;</operator> <name>aclTotal</name></expr>;</condition> <incr><expr><name>aclIndex</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name> <init>= <expr><operator>&amp;</operator><name><name>aclItemData</name><index>[<expr><name>aclIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Don't test public or auditOid (it has been tested already) */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name> <operator>==</operator> <name>ACL_ID_PUBLIC</name> <operator>||</operator> <name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name> <operator>==</operator> <name>auditOid</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/*
       * Check that the role has the required privileges and that it is
       * inherited by auditOid.
       */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_privs</name></name> <operator>&amp;</operator> <name>mask</name> <operator>&amp;&amp;</operator> <call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we have a detoasted copy, free it */</comment>
  <if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator><name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a role has any of the permissions in the mask on a relation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>audit_on_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>auditOid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>

  <comment type="block">/* Get relation tuple from pg_class */</comment>
  <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Get the relation's ACL */</comment>
  <expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only check if non-NULL, since NULL means no permissions */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>audit_on_acl</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Free the relation tuple */</comment>
  <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a role has any of the permissions in the mask on a column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>audit_on_attribute</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attNum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>auditOid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HeapTuple</name></type> <name>attTuple</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>

  <comment type="block">/* Get the attribute's ACL */</comment>
  <expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Only consider attributes that have not been dropped */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><name>attTuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>audit_on_acl</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Free attribute */</comment>
  <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a role has any of the permissions in the mask on a column in
 * the provided set.  If the set is empty, then all valid columns in the
 * relation will be tested.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>audit_on_any_attribute</name><parameter_list>(
    <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>auditOid</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attributeSet</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AttrNumber</name></type> <name>col</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>tmpSet</name></decl>;</decl_stmt>

  <comment type="block">/* If bms is empty then check for any column match */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>attributeSet</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>nattrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>curr_att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>classTuple</name></decl>;</decl_stmt>
    <comment type="block">/* Get relation to determine total columns */</comment>
    <expr_stmt><expr><name>classTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nattrs</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check each column */</comment>
    <for>for <control>(<init><expr><name>curr_att</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_att</name> <operator>&lt;=</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>curr_att</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><call><name>audit_on_attribute</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>curr_att</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* bms_first_member is destructive, so make a copy before using it. */</comment>
  <expr_stmt><expr><name>tmpSet</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>attributeSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check each column */</comment>
  <while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpSet</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>col</name> <operator>+=</operator> <name>YBFirstLowInvalidAttributeNumber</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>col</name> <operator>+=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>col</name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <call><name>audit_on_attribute</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create AuditEvents for SELECT/DML operations via executor permissions checks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>log_select_dml</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>auditOid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTabls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Do not log if this is an internal statement */</comment>
  <if_stmt><if>if <condition>(<expr><name>internalStatement</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <macro><name>foreach</name> <argument_list>(<argument>lr</argument>, <argument>rangeTabls</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>relNamespaceOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We only care about tables, and can ignore subqueries etc. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Don't log if the session user is not a member of the current
     * role.  This prevents contents of security definer functions
     * from being logged and supresses foreign key queries unless the
     * session user is the owner of the referenced table.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we are not logging all-catalog queries (auditLogCatalog is
     * false) then filter out any system relations here.
     */</comment>
    <expr_stmt><expr><name>relOid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>relNamespaceOid</name> <operator>=</operator> <call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>auditLogCatalog</name> <operator>&amp;&amp;</operator> <call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name>relNamespaceOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Default is that this was not through a grant, to support session
     * logging.  Will be updated below if a grant is found.
     */</comment>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If this is the first RTE then session log unless auditLogRelation
     * is set.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>first</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>auditLogRelation</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We don't have access to the parsetree here, so we have to generate
     * the node type, object type, and command tag by decoding
     * rte-&gt;requiredPerms and rte-&gt;relkind.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <name>ACL_INSERT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_InsertStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_INSERT</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <name>ACL_UPDATE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_UpdateStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_UPDATE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <name>ACL_DELETE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_DeleteStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_DELETE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_SelectStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_SELECT</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_Invalid</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_UNKNOWN</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Use the relation type to assign object type */</comment>
    <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
      <case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_TABLE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
      <case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_INDEX</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_SEQUENCE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_TOASTVALUE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_VIEW</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_COMPOSITE_TYPE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_FOREIGN_TABLE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_MATVIEW</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_UNKNOWN</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Get a copy of the relation name and assign it to object name */</comment>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name> <operator>=</operator>
        <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>relNamespaceOid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform object auditing only if the audit role is valid */</comment>
    <if_stmt><if>if <condition>(<expr><name>auditOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>AclMode</name></type> <name>auditPerms</name> <init>= <expr><operator>(</operator><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_INSERT</name> <operator>|</operator> <name>ACL_DELETE</name><operator>)</operator> <operator>&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/*
       * If any of the required permissions for the relation are granted
       * to the audit role then audit the relation
       */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>audit_on_relation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>auditPerms</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

      <comment type="block">/*
       * Else check if the audit role has column-level permissions for
       * select, insert, or update.
       */</comment>
      <if type="elseif">else if <condition>(<expr><name>auditPerms</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/*
         * Check the select columns
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>auditPerms</name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator>
              <call><name>audit_on_any_attribute</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check the insert columns
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>&amp;&amp;</operator> <name>auditPerms</name> <operator>&amp;</operator> <name>ACL_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator>
              <call><name>audit_on_any_attribute</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>, <argument><expr><name>auditPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check the update columns
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>&amp;&amp;</operator> <name>auditPerms</name> <operator>&amp;</operator> <name>ACL_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator>
              <call><name>audit_on_any_attribute</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>auditPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do relation level logging if a grant was found */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do relation level logging if auditLogRelation is set */</comment>
    <if_stmt><if>if <condition>(<expr><name>auditLogRelation</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>

  <comment type="block">/*
   * If no tables were found that means that RangeTbls was empty or all
   * relations were in the system schema.  In that case still log a session
   * record.
   */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>granted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create AuditEvents for non-catalog function execution, as detected by
 * log_object_access() below.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>log_function_execute</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stackItem</name></decl>;</decl_stmt>

  <comment type="block">/* Get info about the function. */</comment>
  <expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>proctup</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Logging execution of all pg_catalog functions would make the log
   * unusably noisy.
   */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Push audit event onto the stack */</comment>
  <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <call><name>stack_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the fully-qualified function name. */</comment>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name> <operator>=</operator>
      <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Log the function call */</comment>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_DoStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_EXECUTE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TYPE_FUNCTION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name> <operator>=</operator> <name><name>stackItem</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>stackItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Pop audit event from the stack */</comment>
  <expr_stmt><expr><call><name>stack_pop</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>stackId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hook functions
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorCheckPerms_hook_type</name></type> <name>next_ExecutorCheckPerms_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>next_ProcessUtility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>object_access_hook_type</name></type> <name>next_object_access_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorStart_hook_type</name></type> <name>next_ExecutorStart_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pgaudit_NextExecutorStart_hook</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Call the previous hook or standard function */</comment>
  <if_stmt><if>if <condition>(<expr><name>next_ExecutorStart_hook</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>next_ExecutorStart_hook</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>isAuditLoggingDisabled</name><parameter_list>()</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>auditRole</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>auditRole</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>auditLogBitmap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hook ExecutorStart to get the query text and basic command type for queries
 * that do not contain a table and so can't be idenitified accurately in
 * ExecutorCheckPerms.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pgaudit_ExecutorStart_hook</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stackItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isAuditLoggingDisabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>pgaudit_NextExecutorStart_hook</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>internalStatement</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Push the audit even onto the stack */</comment>
    <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <call><name>stack_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize command using queryDesc-&gt;operation */</comment>
    <switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>CMD_SELECT</name></expr>:</case>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_SelectStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_SELECT</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_InsertStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_INSERT</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_UpdateStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_UPDATE</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>CMD_DELETE</name></expr>:</case>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_DeleteStmt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_DELETE</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default:</default>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_Invalid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name>COMMAND_UNKNOWN</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* Initialize the audit event */</comment>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>paramList</name></name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call the previous hook or standard function */</comment>
  <expr_stmt><expr><call><name>pgaudit_NextExecutorStart_hook</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Move the stack memory context to the query memory context.  This needs
   * to be done here because the query context does not exist before the
   * call to standard_ExecutorStart() but the stack item is required by
   * pgaudit_ExecutorCheckPerms_hook() which is called during
   * standard_ExecutorStart().
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>stackItem</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>stackItem</name><operator>-&gt;</operator><name>contextAudit</name></name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hook ExecutorCheckPerms to do session and object auditing for DML.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>pgaudit_ExecutorCheckPerms_hook</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTabls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Oid</name></type> <name>auditOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the audit oid if the role exists */</comment>
  <if_stmt><if>if <condition>(<expr><name>auditRole</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>auditRole</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>auditOid</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><name>auditRole</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Log DML if the audit role is valid or session logging is enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>auditOid</name> <operator>!=</operator> <name>InvalidOid</name> <operator>||</operator> <name>auditLogBitmap</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_select_dml</name><argument_list>(<argument><expr><name>auditOid</name></expr></argument>, <argument><expr><name>rangeTabls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Call the next hook function */</comment>
  <if_stmt><if>if <condition>(<expr><name>next_ExecutorCheckPerms_hook</name> <operator>&amp;&amp;</operator> <operator>!</operator><call>(<modifier>*</modifier><name>next_ExecutorCheckPerms_hook</name>)<argument_list>(<argument><expr><name>rangeTabls</name></expr></argument>, <argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pgaudit_NextProcessUtility_hook</name><parameter_list>(
    <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
    <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
    <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
    <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
    <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Call the standard process utility chain. */</comment>
  <if_stmt><if>if <condition>(<expr><name>next_ProcessUtility_hook</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call>(<modifier>*</modifier><name>next_ProcessUtility_hook</name>)<argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hook ProcessUtility to do session auditing for DDL and utility commands.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pgaudit_ProcessUtility_hook</name><parameter_list>(
    <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
    <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
    <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
    <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
    <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>stackItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64</name></type> <name>stackId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/*
      Early bail out on pgAudit if
      1. auditLogBitmap is not set (i.e. auditing is not enabled)
      2. auditRole is not set (i.e. you do not have permissions to audit)
      3. if you are not trying to set variable pgaudit.log. In that case you might need to
         log the set statement too and hence you cant bail out.
  */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>isAuditLoggingDisabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>T_VariableSetStmt</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><literal type="string">"pgaudit."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>pgaudit_NextProcessUtility_hook</name><argument_list>(
        <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/*
   * Don't audit substatements.  All the substatements we care about should
   * be covered by the event triggers.
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>context</name> <operator>&lt;=</operator> <name>PROCESS_UTILITY_QUERY</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Process top level utility statement */</comment>
    <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/*
       * If the stack is not empty then the only allowed entries are open
       * select, show, and explain cursors
       */</comment>
      <if_stmt><if>if <condition>(<expr><name>auditEventStack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>AuditEventStackItem</name> <modifier>*</modifier></type><name>nextItem</name> <init>= <expr><name>auditEventStack</name></expr></init></decl>;</decl_stmt>

        <do>do <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_SelectStmt</name> <operator>&amp;&amp;</operator>
              <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_VariableShowStmt</name> <operator>&amp;&amp;</operator>
              <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_ExplainStmt</name> <operator>&amp;&amp;</operator>
              <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_BackfillIndexStmt</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// TODO(Sudheer): Remove the following statements suppressing the</comment>
            <comment type="line">// 'stack is not empty' error  once we have a proper fix for</comment>
            <comment type="line">// correctly restarting write operations in presence of PGAudit.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_InsertStmt</name> <operator>&amp;&amp;</operator>
                <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_DeleteStmt</name> <operator>&amp;&amp;</operator>
                <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_UpdateStmt</name> <operator>&amp;&amp;</operator>
                <name><name>nextItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>T_ExecuteStmt</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit stack is not empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>nextItem</name> <operator>=</operator> <name><name>nextItem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name>nextItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <call><name>stack_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>paramList</name></name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <call><name>stack_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>stackId</name> <operator>=</operator> <name><name>stackItem</name><operator>-&gt;</operator><name>stackId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandText</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If this is a DO block log it before calling the next ProcessUtility
     * hook.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_FUNCTION</name> <operator>&amp;&amp;</operator> <name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>==</operator> <name>T_DoStmt</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>stackItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * A close will free the open cursor which will also free the close
     * audit entry. Immediately log the close and set stackItem to NULL so
     * it won't be logged later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>==</operator> <name>T_ClosePortalStmt</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_MISC</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>stackItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>stackItem</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call the standard process utility chain. */</comment>
  <expr_stmt><expr><call><name>pgaudit_NextProcessUtility_hook</name><argument_list>(
      <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Process the audit event if there is one.  Also check that this event
   * was not popped off the stack by a memory context being free'd
   * elsewhere.
   */</comment>
  <if_stmt><if>if <condition>(<expr><name>stackItem</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/*
     * Make sure the item we want to log is still on the stack - if not
     * then something has gone wrong and an error will be raised.
     */</comment>
    <expr_stmt><expr><call><name>stack_valid</name><argument_list>(<argument><expr><name>stackId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Log the utility command if logging is on, the command has not
     * already been logged by another hook, and the transaction is not
     * aborted.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>auditLogBitmap</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stackItem</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>stackItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hook object_access_hook to provide fully-qualified object names for function
 * calls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pgaudit_object_access_hook</name><parameter_list>(
    <parameter><decl><type><name>ObjectAccessType</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_FUNCTION</name> <operator>&amp;&amp;</operator> <name>access</name> <operator>==</operator> <name>OAT_FUNCTION_EXECUTE</name> <operator>&amp;&amp;</operator> <name>auditEventStack</name> <operator>&amp;&amp;</operator>
      <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_function_execute</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>next_object_access_hook</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>next_object_access_hook</name>)<argument_list>(<argument><expr><name>access</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Event trigger functions
 */</comment>

<comment type="block">/*
 * Supply additional data for (non drop) statements that have event trigger
 * support and can be deparsed.
 *
 * Drop statements are handled below through the older sql_drop event trigger.
 */</comment>
<function><type><name>Datum</name></type> <name>pgaudit_ddl_command_end</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>eventData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>row</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TupleDesc</name></type> <name>spiTupDesc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextOld</name></decl>;</decl_stmt>

  <comment type="block">/* Continue only if session DDL logging is enabled */</comment>
  <if_stmt><if>if <condition>(<expr><operator>~</operator><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_DDL</name> <operator>&amp;&amp;</operator> <operator>~</operator><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_ROLE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Be sure the module was loaded */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>auditEventStack</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(
        <argument><expr><name>ERROR</name></expr></argument>,
        <argument><expr><literal type="string">"pgaudit not loaded before call to "</literal>
        <literal type="string">"pgaudit_ddl_command_end()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* This is an internal statement - do not log it */</comment>
  <expr_stmt><expr><name>internalStatement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure the fuction was fired as a trigger */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not fired by event trigger manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Switch memory context for query */</comment>
  <expr_stmt><expr><name>contextQuery</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
      <argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><literal type="string">"pgaudit_func_ddl_command_end temporary context"</literal></expr></argument>,
      <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>contextOld</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get information about triggered events */</comment>
  <expr_stmt><expr><name>eventData</name> <operator>=</operator> <operator>(</operator><name>EventTriggerData</name> <operator>*</operator><operator>)</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logStmtLevel</name></name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>eventData</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>eventData</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>eventData</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return objects affected by the (non drop) DDL statement */</comment>
  <expr_stmt><expr><name>query</name> <operator>=</operator>
      <literal type="string">"SELECT UPPER(object_type), object_identity, UPPER(command_tag)\n"</literal>
      <literal type="string">"  FROM pg_catalog.pg_event_trigger_ddl_commands()"</literal></expr>;</expr_stmt>

  <comment type="block">/* Attempt to connect */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit_ddl_command_end: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Execute the query */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit_ddl_command_end: SPI_execute returned %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Iterate returned rows */</comment>
  <expr_stmt><expr><name>spiTupDesc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>row</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>row</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>spiTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>spiTuple</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>row</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Supply object name and type for audit event */</comment>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spiTuple</name></expr></argument>, <argument><expr><name>spiTupDesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spiTuple</name></expr></argument>, <argument><expr><name>spiTupDesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spiTuple</name></expr></argument>, <argument><expr><name>spiTupDesc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Identify grant/revoke commands - these are the only non-DDL class
     * commands that should be coming through the event triggers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name></expr></argument>, <argument><expr><name>COMMAND_GRANT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>command</name></name></expr></argument>, <argument><expr><name>COMMAND_REVOKE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>NodeTag</name></type> <name>currentCommandTag</name> <init>= <expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>T_GrantStmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>commandTag</name></name> <operator>=</operator> <name>currentCommandTag</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Complete the query */</comment>
  <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>contextQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No longer in an internal statement */</comment>
  <expr_stmt><expr><name>internalStatement</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Supply additional data for drop statements that have event trigger support.
 */</comment>
<function><type><name>Datum</name></type> <name>pgaudit_sql_drop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>row</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TupleDesc</name></type> <name>spiTupDesc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemoryContext</name></type> <name>contextOld</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>~</operator><name>auditLogBitmap</name> <operator>&amp;</operator> <name>LOG_DDL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Be sure the module was loaded */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>auditEventStack</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(
        <argument><expr><name>ERROR</name></expr></argument>,
        <argument><expr><literal type="string">"pgaudit not loaded before call to "</literal>
        <literal type="string">"pgaudit_sql_drop()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* This is an internal statement - do not log it */</comment>
  <expr_stmt><expr><name>internalStatement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure the fuction was fired as a trigger */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not fired by event trigger manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Switch memory context for the query */</comment>
  <expr_stmt><expr><name>contextQuery</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
      <argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><literal type="string">"pgaudit_func_ddl_command_end temporary context"</literal></expr></argument>,
      <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>contextOld</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return objects affected by the drop statement */</comment>
  <expr_stmt><expr><name>query</name> <operator>=</operator>
      <literal type="string">"SELECT UPPER(object_type),\n"</literal>
      <literal type="string">"       object_identity\n"</literal>
      <literal type="string">"  FROM pg_catalog.pg_event_trigger_dropped_objects()\n"</literal>
      <literal type="string">" WHERE lower(object_type) &lt;&gt; 'type'\n"</literal>
      <literal type="string">"   AND schema_name &lt;&gt; 'pg_toast'"</literal></expr>;</expr_stmt>

  <comment type="block">/* Attempt to connect */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit_ddl_drop: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Execute the query */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgaudit_ddl_drop: SPI_execute returned %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Iterate returned rows */</comment>
  <expr_stmt><expr><name>spiTupDesc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>row</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>row</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>row</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>spiTuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>spiTuple</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>row</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectType</name></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spiTuple</name></expr></argument>, <argument><expr><name>spiTupDesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>objectName</name></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spiTuple</name></expr></argument>, <argument><expr><name>spiTupDesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>auditEventStack</name><operator>-&gt;</operator><name>auditEvent</name><operator>.</operator><name>logged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>log_audit_event</name><argument_list>(<argument><expr><name>auditEventStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Complete the query */</comment>
  <expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>contextOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>contextQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No longer in an internal statement */</comment>
  <expr_stmt><expr><name>internalStatement</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GUC check and assign functions
 */</comment>

<comment type="block">/*
 * Take a pgaudit.log value such as "read, write, dml", verify that each of the
 * comma-separated tokens corresponds to a LogClass value, and convert them into
 * a bitmap that log_audit_event can check.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_pgaudit_log</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newVal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>flagRawList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rawVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure newval is a comma-separated list of tokens. */</comment>
  <expr_stmt><expr><name>rawVal</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawVal</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagRawList</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flagRawList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
   * Check that we recognise each token, and add it to the bitmap we're
   * building up in a newly-allocated int *f.
   */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <macro><name>foreach</name> <argument_list>(<argument>lt</argument>, <argument>flagRawList</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>subtract</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>class</name></decl>;</decl_stmt>

    <comment type="block">/* If token is preceded by -, then the token is subtractive */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>token</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>subtract</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Test each token */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_NONE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_NONE</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_ALL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_ALL</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_DDL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_DDL</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_FUNCTION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_FUNCTION</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_MISC</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_MISC</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_READ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_READ</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_ROLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_ROLE</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>CLASS_WRITE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>class</name> <operator>=</operator> <name>LOG_WRITE</name></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flagRawList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Add or subtract class bits from the log bitmap */</comment>
    <if_stmt><if>if <condition>(<expr><name>subtract</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>class</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>class</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flagRawList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store the bitmap for assign_pgaudit_log */</comment>
  <expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set pgaudit_log from extra (ignoring newVal, which has already been
 * converted to a bitmap above). Note that extra may not be set if the
 * assignment is to be suppressed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assign_pgaudit_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>extra</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>auditLogBitmap</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>extra</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take a pgaudit.log_level value such as "debug" and check that is is valid.
 * Return the enum value so it does not have to be checked again in the assign
 * function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_pgaudit_log_level</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newVal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>logLevel</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate memory to store the log level */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>logLevel</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Find the log level enum */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG5</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG4</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug3"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG3</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"debug1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>INFO</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>NOTICE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newVal</name></expr></argument>, <argument><expr><literal type="string">"log"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>logLevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt></block_content></block></if>

  <comment type="block">/* Error if the log level enum is not found */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>logLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Return the log level enum */</comment>
  <expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <name>logLevel</name></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set pgaudit_log from extra (ignoring newVal, which has already been
 * converted to an enum above). Note that extra may not be set if the
 * assignment is to be suppressed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assign_pgaudit_log_level</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>extra</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>auditLogLevel</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>extra</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Define GUC variables and install hooks upon module load.
 */</comment>
<function><type><name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* Be sure we do initialization only once */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>inited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>inited</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Must be loaded with shared_preload_libraries */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(
        <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgaudit must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Define pgaudit.log */</comment>
  <expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies which classes of statements will be logged by session audit "</literal>
      <literal type="string">"logging. Multiple classes can be provided using a comma-separated "</literal>
      <literal type="string">"list and classes can be subtracted by prefacing the class with a "</literal>
      <literal type="string">"- sign."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>auditLog</name></expr></argument>,
      <argument><expr><literal type="string">"none"</literal></expr></argument>,
      <argument><expr><name>PGC_SUSET</name></expr></argument>,
      <argument><expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr></argument>,
      <argument><expr><name>check_pgaudit_log</name></expr></argument>,
      <argument><expr><name>assign_pgaudit_log</name></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_catalog */</comment>
  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_catalog"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies that session logging should be enabled in the case where "</literal>
      <literal type="string">"all relations in a statement are in pg_catalog.  Disabling this "</literal>
      <literal type="string">"setting will reduce noise in the log from tools like psql and PgAdmin "</literal>
      <literal type="string">"that query the catalog heavily."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditLogCatalog</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_client */</comment>
  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_client"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies whether audit messages should be visible to the client. "</literal>
      <literal type="string">"This setting should generally be left disabled but may be useful for "</literal>
      <literal type="string">"debugging or other purposes."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditLogClient</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_level */</comment>
  <expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_level"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies the log level that will be used for log entries. This "</literal>
      <literal type="string">"setting is used for regression testing and may also be useful to end "</literal>
      <literal type="string">"users for testing or other purposes.  It is not intended to be used "</literal>
      <literal type="string">"in a production environment as it may leak which statements are being "</literal>
      <literal type="string">"logged to the user."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>auditLogLevelString</name></expr></argument>,
      <argument><expr><literal type="string">"log"</literal></expr></argument>,
      <argument><expr><name>PGC_SUSET</name></expr></argument>,
      <argument><expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr></argument>,
      <argument><expr><name>check_pgaudit_log_level</name></expr></argument>,
      <argument><expr><name>assign_pgaudit_log_level</name></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_parameter */</comment>
  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_parameter"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies that audit logging should include the parameters that were "</literal>
      <literal type="string">"passed with the statement. When parameters are present they will be "</literal>
      <literal type="string">"be included in CSV format after the statement text."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditLogParameter</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_relation */</comment>
  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_relation"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies whether session audit logging should create a separate log "</literal>
      <literal type="string">"entry for each relation referenced in a SELECT or DML statement. "</literal>
      <literal type="string">"This is a useful shortcut for exhaustive logging without using object "</literal>
      <literal type="string">"audit logging."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditLogRelation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.log_statement_once */</comment>
  <expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.log_statement_once"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies whether logging will include the statement text and "</literal>
      <literal type="string">"parameters with the first log entry for a statement/substatement "</literal>
      <literal type="string">"combination or with every entry.  Disabling this setting will result "</literal>
      <literal type="string">"in less verbose logging but may make it more difficult to determine "</literal>
      <literal type="string">"the statement that generated a log entry, though the "</literal>
      <literal type="string">"statement/substatement pair along with the process id should suffice "</literal>
      <literal type="string">"to identify the statement text logged with a previous entry."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditLogStatementOnce</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Define pgaudit.role */</comment>
  <expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(
      <argument><expr><literal type="string">"pgaudit.role"</literal></expr></argument>,

      <argument><expr><literal type="string">"Specifies the master role to use for object audit logging.  Muliple "</literal>
      <literal type="string">"audit roles can be defined by granting them to the master role. This "</literal>
      <literal type="string">"allows multiple groups to be in charge of different aspects of audit "</literal>
      <literal type="string">"logging."</literal></expr></argument>,

      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auditRole</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>GUC_NOT_IN_SAMPLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Install our hook functions after saving the existing pointers to
   * preserve the chains.
   */</comment>
  <expr_stmt><expr><name>next_ExecutorStart_hook</name> <operator>=</operator> <name>ExecutorStart_hook</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ExecutorStart_hook</name> <operator>=</operator> <name>pgaudit_ExecutorStart_hook</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>next_ExecutorCheckPerms_hook</name> <operator>=</operator> <name>ExecutorCheckPerms_hook</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ExecutorCheckPerms_hook</name> <operator>=</operator> <name>pgaudit_ExecutorCheckPerms_hook</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>next_ProcessUtility_hook</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>pgaudit_ProcessUtility_hook</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>next_object_access_hook</name> <operator>=</operator> <name>object_access_hook</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>object_access_hook</name> <operator>=</operator> <name>pgaudit_object_access_hook</name></expr>;</expr_stmt>

  <comment type="block">/* Log that the extension has completed initialization */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgaudit extension initialized"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgaudit extension initialized"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* EXEC_BACKEND */</comment>

  <expr_stmt><expr><name>inited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function></unit>
