<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/pg_stat_monitor/pg_stat_monitor.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_stat_monitor.c
 *		Track statement execution times across a whole database cluster.
 *
 * Portions Copyright Â© 2018-2020, Percona LLC and/or its affiliates
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * IDENTIFICATION
 *	  contrib/pg_stat_monitor/pg_stat_monitor.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_stat_monitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/server/pgsql_webserver_wrapper.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILD_VERSION</name></cpp:macro>                   <cpp:value>"0.9.0"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_STAT_STATEMENTS_COLS</name></cpp:macro>         <cpp:value>51</cpp:value></cpp:define>  <comment type="block">/* maximum of above */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSM_TEXT_FILE</name></cpp:macro>                  <cpp:value>"/tmp/pg_stat_monitor_query"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGUNSIXBIT</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((val) &amp; 0x3F) + '0')</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_snprintf</name><parameter_list>(<parameter><type><name>_str_dst</name></type></parameter>, <parameter><type><name>_str_src</name></type></parameter>, <parameter><type><name>_len</name></type></parameter>, <parameter><type><name>_max_len</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do                                                   \
{                                                    \
	int i;                                           \
	for(i = 0; i &lt; _len &amp;&amp; i &lt; _max_len; i++)        \
	{\
		_str_dst[i] = _str_src[i];                   \
	}\
}while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_snprintf2</name><parameter_list>(<parameter><type><name>_str_dst</name></type></parameter>, <parameter><type><name>_str_src</name></type></parameter>, <parameter><type><name>_len1</name></type></parameter>, <parameter><type><name>_len2</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>do                                                      \
{                                                       \
	int i,j;                                            \
	for(i = 0; i &lt; _len1; i++)                        \
		for(j = 0; j &lt; _len2; j++)        \
		{                                               \
			_str_dst[i][j] = _str_src[i][j];                  \
		}                                               \
}while(0)</cpp:value></cpp:define>

<comment type="block">/*---- Initicalization Function Declarations ----*/</comment>
<function_decl><type><name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*---- Local variables ----*/</comment>

<comment type="block">/* Current nesting depth of ExecutorRun+ProcessUtility calls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nested_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>plan_nested_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The array to store outer layer query id*/</comment>
<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>nested_queryids</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>qfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>system_init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type>  <name>rusage_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type>  <name>rusage_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name><name>pgss_qbuf</name><index>[<expr><name>MAX_BUCKETS</name></expr>]</index></name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgss_explain</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>get_histogram_bucket</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>q_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsSystemInitialized</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_queries_buffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bucket_id</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>time_diff</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsBucketValid</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Saved hook values in case of unload */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>planner_hook_type</name></type> <name>planner_hook_next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>prev_post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorStart_hook_type</name></type> <name>prev_ExecutorStart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorRun_hook_type</name></type> <name>prev_ExecutorRun</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorFinish_hook_type</name></type> <name>prev_ExecutorFinish</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorEnd_hook_type</name></type> <name>prev_ExecutorEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>emit_log_hook_type</name></type> <name>prev_emit_log_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>pgsm_emit_log_hook</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorCheckPerms_hook_type</name></type> <name>prev_ExecutorCheckPerms_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor_1_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor_1_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_stat_monitor_settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_histogram_timings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>uint</name></type> <name>pg_get_client_addr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pg_get_application_name</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>application_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PgBackendStatus</name> <modifier>*</modifier></type><name>pg_get_backend_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>intarray_get_datum</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name><name>arr</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgss_ExecutorCheckPerms</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>pgss_planner_hook</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
					<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>
					)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BufferUsageAccumDiff</name><parameter_list>(<parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>bufusage</name></decl></parameter>, <parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>pgBufferUsage</name></decl></parameter>, <parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>bufusage_start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
                                <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
                                <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
                                <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
                                <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>pgss_hash_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>unpack_sql_state</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sql_state</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_store_error</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pgssQueryEntry</name> <modifier>*</modifier></type><name>pgss_store_query_info</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>dbid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>userid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>ip</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>query_len</name></decl></parameter>,
					  <parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_store_utility</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>total_time</name></decl></parameter>,
					<parameter><decl><type><name>uint64</name></type> <name>rows</name></decl></parameter>,
					<parameter><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>,
					<parameter><decl><type><name>WalUsage</name> <modifier>*</modifier></type><name>walusage</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_store</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						<parameter><decl><type><name>PlanInfo</name> <modifier>*</modifier></type><name>plan_info</name></decl></parameter>,
						<parameter><decl><type><name>CmdType</name></type> <name>cmd_type</name></decl></parameter>,
						<parameter><decl><type><name>SysInfo</name> <modifier>*</modifier></type><name>sys_info</name></decl></parameter>,
						<parameter><decl><type><name>ErrorInfo</name> <modifier>*</modifier></type><name>error_info</name></decl></parameter>,
						<parameter><decl><type><name>double</name></type> <name>total_time</name></decl></parameter>,
						<parameter><decl><type><name>uint64</name></type> <name>rows</name></decl></parameter>,
						<parameter><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>,
						<parameter><decl><type><name>WalUsage</name> <modifier>*</modifier></type><name>walusage</name></decl></parameter>,
						<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
						<parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_stat_monitor_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>showtext</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendJumble</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleQuery</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleRangeTable</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleExpr</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordConstLocation</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_normalized_query</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>query_len_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_in_constant_lengths</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>comp_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>get_next_wbucket</name><parameter_list>(<parameter><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_store_query</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>,
				  <parameter><decl><type><name>CmdType</name></type> <name>cmd_type</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>query_location</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>query_len</name></decl></parameter>,
				  <parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
				  <parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>read_query</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>read_query_buffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bucket_id</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_txt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>get_query_id</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Module load callback
 */</comment>
<comment type="line">// cppcheck-suppress unusedFunction</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: %s()"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * In order to create our shared memory area, we have to be loaded via
	 * shared_preload_libraries.  If not, fall out without hooking into any of
	 * the main system.  (We don't throw error here because it seems useful to
	 * allow the pg_stat_statements functions to be created even when the
	 * module isn't active.  The functions must protect themselves against
	 * being called then, however.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Inilize the GUC variables */</comment>
	<expr_stmt><expr><call><name>init_guc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PGSM_MAX_BUCKETS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>file_name</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>PGSM_TEXT_FILE</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>EmitWarningsOnPlaceholders</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Request additional shared resources.  (These are no-ops if we're not in
	 * the postmaster process.)  We'll allocate or attach to the shared
	 * resources in pgss_shmem_startup().
	 */</comment>
	<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>hash_memsize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RequestNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Install hooks.
	 */</comment>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> 		<operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> 				<operator>=</operator> <name>pgss_shmem_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_post_parse_analyze_hook</name> 	<operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> 		<operator>=</operator> <name>pgss_post_parse_analyze</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorStart</name> 				<operator>=</operator> <name>ExecutorStart_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorStart_hook</name> 				<operator>=</operator> <name>pgss_ExecutorStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorRun</name> 				<operator>=</operator> <name>ExecutorRun_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorRun_hook</name> 				<operator>=</operator> <name>pgss_ExecutorRun</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorFinish</name> 			<operator>=</operator> <name>ExecutorFinish_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorFinish_hook</name> 			<operator>=</operator> <name>pgss_ExecutorFinish</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorEnd</name> 				<operator>=</operator> <name>ExecutorEnd_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> 				<operator>=</operator> <name>pgss_ExecutorEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ProcessUtility</name> 			<operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> 			<operator>=</operator> <name>pgss_ProcessUtility</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
	<expr_stmt><expr><name>planner_hook_next</name>       		<operator>=</operator> <name>planner_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>planner_hook</name>                    <operator>=</operator> <name>pgss_planner_hook</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>emit_log_hook</name>                 <operator>=</operator> <name>pgsm_emit_log_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorCheckPerms_hook</name> 	<operator>=</operator> <name>ExecutorCheckPerms_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorCheckPerms_hook</name>		<operator>=</operator> <name>pgss_ExecutorCheckPerms</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nested_queryids</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_stack_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>system_init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Module unload callback
 */</comment>
<comment type="line">// cppcheck-suppress unusedFunction</comment>
<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>system_init</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> 		<operator>=</operator> <name>prev_shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>prev_post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorStart_hook</name> 		<operator>=</operator> <name>prev_ExecutorStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorRun_hook</name> 		<operator>=</operator> <name>prev_ExecutorRun</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorFinish_hook</name> 	<operator>=</operator> <name>prev_ExecutorFinish</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> 		<operator>=</operator> <name>prev_ExecutorEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> 	<operator>=</operator> <name>prev_ProcessUtility</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nested_queryids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_entry_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shmem_startup hook: allocate or attach to shared memory,
 * then load any pre-existing statistics from file.
 * Also create and load the query-texts file, which is expected to exist
 * (even if empty) while the module is enabled.
 */</comment>
<function><type><name>void</name></type>
<name>pgss_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>pgss_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Select the version of pg_stat_monitor.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_monitor_version</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>BUILD_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Post-parse-analysis hook: mark query with a queryId
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssJumbleState</name></type> <name>jstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssStoreKind</name></type>   <name>kind</name> <init>= <expr><name>PGSS_PARSE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Utility statements get queryId zero.  We do this even in cases where
	 * the statement contains an optimizable statement for which a queryId
	 * could be derived (such as EXPLAIN or DECLARE CURSOR).  For such cases,
	 * runtime control will first go through ProcessUtility and then the
	 * executor, and we don't want the executor hooks to do anything, since we
	 * are already measuring the statement's costs at the utility level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <call><name>get_query_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are unlucky enough to get a hash of zero, use 1 instead, to
	 * prevent confusion with the utility-statement case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>==</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jstate</name><operator>.</operator><name>clocations_count</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgss_store_query</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name></expr></argument>,          <comment type="block">/* queryid */</comment>
               <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>,          <comment type="block">/* query */</comment>
               <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,            <comment type="block">/* CmdType */</comment>
			   <argument><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,		  <comment type="block">/* Query Location */</comment>
               <argument><expr><name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,			  	  <comment type="block">/* Query Len */</comment>
               <argument><expr><operator>&amp;</operator><name>jstate</name></expr></argument>,                       <comment type="block">/* pgssJumbleState */</comment>
			   <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>						  <comment type="block">/*pgssStoreKind */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorStart hook: start up tracking if needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>             <name>queryId</name>       <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage_start</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: failed to execute getrusage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorStart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If query has queryId zero, don't track it.  This prevents double
	 * counting of optimizable statements that are directly contained in
	 * utility statements.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PGSM_ENABLED</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name> <operator>!=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set up to track total elapsed time in ExecutorRun.  Make sure the
		 * space is allocated in the per-query context so it will go away at
		 * ExecutorEnd.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <call><name>InstrAlloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INSTRUMENT_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>,                                 <comment type="block">/* query id */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,					<comment type="block">/* query text */</comment>
					<argument><expr><name>NULL</name></expr></argument>,                                   <comment type="block">/* PlanInfo */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>,                   <comment type="block">/* CmdType */</comment>
					<argument><expr><name>NULL</name></expr></argument>,                                   <comment type="block">/* SysInfo */</comment>
					<argument><expr><name>NULL</name></expr></argument>,									<comment type="block">/* ErrorInfo */</comment>
					<argument><expr><literal type="number">0</literal></expr></argument>,                                      <comment type="block">/* totaltime */</comment>
					<argument><expr><literal type="number">0</literal></expr></argument>,                                      <comment type="block">/* rows */</comment>
					<argument><expr><name>NULL</name></expr></argument>,                                   <comment type="block">/*  bufusage */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
					<argument><expr><name>NULL</name></expr></argument>,                                   <comment type="block">/* walusage */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>PGSS_EXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>							   <comment type="block">/* pgssStoreKind */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorRun hook: all we need do is track nesting depth
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nested_level</name> <operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nested_level</name> <operator>&lt;</operator> <name>max_stack_depth</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nested_queryids</name><index>[<expr><name>nested_level</name></expr>]</index></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nested_level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_ExecutorRun</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>prev_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nested_level</name> <operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nested_level</name> <operator>&lt;</operator> <name>max_stack_depth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nested_queryids</name><index>[<expr><name>nested_level</name></expr>]</index></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nested_level</name> <operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nested_level</name> <operator>&lt;</operator> <name>max_stack_depth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nested_queryids</name><index>[<expr><name>nested_level</name></expr>]</index></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorFinish hook: all we need do is track nesting depth
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>nested_level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_ExecutorFinish</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>prev_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgss_explain</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>NewExplainState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainBeginOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExplainPrintPlan</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExplainEndOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorEnd hook: store results if needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>             <name>queryId</name>       <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name>    <modifier>*</modifier></type><name>pgss</name>         <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysInfo</name></type>            <name>sys_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanInfo</name></type>           <name>plan_info</name></decl>;</decl_stmt>

	<comment type="block">/* Extract the plan information in case of SELECT statment */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name>PGSM_QUERY_PLAN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mct</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>plan_info</name><operator>.</operator><name>plan_text</name></name></expr></argument>, <argument><expr><name>PLAN_TEXT_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pgss_explain</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan_info</name><operator>.</operator><name>planid</name></name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>plan_info</name><operator>.</operator><name>plan_text</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>plan_info</name><operator>.</operator><name>plan_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>queryId</name> <operator>!=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure stats accumulation is done.  (Note: it's okay if several
		 * levels of hook all do this.)
		 */</comment>
		<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage_end</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: failed to execute getrusage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>sys_info</name><operator>.</operator><name>utime</name></name> <operator>=</operator> <call><name>time_diff</name><argument_list>(<argument><expr><name><name>rusage_end</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><name><name>rusage_start</name><operator>.</operator><name>ru_utime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sys_info</name><operator>.</operator><name>stime</name></name> <operator>=</operator> <call><name>time_diff</name><argument_list>(<argument><expr><name><name>rusage_end</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><name><name>rusage_start</name><operator>.</operator><name>ru_stime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>,                                 <comment type="block">/* query id */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,					<comment type="block">/* query text */</comment>
					<argument><expr><operator>&amp;</operator><name>plan_info</name></expr></argument>,								<comment type="block">/* PlanInfo */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>,					<comment type="block">/* CmdType */</comment>
					<argument><expr><operator>&amp;</operator><name>sys_info</name></expr></argument>,								<comment type="block">/* SysInfo */</comment>
					<argument><expr><name>NULL</name></expr></argument>,									<comment type="block">/* ErrorInfo */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name><operator>-&gt;</operator><name>total</name></name> <operator>*</operator> <literal type="number">1000.0</literal></expr></argument>,	<comment type="block">/* totaltime */</comment>
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>,		<comment type="block">/* rows */</comment>
					<argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name><operator>-&gt;</operator><name>bufusage</name></name></expr></argument>,		<comment type="block">/*  bufusage */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
					<argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name><operator>-&gt;</operator><name>walusage</name></name></expr></argument>,		<comment type="block">/* walusage */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>PGSS_FINISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 							<comment type="block">/* pgssStoreKind */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>num_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgss_ExecutorCheckPerms</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>abort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>lr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name><name>list_oid</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>num_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lr</argument>, <argument>rt</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>REL_LST</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>list_oid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>namespace_name</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relation_name</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>list_oid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>namespace_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relation_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>REL_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s.%s*"</literal></expr></argument>, <argument><expr><name>namespace_name</name></expr></argument>, <argument><expr><name>relation_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>relations</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>REL_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>namespace_name</name></expr></argument>, <argument><expr><name>relation_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>num_relations</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>prev_ExecutorCheckPerms_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>prev_ExecutorCheckPerms_hook</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>abort</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PlannedStmt</name><modifier>*</modifier></type>
<name>pgss_planner_hook</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name>			<modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>PGSM_TRACK_PLANNING</name> <operator>&amp;&amp;</operator> <name>query_string</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>queryId</name></name> <operator>!=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanInfo</name></type>	<name>plan_info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>duration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalUsage</name></type>	<name>walusage_start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalUsage</name></type>    <name>walusage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plan_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We need to track buffer usage as the planner can access them. */</comment>
		<expr_stmt><expr><name>bufusage_start</name> <operator>=</operator> <name>pgBufferUsage</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Similarly the planner could write some WAL records in some cases
		 * (e.g. setting a hint bit with those being WAL-logged)
		 */</comment>
		<expr_stmt><expr><name>walusage_start</name> <operator>=</operator> <name>pgWalUsage</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plan_nested_level</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
    		<if_stmt><if>if <condition>(<expr><name>planner_hook_next</name></expr>)</condition><block type="pseudo"><block_content>
        		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>planner_hook_next</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
    			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>plan_nested_level</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>duration</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calc differences of buffer counters. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calc differences of WAL counters. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WalUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgWalUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>queryId</name></name></expr></argument>,          		<comment type="block">/* query id */</comment>
				<argument><expr><name>query_string</name></expr></argument>,						<comment type="block">/* query */</comment>
				<argument><expr><operator>&amp;</operator><name>plan_info</name></expr></argument>,							<comment type="block">/* PlanInfo */</comment>
				<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,					<comment type="block">/* CmdType */</comment>
				<argument><expr><name>NULL</name></expr></argument>,								<comment type="block">/* SysInfo */</comment>
				<argument><expr><name>NULL</name></expr></argument>,								<comment type="block">/* ErrorInfo */</comment>
				<argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* totaltime */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,									<comment type="block">/* rows */</comment>
				<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>,							<comment type="block">/*  bufusage */</comment>
				<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>,							<comment type="block">/* walusage */</comment>
				<argument><expr><name>NULL</name></expr></argument>,								<comment type="block">/* pgssJumbleState */</comment>
				<argument><expr><name>PGSS_PLAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 							<comment type="block">/* pgssStoreKind */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>planner_hook_next</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>planner_hook_next</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ProcessUtility hook
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_ProcessUtility</name><argument_list>(<argument><expr><name>PlannedStmt</name> <operator>*</operator><name>pstmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>queryString</name></expr></argument>,
								<argument><expr><name>ProcessUtilityContext</name> <name>context</name></expr></argument>,
								<argument><expr><name>ParamListInfo</name> <name>params</name></expr></argument>, <argument><expr><name>QueryEnvironment</name> <operator>*</operator><name>queryEnv</name></expr></argument>,
								<argument><expr><name>DestReceiver</name> <operator>*</operator><name>dest</name></expr></argument>,
								<argument><expr><name>QueryCompletion</name> <operator>*</operator><name>qc</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name> <name>pgss_ProcessUtility</name><argument_list>(<argument><expr><name>PlannedStmt</name> <operator>*</operator><name>pstmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>queryString</name></expr></argument>,
                                <argument><expr><name>ProcessUtilityContext</name> <name>context</name></expr></argument>, <argument><expr><name>ParamListInfo</name> <name>params</name></expr></argument>,
                                <argument><expr><name>QueryEnvironment</name> <operator>*</operator><name>queryEnv</name></expr></argument>,
                                <argument><expr><name>DestReceiver</name> <operator>*</operator><name>dest</name></expr></argument>,
                                <argument><expr><name>char</name> <operator>*</operator><name>completionTag</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's an EXECUTE statement, we don't track it and don't increment the
	 * nesting level.  This allows the cycles to be charged to the underlying
	 * PREPARE instead (by the Executor hooks), which is much more useful.
	 *
	 * We also don't track execution of PREPARE.  If we did, we would get one
	 * hash table entry for the PREPARE (with hash calculated from the query
	 * string), and then a different one with the same query string (but hash
	 * calculated from the query tree) would be used to accumulate costs of
	 * ensuing EXECUTEs.  This would be confusing, and inconsistent with other
	 * cases where planning time is not included at all.
	 *
	 * Likewise, we don't track execution of DEALLOCATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PGSM_TRACK_UTILITY</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>PrepareStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DeallocateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>duration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalUsage</name></type>    <name>walusage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name> <init>= <expr><name>pgBufferUsage</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
		<decl_stmt><decl><type><name>WalUsage</name></type>    <name>walusage_start</name> <init>= <expr><name>pgWalUsage</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
									,<argument><expr><name>qc</name></expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
									,<argument><expr><name>completionTag</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
									)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
										<argument><expr><name>dest</name></expr></argument>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
									,<argument><expr><name>qc</name></expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
									,<argument><expr><name>completionTag</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
									)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
			<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block>

		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>duration</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
		<expr_stmt><expr><name>rows</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>qc</name> <operator>&amp;&amp;</operator> <name><name>qc</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_COPY</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>qc</name><operator>-&gt;</operator><name>nprocessed</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<comment type="block">/* calc differences of WAL counters. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WalUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgWalUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* parse command tag to retrieve the number of affected rows. */</comment>
		<if_stmt><if>if <condition>(<expr><name>completionTag</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"COPY "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>completionTag</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* calc differences of buffer counters. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgss_store_utility</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,								<comment type="block">/* query text */</comment>
							<argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr></argument>,		<comment type="block">/* totaltime */</comment>
							<argument><expr><name>rows</name></expr></argument>,									<comment type="block">/* rows */</comment>
							<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>,								<comment type="block">/* bufusage */</comment>
							<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>								<comment type="block">/* walusage */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
									,<argument><expr><name>qc</name></expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
									,<argument><expr><name>completionTag</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
									)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
										<argument><expr><name>dest</name></expr></argument>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr></cpp:if>
									,<argument><expr><name>qc</name></expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
									,<argument><expr><name>completionTag</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
									)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BufferUsageAccumDiff</name><parameter_list>(<parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>bufusage</name></decl></parameter>, <parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>pgBufferUsage</name></decl></parameter>, <parameter><decl><type><name>BufferUsage</name><modifier>*</modifier></type> <name>bufusage_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* calc differences of buffer counters. */</comment>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>shared_blks_hit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_read</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>shared_blks_read</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>shared_blks_read</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_written</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>shared_blks_written</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>shared_blks_written</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_hit</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>local_blks_hit</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>local_blks_hit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_read</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>local_blks_read</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>local_blks_read</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_written</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>local_blks_written</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>local_blks_written</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>temp_blks_read</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>temp_blks_read</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>temp_blks_read</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>temp_blks_written</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>temp_blks_written</name></name> <operator>-</operator> <name><name>bufusage_start</name><operator>-&gt;</operator><name>temp_blks_written</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_read_time</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>, <argument><expr><name><name>bufusage_start</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_write_time</name></name> <operator>=</operator> <name><name>pgBufferUsage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>, <argument><expr><name><name>bufusage_start</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Given an arbitrarily long query string, produce a hash for the purposes of
 * identifying the query, without normalizing constants.  Used when hashing
 * utility statements.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>pgss_hash_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>,
											<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PgBackendStatus</name><modifier>*</modifier></type>
<name>pg_get_backend_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>local_beentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		             <name>num_backends</name> <init>= <expr><call><name>pgstat_fetch_stat_numbackends</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                  <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_backends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>local_beentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_beentry</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>beentry</name> <operator>=</operator> <operator>&amp;</operator><name><name>local_beentry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>beentry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_get_application_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>application_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><call><name>pg_get_backend_status</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>, <argument><expr><name>APPLICATIONNAME_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_appname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store some statistics for a statement.
 *
 * If queryId is 0 then this is a utility statement and we should compute
 * a suitable queryId internally.
 *
 * If jstate is not NULL then we're trying to create an entry for which
 * we have no statistics as yet; we just want to record the normalized
 */</comment>

<function><type><specifier>static</specifier> <name>uint</name></type>
<name>pg_get_client_addr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name> <init>= <expr><call><name>pg_get_backend_status</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>remote_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
							 <argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_clientaddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
							 <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ntohl</name><argument_list>(<argument><expr><call><name>inet_addr</name><argument_list>(<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>, <argument><expr><literal type="string">"[local]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ntohl</name><argument_list>(<argument><expr><call><name>inet_addr</name><argument_list>(<argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>ntohl</name><argument_list>(<argument><expr><call><name>inet_addr</name><argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_update_entry</name><parameter_list>(<parameter><decl><type><name>pgssEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>bucketid</name></decl></parameter>,
						<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						<parameter><decl><type><name>PlanInfo</name> <modifier>*</modifier></type><name>plan_info</name></decl></parameter>,
						<parameter><decl><type><name>CmdType</name></type> <name>cmd_type</name></decl></parameter>,
						<parameter><decl><type><name>SysInfo</name> <modifier>*</modifier></type><name>sys_info</name></decl></parameter>,
						<parameter><decl><type><name>ErrorInfo</name> <modifier>*</modifier></type><name>error_info</name></decl></parameter>,
						<parameter><decl><type><name>double</name></type> <name>total_time</name></decl></parameter>,
						<parameter><decl><type><name>uint64</name></type> <name>rows</name></decl></parameter>,
						<parameter><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>,
						<parameter><decl><type><name>WalUsage</name> <modifier>*</modifier></type><name>walusage</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>reset</name></decl></parameter>,
						<parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>                 <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			    <name><name>application_name</name><index>[<expr><name>APPLICATIONNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				    <name>application_name_len</name> <init>= <expr><call><name>pg_get_application_name</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name>     <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>              <name>old_mean</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             	<name>message_len</name> <init>= <expr><ternary><condition><expr><name>error_info</name></expr> ?</condition><then> <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>error_info</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             	<name>sqlcode_len</name> <init>= <expr><ternary><condition><expr><name>error_info</name></expr> ?</condition><then> <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>error_info</name><operator>-&gt;</operator><name>sqlcode</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             	<name>plan_text_len</name> <init>= <expr><ternary><condition><expr><name>plan_info</name></expr> ?</condition><then> <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>plan_info</name><operator>-&gt;</operator><name>plan_text</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>


	<comment type="block">/* volatile block */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>pgssEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Start collecting data for next bucket and reset all counters */</comment>
		<if_stmt><if>if <condition>(<expr><name>reset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Counters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>PGSS_PLAN</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>usage</name></name> <operator>=</operator> <name>USAGE_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>total_time</name></name> <operator>+=</operator> <name>total_time</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>min_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>max_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>mean_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Increment the counts, except when jstate is not NULL */</comment>
			<expr_stmt><expr><name>old_mean</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>mean_time</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>mean_time</name></name> <operator>+=</operator> <operator>(</operator><name>total_time</name> <operator>-</operator> <name>old_mean</name><operator>)</operator> <operator>/</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>sum_var_time</name></name> <operator>+=</operator><operator>(</operator><name>total_time</name> <operator>-</operator> <name>old_mean</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>total_time</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>mean_time</name></name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* calculate min and max time */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>min_time</name></name> <operator>&gt;</operator> <name>total_time</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>min_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>max_time</name></name> <operator>&lt;</operator> <name>total_time</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plantime</name><operator>.</operator><name>max_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>PGSS_FINISHED</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>usage</name></name> <operator>=</operator> <name>USAGE_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>total_time</name></name> <operator>+=</operator> <name>total_time</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>min_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>max_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>mean_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Increment the counts, except when jstate is not NULL */</comment>
			<expr_stmt><expr><name>old_mean</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>mean_time</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>mean_time</name></name> <operator>+=</operator> <operator>(</operator><name>total_time</name> <operator>-</operator> <name>old_mean</name><operator>)</operator> <operator>/</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>sum_var_time</name></name> <operator>+=</operator><operator>(</operator><name>total_time</name> <operator>-</operator> <name>old_mean</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>total_time</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>mean_time</name></name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* calculate min and max time */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>min_time</name></name> <operator>&gt;</operator> <name>total_time</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>min_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>max_time</name></name> <operator>&lt;</operator> <name>total_time</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>time</name><operator>.</operator><name>max_time</name></name> <operator>=</operator> <name>total_time</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>get_histogram_bucket</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>resp_calls</name><index>[<expr><name>index</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>_snprintf</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>planinfo</name><operator>.</operator><name>plan_text</name></name></expr></argument>, <argument><expr><name><name>plan_info</name><operator>-&gt;</operator><name>plan_text</name></name></expr></argument>, <argument><expr><name>plan_text_len</name></expr></argument>, <argument><expr><name>PLAN_TEXT_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_snprintf</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>application_name</name></name></expr></argument>, <argument><expr><name>application_name</name></expr></argument>, <argument><expr><name>application_name_len</name></expr></argument>, <argument><expr><name>APPLICATIONNAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>num_relations</name></name> <operator>=</operator> <name><name>pgss</name><operator>-&gt;</operator><name>num_relations</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_snprintf2</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>relations</name></name></expr></argument>, <argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>, <argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>num_relations</name></name></expr></argument>,  <argument><expr><name>REL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>cmd_type</name></name> <operator>=</operator> <name>cmd_type</name></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>nested_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nested_level</name> <operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nested_level</name> <operator>&lt;</operator> <name>max_stack_depth</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>parentid</name></name> <operator>=</operator> <name><name>nested_queryids</name><index>[<expr><name>nested_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>parentid</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>error_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>error</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <name><name>error_info</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_snprintf</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>error</name><operator>.</operator><name>sqlcode</name></name></expr></argument>, <argument><expr><name><name>error_info</name><operator>-&gt;</operator><name>sqlcode</name></name></expr></argument>, <argument><expr><name>sqlcode_len</name></expr></argument>, <argument><expr><name>SQLCODE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_snprintf</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>error</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name><name>error_info</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name>message_len</name></expr></argument>, <argument><expr><name>ERROR_MESSAGE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name>rows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bufusage</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_hit</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_read</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_read</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_dirtied</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_written</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>shared_blks_written</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_hit</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_hit</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_read</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_read</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_dirtied</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_written</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>local_blks_written</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>temp_blks_read</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>temp_blks_read</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>temp_blks_written</name></name> <operator>+=</operator> <name><name>bufusage</name><operator>-&gt;</operator><name>temp_blks_written</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>blk_read_time</name></name> <operator>+=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>blocks</name><operator>.</operator><name>blk_write_time</name></name> <operator>+=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>bufusage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>calls</name><operator>.</operator><name>usage</name></name> <operator>+=</operator> <call><name>USAGE_EXEC</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>info</name><operator>.</operator><name>host</name></name> <operator>=</operator> <call><name>pg_get_client_addr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sys_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>sysinfo</name><operator>.</operator><name>utime</name></name> <operator>=</operator> <name><name>sys_info</name><operator>-&gt;</operator><name>utime</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>sysinfo</name><operator>.</operator><name>stime</name></name> <operator>=</operator> <name><name>sys_info</name><operator>-&gt;</operator><name>stime</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>walusage</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_records</name></name> <operator>+=</operator> <name><name>walusage</name><operator>-&gt;</operator><name>wal_records</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_fpi</name></name> <operator>+=</operator> <name><name>walusage</name><operator>-&gt;</operator><name>wal_fpi</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_bytes</name></name> <operator>+=</operator> <name><name>walusage</name><operator>-&gt;</operator><name>wal_bytes</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pgssEntry</name><modifier>*</modifier></type>
<name>pgss_get_entry</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bucket_id</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>userid</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>dbid</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>ip</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>planid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssEntry</name>       <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssHashKey</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>            <modifier>*</modifier></type><name>pgss_hash</name> <init>= <expr><call><name>pgsm_get_hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>bucket_id</name></name> <operator>=</operator> <name>bucket_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>userid</name></name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>queryid</name></name> <operator>=</operator> <name>queryid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>ip</name></name> <operator>=</operator> <call><name>pg_get_client_addr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>planid</name></name> <operator>=</operator> <name>planid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>pgssEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pgss_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
	<block>{<block_content>
		 <comment type="block">/* OK to create a new hashtable entry */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_entry_alloc</name><argument_list>(<argument><expr><name>pgss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_store_query</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>,
				  <parameter><decl><type><name>CmdType</name></type> <name>cmd_type</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>query_location</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>query_len</name></decl></parameter>,
				  <parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
				  <parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>norm_query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>query_location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_location</name> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>query</name> <operator>+=</operator> <name>query_location</name></expr>;</expr_stmt>
		<comment type="block">/* Length of 0 (or -1) means "rest of string" */</comment>
		<if_stmt><if>if <condition>(<expr><name>query_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>query_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_len</name> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If query location is unknown, distrust query_len as well */</comment>
		<expr_stmt><expr><name>query_location</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>query_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Discard leading and trailing whitespace, too.  Use scanner_isspace()
	 * not libc's isspace(), because we want to match the lexer's behavior.
	 */</comment>
	<while>while <condition>(<expr><name>query_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>scanner_isspace</name><argument_list>(<argument><expr><name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query</name><operator>++</operator></expr><operator>,</operator> <expr><name>query_location</name><operator>++</operator></expr><operator>,</operator> <expr><name>query_len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
	<while>while <condition>(<expr><name>query_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>scanner_isspace</name><argument_list>(<argument><expr><name><name>query</name><index>[<expr><name>query_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>jstate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>norm_query</name> <operator>=</operator> <call><name>generate_normalized_query</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
											   <argument><expr><name>query_location</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>query_len</name></expr></argument>,
											   <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
     * For utility statements, we just hash the query string to get an ID.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name>queryid</name> <operator>==</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>queryid</name> <operator>=</operator> <call><name>pgss_hash_string</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name>queryid</name></expr></argument>,                 <comment type="block">/* query id */</comment>
				<argument><expr><ternary><condition><expr><name>PGSM_NORMALIZED_QUERY</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>norm_query</name></expr> ?</condition><then> <expr><name>norm_query</name></expr> </then><else>: <expr><name>query</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>query</name></expr></else></ternary></expr></argument>, <comment type="block">/* query */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* PlanInfo */</comment>
				<argument><expr><name>cmd_type</name></expr></argument>,				<comment type="block">/* CmdType */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* SysInfo */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* ErrorInfo */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* totaltime */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* rows */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/*  bufusage */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* walusage */</comment>
				<argument><expr><name>jstate</name></expr></argument>,					<comment type="block">/* pgssJumbleState */</comment>
				<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* pgssStoreKind */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_store_error</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>,
				<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorInfo</name></type>		<name>error_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>error_info</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>error_info</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name>ERROR_MESSAGE_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>error_info</name><operator>.</operator><name>sqlcode</name></name></expr></argument>, <argument><expr><name>SQLCODE_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name>queryid</name></expr></argument>,                 <comment type="block">/* query id */</comment>
				<argument><expr><name>query</name></expr></argument>,					<comment type="block">/* query text */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* PlanInfo */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* CmdType */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* SysInfo */</comment>
				<argument><expr><operator>&amp;</operator><name>error_info</name></expr></argument>, 			<comment type="block">/* ErrorInfo */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* total_time */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* rows */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* bufusage */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* walusage */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* pgssJumbleState */</comment>
				<argument><expr><name>PGSS_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* pgssStoreKind */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_store_utility</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>total_time</name></decl></parameter>,
					<parameter><decl><type><name>uint64</name></type> <name>rows</name></decl></parameter>,
					<parameter><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>,
					<parameter><decl><type><name>WalUsage</name> <modifier>*</modifier></type><name>walusage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>          <name>queryid</name> <init>= <expr><call><name>pgss_hash_string</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pgss_store</name><argument_list>(<argument><expr><name>queryid</name></expr></argument>,                 <comment type="block">/* query id */</comment>
				<argument><expr><name>query</name></expr></argument>,					<comment type="block">/* query text */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* PlanInfo */</comment>
				<argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* CmdType */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* SysInfo */</comment>
				<argument><expr><name>NULL</name></expr></argument>, 					<comment type="block">/* ErrorInfo */</comment>
				<argument><expr><name>total_time</name></expr></argument>,				<comment type="block">/* total_time */</comment>
				<argument><expr><name>rows</name></expr></argument>,					<comment type="block">/* rows */</comment>
				<argument><expr><name>bufusage</name></expr></argument>,				<comment type="block">/* bufusage */</comment>
				<argument><expr><name>walusage</name></expr></argument>,				<comment type="block">/* walusage */</comment>
				<argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* pgssJumbleState */</comment>
				<argument><expr><name>PGSS_FINISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* pgssStoreKind */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Store some statistics for a statement.
 *
 * If queryId is 0 then this is a utility statement and we should compute
 * a suitable queryId internally.
 *
 * If jstate is not NULL then we're trying to create an entry for which
 * we have no statistics as yet; we just want to record the normalized
 * query string.  total_time, rows, bufusage are ignored in this case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_store</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
			<parameter><decl><type><name>PlanInfo</name> <modifier>*</modifier></type><name>plan_info</name></decl></parameter>,
			<parameter><decl><type><name>CmdType</name></type> <name>cmd_type</name></decl></parameter>,
			<parameter><decl><type><name>SysInfo</name> <modifier>*</modifier></type><name>sys_info</name></decl></parameter>,
			<parameter><decl><type><name>ErrorInfo</name> <modifier>*</modifier></type><name>error_info</name></decl></parameter>,
			<parameter><decl><type><name>double</name></type> <name>total_time</name></decl></parameter>,
			<parameter><decl><type><name>uint64</name></type> <name>rows</name></decl></parameter>,
			<parameter><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>,
			<parameter><decl><type><name>WalUsage</name> <modifier>*</modifier></type><name>walusage</name></decl></parameter>,
			<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
			<parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssEntry</name>		<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 			<name>reset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>bucketid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>userid</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>dbid</name> <init>= <expr><name>MyDatabaseId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>ip</name> <init>= <expr><call><name>pg_get_client_addr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>planid</name> <init>= <expr><ternary><condition><expr><name>plan_info</name></expr> ?</condition><then> <expr><name><name>plan_info</name><operator>-&gt;</operator><name>planid</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      <modifier>*</modifier></type><name>redacted_query</name></decl>;</decl_stmt>

	<comment type="block">/*  Monitoring is disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PGSM_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>redacted_query</name> <operator>=</operator> <call><name>RedactPasswordIfExists</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>pgss_qbuf</name><index>[<expr><name><name>pgss</name><operator>-&gt;</operator><name>current_wbucket</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bucketid</name> <operator>=</operator> <call><name>get_next_wbucket</name><argument_list>(<argument><expr><name>pgss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bucketid</name> <operator>!=</operator> <name><name>pgss</name><operator>-&gt;</operator><name>current_wbucket</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>reset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>current_wbucket</name></name> <operator>=</operator> <name>bucketid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGSS_PARSE</name></expr>:</case>
		<case>case <expr><name>PGSS_PLAN</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pgssQueryEntry</name> <modifier>*</modifier></type><name>query_entry</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>query_entry</name> <operator>=</operator> <call><name>pgss_store_query_info</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>redacted_query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>redacted_query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>query_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>PGSS_ERROR</name></expr>:</case>
		<case>case <expr><name>PGSS_EXEC</name></expr>:</case>
		<case>case <expr><name>PGSS_FINISHED</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pgssQueryEntry</name> <modifier>*</modifier></type><name>query_entry</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>query_entry</name> <operator>=</operator> <call><name>pgss_store_query_info</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>redacted_query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>redacted_query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>query_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgss_get_entry</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>planid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>jstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgss_update_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,		<comment type="block">/* entry */</comment>
							<argument><expr><name>bucketid</name></expr></argument>,			<comment type="block">/* bucketid */</comment>
							<argument><expr><name>queryid</name></expr></argument>,			<comment type="block">/* queryid */</comment>
							<argument><expr><name>redacted_query</name></expr></argument>, 	<comment type="block">/* query */</comment>
							<argument><expr><name>plan_info</name></expr></argument>,			<comment type="block">/* PlanInfo */</comment>
							<argument><expr><name>cmd_type</name></expr></argument>,			<comment type="block">/* CmdType */</comment>
							<argument><expr><name>sys_info</name></expr></argument>,			<comment type="block">/* SysInfo */</comment>
							<argument><expr><name>error_info</name></expr></argument>,			<comment type="block">/* ErrorInfo */</comment>
							<argument><expr><name>total_time</name></expr></argument>,			<comment type="block">/* total_time */</comment>
							<argument><expr><name>rows</name></expr></argument>,				<comment type="block">/* rows */</comment>
							<argument><expr><name>bufusage</name></expr></argument>,			<comment type="block">/* bufusage */</comment>
							<argument><expr><name>walusage</name></expr></argument>,			<comment type="block">/* walusage */</comment>
							<argument><expr><name>reset</name></expr></argument>,				<comment type="block">/* reset */</comment>
							<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* kind */</comment>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>PGSS_NUMKIND</name></expr>:</case>
		<case>case <expr><name>PGSS_INVALID</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Reset all statement statistics.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_monitor_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssSharedState</name>     <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_entry_dealloc</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_query_entry_dealloc</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_stat_monitor</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_stat_monitor_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsBucketValid</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>     <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>        <name>bucket_t</name></decl>,<decl><type ref="prev"/><name>current_t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>        <name>diff_t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name>      <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strptime</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>bucket_start_time</name><index>[<expr><name>bucketid</name></expr>]</index></name></expr></argument>,  <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket_t</name> <operator>=</operator> <call><name>mktime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>diff_t</name> <operator>=</operator> <call><name>difftime</name><argument_list>(<argument><expr><name>current_t</name></expr></argument>, <argument><expr><name>bucket_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff_t</name> <operator>&gt;</operator> <operator>(</operator><name>PGSM_BUCKET_TIME</name> <operator>*</operator> <name>PGSM_MAX_BUCKETS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Common code for all versions of pg_stat_statements() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_stat_monitor_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>showtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name>	     <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		     <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name>      <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	     <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	     <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>      <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>		     <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssQueryEntry</name>		 <modifier>*</modifier></type><name>query_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			     <name><name>parentid_txt</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name>      <modifier>*</modifier></type><name>pgss</name> <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>                 <modifier>*</modifier></type><name>pgss_hash</name> <init>= <expr><call><name>pgsm_get_hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 				<modifier>*</modifier></type><name>query_txt</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PGSM_QUERY_MAX_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">48</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: incorrect number of output arguments, required %d"</literal></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>pgss_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>         <name><name>values</name><index>[<expr><name>PG_STAT_STATEMENTS_COLS</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>          <name><name>nulls</name><index>[<expr><name>PG_STAT_STATEMENTS_COLS</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		      <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Counters</name></type>      <name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>        <name>stddev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>          <name><name>queryid_text</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>          <name><name>planid_text</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>        <name>queryid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>queryid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		  <name>bucketid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>bucket_id</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		  <name>dbid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>dbid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		  <name>userid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>userid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>        <name>ip</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>ip</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>        <name>planid</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>planid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>pgss_qbuf</name><index>[<expr><name>bucketid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 		  <name>is_allowed_role</name> <init>= <expr><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBucketValid</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>query_entry</name> <operator>=</operator> <call><name>hash_find_query_entry</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>query_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>read_query</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>query_txt</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read_query_buffer</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>query_txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>MAX_QUERY_BUFFER_BUCKET</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query_txt</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"insufficient disk/shared space"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* copy counters to a local variable to keep locking time short */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>volatile</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>pgssEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* bucketid at column number 0 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* userid at column number 1 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* dbid at column number 2 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
	 	* ip address at column number 3,
	 	* Superusers or members of pg_read_all_stats members
	 	* are allowed
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>is_allowed_role</name> <operator>||</operator> <name>userid</name> <operator>==</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* queryid at column number 4 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>queryid_text</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%08lX"</literal></expr></argument>, <argument><expr><name>queryid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>queryid_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* planid at column number 5 */</comment>
		<if_stmt><if>if <condition>(<expr><name>planid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>planid_text</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%08lX"</literal></expr></argument>, <argument><expr><name>planid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>planid_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_allowed_role</name> <operator>||</operator> <name>userid</name> <operator>==</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>showtext</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

				<comment type="block">/* query at column number 6 */</comment>
				<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>pg_any_to_server</name><argument_list>(<argument><expr><name>query_txt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query_txt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>query_txt</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* plan at column number 7 */</comment>
				<if_stmt><if>if <condition>(<expr><name>planid</name> <operator>&amp;&amp;</operator> <name><name>tmp</name><operator>.</operator><name>planinfo</name><operator>.</operator><name>plan_text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>planinfo</name><operator>.</operator><name>plan_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* query at column number 6 */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* plan at column number 7 */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* query text at column number 6 */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"&lt;insufficient privilege&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"&lt;insufficient privilege&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>


		<comment type="block">/* state at column number 8 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* parentid at column number 9 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>parentid</name></name> <operator>!=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>parentid_txt</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%08lX"</literal></expr></argument>,<argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>parentid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>parentid_txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

		<comment type="block">/* application_name at column number 9 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* relations at column number 10 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>num_relations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>     <name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>text_str</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>tmp_str</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>    <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Need to calculate the actual size, and avoid unnessary memory usage */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>num_relations</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>relations</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s,%s"</literal></expr></argument>, <argument><expr><name>text_str</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>relations</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* cmd_type at column number 11 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>cmd_type</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>info</name><operator>.</operator><name>cmd_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* elevel at column number 12 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>error</name><operator>.</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sqlcode at column number 13 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>error</name><operator>.</operator><name>sqlcode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>error</name><operator>.</operator><name>sqlcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* message at column number 14 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>error</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>error</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* bucket_start_time at column number 15 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>bucket_start_time</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>bucket_id</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*  Query of pg_stat_monitor itslef started from zero count */</comment>
			<expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>resp_calls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* calls at column number 16 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* total_time at column number 17 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>time</name><operator>.</operator><name>total_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* min_time at column number 18 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>time</name><operator>.</operator><name>min_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* max_time at column number 19 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>time</name><operator>.</operator><name>max_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mean_time at column number 20 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>time</name><operator>.</operator><name>mean_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>time</name><operator>.</operator><name>sum_var_time</name></name> <operator>/</operator> <name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stddev</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* calls at column number 21 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calls at column number 22 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*  Query of pg_stat_monitor itslef started from zero count */</comment>
			<expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>calls</name><operator>.</operator><name>calls</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmp</name><operator>.</operator><name>resp_calls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* calls at column number 23 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* total_time at column number 24 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plantime</name><operator>.</operator><name>total_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* min_time at column number 25 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plantime</name><operator>.</operator><name>min_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* max_time at column number 26 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plantime</name><operator>.</operator><name>max_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mean_time at column number 27 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plantime</name><operator>.</operator><name>mean_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plantime</name><operator>.</operator><name>sum_var_time</name></name> <operator>/</operator> <name><name>tmp</name><operator>.</operator><name>plancalls</name><operator>.</operator><name>calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stddev</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* calls at column number 28 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* blocks are from column number 29 - 40 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_hit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_dirtied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>shared_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_hit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_dirtied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>local_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>temp_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>temp_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>blocks</name><operator>.</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* resp_calls at column number 41 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>IntArrayGetTextDatum</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>resp_calls</name></name></expr></argument>, <argument><expr><name>MAX_RESPONSE_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* utime at column number 42 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>sysinfo</name><operator>.</operator><name>utime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* stime at column number 43 */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>sysinfo</name><operator>.</operator><name>stime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>wal_bytes</name></decl>;</decl_stmt>

			<comment type="block">/* wal_records at column number 44 */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_records</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* wal_fpi at column number 45 */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_fpi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>walusage</name><operator>.</operator><name>wal_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Convert to numeric */</comment>
			<expr_stmt><expr><name>wal_bytes</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
											<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* wal_bytes at column number 46 */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>wal_bytes</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>query_txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>get_next_wbucket</name><parameter_list>(<parameter><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>	<name>tv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>          <name>current_usec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>          <name>bucket_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name>       <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_usec</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_usec</name> <operator>=</operator> <operator>(</operator><name>current_usec</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>current_usec</name> <operator>-</operator> <name><name>pgss</name><operator>-&gt;</operator><name>prev_bucket_usec</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>PGSM_BUCKET_TIME</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>          <name><name>file_name</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>            <name>sec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bucket_id</name> <operator>=</operator> <operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>/</operator> <name>PGSM_BUCKET_TIME</name><operator>)</operator> <operator>%</operator> <name>PGSM_MAX_BUCKETS</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>pgss_qbuf</name><index>[<expr><name>bucket_id</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_entry_dealloc</name><argument_list>(<argument><expr><name>bucket_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_query_entry_dealloc</name><argument_list>(<argument><expr><name>bucket_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>PGSM_TEXT_FILE</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>bucket_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reset the query buffer */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>prev_bucket_usec</name></name> <operator>=</operator> <name>current_usec</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lt</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sec</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>-</operator> <operator>(</operator><name><name>lt</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>%</operator> <name>PGSM_BUCKET_TIME</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>bucket_start_time</name><index>[<expr><name>bucket_id</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>bucket_start_time</name><index>[<expr><name>bucket_id</name></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				<argument><expr><literal type="string">"%04d-%02d-%02d %02d:%02d:%02d"</literal></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>bucket_id</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>pgss</name><operator>-&gt;</operator><name>current_wbucket</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendJumble: Append a value that is substantive in a given query to
 * the current jumble.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendJumble</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>jumble</name> <init>= <expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>jumble_len</name> <init>= <expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Whenever the jumble buffer is full, we hash the current contents and
	 * reset the buffer to contain just that hash value, thus relying on the
	 * hash to summarize everything so far.
	 */</comment>
	<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>part_size</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>jumble_len</name> <operator>&gt;=</operator> <name>JUMBLE_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>start_hash</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>start_hash</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><name>jumble</name></expr></argument>,
														  <argument><expr><name>JUMBLE_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jumble</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>start_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>jumble_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>start_hash</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>part_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>JUMBLE_SIZE</name> <operator>-</operator> <name>jumble_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jumble</name> <operator>+</operator> <name>jumble_len</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>part_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jumble_len</name> <operator>+=</operator> <name>part_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>+=</operator> <name>part_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>part_size</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name> <operator>=</operator> <name>jumble_len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrappers around AppendJumble to encapsulate details of serialization
 * of individual local variable elements.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APP_JUMB</name><parameter_list>(<parameter><type><name>item</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>AppendJumble(jstate, (const unsigned char *) &amp;(item), sizeof(item))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APP_JUMB_STRING</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>AppendJumble(jstate, (const unsigned char *) (str), strlen(str) + 1)</cpp:value></cpp:define>

<comment type="block">/*
 * JumbleQuery: Selectively serialize the query tree, appending significant
 * data to the "query jumble" while ignoring nonsignificant data.
 *
 * Rule of thumb for what to include is that we should ignore anything not
 * semantically significant (such as alias names) as well as anything that can
 * be deduced from child nodes (else we'd just be double-hashing that piece
 * of information).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleQuery</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* resultRelation is usually predictable from commandType */</comment>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleRangeTable</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we ignore rowMarks */</comment>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Jumble a range table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleRangeTable</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>

				<comment type="block">/*
				 * Depending on the CTE name here isn't ideal, but it's the
				 * only info we have to identify the referenced WITH item.
				 */</comment>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Jumble an expression tree
 *
 * In general this function should handle all the same node types that
 * expression_tree_walker() does, and therefore it's coded to be as parallel
 * to that function as possible.  However, since we are only invoked on
 * queries immediately post-parse-analysis, we need not handle node types
 * that only appear in planning.
 *
 * Note: the reason we don't simply use expression_tree_walker() is that the
 * point of that function is to support tree walkers that don't care about
 * most tree node types, but here we care about all types.  We should complain
 * about any unrecognized node type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleExpr</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always emit the node's NodeTag, then any additional fields that are
	 * considered significant, and then we recurse to any child nodes.
	 */</comment>
	<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_YbBatchedExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>YbBatchedExpr</name>	<modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><name>YbBatchedExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bexpr</name><operator>-&gt;</operator><name>orig_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* We jumble only the constant's type, not its value */</comment>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Also, record its parse location for query normalization */</comment>
				<expr_stmt><expr><call><name>RecordConstLocation</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Also, track the highest external Param id */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
					<name><name>p</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grpnode</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grpnode</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>nae</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nae</name><operator>-&gt;</operator><name>argnumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nae</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>cio</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cio</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cio</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acexpr</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>acexpr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acexpr</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>crexpr</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>crexpr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>crexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>(</operator><name>CaseTestExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>mmexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>mmexpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mmexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* type is fully determined by op */</comment>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nt</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cd</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>cdv</name> <init>= <expr><operator>(</operator><name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cdv</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>sd</name> <init>= <expr><operator>(</operator><name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sd</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cvarno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>ie</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ie</name><operator>-&gt;</operator><name>infercollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ie</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>ie</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>isNatural</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>from</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>from</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IntList</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gsnode</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gsnode</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we store the string name because RTE_CTE RTEs need it */</comment>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>all</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tablefunc</name> <init>= <expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>tablefunc</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>tablefunc</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tablefunc</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Only a warning, since we can stumble along anyway */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Record location of constant within query string of query tree
 * that is currently being walked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordConstLocation</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* -1 indicates unknown or undefined location */</comment>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* enlarge array if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>&gt;=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name> <operator>=</operator> <operator>(</operator><name>pgssLocationLen</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr></argument>,
						 <argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>*</operator>
						 <sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>]</index></name><operator>.</operator><name>location</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<comment type="block">/* initialize lengths to -1 to simplify fill_in_constant_lengths */</comment>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a normalized version of the query string that will be used to
 * represent all similar queries.
 *
 * Note that the normalized representation may well vary depending on
 * just which "equivalent" query is used to create the hashtable entry.
 * We assume this is OK.
 *
 * If query_loc &gt; 0, then "query" has been advanced by that much compared to
 * the original string start, so we need to translate the provided locations
 * to compensate.  (This lets us avoid re-scanning statements before the one
 * of interest, so it's worth doing.)
 *
 * *query_len_p contains the input string length, and is updated with
 * the result string length on exit.  The resulting string might be longer
 * or shorter depending on what happens with replacement of constants.
 *
 * Returns a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_normalized_query</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>query_len_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>norm_query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_len</name> <init>= <expr><operator>*</operator><name>query_len_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>norm_query_buflen</name></decl>,	<comment type="block">/* Space allowed for norm_query */</comment>
				<decl><type ref="prev"/><name>len_to_wrt</name></decl>,		<comment type="block">/* Length (in bytes) to write */</comment>
				<decl><type ref="prev"/><name>quer_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/* Source query byte location */</comment>
				<decl><type ref="prev"/><name>n_quer_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <comment type="block">/* Normalized query byte location */</comment>
				<decl><type ref="prev"/><name>last_off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/* Offset from start for previous tok */</comment>
				<decl><type ref="prev"/><name>last_tok_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* Length (in bytes) of that tok */</comment>

	<comment type="block">/*
	 * Get constants' lengths (core system only gives us locations).  Note
	 * this also ensures the items are sorted by location.
	 */</comment>
	<expr_stmt><expr><call><name>fill_in_constant_lengths</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow for $n symbols to be longer than the constants they replace.
	 * Constants must take at least one byte in text form, while a $n symbol
	 * certainly isn't more than 11 bytes, even if n reaches INT_MAX.  We
	 * could refine that limit based on the max value of n for the current
	 * query, but it hardly seems worth any extra effort to do so.
	 */</comment>
	<expr_stmt><expr><name>norm_query_buflen</name> <operator>=</operator> <name>query_len</name> <operator>+</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<comment type="block">/* Allocate result buffer */</comment>
	<expr_stmt><expr><name>norm_query</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>norm_query_buflen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,		<comment type="block">/* Offset from start for cur tok */</comment>
					<decl><type ref="prev"/><name>tok_len</name></decl>;</decl_stmt>	<comment type="block">/* Length (in bytes) of that tok */</comment>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>location</name></expr>;</expr_stmt>
		<comment type="block">/* Adjust recorded location if we're dealing with partial string */</comment>
		<expr_stmt><expr><name>off</name> <operator>-=</operator> <name>query_loc</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tok_len</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore any duplicates */</comment>

		<comment type="block">/* Copy next chunk (what precedes the next constant) */</comment>
		<expr_stmt><expr><name>len_to_wrt</name> <operator>=</operator> <name>off</name> <operator>-</operator> <name>last_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len_to_wrt</name> <operator>-=</operator> <name>last_tok_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len_to_wrt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>norm_query</name> <operator>+</operator> <name>n_quer_loc</name></expr></argument>, <argument><expr><name>query</name> <operator>+</operator> <name>quer_loc</name></expr></argument>, <argument><expr><name>len_to_wrt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_quer_loc</name> <operator>+=</operator> <name>len_to_wrt</name></expr>;</expr_stmt>

		<comment type="block">/* And insert a param symbol in place of the constant token */</comment>
		<expr_stmt><expr><name>n_quer_loc</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>norm_query</name> <operator>+</operator> <name>n_quer_loc</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>quer_loc</name> <operator>=</operator> <name>off</name> <operator>+</operator> <name>tok_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_off</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_tok_len</name> <operator>=</operator> <name>tok_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We've copied up until the last ignorable constant.  Copy over the
	 * remaining bytes of the original query string.
	 */</comment>
	<expr_stmt><expr><name>len_to_wrt</name> <operator>=</operator> <name>query_len</name> <operator>-</operator> <name>quer_loc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len_to_wrt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>norm_query</name> <operator>+</operator> <name>n_quer_loc</name></expr></argument>, <argument><expr><name>query</name> <operator>+</operator> <name>quer_loc</name></expr></argument>, <argument><expr><name>len_to_wrt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_quer_loc</name> <operator>+=</operator> <name>len_to_wrt</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_quer_loc</name> <operator>&lt;=</operator> <name>norm_query_buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_query</name><index>[<expr><name>n_quer_loc</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>query_len_p</name> <operator>=</operator> <name>n_quer_loc</name></expr>;</expr_stmt>
	<return>return <expr><name>norm_query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a valid SQL string and an array of constant-location records,
 * fill in the textual lengths of those constants.
 *
 * The constants may use any allowed constant syntax, such as float literals,
 * bit-strings, single-quoted strings and dollar-quoted strings.  This is
 * accomplished by using the public API for the core scanner.
 *
 * It is the caller's job to ensure that the string is a valid SQL statement
 * with constants at the indicated locations.  Since in practice the string
 * has already been parsed, and the locations that the caller provides will
 * have originated from within the authoritative parser, this should not be
 * a problem.
 *
 * Duplicate constant pointers are possible, and will have their lengths
 * marked as '-1', so that they are later ignored.  (Actually, we assume the
 * lengths were initialized as -1 to start with, and don't change them here.)
 *
 * If query_loc &gt; 0, then "query" has been advanced by that much compared to
 * the original string start, so we need to translate the provided locations
 * to compensate.  (This lets us avoid re-scanning statements before the one
 * of interest, so it's worth doing.)
 *
 * N.B. There is an assumption that a '-' character at a Const location begins
 * a negative numeric constant.  This precludes there ever being another
 * reason for a constant to start with a '-'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_in_constant_lengths</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssLocationLen</name>		<modifier>*</modifier></type><name>locs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_yyscan_t</name></type>		<name>yyscanner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_yy_extra_type</name></type>	<name>yyextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_YYSTYPE</name></type>		<name>yylval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YYLTYPE</name></type>				<name>yylloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>last_loc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sort the records by location so that we can process them in order while
	 * scanning the query text.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr></argument>, <argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comp_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>locs</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialize the flex scanner --- should match raw_parser() */</comment>
	<expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <call><name>scanner_init</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>yyextra</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
							<argument><expr><operator>&amp;</operator><name>ScanKeywords</name></expr></argument>,
							<argument><expr><name>ScanKeywordTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
							<expr_stmt><expr><name>ScanKeywords</name></expr><operator>,</operator>
							<expr><name>NumScanKeywords</name></expr></expr_stmt>)</block_content></block>;</function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* we don't want to re-emit any escape string warnings */</comment>
	<expr_stmt><expr><name><name>yyextra</name><operator>.</operator><name>escape_string_warning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Search for each constant, in sequence */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>loc</name> <init>= <expr><name><name>locs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>location</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tok</name></decl>;</decl_stmt>

		<comment type="block">/* Adjust recorded location if we're dealing with partial string */</comment>
		<expr_stmt><expr><name>loc</name> <operator>-=</operator> <name>query_loc</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>loc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;=</operator> <name>last_loc</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* Duplicate constant, ignore */</comment>

		<comment type="block">/* Lex tokens until we find the desired constant */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>core_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We should not hit end-of-string, but if we do, behave sanely */</comment>
			<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* out of inner for-loop */</comment>

			<comment type="block">/*
			 * We should find the token position exactly, but if we somehow
			 * run past it, work with that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>yylloc</name> <operator>&gt;=</operator> <name>loc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * It's a negative value - this is the one and only case
					 * where we replace more than a single token.
					 *
					 * Do not compensate for the core system's special-case
					 * adjustment of location to that of the leading '-'
					 * operator in the event of a negative constant.  It is
					 * also useful for our purposes to start from the minus
					 * symbol.  In this way, queries like "select * from foo
					 * where bar = 1" and "select * from foo where bar = -2"
					 * will have identical normalized query strings.
					 */</comment>
					<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>core_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* out of inner for-loop */</comment>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We now rely on the assumption that flex has placed a zero
				 * byte after the text of the current token in scanbuf.
				 */</comment>
				<expr_stmt><expr><name><name>locs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>yyextra</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* out of inner for-loop */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If we hit end-of-string, give up, leaving remaining lengths -1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>last_loc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>scanner_finish</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

<comment type="block">/*
 * comp_location: comparator for qsorting pgssLocationLen structs by location
 */</comment>
static <function><type><name>int</name></type>
<name>comp_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>l</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>pgssLocationLen</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>r</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>pgssLocationLen</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_STRING_LEN</name></cpp:macro>	<cpp:value>1024</cpp:value></cpp:define>
<comment type="block">/* Convert array into Text dataum */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>intarray_get_datum</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name><name>arr</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>     <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>str</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>tmp</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>    <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need to calculate the actual size, and avoid unnessary memory usage */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">",%d"</literal></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>read_query</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name>            <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>query_id</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>query_len</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rlen</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>buf_len</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* Move forwad to skip length bytes */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;=</operator> <name>buf_len</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>rlen</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* query id */</comment>
		<if_stmt><if>if <condition>(<expr><name>query_id</name> <operator>==</operator> <name>queryid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rlen</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>&lt;=</operator> <name>rlen</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>rlen</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* query len */</comment>
		<expr_stmt><expr><name>rlen</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>&lt;</operator> <name>rlen</name> <operator>+</operator> <name>query_len</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>rlen</name></expr>]</index></name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Actual query */</comment>
				<expr_stmt><expr><name><name>query</name><index>[<expr><name>query_len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>query_id</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rlen</name> <operator>+=</operator> <name>query_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>
<label><name>exit</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>PGSM_OVERFLOW_TARGET</name> <operator>==</operator> <name>OVERFLOW_TARGET_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"&lt;insufficient shared space&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pgssQueryEntry</name><modifier>*</modifier></type>
<name>pgss_store_query_info</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bucketid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>dbid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>userid</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>ip</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>query_len</name></decl></parameter>,
					  <parameter><decl><type><name>pgssStoreKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type>          <name>buf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name>   <init>= <expr><call><name>pgsm_get_ss</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name>   <modifier>*</modifier></type><name>buf</name>    <init>= <expr><name><name>pgss_qbuf</name><index>[<expr><name><name>pgss</name><operator>-&gt;</operator><name>current_wbucket</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssQueryEntry</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>query_len</name> <operator>&gt;</operator> <name>PGSM_QUERY_MAX_LEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_len</name> <operator>=</operator> <name>PGSM_QUERY_MAX_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Already have query in the shared buffer, there
	 * is no need to add that again.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_find_query_entry</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>entry</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_create_query_entry</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf_len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_len</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>QUERY_BUFFER_OVERFLOW</name><argument_list>(<argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<switch>switch<condition>(<expr><name>PGSM_OVERFLOW_TARGET</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OVERFLOW_TARGET_NONE</name></expr>:</case>
				<return>return <expr><name>NULL</name></expr>;</return>
			<case>case <expr><name>OVERFLOW_TARGET_DISK</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>dump_queries_buffer</name><argument_list>(<argument><expr><name>bucketid</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAX_QUERY_BUFFER_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buf_len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>buf_len</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryid</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* query id */</comment>
	<expr_stmt><expr><name>buf_len</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>buf_len</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>query_len</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* query length */</comment>
	<expr_stmt><expr><name>buf_len</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>buf_len</name></expr>]</index></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* query */</comment>
	<expr_stmt><expr><name>buf_len</name> <operator>+=</operator> <name>query_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_len</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>get_query_id</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>queryid</name></decl>;</decl_stmt>

	<comment type="block">/* Set up workspace for query jumbling */</comment>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>JUMBLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name> <operator>=</operator> <operator>(</operator><name>pgssLocationLen</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Compute query ID and mark the Query node with it */</comment>
	<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queryid</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble</name></name></expr></argument>, <argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>queryid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_stat_monitor_settings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name>		<modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>			<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name>		<modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_stat_monitor: set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_stat_monitor: incorrect number of output arguments, required %d"</literal></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SETTINGS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><call><name>get_conf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>guc_restart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>set_qbuf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pgss_qbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgsm_emit_log_hook</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemInitialized</name><argument_list>()</argument_list></call> <operator>||</operator> <name>edata</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>ERROR</name> <operator>||</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>WARNING</name> <operator>||</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>INFO</name> <operator>||</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>DEBUG1</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>queryid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>debug_query_string</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>queryid</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>debug_query_string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pgss_store_error</name><argument_list>(<argument><expr><name>queryid</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>debug_query_string</name></expr> ?</condition><then> <expr><name>debug_query_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<label><name>exit</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>prev_emit_log_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>prev_emit_log_hook</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsSystemInitialized</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>system_init</name> <operator>&amp;&amp;</operator> <call><name>IsHashInitialize</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_queries_buffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bucket_id</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>  <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>file_name</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>PGSM_TEXT_FILE</name></expr></argument>, <argument><expr><name>bucket_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
             	<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
                    		<argument><expr><name>file_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>buf_len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
             	<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
                    		<argument><expr><name>file_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>read_query_buffer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bucket_id</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>queryid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_txt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>           <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>           <name>buf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>          <name><name>file_name</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>           <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>PGSM_TEXT_FILE</name></expr></argument>, <argument><expr><name>bucket_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_QUERY_BUFFER_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>off</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAX_QUERY_BUFFER_BUCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>!=</operator> <name>MAX_QUERY_BUFFER_BUCKET</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <name>buf_len</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>read_query</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bucket_id</name></expr></argument>, <argument><expr><name>queryid</name></expr></argument>, <argument><expr><name>query_txt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>buf_len</name></expr>;</return>

<label><name>exit</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
				<argument><expr><name>file_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>buf_len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>time_diff</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>mstart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>mend</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>mend</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>end</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>end</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000.0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>mstart</name>   <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>start</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>start</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000.0</literal><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>mend</name> <operator>-</operator> <name>mstart</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>unpack_sql_state</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sql_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PGUNSIXBIT</name><argument_list>(<argument><expr><name>sql_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sql_state</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_histogram_bucket</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>q_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>q_min</name> <init>= <expr><name>PGSM_HISTOGRAM_MIN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>q_max</name> <init>= <expr><name>PGSM_HISTOGRAM_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>    <name>b_count</name> <init>= <expr><name>PGSM_HISTOGRAM_BUCKETS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>    <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_min</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>bucket_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>q_time</name> <operator>-=</operator> <name>q_min</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>b_max</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name>q_max</name> <operator>-</operator> <name>q_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>bucket_size</name> <operator>=</operator> <operator>(</operator><name>b_max</name> <operator>-</operator> <name>b_min</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>b_count</name></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;=</operator> <name>b_count</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>b_start</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>index</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>exp</name><argument_list>(<argument><expr><name>bucket_size</name> <operator>*</operator> <operator>(</operator><name>index</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>b_end</name> <init>= <expr><call><name>exp</name><argument_list>(<argument><expr><name>bucket_size</name> <operator>*</operator> <name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>index</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>q_time</name> <operator>&lt;</operator> <name>b_start</name><operator>)</operator>
			<operator>||</operator> <operator>(</operator><name>q_time</name> <operator>&gt;=</operator> <name>b_start</name> <operator>&amp;&amp;</operator> <name>q_time</name> <operator>&lt;=</operator> <name>b_end</name><operator>)</operator>
			<operator>||</operator> <operator>(</operator><name>index</name> <operator>==</operator> <name>b_count</name> <operator>&amp;&amp;</operator> <name>q_time</name> <operator>&gt;</operator> <name>b_end</name><operator>)</operator></expr> )</condition>
		<block>{<block_content>
			<return>return <expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>get_histogram_timings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>q_min</name> <init>= <expr><name>PGSM_HISTOGRAM_MIN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>q_max</name> <init>= <expr><name>PGSM_HISTOGRAM_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>    <name>b_count</name> <init>= <expr><name>PGSM_HISTOGRAM_BUCKETS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>    <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_min</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>bucket_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>tmp_str</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>MAX_STRING_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>text_str</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>MAX_STRING_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>b_max</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name>q_max</name> <operator>-</operator> <name>q_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket_size</name> <operator>=</operator> <operator>(</operator><name>b_max</name> <operator>-</operator> <name>b_min</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>b_count</name></expr>;</expr_stmt>
	<for>for<control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;=</operator> <name>b_count</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>b_start</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>index</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>exp</name><argument_list>(<argument><expr><name>bucket_size</name> <operator>*</operator> <operator>(</operator><name>index</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>b_end</name> <init>= <expr><call><name>exp</name><argument_list>(<argument><expr><name>bucket_size</name> <operator>*</operator> <name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><literal type="string">"(%ld - %ld)}"</literal></expr></argument>, <argument><expr><name>b_start</name></expr></argument>, <argument><expr><name>b_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s, (%ld - %ld)}"</literal></expr></argument>, <argument><expr><name>text_str</name></expr></argument>, <argument><expr><name>b_start</name></expr></argument>, <argument><expr><name>b_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>text_str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function></unit>
