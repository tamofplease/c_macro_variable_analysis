<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/bloom/blinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * blinsert.c
 *		Bloom index build and insert functions.
 *
 * Copyright (c) 2016-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  contrib/bloom/blinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/generic_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bloom.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * State of bloom index build.  We accumulate one page data here before
 * flushing it to buffer manager.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BloomState</name></type>	<name>blstate</name></decl>;</decl_stmt>		<comment type="block">/* bloom index state */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>indtuples</name></decl>;</decl_stmt>		<comment type="block">/* total number of tuples indexed */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpCtx</name></decl>;</decl_stmt>		<comment type="block">/* temporary memory context reset after each
								 * tuple */</comment>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>data</name></decl>;</decl_stmt>		<comment type="block">/* cached page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* number of tuples in cached page */</comment>
}</block></struct></type> <name>BloomBuildState</name>;</typedef>

<comment type="block">/*
 * Flush page cached in BloomBuildState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flushCachedPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BloomBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name> <init>= <expr><call><name>BloomNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>GenericXLogStart</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GENERIC_XLOG_FULL_IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GenericXLogFinish</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * (Re)initialize cached page in BloomBuildState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initCachedPage</name><parameter_list>(<parameter><decl><type><name>BloomBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BloomInitPage</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per-tuple callback from IndexBuildHeapScan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bloomBuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BloomBuildState</name> <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>BloomBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BloomTuple</name> <modifier>*</modifier></type><name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>BloomFormTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>blstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to add next item to cached page */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BloomPageAddItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>blstate</name></name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Next item was added successfully */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Cached page is full, flush it out and make a new one */</comment>
		<expr_stmt><expr><call><name>flushCachedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initCachedPage</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BloomPageAddItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>blstate</name></name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We shouldn't be here since we're inserting to the empty page */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add new bloom tuple to empty page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Next item was added successfully */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update total tuple count */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a new bloom index.
 */</comment>
<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>blbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BloomBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the meta page */</comment>
	<expr_stmt><expr><call><name>BloomInitMetapage</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the bloom build state */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initBloomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>blstate</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>tmpCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><literal type="string">"Bloom build temporary context"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initCachedPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the heap scan */</comment>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>IndexBuildHeapScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>bloomBuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flush last page if needed (it will be, unless heap was empty) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flushCachedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an empty bloom index in the initialization fork.
 */</comment>
<function><type><name>void</name></type>
<name>blbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>

	<comment type="block">/* Construct metapage. */</comment>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BloomFillMetapage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write the page and log it.  It might seem that an immediate sync would
	 * be sufficient to guarantee that the file exists on disk, but recovery
	 * itself might remove it while replaying, for example, an
	 * XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE record.  Therefore, we need
	 * this even when wal_level=minimal.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>BLOOM_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>BLOOM_METAPAGE_BLKNO</name></expr></argument>,
			  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><operator>-&gt;</operator><name>rd_smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>,
				<argument><expr><name>BLOOM_METAPAGE_BLKNO</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * An immediate sync is required even if we xlog'd the page, because the
	 * write did not go through shared_buffers and therefore a concurrent
	 * checkpoint may have moved the redo pointer past our xlog record.
	 */</comment>
	<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert new tuple to the bloom index.
 */</comment>
<function><type><name>bool</name></type>
<name>blinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		 <parameter><decl><type><name>ItemPointer</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
		 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
		 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BloomState</name></type>	<name>blstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BloomTuple</name> <modifier>*</modifier></type><name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>insertCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BloomMetaPageData</name> <modifier>*</modifier></type><name>metaData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>,
				<decl><type ref="prev"/><name>metaBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>,
				<decl><type ref="prev"/><name>metaPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>insertCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">"Bloom insert temporary context"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initBloomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blstate</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>BloomFormTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blstate</name></expr></argument>, <argument><expr><name>ht_ctid</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At first, try to insert new tuple to the first page in notFullPage
	 * array.  If successful, we don't need to modify the meta page.
	 */</comment>
	<expr_stmt><expr><name>metaBuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>BLOOM_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaData</name> <operator>=</operator> <call><name>BloomPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metaData</name><operator>-&gt;</operator><name>nEnd</name></name> <operator>&gt;</operator> <name><name>metaData</name><operator>-&gt;</operator><name>nStart</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>metaData</name><operator>-&gt;</operator><name>notFullPage</name><index>[<expr><name><name>metaData</name><operator>-&gt;</operator><name>nStart</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Don't hold metabuffer lock while doing insert */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>GenericXLogStart</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We might have found a page that was recently deleted by VACUUM.  If
		 * so, we can reuse it, but we must reinitialize it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BloomPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BloomInitPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BloomPageAddItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blstate</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Success!  Apply the change, clean up, and exit */</comment>
			<expr_stmt><expr><call><name>GenericXLogFinish</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Didn't fit, must try other pages */</comment>
		<expr_stmt><expr><call><name>GenericXLogAbort</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No entries in notFullPage */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Try other pages in notFullPage array.  We will have to change nStart in
	 * metapage.  Thus, grab exclusive lock on metapage.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nStart might have changed while we didn't have lock */</comment>
	<expr_stmt><expr><name>nStart</name> <operator>=</operator> <name><name>metaData</name><operator>-&gt;</operator><name>nStart</name></name></expr>;</expr_stmt>

	<comment type="block">/* Skip first page if we already tried it above */</comment>
	<if_stmt><if>if <condition>(<expr><name>nStart</name> <operator>&lt;</operator> <name><name>metaData</name><operator>-&gt;</operator><name>nEnd</name></name> <operator>&amp;&amp;</operator>
		<name>blkno</name> <operator>==</operator> <name><name>metaData</name><operator>-&gt;</operator><name>notFullPage</name><index>[<expr><name>nStart</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nStart</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This loop iterates for each page we try from the notFullPage array, and
	 * will also initialize a GenericXLogState for the fallback case of having
	 * to allocate a new page.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>GenericXLogStart</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get modifiable copy of metapage */</comment>
		<expr_stmt><expr><name>metaPage</name> <operator>=</operator> <call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>metaBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metaData</name> <operator>=</operator> <call><name>BloomPageGetMeta</name><argument_list>(<argument><expr><name>metaPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nStart</name> <operator>&gt;=</operator> <name><name>metaData</name><operator>-&gt;</operator><name>nEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* no more entries in notFullPage array */</comment>

		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>metaData</name><operator>-&gt;</operator><name>notFullPage</name><index>[<expr><name>nStart</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Basically same logic as above */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BloomPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BloomInitPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BloomPageAddItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blstate</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Success!  Apply the changes, clean up, and exit */</comment>
			<expr_stmt><expr><name><name>metaData</name><operator>-&gt;</operator><name>nStart</name></name> <operator>=</operator> <name>nStart</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GenericXLogFinish</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Didn't fit, must try other pages */</comment>
		<expr_stmt><expr><call><name>GenericXLogAbort</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nStart</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Didn't find place to insert in notFullPage array.  Allocate new page.
	 * (XXX is it good to do this while holding ex-lock on the metapage??)
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>BloomNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GENERIC_XLOG_FULL_IMAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BloomInitPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BloomPageAddItem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blstate</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We shouldn't be here since we're inserting to an empty page */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add new bloom tuple to empty page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reset notFullPage array to contain just this new page */</comment>
	<expr_stmt><expr><name><name>metaData</name><operator>-&gt;</operator><name>nStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metaData</name><operator>-&gt;</operator><name>nEnd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metaData</name><operator>-&gt;</operator><name>notFullPage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply the changes, clean up, and exit */</comment>
	<expr_stmt><expr><call><name>GenericXLogFinish</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
