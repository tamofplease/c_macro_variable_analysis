<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/contrib/tablefunc/tablefunc.c"><comment type="block">/*
 * contrib/tablefunc/tablefunc.c
 *
 *
 * tablefunc
 *
 * Sample to demonstrate C functions which return setof scalar
 * and setof composite.
 * Joe Conway &lt;mail@joeconway.com&gt;
 * And contributors:
 * Nabil Sayegh &lt;postgresql@e-trolley.de&gt;
 *
 * Copyright (c) 2002-2018, PostgreSQL Global Development Group
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tablefunc.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>load_categories_hash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cats_sql</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type><name>get_crosstab_tuplestore</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>,
						<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>crosstab_hash</name></decl></parameter>,
						<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
						<parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateConnectbyTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>compatCrosstabTupleDescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc1</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compatConnectbyTupleDescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc1</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_normal_pair</name><parameter_list>(<parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x1</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type><name>connectby</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parent_key_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>orderby_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch_delim</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_with</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>max_depth</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>,
		  <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_tuplestore_recursively</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parent_key_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>orderby_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch_delim</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_with</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>serial</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>max_depth</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>,
							 <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
							 <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>,
							 <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>float8</name></type>		<name>mean</name></decl>;</decl_stmt>			<comment type="block">/* mean of the distribution */</comment>
	<decl_stmt><decl><type><name>float8</name></type>		<name>stddev</name></decl>;</decl_stmt>			<comment type="block">/* stddev of the distribution */</comment>
	<decl_stmt><decl><type><name>float8</name></type>		<name>carry_val</name></decl>;</decl_stmt>		<comment type="block">/* hold second generated value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_carry</name></decl>;</decl_stmt>		<comment type="block">/* use second generated value */</comment>
}</block></struct></type> <name>normal_rand_fctx</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xpfree</name><parameter_list>(<parameter><type><name>var_</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (var_ != NULL) \
		{ \
			pfree(var_); \
			var_ = NULL; \
		} \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xpstrdup</name><parameter_list>(<parameter><type><name>tgtvar_</name></type></parameter>, <parameter><type><name>srcvar_</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (srcvar_) \
			tgtvar_ = pstrdup(srcvar_); \
		else \
			tgtvar_ = NULL; \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xstreq</name><parameter_list>(<parameter><type><name>tgtvar_</name></type></parameter>, <parameter><type><name>srcvar_</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((tgtvar_ == NULL) &amp;&amp; (srcvar_ == NULL)) || \
	 ((tgtvar_ != NULL) &amp;&amp; (srcvar_ != NULL) &amp;&amp; (strcmp(tgtvar_, srcvar_) == 0)))</cpp:value></cpp:define>

<comment type="block">/* sign, 10 digits, '\0' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_STRLEN</name></cpp:macro>	<cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* stored info for a crosstab category */</comment>
<typedef>typedef <type><struct>struct <name>crosstab_cat_desc</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catname</name></decl>;</decl_stmt>		<comment type="block">/* full category name */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>attidx</name></decl>;</decl_stmt>			<comment type="block">/* zero based */</comment>
}</block></struct></type> <name>crosstab_cat_desc</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CATNAME_LEN</name></cpp:macro>			<cpp:value>NAMEDATALEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_CATS</name></cpp:macro>				<cpp:value>64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>crosstab_HashTableLookup</name><parameter_list>(<parameter><type><name>HASHTAB</name></type></parameter>, <parameter><type><name>CATNAME</name></type></parameter>, <parameter><type><name>CATDESC</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	crosstab_HashEnt *hentry; char key[MAX_CATNAME_LEN]; \
	\
	MemSet(key, 0, MAX_CATNAME_LEN); \
	snprintf(key, MAX_CATNAME_LEN - 1, "%s", CATNAME); \
	hentry = (crosstab_HashEnt*) hash_search(HASHTAB, \
										 key, HASH_FIND, NULL); \
	if (hentry) \
		CATDESC = hentry-&gt;catdesc; \
	else \
		CATDESC = NULL; \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>crosstab_HashTableInsert</name><parameter_list>(<parameter><type><name>HASHTAB</name></type></parameter>, <parameter><type><name>CATDESC</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	crosstab_HashEnt *hentry; bool found; char key[MAX_CATNAME_LEN]; \
	\
	MemSet(key, 0, MAX_CATNAME_LEN); \
	snprintf(key, MAX_CATNAME_LEN - 1, "%s", CATDESC-&gt;catname); \
	hentry = (crosstab_HashEnt*) hash_search(HASHTAB, \
										 key, HASH_ENTER, &amp;found); \
	if (found) \
		ereport(ERROR, \
				(errcode(ERRCODE_DUPLICATE_OBJECT), \
				 errmsg("duplicate category name"))); \
	hentry-&gt;catdesc = CATDESC; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/* hash table */</comment>
<typedef>typedef <type><struct>struct <name>crosstab_hashent</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>internal_catname</name><index>[<expr><name>MAX_CATNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>crosstab_cat_desc</name> <modifier>*</modifier></type><name>catdesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>crosstab_HashEnt</name>;</typedef>

<comment type="block">/*
 * normal_rand - return requested number of random values
 * with a Gaussian (Normal) distribution.
 *
 * inputs are int numvals, float8 mean, and float8 stddev
 * returns setof float8
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>normal_rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>normal_rand</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>max_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>normal_rand_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>mean</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>stddev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>carry_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_carry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* total number of tuples to be returned */</comment>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>normal_rand_fctx</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>normal_rand_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use fctx to keep track of upper and lower bounds from call to call.
		 * It will also be used to carry over the spare value we get from the
		 * Box-Muller algorithm so that we only actually calculate a new value
		 * every other call.
		 */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>mean</name></name> <operator>=</operator> <call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>stddev</name></name> <operator>=</operator> <call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>carry_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>use_carry</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_calls</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mean</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>mean</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>stddev</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>stddev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>carry_val</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>carry_val</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>use_carry</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>use_carry</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name>max_calls</name></expr>)</condition>	<comment type="block">/* do when there is more left to send */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_carry</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * reset use_carry and use second value obtained on last pass
			 */</comment>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>use_carry</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>carry_val</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>float8</name></type>		<name>normval_1</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float8</name></type>		<name>normval_2</name></decl>;</decl_stmt>

			<comment type="block">/* Get the next two normal values */</comment>
			<expr_stmt><expr><call><name>get_normal_pair</name><argument_list>(<argument><expr><operator>&amp;</operator><name>normval_1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>normval_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* use the first */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>mean</name> <operator>+</operator> <operator>(</operator><name>stddev</name> <operator>*</operator> <name>normval_1</name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* and save the second */</comment>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>carry_val</name></name> <operator>=</operator> <name>mean</name> <operator>+</operator> <operator>(</operator><name>stddev</name> <operator>*</operator> <name>normval_2</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>use_carry</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* send the result */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_normal_pair()
 * Assigns normally distributed (Gaussian) values to a pair of provided
 * parameters, with mean 0, standard deviation 1.
 *
 * This routine implements Algorithm P (Polar method for normal deviates)
 * from Knuth's _The_Art_of_Computer_Programming_, Volume 2, 3rd ed., pages
 * 122-126. Knuth cites his source as "The polar method", G. E. P. Box, M. E.
 * Muller, and G. Marsaglia, _Annals_Math,_Stat._ 29 (1958), 610-611.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_normal_pair</name><parameter_list>(<parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x1</name></decl></parameter>, <parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>x2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>u1</name></decl>,
				<decl><type ref="prev"/><name>u2</name></decl>,
				<decl><type ref="prev"/><name>v1</name></decl>,
				<decl><type ref="prev"/><name>v2</name></decl>,
				<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>u1</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>MAX_RANDOM_VALUE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>u2</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><name>float8</name><operator>)</operator> <name>MAX_RANDOM_VALUE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>v1</name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>u1</name><operator>)</operator> <operator>-</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>v2</name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>u2</name><operator>)</operator> <operator>-</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>v1</name> <operator>*</operator> <name>v1</name> <operator>+</operator> <name>v2</name> <operator>*</operator> <name>v2</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>s</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>x1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>x2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><operator>(</operator><operator>-</operator><literal type="number">2.0</literal> <operator>*</operator> <call><name>log</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>x1</name> <operator>=</operator> <name>v1</name> <operator>*</operator> <name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>x2</name> <operator>=</operator> <name>v2</name> <operator>*</operator> <name>s</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * crosstab - create a crosstab of rowids and values columns from a
 * SQL statement returning one rowid column, one category column,
 * and one value column.
 *
 * e.g. given sql which produces:
 *
 *			rowid	cat		value
 *			------+-------+-------
 *			row1	cat1	val1
 *			row1	cat2	val2
 *			row1	cat3	val3
 *			row1	cat4	val4
 *			row2	cat1	val5
 *			row2	cat2	val6
 *			row2	cat3	val7
 *			row2	cat4	val8
 *
 * crosstab returns:
 *					&lt;===== values columns =====&gt;
 *			rowid	cat1	cat2	cat3	cat4
 *			------+-------+-------+-------+-------
 *			row1	val1	val2	val3	val4
 *			row2	val5	val6	val7	val8
 *
 * NOTES:
 * 1. SQL result must be ordered by 1,2.
 * 2. The number of values columns depends on the tuple description
 *	  of the function's declared return type.  The return type's columns
 *	  must match the datatypes of the SQL query's result.  The datatype
 *	  of the category column can be anything, however.
 * 3. Missing values (i.e. not enough adjacent rows of same rowid to
 *	  fill the number of result values columns) are filled in with nulls.
 * 4. Extra values (i.e. too many adjacent rows of same rowid to fill
 *	  the number of result values columns) are skipped.
 * 5. Rows with all nulls in the values columns are skipped.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>crosstab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>crosstab</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>max_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>spi_tuptable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>spi_tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firstpass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lastrowid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_categories</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>proc</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"crosstab: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Retrieve the desired rows */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* If no qualifying tuples, fall out early */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>SPI_OK_SELECT</name> <operator>||</operator> <name>proc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>spi_tuptable</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>spi_tupdesc</name> <operator>=</operator> <name><name>spi_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * The provided SQL query must always return three columns.
	 *
	 * 1. rowname
	 *	the label or identifier for each row in the final result
	 * 2. category
	 *	the label or identifier for each column in the final result
	 * 3. values
	 *	the value for each column in the final result
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spi_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid source data SQL statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The provided SQL must return 3 "</literal>
						   <literal type="string">"columns: rowid, category, and values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get a tuple descriptor for our result type */</comment>
	<switch>switch <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPEFUNC_COMPOSITE</name></expr>:</case>
			<comment type="block">/* success */</comment>
			<break>break;</break>
		<case>case <expr><name>TYPEFUNC_RECORD</name></expr>:</case>
			<comment type="block">/* failed to determine actual type of RECORD */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
							<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* result type isn't composite */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check that return tupdesc is compatible with the data we got from SPI,
	 * at least based on number and type of attributes
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compatCrosstabTupleDescs</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return and sql tuple descriptions are "</literal> \
						<literal type="string">"incompatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * switch to long-lived memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we have a persistent copy of the result tupdesc */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize our tuplestore in long-lived context */</comment>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate attribute metadata needed later to produce tuples from raw C
	 * strings
	 */</comment>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* total number of tuples to be examined */</comment>
	<expr_stmt><expr><name>max_calls</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

	<comment type="block">/* the return tuple always must have 1 rowid + num_categories columns */</comment>
	<expr_stmt><expr><name>num_categories</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstpass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastrowid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>call_cntr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>call_cntr</name> <operator>&lt;</operator> <name>max_calls</name></expr>;</condition> <incr><expr><name>call_cntr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skip_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>

		<comment type="block">/* allocate and zero space */</comment>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>num_categories</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * now loop through the sql results and assign each value in sequence
		 * to the next category
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_categories</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>spi_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rowid</name></decl>;</decl_stmt>

			<comment type="block">/* see if we've gone too far already */</comment>
			<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&gt;=</operator> <name>max_calls</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* get the next sql result tuple */</comment>
			<expr_stmt><expr><name>spi_tuple</name> <operator>=</operator> <name><name>spi_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>call_cntr</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* get the rowid from the current sql result tuple */</comment>
			<expr_stmt><expr><name>rowid</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If this is the first pass through the values for this rowid,
			 * set the first column to rowid
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>xpstrdup</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check to see if the rowid is the same as that of the last
				 * tuple sent -- if so, skip this tuple entirely
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstpass</name> <operator>&amp;&amp;</operator> <call><name>xstreq</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If rowid hasn't changed on us, continue building the output
			 * tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xstreq</name><argument_list>(<argument><expr><name>rowid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Get the next category item value, which is always attribute
				 * number three.
				 *
				 * Be careful to assign the value to the array index based on
				 * which category we are presently processing.
				 */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * increment the counter since we consume a row for each
				 * category, but not for last pass because the outer loop will
				 * do that for us
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>num_categories</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>call_cntr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We'll fill in NULLs for the missing values, but we need to
				 * decrement the counter since this sql result row doesn't
				 * belong to the current output tuple.
				 */</comment>
				<expr_stmt><expr><name>call_cntr</name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

			<comment type="block">/* build the tuple and store it */</comment>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember current rowid */</comment>
		<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xpstrdup</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstpass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Clean up */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_categories</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* let the caller know we're sending back a tuplestore */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<comment type="block">/* release SPI related resources (and return to caller's context) */</comment>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * crosstab_hash - reimplement crosstab as materialized function and
 * properly deal with missing values (i.e. don't pack remaining
 * values to the left)
 *
 * crosstab - create a crosstab of rowids and values columns from a
 * SQL statement returning one rowid column, one category column,
 * and one value column.
 *
 * e.g. given sql which produces:
 *
 *			rowid	cat		value
 *			------+-------+-------
 *			row1	cat1	val1
 *			row1	cat2	val2
 *			row1	cat4	val4
 *			row2	cat1	val5
 *			row2	cat2	val6
 *			row2	cat3	val7
 *			row2	cat4	val8
 *
 * crosstab returns:
 *					&lt;===== values columns =====&gt;
 *			rowid	cat1	cat2	cat3	cat4
 *			------+-------+-------+-------+-------
 *			row1	val1	val2	null	val4
 *			row2	val5	val6	val7	val8
 *
 * NOTES:
 * 1. SQL result must be ordered by 1.
 * 2. The number of values columns depends on the tuple description
 *	  of the function's declared return type.
 * 3. Missing values (i.e. missing category) are filled in with nulls.
 * 4. Extra values (i.e. not in category results) are skipped.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>crosstab_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>crosstab_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cats_sql</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>crosstab_hash</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>||</operator>
		<name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the requested return tuple description */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to make sure we have a reasonable tuple descriptor
	 *
	 * Note we will attempt to coerce the values into whatever the return
	 * attribute type is and depend on the "in" function to complain if
	 * needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query-specified return tuple and "</literal> \
						<literal type="string">"crosstab function are not compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* load up the categories hash table */</comment>
	<expr_stmt><expr><name>crosstab_hash</name> <operator>=</operator> <call><name>load_categories_hash</name><argument_list>(<argument><expr><name>cats_sql</name></expr></argument>, <argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* let the caller know we're sending back a tuplestore */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<comment type="block">/* now go build it */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <call><name>get_crosstab_tuplestore</name><argument_list>(<argument><expr><name>sql</name></expr></argument>,
												<argument><expr><name>crosstab_hash</name></expr></argument>,
												<argument><expr><name>tupdesc</name></expr></argument>,
												<argument><expr><name>per_query_ctx</name></expr></argument>,
												<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SFRM_Materialize mode expects us to return a NULL Datum. The actual
	 * tuples are in our tuplestore and passed back through rsinfo-&gt;setResult.
	 * rsinfo-&gt;setDesc is set to the tuple description that we actually used
	 * to build our tuples with, so the caller can verify we did what it was
	 * expecting.
	 */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * load up the categories hash table
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>load_categories_hash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cats_sql</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>crosstab_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>SPIcontext</name></decl>;</decl_stmt>

	<comment type="block">/* initialize the category hash table */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>MAX_CATNAME_LEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>crosstab_HashEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>per_query_ctx</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * use INIT_CATS, defined above as a guess of how many hash table entries
	 * to create, initially
	 */</comment>
	<expr_stmt><expr><name>crosstab_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"crosstab hash"</literal></expr></argument>,
								<argument><expr><name>INIT_CATS</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
								<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"load_categories_hash: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Retrieve the category name rows */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>cats_sql</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* Check for qualifying tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>proc</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>spi_tuptable</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>spi_tupdesc</name> <init>= <expr><name><name>spi_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The provided categories SQL query must always return one column:
		 * category - the label or identifier for each column
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>spi_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"provided \"categories\" SQL must "</literal> \
							<literal type="string">"return 1 column of at least one row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>proc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>crosstab_cat_desc</name> <modifier>*</modifier></type><name>catdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>spi_tuple</name></decl>;</decl_stmt>

			<comment type="block">/* get the next sql result tuple */</comment>
			<expr_stmt><expr><name>spi_tuple</name> <operator>=</operator> <name><name>spi_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* get the category from the current sql result tuple */</comment>
			<expr_stmt><expr><name>catname</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>SPIcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>catdesc</name> <operator>=</operator> <operator>(</operator><name>crosstab_cat_desc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>crosstab_cat_desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>catdesc</name><operator>-&gt;</operator><name>catname</name></name> <operator>=</operator> <name>catname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>catdesc</name><operator>-&gt;</operator><name>attidx</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/* Add the proc description block to the hashtable */</comment>
			<expr_stmt><expr><call><name>crosstab_HashTableInsert</name><argument_list>(<argument><expr><name>crosstab_hash</name></expr></argument>, <argument><expr><name>catdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>SPIcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"load_categories_hash: SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>crosstab_hash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create and populate the crosstab tuplestore using the provided source query
 */</comment>
<function><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>get_crosstab_tuplestore</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>,
						<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>crosstab_hash</name></decl></parameter>,
						<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
						<parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_categories</name> <init>= <expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>crosstab_hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name> <init>= <expr><call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>proc</name></decl>;</decl_stmt>

	<comment type="block">/* initialize our tuplestore (while still in query context!) */</comment>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_crosstab_tuplestore: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now retrieve the crosstab source rows */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* Check for qualifying tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>proc</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>spi_tuptable</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>spi_tupdesc</name> <init>= <expr><name><name>spi_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><name><name>spi_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rowid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lastrowid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>firstpass</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result_ncols</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_categories</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no qualifying category tuples */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"provided \"categories\" SQL must "</literal> \
							<literal type="string">"return 1 column of at least one row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The provided SQL query must always return at least three columns:
		 *
		 * 1. rowname	the label for each row - column 1 in the final result
		 * 2. category	the label for each value-column in the final result 3.
		 * value	 the values used to populate the value-columns
		 *
		 * If there are more than three columns, the last two are taken as
		 * "category" and "values". The first column is taken as "rowname".
		 * Additional columns (2 thru N-2) are assumed the same for the same
		 * "rowname", and are copied into the result tuple from the first time
		 * we encounter a particular rowname.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid source data SQL statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The provided SQL must return 3 "</literal> \
							   <literal type="string">" columns; rowid, category, and values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result_ncols</name> <operator>=</operator> <operator>(</operator><name>ncols</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>num_categories</name></expr>;</expr_stmt>

		<comment type="block">/* Recheck to make sure we tuple descriptor still looks reasonable */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name>result_ncols</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query-specified return "</literal> \
							   <literal type="string">"tuple has %d columns but crosstab "</literal> \
							   <literal type="string">"returns %d."</literal></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>result_ncols</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* allocate space */</comment>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>result_ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and make sure it's clear */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>result_ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>proc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>spi_tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>crosstab_cat_desc</name> <modifier>*</modifier></type><name>catdesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catname</name></decl>;</decl_stmt>

			<comment type="block">/* get the next sql result tuple */</comment>
			<expr_stmt><expr><name>spi_tuple</name> <operator>=</operator> <name><name>spi_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* get the rowid from the current sql result tuple */</comment>
			<expr_stmt><expr><name>rowid</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if we're on a new output row, grab the column values up to
			 * column N-2 now
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>firstpass</name> <operator>||</operator> <operator>!</operator><call><name>xstreq</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * a new row means we need to flush the old one first, unless
				 * we're on the very first row
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstpass</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* rowid changed, flush the previous output row */</comment>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>result_ncols</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ncols</name> <operator>-</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

				<comment type="block">/* we're no longer on the first pass */</comment>
				<expr_stmt><expr><name>firstpass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* look up the category and fill in the appropriate column */</comment>
			<expr_stmt><expr><name>catname</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><name>ncols</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>catname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>crosstab_HashTableLookup</name><argument_list>(<argument><expr><name>crosstab_hash</name></expr></argument>, <argument><expr><name>catname</name></expr></argument>, <argument><expr><name>catdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>catdesc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name><name>catdesc</name><operator>-&gt;</operator><name>attidx</name></name> <operator>+</operator> <name>ncols</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator>
						<call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xpstrdup</name><argument_list>(<argument><expr><name>lastrowid</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* flush the last output row */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_crosstab_tuplestore: SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tupstore</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * connectby_text - produce a result set from a hierarchical (parent/child)
 * table.
 *
 * e.g. given table foo:
 *
 *			keyid	parent_keyid pos
 *			------+------------+--
 *			row1	NULL		 0
 *			row2	row1		 0
 *			row3	row1		 0
 *			row4	row2		 1
 *			row5	row2		 0
 *			row6	row4		 0
 *			row7	row3		 0
 *			row8	row6		 0
 *			row9	row5		 0
 *
 *
 * connectby(text relname, text keyid_fld, text parent_keyid_fld
 *			  [, text orderby_fld], text start_with, int max_depth
 *			  [, text branch_delim])
 * connectby('foo', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~') returns:
 *
 *		keyid	parent_id	level	 branch				serial
 *		------+-----------+--------+-----------------------
 *		row2	NULL		  0		  row2				  1
 *		row5	row2		  1		  row2~row5			  2
 *		row9	row5		  2		  row2~row5~row9	  3
 *		row4	row2		  1		  row2~row4			  4
 *		row6	row4		  2		  row2~row4~row6	  5
 *		row8	row6		  3		  row2~row4~row6~row8 6
 *
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>connectby_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECTBY_NCOLS</name></cpp:macro>					<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECTBY_NCOLS_NOBRANCH</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>connectby_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key_fld</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parent_key_fld</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_with</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_depth</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>branch_delim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_branch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_serial</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>||</operator>
		<name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>branch_delim</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>show_branch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* default is no show, tilde for the delimiter */</comment>
		<expr_stmt><expr><name>branch_delim</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the requested return tuple description */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* does it meet our needs */</comment>
	<expr_stmt><expr><call><name>validateConnectbyTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>show_branch</name></expr></argument>, <argument><expr><name>show_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, use it then */</comment>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, go to work */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <call><name>connectby</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
								  <argument><expr><name>key_fld</name></expr></argument>,
								  <argument><expr><name>parent_key_fld</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>branch_delim</name></expr></argument>,
								  <argument><expr><name>start_with</name></expr></argument>,
								  <argument><expr><name>max_depth</name></expr></argument>,
								  <argument><expr><name>show_branch</name></expr></argument>,
								  <argument><expr><name>show_serial</name></expr></argument>,
								  <argument><expr><name>per_query_ctx</name></expr></argument>,
								  <argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
								  <argument><expr><name>attinmeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SFRM_Materialize mode expects us to return a NULL Datum. The actual
	 * tuples are in our tuplestore and passed back through rsinfo-&gt;setResult.
	 * rsinfo-&gt;setDesc is set to the tuple description that we actually used
	 * to build our tuples with, so the caller can verify we did what it was
	 * expecting.
	 */</comment>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>connectby_text_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>connectby_text_serial</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key_fld</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parent_key_fld</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>orderby_fld</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_with</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_depth</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>branch_delim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_branch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_serial</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>||</operator>
		<name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>branch_delim</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>show_branch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* default is no show, tilde for the delimiter */</comment>
		<expr_stmt><expr><name>branch_delim</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the requested return tuple description */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* does it meet our needs */</comment>
	<expr_stmt><expr><call><name>validateConnectbyTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>show_branch</name></expr></argument>, <argument><expr><name>show_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, use it then */</comment>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, go to work */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <call><name>connectby</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
								  <argument><expr><name>key_fld</name></expr></argument>,
								  <argument><expr><name>parent_key_fld</name></expr></argument>,
								  <argument><expr><name>orderby_fld</name></expr></argument>,
								  <argument><expr><name>branch_delim</name></expr></argument>,
								  <argument><expr><name>start_with</name></expr></argument>,
								  <argument><expr><name>max_depth</name></expr></argument>,
								  <argument><expr><name>show_branch</name></expr></argument>,
								  <argument><expr><name>show_serial</name></expr></argument>,
								  <argument><expr><name>per_query_ctx</name></expr></argument>,
								  <argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
								  <argument><expr><name>attinmeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SFRM_Materialize mode expects us to return a NULL Datum. The actual
	 * tuples are in our tuplestore and passed back through rsinfo-&gt;setResult.
	 * rsinfo-&gt;setDesc is set to the tuple description that we actually used
	 * to build our tuples with, so the caller can verify we did what it was
	 * expecting.
	 */</comment>
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * connectby - does the real work for connectby_text()
 */</comment>
<function><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>connectby</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parent_key_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>orderby_fld</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch_delim</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_with</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>max_depth</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>,
		  <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>,
		  <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>serial</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"connectby: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* switch to longer term context to create the tuple store */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize our tuplestore */</comment>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now go get the whole tree */</comment>
	<expr_stmt><expr><call><name>build_tuplestore_recursively</name><argument_list>(<argument><expr><name>key_fld</name></expr></argument>,
								 <argument><expr><name>parent_key_fld</name></expr></argument>,
								 <argument><expr><name>relname</name></expr></argument>,
								 <argument><expr><name>orderby_fld</name></expr></argument>,
								 <argument><expr><name>branch_delim</name></expr></argument>,
								 <argument><expr><name>start_with</name></expr></argument>,
								 <argument><expr><name>start_with</name></expr></argument>,	<comment type="block">/* current_branch */</comment>
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* initial level is 0 */</comment>
								 <argument><expr><operator>&amp;</operator><name>serial</name></expr></argument>,	<comment type="block">/* initial serial is 1 */</comment>
								 <argument><expr><name>max_depth</name></expr></argument>,
								 <argument><expr><name>show_branch</name></expr></argument>,
								 <argument><expr><name>show_serial</name></expr></argument>,
								 <argument><expr><name>per_query_ctx</name></expr></argument>,
								 <argument><expr><name>attinmeta</name></expr></argument>,
								 <argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tupstore</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_tuplestore_recursively</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parent_key_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>orderby_fld</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch_delim</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_with</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>branch</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>serial</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>max_depth</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>,
							 <parameter><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl></parameter>,
							 <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>,
							 <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serial_column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>current_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>current_key_parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>current_level</name><index>[<expr><name>INT32_STRLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>serial_str</name><index>[<expr><name>INT32_STRLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>current_branch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>level</name> <operator>&gt;</operator> <name>max_depth</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build initial sql statement */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_serial</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT %s, %s FROM %s WHERE %s = %s AND %s IS NOT NULL AND %s &lt;&gt; %s"</literal></expr></argument>,
						 <argument><expr><name>key_fld</name></expr></argument>,
						 <argument><expr><name>parent_key_fld</name></expr></argument>,
						 <argument><expr><name>relname</name></expr></argument>,
						 <argument><expr><name>parent_key_fld</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>start_with</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>key_fld</name></expr></argument>, <argument><expr><name>key_fld</name></expr></argument>, <argument><expr><name>parent_key_fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>serial_column</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT %s, %s FROM %s WHERE %s = %s AND %s IS NOT NULL AND %s &lt;&gt; %s ORDER BY %s"</literal></expr></argument>,
						 <argument><expr><name>key_fld</name></expr></argument>,
						 <argument><expr><name>parent_key_fld</name></expr></argument>,
						 <argument><expr><name>relname</name></expr></argument>,
						 <argument><expr><name>parent_key_fld</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>start_with</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>key_fld</name></expr></argument>, <argument><expr><name>key_fld</name></expr></argument>, <argument><expr><name>parent_key_fld</name></expr></argument>,
						 <argument><expr><name>orderby_fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>serial_column</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>CONNECTBY_NCOLS</name> <operator>+</operator> <name>serial_column</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>CONNECTBY_NCOLS_NOBRANCH</name> <operator>+</operator> <name>serial_column</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* First time through, do a little setup */</comment>
	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* root value is the one we initially start with */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>start_with</name></expr>;</expr_stmt>

		<comment type="block">/* root value has no parent */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* root level is 0 */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>current_level</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>current_level</name></expr>;</expr_stmt>

		<comment type="block">/* root branch is just starting root value */</comment>
		<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>start_with</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* root starts the serial with 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>show_serial</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>serial_str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>serial</name><operator>)</operator><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>serial_str</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>serial_str</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* construct the tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now store it */</comment>
		<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* increment level */</comment>
		<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Retrieve the desired rows */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<comment type="block">/* Check for qualifying tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>proc</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>spi_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name> <init>= <expr><name>SPI_tuptable</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>spi_tupdesc</name> <init>= <expr><name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>branchstr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>chk_branchstr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>chk_current_key</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check that return tupdesc is compatible with the one we got from
		 * the query.
		 */</comment>
		<expr_stmt><expr><call><name>compatConnectbyTupleDescs</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branchstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_branchstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_current_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>proc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* initialize branch for this pass */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branchstr</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_branchstr</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>branch_delim</name></expr></argument>, <argument><expr><name>branch</name></expr></argument>, <argument><expr><name>branch_delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* get the next sql result tuple */</comment>
			<expr_stmt><expr><name>spi_tuple</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* get the current key (might be NULL) */</comment>
			<expr_stmt><expr><name>current_key</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* get the parent key (might be NULL) */</comment>
			<expr_stmt><expr><name>current_key_parent</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>spi_tuple</name></expr></argument>, <argument><expr><name>spi_tupdesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* get the current level */</comment>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>current_level</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check to see if this key is also an ancestor */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_key</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_current_key</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>,
								 <argument><expr><name>branch_delim</name></expr></argument>, <argument><expr><name>current_key</name></expr></argument>, <argument><expr><name>branch_delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>chk_branchstr</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>chk_current_key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_RECURSION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"infinite recursion detected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* OK, extend the branch */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_key</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branchstr</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>branch_delim</name></expr></argument>, <argument><expr><name>current_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>current_branch</name> <operator>=</operator> <name><name>branchstr</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

			<comment type="block">/* build a tuple */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>current_key</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>current_key_parent</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>current_level</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>current_branch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>show_serial</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>serial_str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>serial</name><operator>)</operator><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>serial_str</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>serial_str</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* store the tuple for later use */</comment>
			<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* recurse using current_key as the new start_with */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_key</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>build_tuplestore_recursively</name><argument_list>(<argument><expr><name>key_fld</name></expr></argument>,
											 <argument><expr><name>parent_key_fld</name></expr></argument>,
											 <argument><expr><name>relname</name></expr></argument>,
											 <argument><expr><name>orderby_fld</name></expr></argument>,
											 <argument><expr><name>branch_delim</name></expr></argument>,
											 <argument><expr><name>current_key</name></expr></argument>,
											 <argument><expr><name>current_branch</name></expr></argument>,
											 <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											 <argument><expr><name>serial</name></expr></argument>,
											 <argument><expr><name>max_depth</name></expr></argument>,
											 <argument><expr><name>show_branch</name></expr></argument>,
											 <argument><expr><name>show_serial</name></expr></argument>,
											 <argument><expr><name>per_query_ctx</name></expr></argument>,
											 <argument><expr><name>attinmeta</name></expr></argument>,
											 <argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>current_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name>current_key_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* reset branch for next pass */</comment>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>branchstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_branchstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chk_current_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name><name>branchstr</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name><name>chk_branchstr</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xpfree</name><argument_list>(<argument><expr><name><name>chk_current_key</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check expected (query runtime) tupdesc suitable for Connectby
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateConnectbyTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_branch</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_serial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>serial_column</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>show_serial</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>serial_column</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* are there the correct number of columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>show_branch</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>td</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <operator>(</operator><name>CONNECTBY_NCOLS</name> <operator>+</operator> <name>serial_column</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query-specified return tuple has "</literal> \
							   <literal type="string">"wrong number of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>td</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name>CONNECTBY_NCOLS_NOBRANCH</name> <operator>+</operator> <name>serial_column</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query-specified return tuple has "</literal> \
							   <literal type="string">"wrong number of columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* check that the types of the first two columns match */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"First two columns must be the same type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check that the type of the third column is INT4 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Third column must be type %s."</literal></expr></argument>,
						   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check that the type of the fourth column is TEXT if applicable */</comment>
	<if_stmt><if>if <condition>(<expr><name>show_branch</name> <operator>&amp;&amp;</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fourth column must be type %s."</literal></expr></argument>,
						   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check that the type of the fifth column is INT4 */</comment>
	<if_stmt><if>if <condition>(<expr><name>show_branch</name> <operator>&amp;&amp;</operator> <name>show_serial</name> <operator>&amp;&amp;</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query-specified return tuple not valid for Connectby: "</literal>
						<literal type="string">"fifth column must be type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check that the type of the fifth column is INT4 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>show_branch</name> <operator>&amp;&amp;</operator> <name>show_serial</name> <operator>&amp;&amp;</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query-specified return tuple not valid for Connectby: "</literal>
						<literal type="string">"fourth column must be type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, the tupdesc is valid for our purposes */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check if spi sql tupdesc and return tupdesc are compatible
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compatConnectbyTupleDescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>ret_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>sql_tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ret_atttypid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sql_atttypid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>ret_atttypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>sql_atttypmod</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Result must have at least 2 columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sql_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query must return at least two columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * These columns must match the result type indicated by the calling
	 * query.
	 */</comment>
	<expr_stmt><expr><name>ret_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_atttypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql_atttypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret_atttypid</name> <operator>!=</operator> <name>sql_atttypid</name> <operator>||</operator>
		<operator>(</operator><name>ret_atttypmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret_atttypmod</name> <operator>!=</operator> <name>sql_atttypmod</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SQL key field type %s does "</literal> \
						   <literal type="string">"not match return key field type %s."</literal></expr></argument>,
						   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>ret_atttypid</name></expr></argument>, <argument><expr><name>ret_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>sql_atttypid</name></expr></argument>, <argument><expr><name>sql_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ret_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret_atttypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql_atttypmod</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret_atttypid</name> <operator>!=</operator> <name>sql_atttypid</name> <operator>||</operator>
		<operator>(</operator><name>ret_atttypmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret_atttypmod</name> <operator>!=</operator> <name>sql_atttypmod</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SQL parent key field type %s does "</literal> \
						   <literal type="string">"not match return parent key field type %s."</literal></expr></argument>,
						   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>ret_atttypid</name></expr></argument>, <argument><expr><name>ret_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>sql_atttypid</name></expr></argument>, <argument><expr><name>sql_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, the two tupdescs are compatible for our purposes */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check if two tupdescs match in type of attributes
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compatCrosstabTupleDescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>ret_tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>sql_tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>ret_attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ret_atttypid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>sql_attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sql_atttypid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ret_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator>
		<name><name>sql_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check the rowid types match */</comment>
	<expr_stmt><expr><name>ret_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql_atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret_atttypid</name> <operator>!=</operator> <name>sql_atttypid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid return type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SQL rowid datatype does not match "</literal> \
						   <literal type="string">"return rowid datatype."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * - attribute [1] of the sql tuple is the category; no need to check it -
	 * attribute [2] of the sql tuple should match attributes [1] to [natts]
	 * of the return tuple
	 */</comment>
	<expr_stmt><expr><name>sql_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sql_tupdesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ret_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ret_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ret_tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ret_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>sql_attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* OK, the two tupdescs are compatible for our purposes */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
