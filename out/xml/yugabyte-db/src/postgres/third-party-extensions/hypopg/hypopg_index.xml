<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/hypopg/hypopg_index.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hypopg_index.c: Implementation of hypothetical indexes for PostgreSQL
 *
 * This file contains all the internal code related to hypothetical indexes
 * support.
 *
 * This program is open source, licensed under the PostgreSQL license.
 * For license terms, see the LICENSE file.
 *
 * Copyright (C) 2015-2022: Julien Rouhaud
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_tuple.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"include/hypopg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"include/hypopg_index.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
<comment type="block">/* this will be updated, when needed, by hypo_discover_am */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>BLOOM_AM_OID</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*--- Variables exported ---*/</comment>

<decl_stmt><decl><type><name>explain_get_index_name_hook_type</name></type> <name>prev_explain_get_index_name_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hypoIndexes</name></decl>;</decl_stmt>

<comment type="block">/*--- Functions --- */</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_drop_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_relation_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_get_indexdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_reset_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_addIndex</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hypo_can_return</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_discover_am</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_estimate_index_simple</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>,
									   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_estimate_index</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>hypo_estimate_index_colsize</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_index_pfree</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hypo_index_remove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>hypoIndex</name> <modifier>*</modifier></type><name>hypo_index_store_parsetree</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>hypoIndex</name> <modifier>*</modifier></type> <name>hypo_newIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeycolumns</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>ninccolumns</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_set_indexname</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * palloc a new hypoIndex, and give it a new OID, and some other global stuff.
 * This function also parse index storage options (if any) to check if they're
 * valid.
 */</comment>
<function><type><specifier>static</specifier> <name>hypoIndex</name> <modifier>*</modifier></type>
<name>hypo_newIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeycolumns</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ninccolumns</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must be declared "volatile", because used in a PG_CATCH() */</comment>
	<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier><specifier>volatile</specifier></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>amoptions_function</name></type> <name>amoptions</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>amoptions</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: access method \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>oid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>hypo_discover_am</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>HypoMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hypoIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypothetical index is not supported on temp table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>

	<comment type="block">/*
	 * Since 9.6, AM informations are available through an amhandler function,
	 * returning an IndexAmRoutine containing what's needed.
	 */</comment>
	<expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutine</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amhasgettuple</name></name> <operator>=</operator> <operator>(</operator><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amhasgetbitmap</name></name> <operator>=</operator> <operator>(</operator><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>amoptions</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcaninclude</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcaninclude</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Up to 9.5, all information is available in the pg_am tuple */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcanreturn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcanorderbyop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amoptionalkey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amsearcharray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amsearchnulls</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amhasgettuple</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amgettuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amhasgetbitmap</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amgetbitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcanunique</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcanmulticol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>amoptions</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amcanorder</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* palloc all arrays */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr>sizeof<operator>(</operator><name>short</name> <name>int</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>nkeycolumns</name> <operator>+</operator> <name>ninccolumns</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* only palloc sort related fields if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canreturn</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nkeycolumns</name> <operator>+</operator> <name>ninccolumns</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>hypo_getNewOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>immediate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Parse AM-specific options, convert to text array form, validate.
		 */</comment>
		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_reloptions</name><argument_list>(<argument><expr><name>amoptions</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * reject unsupported am. It could be done earlier but it's simpler
		 * (and was previously done) here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
			<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BRIN_AM_OID</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
			<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BLOOM_AM_OID</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
			<comment type="block">/*
			 * Only support hash indexes for pg10+.  In previous version they
			 * weren't crash safe, and changes in pg10+ also significantly
			 * changed the disk space allocation.
			 */</comment>
			 <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>HASH_AM_OID</name>
			 <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>LSM_AM_OID</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * do not store hypothetical indexes with access method not
			 * supported
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: access method \"%s\" is not supported"</literal></expr></argument>,
				 <argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No more elog beyond this point. */</comment>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Free what was palloc'd in HypoMemoryContext */</comment>
		<expr_stmt><expr><call><name>hypo_index_pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add an hypoIndex to hypoIndexes */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_addIndex</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>HypoMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hypoIndexes</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hypoIndexes</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove cleanly all hypothetical indexes by calling hypo_index_remove() on
 * each entry. hypo_index_remove() function pfree all allocated memory
 */</comment>
<function><type><name>void</name></type>
<name>hypo_index_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The cell is removed in hypo_index_remove(), so we can't iterate using
	 * standard foreach / lnext macros.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>hypoIndexes</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hypo_index_remove</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>hypoIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypoIndexes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hypo_reset_fake_oids</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create an hypothetical index from its CREATE INDEX parsetree.  This function
 * is where all the hypothetic index creation is done, except the index size
 * estimation.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>hypoIndex</name> <modifier>*</modifier></type>
<name>hypo_index_store_parsetree</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must be declared "volatile", because used in a PG_CATCH() */</comment>
	<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier><specifier>volatile</specifier></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>indexRelationName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeycolumns</name></decl>,
				<decl><type ref="prev"/><name>ninccolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>accessMethod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_colocated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablegroupId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>accessMethod</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>accessMethod</name></name></expr>;</expr_stmt>
	<comment type="block">/*
	 * When access method is absent (missing access_method_clause in gram.y),
	 * use LSM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>accessMethod</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accessMethod</name> <operator>=</operator> <literal type="string">"lsm"</literal></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/*
	 * This mirrors the transformation done in yugabyte db for btree and hash
	 * access methods.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><literal type="string">"btree"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accessMethod</name> <operator>=</operator> <literal type="string">"lsm"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accessMethod</name> <operator>=</operator> <literal type="string">"lsm"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * Support for hypothetical BRIN indexes is broken in some minor versions
	 * of pg10, pg11 and pg12.  For simplicity, check PG_VERSION_NUM rather
	 * than the real instance version, which should be right most of the
	 * time.  When it's not, the only effect is to have a less user-friendly
	 * error message.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100012</literal><operator>)</operator> <operator>||</operator> \
	<operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">110007</literal><operator>)</operator> <operator>||</operator> \
	<operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120002</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>get_am_oid</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BRIN_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: BRIN hypothetical indexes are only supported"</literal>
				<literal type="string">" with PostgreSQL "</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
				<literal type="string">"12.2"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
				<literal type="string">"11.7"</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<literal type="string">"10.12"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>					<comment type="block">/* pg 11 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>					<comment type="block">/* pg 12 */</comment>
				<literal type="string">" and later."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Some sanity checks */</comment>
	<switch>switch <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<comment type="block">/* this is supported */</comment>
			<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">110000</literal></expr></cpp:if>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: cannot create hypothetical index on"</literal>
				 <literal type="string">" partitioned table \"%s\""</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: \"%s\" is not a table or materialized view"</literal></expr></argument>,
				 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: \"%s\" is not a table"</literal></expr></argument>,
				 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></switch>

	<comment type="block">/* Run parse analysis ... */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nkeycolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>list_intersection</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: included columns must not intersect with key columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ninccolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ninccolumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>nkeycolumns</name> <operator>&gt;</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: cannot use more thant %d columns in an index"</literal></expr></argument>,
			 <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now create the hypothetical index entry */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hypo_newIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><name>nkeycolumns</name></expr></argument>, <argument><expr><name>ninccolumns</name></expr></argument>,
						  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ind_avg_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>amcanunique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: access method \"%s\" does not support unique indexes"</literal></expr></argument>,
							<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nkeycolumns</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>amcanmulticol</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: access method \"%s\" does not support multicolumn indexes"</literal></expr></argument>,
							<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator> <name>indexIncludingParams</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>amcaninclude</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: access method \"%s\" does not support included columns"</literal></expr></argument>,
							<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>nkeycolumns</name> <operator>+</operator> <name>ninccolumns</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>=</operator> <name>nkeycolumns</name></expr>;</expr_stmt>

		<comment type="block">/* handle predicate if present */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pred</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CheckPredicate</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pred</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>HypoMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * process attributeList
		 */</comment>
		<expr_stmt><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;indexParams</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>attribute</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Process the column-or-expression to be indexed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Simple index attribute */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* get the attribute catalog info */</comment>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: column \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* setup the attnum */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

				<comment type="block">/* setup the collation */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

				<comment type="block">/* get the atttype */</comment>
				<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*---------------------------
				 * handle index on expression
				 *
				 * Adapted from DefineIndex() and ComputeIndexAttrs()
				 *
				 * Statistics on expression index will be really wrong, since
				 * they're only computed when a real index exists (selectivity
				 * and average width).
				 */</comment>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"expr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Strip any top-level COLLATE clause.  This ensures that we
				 * treat "x COLLATE y" and "(x COLLATE y)" alike.
				 */</comment>
				<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * User wrote "(column)" or "(column COLLATE something)".
					 * Treat it like simple attribute anyway.
					 */</comment>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Generated index name will have _expr instead of attname
					 * in generated index name, and error message will also be
					 * slighty different in case on unexisting column from a
					 * simple attribute, but that's how ComputeIndexAttrs()
					 * proceed.
					 */</comment>

				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * transformExpr() should have already rejected
					 * subqueries, aggregates, and window functions, based on
					 * the EXPR_KIND_ for an index expression.
					 */</comment>

					<comment type="block">/*
					 * An expression using mutable functions is probably
					 * wrong, since if you aren't going to get the same result
					 * for the same data every time, it's not clear what the
					 * index entries mean at all.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>CheckMutability</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: functions in index expression must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* marks expression */</comment>

					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>HypoMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>ind_avg_width</name> <operator>+=</operator> <call><name>hypo_estimate_index_colsize</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Apply collation override if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator>
					<call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check we have a collation iff it's a collatable type.  The only
			 * expected failures here are (1) COLLATE applied to a
			 * noncollatable type, or (2) index expression had an unresolved
			 * collation.  But we might as well code this to be a complete
			 * consistency check.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: could not determine which collation to use for index expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: collations are not supported by type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* get the opclass */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
			<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>GetIndexOpClass</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
									  <argument><expr><name>atttype</name></expr></argument>,
									  <argument><expr><name>accessMethod</name></expr></argument>,
									  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>ResolveOpClass</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
									  <argument><expr><name>atttype</name></expr></argument>,
									  <argument><expr><name>accessMethod</name></expr></argument>,
									  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>opclass</name></expr>;</expr_stmt>
			<comment type="block">/* setup the opfamily */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* setup the sort info if am handles it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* setup NULLS LAST, NULLS FIRST cases are handled below */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<comment type="block">/* default ordering is ASC */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DESC</name><operator>)</operator></expr>;</expr_stmt>
				<comment type="block">/* default null ordering is LAST for ASC, FIRST for DESC */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>==</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DESC</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>==</operator> <name>SORTBY_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* handle index-only scan info */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90500</literal></expr></cpp:if>

			<comment type="block">/*
			 * OIS info is global for the index before 9.5, so look for the
			 * information only once in that case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * specify first column, but it doesn't matter as this will
				 * only be used with GiST am, which cannot do IOS prior pg 9.5
				 */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canreturn</name></name> <operator>=</operator> <call><name>hypo_can_return</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												   <argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* per-column IOS information */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canreturn</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>hypo_can_return</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>,
													 <argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/*
			 * We assume the index has the colocation status of the table.
			 * That is, table and index would both be colocated or,
			 * they would both be not colocated.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsYBRelationById</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_props</name> <init>= <expr><call><name>YbGetTablePropertiesById</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>is_colocated</name>    <operator>=</operator> <name><name>yb_props</name><operator>-&gt;</operator><name>is_colocated</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tablegroupId</name>    <operator>=</operator> <name><name>yb_props</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nhashcolumns</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<comment type="block">/*
			 * In Yugabyte, use HASH as the default for the first column of
			 * non-colocated tables
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name>attn</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_DEFAULT</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name>is_colocated</name> <operator>&amp;&amp;</operator> <name>tablegroupId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nhashcolumns</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attn</name> <operator>==</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We disallow indexes on system columns other than OID.  They would
		 * not necessarily get updated correctly, and they don't seem useful
		 * anyway.
		 */</comment>
		<for>for <control>(<init><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attn</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>attn</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>attn</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;</operator> <literal type="number">0</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
					<operator>&amp;&amp;</operator> <name>attno</name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: index creation on system columns is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
		<expr_stmt><expr><name>attn</name> <operator>=</operator> <name>nkeycolumns</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;indexIncludingParams</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>attribute</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Handle not supported features as in ComputeIndexAttrs() */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: including column does not support a collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: including column does not support an operator class"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: including column does not support ASC/DESC options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>!=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: including column does not support NULLS FIRST/LAST options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Process the column-or-expression to be indexed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Simple index attribute */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexRelationName</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* get the attribute catalog info */</comment>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: column \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* setup the attnum */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

				<comment type="block">/* get the atttype */</comment>
				<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: expressions are not supported in included columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>ind_avg_width</name> <operator>+=</operator> <call><name>hypo_estimate_index_colsize</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* per-column IOS information */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canreturn</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>hypo_can_return</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>,
													 <argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attn</name> <operator>==</operator> <operator>(</operator><name>nkeycolumns</name> <operator>+</operator> <name>ninccolumns</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Also check for system columns used in expressions or predicates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>indexattrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
						<expr><name>i</name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
								  <argument><expr><name>indexattrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: index creation on system columns is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check if the average size fits in a btree index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ind_avg_width</name> <operator>&gt;=</operator> <name>HYPO_BTMaxItemSize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: estimated index row size %d "</literal>
								<literal type="string">"exceeds maximum %ld"</literal></expr></argument>,
								<argument><expr><name>ind_avg_width</name></expr></argument>, <argument><expr><name>HYPO_BTMaxItemSize</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than 1/3 of a buffer page "</literal>
								 <literal type="string">"cannot be indexed.\nConsider a function index "</literal>
								 <literal type="string">" of an MD5 hash of the value, or use full text "</literal>
								 <literal type="string">"indexing\n(which is not yet supported by hypopg)."</literal></expr></argument>
								 )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<comment type="block">/* Warn about posssible error with a 80% avg size */</comment>
			<if type="elseif">else if <condition>(<expr><name>ind_avg_width</name> <operator>&gt;=</operator> <name>HYPO_BTMaxItemSize</name> <operator>*</operator> <literal type="number">.8</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: estimated index row size %d "</literal>
								<literal type="string">"is close to maximum %ld"</literal></expr></argument>,
								<argument><expr><name>ind_avg_width</name></expr></argument>, <argument><expr><name>HYPO_BTMaxItemSize</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than 1/3 of a buffer page "</literal>
								 <literal type="string">"cannot be indexed.\nConsider a function index "</literal>
								 <literal type="string">" of an MD5 hash of the value, or use full text "</literal>
								 <literal type="string">"indexing\n(which is not yet supported by hypopg)."</literal></expr></argument>
								 )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No more elog beyond this point. */</comment>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Free what was palloc'd in HypoMemoryContext */</comment>
		<expr_stmt><expr><call><name>hypo_index_pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the ordering information for the index, if any. Adapted from
	 * plancat.c - get_relation_info().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise, identify the corresponding btree opfamilies by trying to
		 * map this index's "&lt;" operators into btree.  Since "&lt;" uniquely
		 * defines the behavior of a sort order, this is a sufficient test.
		 *
		 * XXX This method is rather slow and also requires the undesirable
		 * assumption that the other index AM numbers its strategies the same
		 * as btree.  It'd be better to have a way to explicitly declare the
		 * corresponding btree opfamily for each opfamily of the other index
		 * type.  But given the lack of current or foreseeable amcanorder
		 * index types, it's not worth expending more effort on now.
		 */</comment>
		<for>for <control>(<init><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attn</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>attn</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ltopr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>btopfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>btopcintype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>btstrategy</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ltopr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>btopfamily</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>btopcintype</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>btstrategy</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>btopcintype</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<name>btstrategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Successful mapping */</comment>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>btopfamily</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Fail ... quietly treat index as unordered */</comment>
				<comment type="block">/* also pfree allocated memory */</comment>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hypo_set_indexname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>indexRelationName</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hypo_addIndex</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove an hypothetical index from the list of hypothetical indexes.
 * pfree (by calling hypo_index_pfree) all memory that has been allocated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hypo_index_remove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>indexid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hypoIndexes</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>hypoIndexes</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hypo_index_pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* pfree all allocated memory for within an hypoIndex and the entry itself. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_index_pfree</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* pfree all memory that has been allocated */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name><operator>)</operator> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>canreturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* finally pfree the entry */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*--------------------------------------------------
 * Add an hypothetical index to the list of indexes.
 * Caller should have check that the specified hypoIndex does belong to the
 * specified relation.  This function also assume that the specified entry
 * already contains every needed information, so we just basically need to copy
 * it from the hypoIndex to the new IndexOptInfo.  Every specific handling is
 * done at store time (ie.  hypo_index_store_parsetree).  The only exception is
 * the size estimation, recomputed verytime, as it needs up to date statistics.
 */</comment>
<function><type><name>void</name></type>
<name>hypo_injectHypotheticalIndex</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
							 <parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>,

	<comment type="block">/*
	 * For convenience and readability, use nkeycolumns even for pg10-
	 * version.  In this case, this var will be initialized to ncolumns
	 */</comment>
				<decl><type ref="prev"/><name>nkeycolumns</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>


	<comment type="block">/* create a node */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>

	<comment type="block">/* General stuff */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>	<comment type="block">/* same tablespace as
												 * relation, TODO */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>=</operator> <name>nkeycolumns</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>nkeycolumns</name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexcollations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name><operator>)</operator> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>canreturn</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>canreturn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>canreturn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Fetch the ordering information for the index, if any. This is handled
	 * in hypo_index_store_parsetree(). Again, adapted from plancat.c -
	 * get_relation_info()
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a btree index, we can use its opfamily OIDs directly as the
		 * sort ordering opfamily OIDs.
		 */</comment>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>opfamily</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcostestimate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>immediate</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>immediate</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90500</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>canreturn</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>canreturn</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcanorderbyop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amoptionalkey</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amsearcharray</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amsearchnulls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amhasgettuple</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amhasgettuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amhasgetbitmap</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amhasgetbitmap</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>amcanparallel</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* these has already been handled in hypo_index_store_parsetree() if any */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>predOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* will be set later in indxpath.c */</comment>

	<comment type="block">/*
	 * Build targetlist using the completed indexprs data. copied from
	 * PostgreSQL
	 */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indextlist</name></name> <operator>=</operator> <call><name>build_index_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * estimate most of the hypothyetical index stuff, more exactly: tuples,
	 * pages and tree_height (9.3+)
	 */</comment>
	<expr_stmt><expr><call><name>hypo_estimate_index</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>tree_height</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * obviously, setup this tag. However, it's only checked in
	 * selfuncs.c/get_actual_variable_range, so we still need to add
	 * hypothetical indexes *ONLY* in an explain-no-analyze command.
	 */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>hypothetical</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>nhashcolumns</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nhashcolumns</name></name></expr>;</expr_stmt>

	<comment type="block">/* add our hypothetical index in the relation's indexlist */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the stored hypothetical index for a given oid if any, NULL otherwise
 */</comment>
<function><type><name>hypoIndex</name> <modifier>*</modifier></type>
<name>hypo_get_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>indexId</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>entry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the hypothetical index name ifs indexId is ours, NULL otherwise, as
 * this is what explain_get_index_name expects to continue his job.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>hypo_explain_get_index_name_hook</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isExplain</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>index</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>hypo_get_index</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>index</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>index</name><operator>-&gt;</operator><name>indexname</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_explain_get_index_name_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>prev_explain_get_index_name_hook</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * List created hypothetical indexes
 */</comment>
<function><type><name>Datum</name></type>
<name>hypopg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>predDatum</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>HYPO_INDEX_NB_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>HYPO_INDEX_NB_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>exprsString</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int8GetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>buildint2vector</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>buildoidvector</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>buildoidvector</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* no indoption for now, TODO */</comment>

		<comment type="block">/* get each of indexprs, if any */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>entry-&gt;indexprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprsString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name><name>exprsString</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>exprsString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>exprsString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Convert the index predicate (if any) to a text datum.  Note we
		 * convert implicit-AND format to normal explicit-AND for storage.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>predString</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>predString</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>predDatum</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>HYPO_INDEX_NB_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL wrapper to create an hypothetical index with his parsetree
 */</comment>
<function><type><name>Datum</name></type>
<name>hypopg_create_index</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>HYPO_INDEX_CREATE_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>HYPO_INDEX_CREATE_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier>		<name>hypoIndex</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_IndexStmt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				 <argument><expr><literal type="string">"hypopg: SQL order #%d is not a CREATE INDEX statement"</literal></expr></argument>,
				 <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hypo_index_store_parsetree</name><argument_list>(<argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL wrapper to drop an hypothetical index.
 */</comment>
<function><type><name>Datum</name></type>
<name>hypopg_drop_index</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>hypo_index_remove</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL Wrapper around the hypothetical index size estimation
 */</comment>
<function><type><name>Datum</name></type>
<name>hypopg_relation_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>indexid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hypo_estimate_index_simple</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>pages</name> <operator>*</operator> <literal type="number">1.0L</literal> <operator>*</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse an hypoIndex, indentified by its indexid to the actual CREATE INDEX
 * command.
 *
 * Heavilty inspired on pg_get_indexdef_worker()
 */</comment>

<function><type><name>Datum</name></type>
<name>hypopg_get_indexdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>,
				<decl><type ref="prev"/><name>cpt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>indexid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>oid</name></name> <operator>!=</operator> <name>indexid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s ON %s.%s USING %s ("</literal></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>unique</name></name></expr> ?</condition><then> <expr><literal type="string">"UNIQUE INDEX"</literal></expr> </then><else>: <expr><literal type="string">"INDEX"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indcoll</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycolcollation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>keycoltypmod</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycoltype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keycoltypmod</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycolcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* expressional index */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Deparse */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Need parens if it's not a bare function call */</comment>
			<if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>indexkey</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator> <name>COERCE_EXPLICIT_CALL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycolcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cpt</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Add collation, if not default for column */</comment>
		<expr_stmt><expr><name>indcoll</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indcoll</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>indcoll</name> <operator>!=</operator> <name>keycolcollation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><operator>(</operator><name>indcoll</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Add the operator class name, if not default */</comment>
		<expr_stmt><expr><call><name>get_opclass_name</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add options if relevant */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if it supports sort ordering, report DESC and NULLS opts */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* NULLS FIRST is the default in this case */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>&gt;=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>&gt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>options</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>entry-&gt;options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s = "</literal></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fillfactor"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"pages_per_range"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">" hypopg: option %s unhandled, please report the bug"</literal></expr></argument>,
					 <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE %s"</literal></expr></argument>, <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
															   <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL wrapper to remove all declared hypothetical indexes.
 */</comment>
<function><type><name>Datum</name></type>
<name>hypopg_reset_index</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>hypo_index_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Simple function to set the indexname, dealing with max name length, and the
 * ending \0
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_set_indexname</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>oid</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* store &lt;oid&gt;, oid shouldn't be more than
								 * 9999999999 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalsize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;%d&gt;"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we'll prefix the given indexname with the oid, and reserve a final \0 */</comment>
	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* final index name must not exceed NAMEDATALEN */</comment>
	<if_stmt><if>if <condition>(<expr><name>totalsize</name> <operator>&gt;</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* eventually truncate the given indexname at NAMEDATALEN-1 if needed */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>, <argument><expr><name>totalsize</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fill the pages and tuples information for a given hypoIndex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_estimate_index_simple</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * retrieve number of tuples and pages of the related relation, adapted
	 * from plancat.c/get_relation_info().
	 */</comment>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open the hypo index' relation */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: cannot access temporary or unlogged relations during recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltablespace</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <operator>(</operator><name>Relids</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>estimate_rel_size</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close the relation and release the lock now */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hypo_estimate_index</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fill the pages and tuples information for a given hypoIndex and a given
 * RelOptInfo
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_estimate_index</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ind_avg_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usable_page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>bloat_factor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fillfactor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* for B-tree, hash, GiST and SP-Gist */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type>			<name>pages_per_range</name> <init>= <expr><name>BRIN_DEFAULT_PAGES_PER_RANGE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type>			<name>bloomLength</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int</name></type>			<name>additional_bloat</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ind_avg_width</name> <operator>+=</operator> <call><name>hypo_estimate_index_colsize</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No predicate, as much tuples as estmated on its relation */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We have a predicate. Find it's selectivity and setup the estimated
		 * number of line according to it
		 */</comment>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>selectivity</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/* create a fake minimal PlannerInfo */</comment>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>

		<comment type="block">/* only 1 table: the one related to this hypothetical index */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* don't include inherited children */</comment>
		<expr_stmt><expr><name>rtable</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>parse</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>rtable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>parse</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * allocate simple_rel_arrays and simple_rte_arrays. This function
		 * will also setup simple_rte_arrays with the previous rte.
		 */</comment>
		<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* also add our table info */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * per comment on clause_selectivity(), JOIN_INNER must be passed if
		 * the clause isn't a join clause, which is our case, and passing 0 to
		 * varRelid is appropriate for restriction clause.
		 */</comment>
		<expr_stmt><expr><name>selectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"hypopg: selectivity for index \"%s\": %lf"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>, <argument><expr><name>selectivity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>selectivity</name> <operator>*</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* handle index storage parameters */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>entry-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fillfactor"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fillfactor</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"pages_per_range"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_per_range</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bloomLength</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* -------------------------------
		 * quick estimating of index size:
		 *
		 * sizeof(PageHeader) : 24 (1 per page)
		 * sizeof(BTPageOpaqueData): 16 (1 per page)
		 * sizeof(IndexTupleData): 8 (1 per tuple, referencing heap)
		 * sizeof(ItemIdData): 4 (1 per tuple, storing the index item)
		 * default fillfactor: 90%
		 * no NULL handling
		 * fixed additional bloat: 20%
		 *
		 * I'll also need to read more carefully nbtree code to check if
		 * this is accurate enough.
		 *
		 */</comment>
		<expr_stmt><expr><name>line_size</name> <operator>=</operator> <name>ind_avg_width</name> <operator>+</operator>
			<operator>+</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name><operator>)</operator>
			<operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>usable_page_size</name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>bloat_factor</name> <operator>=</operator> <operator>(</operator><literal type="number">200.0</literal>
						<operator>-</operator> <operator>(</operator><ternary><condition><expr><name>fillfactor</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>BTREE_DEFAULT_FILLFACTOR</name></expr> </then><else>: <expr><name>fillfactor</name></expr></else></ternary><operator>)</operator>
						<operator>+</operator> <name>additional_bloat</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <name>line_size</name> <operator>*</operator> <name>bloat_factor</name> <operator>/</operator> <name>usable_page_size</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* TODO */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
	<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BRIN_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ranges</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>/</operator> <name>pages_per_range</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_minmax</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>data_size</name></decl>;</decl_stmt>

		<comment type="block">/* -------------------------------
		 * quick estimation of index size. A BRIN index contains
		 * - a root page
		 * - a range map: REVMAP_PAGE_MAXITEMS items (one per range
		 *	 block) per revmap block
		 * - regular type: sizeof(BrinTuple) per range, plus depending
		 *	 on opclass:
		 *	 - *_minmax_ops: 2 Datums (min &amp; max obviously)
		 *	 - *_inclusion_ops: 3 datumes (inclusion and 2 bool)
		 *
		 * I assume same minmax VS. inclusion opclass for all columns.
		 * BRIN access method does not bloat, don't add any additional.
		 */</comment>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">1</literal>		<comment type="block">/* root page */</comment>
			<operator>+</operator> <operator>(</operator><name>ranges</name> <operator>/</operator> <name>REVMAP_PAGE_MAXITEMS</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* revmap */</comment>

		<comment type="block">/* get the operator class name */</comment>
		<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: cache lookup failed for opclass %u"</literal></expr></argument>,
				 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>opcrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* is it a minmax or an inclusion operator class ? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strstr</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>, <argument><expr><literal type="string">"minmax_ops"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_minmax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* compute data_size according to opclass kind */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_minmax</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BrinTuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>ind_avg_width</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BrinTuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>ind_avg_width</name>
				<operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>data_size</name> <operator>=</operator> <name>data_size</name> <operator>*</operator> <name>ranges</name>
			<operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeOfPageHeaderData</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>+=</operator> <name>data_size</name></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
	<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BLOOM_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ----------------------------
		 * bloom indexes are fixed size, depending on bloomLength (default 5B),
		 * see blutils.c
		 *
		 * A bloom index contains a meta page.
		 * Each other pages contains:
		 * - page header
		 * - opaque data
		 * - lines:
		 *   - ItemPointerData (BLOOMTUPLEHDRSZ)
		 *   - SignType * bloomLength
		 *
		 */</comment>
		<expr_stmt><expr><name>usable_page_size</name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeOfPageHeaderData</name></expr></argument>)</argument_list></call>
			<operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>sizeof_BloomPageOpaqueData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>line_size</name> <operator>=</operator> <name>BLOOMTUPLEHDRSZ</name> <operator>+</operator>
			<name>sizeof_SignType</name> <operator>*</operator> <name>bloomLength</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* meta page */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>+=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <call><name>ceil</name><argument_list>(
										   <argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <name>line_size</name><operator>)</operator> <operator>/</operator> <name>usable_page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
	<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>HASH_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ----------------------------
		 * From hash AM readme (src/backend/access/hash/README):
		 *
		 *   There are four kinds of pages in a hash index: the meta page (page
		 *   zero), which contains statically allocated control information;
		 *   primary bucket pages; overflow pages; and bitmap pages, which keep
		 *   track of overflow pages that have been freed and are available for
		 *   re-use.  For addressing purposes, bitmap pages are regarded as a
		 *   subset of the overflow pages.
		 * [...]
		 *   A hash index consists of two or more "buckets", into which tuples
		 *   are placed whenever their hash key maps to the bucket number.
		 *   [...]
		 *   Each bucket in the hash index comprises one or more index pages.
		 *   The bucket's first page is permanently assigned to it when the
		 *   bucket is created.  Additional pages, called "overflow pages", are
		 *   added if the bucket receives too many tuples to fit in the primary
		 *   bucket page.
		 *
		 * Hash AM also already provides some functions to compute an initial
		 * number of buckets given the estimated number of tuples the index
		 * will contains, which is a good enough estimate for hypothetical
		 * index.
		 *
		 * The code below is simply an adaptation of original code to compute
		 * the initial number of bucket, modified to cope with hypothetical
		 * index, plus some naive estimates for the overflow and bitmap pages.
		 *
		 * For more details, refer to the original code, in:
		 *   - _hash_init()
		 *   - _hash_init_metabuffer()
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>data_width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>item_width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>ffactor</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>dnumbuckets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>num_buckets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>num_overflow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>num_bitmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>lshift</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine the target fill factor (in tuples per bucket) for this index.
	 * The idea is to make the fill factor correspond to pages about as full
	 * as the user-settable fillfactor parameter says.  We can compute it
	 * exactly since the index datatype (i.e. uint32 hash key) is fixed-width.
	 */</comment>
	<expr_stmt><expr><name>data_width</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_width</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>		<comment type="block">/* include the line pointer */</comment>
	<expr_stmt><expr><name>ffactor</name> <operator>=</operator> <call><name>HypoHashGetTargetPageUsage</name><argument_list>(<argument><expr><name>fillfactor</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>item_width</name></expr>;</expr_stmt>
	<comment type="block">/* keep to a sane range */</comment>
	<if_stmt><if>if <condition>(<expr><name>ffactor</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ffactor</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Choose the number of initial bucket pages to match the fill factor
	 * given the estimated number of tuples.  We round up the result to the
	 * total number of buckets which has to be allocated before using its
	 * hashm_spares element. However always force at least 2 bucket pages. The
	 * upper limit is determined by considerations explained in
	 * _hash_expandtable().
	 */</comment>
	<expr_stmt><expr><name>dnumbuckets</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>ffactor</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dnumbuckets</name> <operator>&lt;=</operator> <literal type="number">2.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>dnumbuckets</name> <operator>&gt;=</operator> <operator>(</operator><name>double</name><operator>)</operator> <literal type="number">0x40000000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <literal type="number">0x40000000</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <call><name>_hash_get_totalbuckets</name><argument_list>(<argument><expr><call><name>_hash_spareindex</name><argument_list>(<argument><expr><name>dnumbuckets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Naive estimate of overflow pages, knowing that a page can store ffactor
	 * tuples: we compute the number of tuples that wouldn't fit in the
	 * previously computed number of buckets, and compute the number of pages
	 * needed to store them.
	 */</comment>
	<expr_stmt><expr><name>num_overflow</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>tuples</name></name> <operator>-</operator> <operator>(</operator><name>num_buckets</name> <operator>*</operator> <name>ffactor</name><operator>)</operator><operator>)</operator> <operator>/</operator>
					   <name>ffactor</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find largest bitmap array size that will fit in page size */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
	<expr_stmt><expr><name>lshift</name> <operator>=</operator> <call><name>pg_leftmost_one_pos32</name><argument_list>(<argument><expr><call><name>HypoHashGetMaxBitmapSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<for>for <control>(<init><expr><name>lshift</name> <operator>=</operator> <call><name>_hash_log2</name><argument_list>(<argument><expr><call><name>HypoHashGetMaxBitmapSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>lshift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>lshift</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lshift</name><operator>)</operator> <operator>&lt;=</operator> <call><name>HypoHashGetMaxBitmapSize</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Naive estimate of bitmap pages, using the previously computed number of
	 * overflow pages.
	 */</comment>
	<expr_stmt><expr><name>num_bitmap</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>num_overflow</name> <operator>/</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator><name>lshift</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Simply add all computed pages, plus one extra block for the meta page */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>num_buckets</name> <operator>+</operator> <name>num_overflow</name> <operator>+</operator> <name>num_bitmap</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* pages and tree_height don't apply to LSM index. */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>LSM_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* we shouldn't raise this error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"hypopg: access method %d is not supported"</literal></expr></argument>,
			 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* make sure the index size is at least one block */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate a single index's column of an hypothetical index.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hypo_estimate_index_colsize</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/* If simple attribute, return avg width */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>col</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>get_attavgwidth</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* It's an expression */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>col</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* get the position in the expression list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>get_attavgwidth</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">2311</literal></expr>:</case>
				<comment type="block">/* md5 */</comment>
				<return>return <expr><literal type="number">32</literal></expr>;</return>
				<break>break;</break>
			<case>case <expr><literal type="number">870</literal></expr>:</case>
			<case>case <expr><literal type="number">871</literal></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* lower and upper, detect if simple attr */</comment>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><call><name>get_attavgwidth</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<comment type="block">/* default fallback estimate will be used */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">50</literal></expr>;</return>					<comment type="block">/* default fallback estimate */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * canreturn should been checked with the amcanreturn proc, but this
 * can't be done without a real Relation, so try to find it out
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hypo_can_return</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no amcanreturn entry, am does not handle IOS */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>amcanreturn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTREE_AM_OID</name></expr>:</case>
			<comment type="block">/*
			 * btree always support Index-Only scan
			 */</comment>
		<case>case <expr><name>LSM_AM_OID</name></expr>:</case>
			<comment type="block">/*
			 * lsm supports Index-Only scan.
			 * This aligns with ybcincanreturn() for non-primary index
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
			<break>break;</break>
		<case>case <expr><name>GIST_AM_OID</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * since 9.5, GiST can do IOS if the opclass define a
				 * GIST_FETCH_PROC support function.
				 */</comment>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>Int8GetDatum</name><argument_list>(<argument><expr><name>GIST_FETCH_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>SPGIST_AM_OID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>spgConfigIn</name></type> <name>in</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* support function 1 tells us if IOS is supported */</comment>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>Int8GetDatum</name><argument_list>(<argument><expr><name>SPGIST_CONFIG_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* just in case */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>funcid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_amproc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>amproc</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>in</name><operator>.</operator><name>attType</name></name> <operator>=</operator> <name>atttype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>canReturnData</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>res</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* all specific case should have been handled */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"hypopg: access method \"%s\" looks like it may"</literal>
				 <literal type="string">" support Index-Only Scan, but it's unexpected.\n"</literal>
				 <literal type="string">"Feel free to warn developper."</literal></expr></argument>,
				 <argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Given an access method name and its oid, try to find out if it's a supported
 * pluggable access method.  If so, save its oid for future use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_discover_am</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90600</literal></expr></cpp:if>
	<comment type="block">/* no (reliable) external am before 9.6 */</comment>
	<return>return;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/* don't try to handle builtin access method */</comment>
	<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>||</operator>
		<name>oid</name> <operator>==</operator> <name>GIST_AM_OID</name> <operator>||</operator>
		<name>oid</name> <operator>==</operator> <name>GIN_AM_OID</name> <operator>||</operator>
		<name>oid</name> <operator>==</operator> <name>SPGIST_AM_OID</name> <operator>||</operator>
		<name>oid</name> <operator>==</operator> <name>BRIN_AM_OID</name> <operator>||</operator>
		<name>oid</name> <operator>==</operator> <name>HASH_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Is it the bloom access method? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>amname</name></expr></argument>, <argument><expr><literal type="string">"bloom"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>BLOOM_AM_OID</name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
