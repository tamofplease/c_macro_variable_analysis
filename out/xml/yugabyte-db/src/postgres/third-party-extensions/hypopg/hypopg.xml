<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/hypopg/hypopg.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hypopg.c: Implementation of hypothetical indexes for PostgreSQL
 *
 * Some functions are imported from PostgreSQL source code, theses are present
 * in hypopg_import.* files.
 *
 * This program is open source, licensed under the PostgreSQL license.
 * For license terms, see the LICENSE file.
 *
 * Copyright (C) 2015-2022: Julien Rouhaud
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"include/hypopg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"include/hypopg_import.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"include/hypopg_index.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*--- Variables exported ---*/</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>isExplain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>hypo_is_enabled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>hypo_use_real_oids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>HypoMemoryContext</name></decl>;</decl_stmt>

<comment type="block">/*--- Private variables ---*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>last_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>min_fake_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>oid_wraparound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*--- Functions --- */</comment>

<function_decl><type><name>PGDLLEXPORT</name> <name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>PGDLLEXPORT</name> <name>Datum</name></type> <name>hypopg_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>hypopg_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>hypo_utility_hook</name><parameter_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
							  <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
							  <parameter><decl><type><name>bool</name></type> <name>readOnlyTree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
							  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							  <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
							  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90300</literal></expr></cpp:if>
							  <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><name>completionTag</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
							  <name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							  )</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_utility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_executorEnd_hook</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorEnd_hook_type</name></type> <name>prev_ExecutorEnd_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>hypo_get_min_fake_oid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hypo_get_relation_info_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>,
										<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>get_relation_info_hook_type</name></type> <name>prev_get_relation_info_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hypo_index_match_table</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hypo_query_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Install hooks */</comment>
	<expr_stmt><expr><name>prev_utility_hook</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>hypo_utility_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_ExecutorEnd_hook</name> <operator>=</operator> <name>ExecutorEnd_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> <operator>=</operator> <name>hypo_executorEnd_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_get_relation_info_hook</name> <operator>=</operator> <name>get_relation_info_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>get_relation_info_hook</name> <operator>=</operator> <name>hypo_get_relation_info_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_explain_get_index_name_hook</name> <operator>=</operator> <name>explain_get_index_name_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>explain_get_index_name_hook</name> <operator>=</operator> <name>hypo_explain_get_index_name_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>isExplain</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hypoIndexes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>HypoMemoryContext</name> <operator>=</operator> <macro><name>AllocSetContextCreate</name><argument_list>(<argument>TopMemoryContext</argument>,
											  <argument><literal type="string">"HypoPG context"</literal></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
											  <argument>ALLOCSET_DEFAULT_SIZES
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
											  ALLOCSET_DEFAULT_MINSIZE</argument>,
											  <argument>ALLOCSET_DEFAULT_INITSIZE</argument>,
											  <argument>ALLOCSET_DEFAULT_MAXSIZE</argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</argument_list></macro></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"hypopg.enabled"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Enable / Disable hypopg"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hypo_is_enabled</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"hypopg.use_real_oids"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Use real oids rather than the range &lt; 16384"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hypo_use_real_oids</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EmitWarningsOnPlaceholders</name><argument_list>(<argument><expr><literal type="string">"hypopg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*---------------------------------
 * Return a new OID for an hypothetical index.
 *
 * To avoid locking on pg_class (required to safely call GetNewOidWithIndex or
 * similar) and to be usable on a standby node, use the oids unused in the
 * FirstBootstrapObjectId / FirstNormalObjectId range rather than real oids.
 * For performance, always start with the biggest oid lesser than
 * FirstNormalObjectId.  This way the loop to find an unused oid will only
 * happens once a single backend has created more than ~2.5k hypothetical
 * indexes.
 *
 * For people needing to have thousands of hypothetical indexes at the same
 * time, we also allow to use the initial implementation that relies on real
 * oids, which comes with all the limitations mentioned above.
 */</comment>
<function><type><name>Oid</name></type>
<name>hypo_getNewOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hypo_use_real_oids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

		<comment type="block">/* Open the relation on which we want a new OID */</comment>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close the relation and release the lock now */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Open pg_class to aks a new OID */</comment>
		<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ask for a new Oid */</comment>
		<expr_stmt><expr><name>newoid</name> <operator>=</operator> <macro><name>GetNewOidWithIndex</name><argument_list>(<argument>pg_class</argument>, <argument>ClassOidIndexId</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
									<argument>ObjectIdAttributeNumber
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
									Anum_pg_class_oid</argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
									)</argument_list></macro></expr>;</expr_stmt>

		<comment type="block">/* Close pg_class and release the lock now */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * First, make sure we know what is the biggest oid smaller than
		 * FirstNormalObjectId present in pg_class.  This can never change so
		 * we cache the value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>min_fake_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_fake_oid</name> <operator>=</operator> <call><name>hypo_get_min_fake_oid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>min_fake_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure there's enough room to get one more Oid */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>hypoIndexes</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>FirstNormalObjectId</name> <operator>-</operator> <name>min_fake_oid</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypopg: not more oid available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Remove hypothetical indexes "</literal>
						<literal type="string">"or enable hypopg.use_real_oids"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<while>while<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>last_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newoid</name> <operator>=</operator> <name>last_oid</name> <operator>=</operator> <name>min_fake_oid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newoid</name> <operator>=</operator> <operator>++</operator><name>last_oid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Check if we just exceeded the fake oids range */</comment>
			<if_stmt><if>if <condition>(<expr><name>newoid</name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newoid</name> <operator>=</operator> <name>min_fake_oid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>last_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>oid_wraparound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we already used all available fake oids, we have to make sure
			 * that the oid isn't used anymore.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>oid_wraparound</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>hypo_get_index</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We can't use this oid.  Reset newoid and start again */</comment>
					<expr_stmt><expr><name>newoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reset the state of the fake oid generator. */</comment>
<function><type><name>void</name></type>
<name>hypo_reset_fake_oids</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hypoIndexes</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oid_wraparound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function setup the "isExplain" flag for next hooks.
 * If this flag is setup, we can add hypothetical indexes.
 */</comment>
<function><type><name>void</name></type>
<name>hypo_utility_hook</name><parameter_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
				  <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
				  <parameter><decl><type><name>bool</name></type> <name>readOnlyTree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
				  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				  <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
				  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90300</literal></expr></cpp:if>
				  <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><name>completionTag</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				  <name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				  )</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>isExplain</name> <operator>=</operator> <call><name>query_or_expression_tree_walker</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
												<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pstmt</name></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
												<argument><expr><name>parsetree</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
												<argument><expr><name>hypo_query_walker</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_utility_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<macro><name>prev_utility_hook</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
						  <argument>pstmt</argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						  <argument>parsetree</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						  <argument>queryString</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
						  <argument>readOnlyTree</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
						  <argument>context</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						  <argument>params</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
						  <argument>queryEnv</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90300</literal></expr></cpp:if>
						  <argument>isTopLevel</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						  <argument>dest</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
						  <argument>completionTag
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						  qc</argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						  )</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<macro><name>standard_ProcessUtility</name><argument_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
								<argument>pstmt</argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
								<argument>parsetree</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								<argument>queryString</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
								<argument>readOnlyTree</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
								<argument>context</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								<argument>params</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
								<argument>queryEnv</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">90300</literal></expr></cpp:if>
								<argument>isTopLevel</argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								<argument>dest</argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130000</literal></expr></cpp:if>
						  <argument>completionTag
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						  qc</argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						  )</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hypo_index_match_table</name><parameter_list>(<parameter><decl><type><name>hypoIndex</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Hypothetical index on the exact same relation, use it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
	<comment type="block">/*
	 * If the table is a partition, see if the hypothetical index belongs to
	 * one of the partition parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relispartition</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parents</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parents</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Detect if the current utility command is compatible with hypothetical indexes
 * i.e. an EXPLAIN, no ANALYZE
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hypo_query_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr></cpp:if>
	<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>utilityStmt</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((ExplainStmt *) parsetree)-&gt;options</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<return>return <expr><name>true</name></expr>;</return>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Reset the isExplain flag after each query */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_executorEnd_hook</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>isExplain</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorEnd_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorEnd_hook</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the minmum usable oid in the FirstBootstrapObjectId -
 * FirstNormalObjectId range.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>hypo_get_min_fake_oid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>, <decl><type ref="prev"/><name>nb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Connect to SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI connect failure - returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><literal type="string">"SELECT max(oid)"</literal>
			<literal type="string">" FROM pg_catalog.pg_class"</literal>
			<literal type="string">" WHERE oid &lt; "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>FirstNormalObjectId</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nb</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>SPI_OK_SELECT</name> <operator>||</operator> <name>nb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypopg: could not find the minimum fake oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>SPI_getvalue</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				 <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
				 <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* release SPI related resources (and return to caller's context) */</comment>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function will execute the "hypo_injectHypotheticalIndex" for every
 * hypothetical index found for each relation if the isExplain flag is setup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypo_get_relation_info_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isExplain</name> <operator>&amp;&amp;</operator> <name>hypo_is_enabled</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

		<comment type="block">/* Open the current relation */</comment>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr></cpp:if>
			<operator>||</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hypoIndexes</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>hypoIndex</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>hypoIndex</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>hypo_index_match_table</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * hypothetical index found, add it to the relation's
					 * indextlist
					 */</comment>
					<expr_stmt><expr><call><name>hypo_injectHypotheticalIndex</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>,
												 <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Close the relation release the lock now */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_get_relation_info_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_get_relation_info_hook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset statistics.
 */</comment>
<function><type><name>PGDLLEXPORT</name> <name>Datum</name></type>
<name>hypopg_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>hypo_index_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
