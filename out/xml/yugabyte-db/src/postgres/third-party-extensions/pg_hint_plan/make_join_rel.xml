<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/pg_hint_plan/make_join_rel.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * make_join_rel.c
 *	  Routines copied from PostgreSQL core distribution with some
 *	  modifications.
 *
 * src/backend/optimizer/path/joinrels.c
 *
 * This file contains the following functions from corresponding files.
 *
 *	static functions:
 *     make_join_rel()
 *     populate_joinrel_with_paths()
 *
 * Portions Copyright (c) 2013-2020, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * adjust_rows: tweak estimated row numbers according to the hint.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>adjust_rows</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>==</operator> <name>RVT_ABSOLUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>==</operator> <name>RVT_ADD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rows</name> <operator>+</operator> <name><name>hint</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>==</operator> <name>RVT_SUB</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator>  <name>rows</name> <operator>-</operator> <name><name>hint</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>==</operator> <name>RVT_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rows</name> <operator>*</operator> <name><name>hint</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* unrecognized rows value type */</comment>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Force estimate to be at least one row, to avoid possible divide-by-zero when interpolating costs : %s"</literal></expr></argument>,
					<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"adjusted rows %d to %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>rows</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_join_rel
 *	   Find or create a join RelOptInfo that represents the join of
 *	   the two given rels, and add to it path information for paths
 *	   created with the two rels as outer and inner rel.
 *	   (The join rel may already contain paths generated from other
 *	   pairs of rels that add up to the same set of base rels.)
 *
 * NB: will return NULL if attempted join is not valid.  This can happen
 * when working with outer joins, or with IN or EXISTS clauses that have been
 * turned into joins.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reversed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name></type> <name>sjinfo_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictlist</name></decl>;</decl_stmt>

	<comment type="block">/* We should never try to join two overlapping sets of rels. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct Relids set that identifies the joinrel. */</comment>
	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check validity and determine join type. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_is_legal</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>sjinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reversed</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* invalid join path */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Swap rels if needed to match the join info. */</comment>
	<if_stmt><if>if <condition>(<expr><name>reversed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>trel</name> <init>= <expr><name>rel1</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel1</name> <operator>=</operator> <name>rel2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel2</name> <operator>=</operator> <name>trel</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a plain inner join, then we won't have found anything in
	 * join_info_list.  Make up a SpecialJoinInfo so that selectivity
	 * estimation functions will know what's being joined.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sjinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sjinfo</name> <operator>=</operator> <operator>&amp;</operator><name>sjinfo_data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_SpecialJoinInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name> <operator>=</operator> <name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name> <operator>=</operator> <name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
		<comment type="block">/* we don't bother trying to make the remaining fields valid */</comment>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>lhs_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find or build the join RelOptInfo, and compute the restrictlist that
	 * goes with this particular joining.
	 */</comment>
	<expr_stmt><expr><name>joinrel</name> <operator>=</operator> <call><name>build_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* !!! START: HERE IS THE PART WHICH ADDED FOR PG_HINT_PLAN !!! */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowsHint</name>   <modifier>*</modifier></type><name>rows_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RowsHint</name>   <modifier>*</modifier></type><name>justforme</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RowsHint</name>   <modifier>*</modifier></type><name>domultiply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Search for applicable rows hint for this join node */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_ROWS</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>rows_hint</name> <operator>=</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>rows_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Skip this rows_hint if it is invalid from the first or it
			 * doesn't target any join rels.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rows_hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>||</operator>
				<name><name>rows_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>rows_hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This joinrel is just the target of this rows_hint, so tweak
				 * rows estimation according to the hint.
				 */</comment>
				<expr_stmt><expr><name>justforme</name> <operator>=</operator> <name>rows_hint</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rows_hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rows_hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rows_hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <name><name>rows_hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>==</operator> <name>RVT_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the rows_hint's target relids is not a subset of both of
				 * component rels and is a subset of this joinrel, ths hint's
				 * targets spread over both component rels. This means that
				 * this hint has been never applied so far and this joinrel is
				 * the first (and only) chance to fire in current join tree.
				 * Only the multiplication hint has the cumulative nature so we
				 * apply only RVT_MULTI in this way.
				 */</comment>
				<expr_stmt><expr><name>domultiply</name> <operator>=</operator> <name>rows_hint</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>justforme</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a hint just for me is found, no other adjust method is
			 * useless, but this cannot be more than twice becuase this joinrel
			 * is already adjusted by this hint.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>justforme</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_NOTUSED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>adjust_rows</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name>justforme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>domultiply</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we have multiple routes up to this joinrel which are not
				 * applicable this hint, this multiply hint will applied more
				 * than twice. But there's no means to know of that,
				 * re-estimate the row number of this joinrel always just
				 * before applying the hint. This is a bit different from
				 * normal planner behavior but it doesn't harm so much.
				 */</comment>
				<expr_stmt><expr><call><name>set_joinrel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
										   <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>adjust_rows</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name>domultiply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<comment type="block">/* !!! END: HERE IS THE PART WHICH ADDED FOR PG_HINT_PLAN !!! */</comment>

	<comment type="block">/*
	 * If we've already proven this join is empty, we needn't consider any
	 * more paths for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>joinrel</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add paths to the join relation. */</comment>
	<expr_stmt><expr><call><name>populate_joinrel_with_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								<argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>joinrel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * populate_joinrel_with_paths
 *	  Add paths to the given joinrel for given pair of joining relations. The
 *	  SpecialJoinInfo provides details about the join and the restrictlist
 *	  contains the join clauses and the other clauses applicable for given pair
 *	  of the joining relations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_joinrel_with_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Consider paths using each rel as both outer and inner.  Depending on
	 * the join type, a provably empty outer or inner rel might mean the join
	 * is provably empty too; in which case throw away any previously computed
	 * paths and mark the join as dummy.  (We do it this way since it's
	 * conceivable that dummy-ness of a multi-element join might only be
	 * noticeable for certain construction paths.)
	 *
	 * Also, a provably constant-false join restriction typically means that
	 * we can skip evaluating one or both sides of the join.  We do this by
	 * marking the appropriate rel as dummy.  For outer joins, a
	 * constant-false restriction that is pushed down still means the whole
	 * join is dummy, while a non-pushed-down one means that no inner rows
	 * will join so we can treat the inner rel as dummy.
	 *
	 * We need only consider the jointypes that appear in join_info_list, plus
	 * JOIN_INNER.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_LEFT</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_RIGHT</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_FULL</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
								 <argument><expr><name>JOIN_FULL</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there are join quals that aren't mergeable or hashable, we
			 * may not be able to build any valid plan.  Complain here so that
			 * we can give a somewhat-useful error message.  (Since we have no
			 * flexibility of planning for a full join, there's no chance of
			 * succeeding later with another pair of input rels.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FULL JOIN is only supported with merge-joinable or hash-joinable join conditions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>

			<comment type="block">/*
			 * We might have a normal semijoin, or a case where we don't have
			 * enough rels to do the semijoin but can unique-ify the RHS and
			 * then do an innerjoin (see comments in join_is_legal).  In the
			 * latter case we can't apply JOIN_SEMI joining.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
									 <argument><expr><name>JOIN_SEMI</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we know how to unique-ify the RHS and one input rel is
			 * exactly the RHS (not a superset) we can consider unique-ifying
			 * it and then doing a regular join.  (The create_unique_path
			 * check here is probably redundant with what join_is_legal did,
			 * but if so the check is cheap because it's cached.  So test
			 * anyway to be sure.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>,
								   <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
									 <argument><expr><name>JOIN_UNIQUE_INNER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>,
									 <argument><expr><name>JOIN_UNIQUE_OUTER</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
									 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>restriction_is_constant_false</name><argument_list>(<argument><expr><name>restrictlist</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mark_dummy_rel</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>,
								 <argument><expr><name>JOIN_ANTI</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
								 <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Apply partitionwise join technique, if possible. */</comment>
	<expr_stmt><expr><call><name>try_partitionwise_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
