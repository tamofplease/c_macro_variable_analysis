<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/pg_hint_plan/pg_hint_plan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_hint_plan.c
 *		  hinting on how to execute a query for PostgreSQL
 *
 * Copyright (c) 2012-2020, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/params.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/geqo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joininfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpgsql.h"</cpp:file></cpp:include>

<comment type="block">/* partially copied from pg_stat_statements */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"normalize_query.h"</cpp:file></cpp:include>

<comment type="block">/* PostgreSQL */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_MODULE_MAGIC</name></cpp:ifdef>
<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_COMMENT_START</name></cpp:macro>		<cpp:value>"/*"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_COMMENT_END</name></cpp:macro>		<cpp:value>"*/"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_COMMENT_KEYWORD</name></cpp:macro>	<cpp:value>"+"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_START</name></cpp:macro>				<cpp:value>BLOCK_COMMENT_START HINT_COMMENT_KEYWORD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_END</name></cpp:macro>				<cpp:value>BLOCK_COMMENT_END</cpp:value></cpp:define>

<comment type="block">/* hint keywords */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_SEQSCAN</name></cpp:macro>			<cpp:value>"SeqScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_INDEXSCAN</name></cpp:macro>			<cpp:value>"IndexScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_INDEXSCANREGEXP</name></cpp:macro>	<cpp:value>"IndexScanRegexp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_BITMAPSCAN</name></cpp:macro>			<cpp:value>"BitmapScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_BITMAPSCANREGEXP</name></cpp:macro>	<cpp:value>"BitmapScanRegexp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_TIDSCAN</name></cpp:macro>			<cpp:value>"TidScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOSEQSCAN</name></cpp:macro>			<cpp:value>"NoSeqScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOINDEXSCAN</name></cpp:macro>		<cpp:value>"NoIndexScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOBITMAPSCAN</name></cpp:macro>		<cpp:value>"NoBitmapScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOTIDSCAN</name></cpp:macro>			<cpp:value>"NoTidScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_INDEXONLYSCAN</name></cpp:macro>		<cpp:value>"IndexOnlyScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_INDEXONLYSCANREGEXP</name></cpp:macro>	<cpp:value>"IndexOnlyScanRegexp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOINDEXONLYSCAN</name></cpp:macro>	<cpp:value>"NoIndexOnlyScan"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_PARALLEL</name></cpp:macro>			<cpp:value>"Parallel"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NESTLOOP</name></cpp:macro>			<cpp:value>"NestLoop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_MERGEJOIN</name></cpp:macro>			<cpp:value>"MergeJoin"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_HASHJOIN</name></cpp:macro>			<cpp:value>"HashJoin"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NONESTLOOP</name></cpp:macro>			<cpp:value>"NoNestLoop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOMERGEJOIN</name></cpp:macro>		<cpp:value>"NoMergeJoin"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_NOHASHJOIN</name></cpp:macro>			<cpp:value>"NoHashJoin"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_LEADING</name></cpp:macro>			<cpp:value>"Leading"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_SET</name></cpp:macro>				<cpp:value>"Set"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_ROWS</name></cpp:macro>				<cpp:value>"Rows"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINT_ARRAY_DEFAULT_INITSIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hint_ereport</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>detail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>hint_parse_ereport(str, detail)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hint_parse_ereport</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>detail</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		ereport(pg_hint_plan_parse_message_level,		\
			(errmsg("pg_hint_plan: hint syntax error at or near \"%s\"", (str)), \
			 errdetail detail)); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skip_space</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>while (isspace(*str)) \
		str++;</cpp:value></cpp:define>

<enum>enum
<block>{
	<decl><name>ENABLE_SEQSCAN</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
	<decl><name>ENABLE_INDEXSCAN</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
	<decl><name>ENABLE_BITMAPSCAN</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
	<decl><name>ENABLE_TIDSCAN</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
	<decl><name>ENABLE_INDEXONLYSCAN</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>
}</block> <decl><name>SCAN_TYPE_BITS</name></decl>;</enum>

<enum>enum
<block>{
	<decl><name>ENABLE_NESTLOOP</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
	<decl><name>ENABLE_MERGEJOIN</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
	<decl><name>ENABLE_HASHJOIN</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>
}</block> <decl><name>JOIN_TYPE_BITS</name></decl>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_ALL_SCAN</name></cpp:macro> <cpp:value>(ENABLE_SEQSCAN | ENABLE_INDEXSCAN | \
						 ENABLE_BITMAPSCAN | ENABLE_TIDSCAN | \
						 ENABLE_INDEXONLYSCAN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_ALL_JOIN</name></cpp:macro> <cpp:value>(ENABLE_NESTLOOP | ENABLE_MERGEJOIN | ENABLE_HASHJOIN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_ALL_SCAN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_ALL_JOIN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* hint keyword of enum type*/</comment>
<typedef>typedef <type><enum>enum <name>HintKeyword</name>
<block>{
	<decl><name>HINT_KEYWORD_SEQSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_INDEXSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_INDEXSCANREGEXP</name></decl>,
	<decl><name>HINT_KEYWORD_BITMAPSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_BITMAPSCANREGEXP</name></decl>,
	<decl><name>HINT_KEYWORD_TIDSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_NOSEQSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_NOINDEXSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_NOBITMAPSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_NOTIDSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_INDEXONLYSCAN</name></decl>,
	<decl><name>HINT_KEYWORD_INDEXONLYSCANREGEXP</name></decl>,
	<decl><name>HINT_KEYWORD_NOINDEXONLYSCAN</name></decl>,

	<decl><name>HINT_KEYWORD_NESTLOOP</name></decl>,
	<decl><name>HINT_KEYWORD_MERGEJOIN</name></decl>,
	<decl><name>HINT_KEYWORD_HASHJOIN</name></decl>,
	<decl><name>HINT_KEYWORD_NONESTLOOP</name></decl>,
	<decl><name>HINT_KEYWORD_NOMERGEJOIN</name></decl>,
	<decl><name>HINT_KEYWORD_NOHASHJOIN</name></decl>,

	<decl><name>HINT_KEYWORD_LEADING</name></decl>,
	<decl><name>HINT_KEYWORD_SET</name></decl>,
	<decl><name>HINT_KEYWORD_ROWS</name></decl>,
	<decl><name>HINT_KEYWORD_PARALLEL</name></decl>,

	<decl><name>HINT_KEYWORD_UNRECOGNIZED</name></decl>
}</block></enum></type> <name>HintKeyword</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCAN_HINT_ACCEPTS_INDEX_NAMES</name><parameter_list>(<parameter><type><name>kw</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(kw == HINT_KEYWORD_INDEXSCAN ||			\
	 kw == HINT_KEYWORD_INDEXSCANREGEXP ||		\
	 kw == HINT_KEYWORD_INDEXONLYSCAN ||		\
	 kw == HINT_KEYWORD_INDEXONLYSCANREGEXP ||	\
	 kw == HINT_KEYWORD_BITMAPSCAN ||				\
	 kw == HINT_KEYWORD_BITMAPSCANREGEXP)</cpp:value></cpp:define>


<typedef>typedef <type><name><name>struct</name> <name>Hint</name></name></type> <name>Hint</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>HintState</name></name></type> <name>HintState</name>;</typedef>

<typedef>typedef <function_decl><type><name>Hint</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>HintCreateFunction</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
									 <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>HintDeleteFunction</name>) <parameter_list>(<parameter><decl><type><name>Hint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>HintDescFunction</name>) <parameter_list>(<parameter><decl><type><name>Hint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>HintCmpFunction</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>HintParseFunction</name>) <parameter_list>(<parameter><decl><type><name>Hint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
										  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* hint types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_HINT_TYPE</name></cpp:macro>	<cpp:value>6</cpp:value></cpp:define>
<typedef>typedef <type><enum>enum <name>HintType</name>
<block>{
	<decl><name>HINT_TYPE_SCAN_METHOD</name></decl>,
	<decl><name>HINT_TYPE_JOIN_METHOD</name></decl>,
	<decl><name>HINT_TYPE_LEADING</name></decl>,
	<decl><name>HINT_TYPE_SET</name></decl>,
	<decl><name>HINT_TYPE_ROWS</name></decl>,
	<decl><name>HINT_TYPE_PARALLEL</name></decl>
}</block></enum></type> <name>HintType</name>;</typedef>

<typedef>typedef <type><enum>enum <name>HintTypeBitmap</name>
<block>{
	<decl><name>HINT_BM_SCAN_METHOD</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>HINT_BM_PARALLEL</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block></enum></type> <name>HintTypeBitmap</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>HintTypeName</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"scan method"</literal></expr>,
	<expr><literal type="string">"join method"</literal></expr>,
	<expr><literal type="string">"leading"</literal></expr>,
	<expr><literal type="string">"set"</literal></expr>,
	<expr><literal type="string">"rows"</literal></expr>,
	<expr><literal type="string">"parallel"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* hint status */</comment>
<typedef>typedef <type><enum>enum <name>HintStatus</name>
<block>{
	<decl><name>HINT_STATE_NOTUSED</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,		<comment type="block">/* specified relation not used in query */</comment>
	<decl><name>HINT_STATE_USED</name></decl>,			<comment type="block">/* hint is used */</comment>
	<decl><name>HINT_STATE_DUPLICATION</name></decl>,		<comment type="block">/* specified hint duplication */</comment>
	<decl><name>HINT_STATE_ERROR</name></decl>			<comment type="block">/* execute error (parse error does not include
								 * it) */</comment>
}</block></enum></type> <name>HintStatus</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hint_state_enabled</name><parameter_list>(<parameter><type><name>hint</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((hint)-&gt;base.state == HINT_STATE_NOTUSED || \
								  (hint)-&gt;base.state == HINT_STATE_USED)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>qno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>msgqno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>qnostr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>current_hint_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * However we usually take a hint stirng in post_parse_analyze_hook, we still
 * need to do so in planner_hook when client starts query execution from the
 * bind message on a prepared query. This variable prevent duplicate and
 * sometimes harmful hint string retrieval.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>current_hint_retrieved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* common data for all hints. */</comment>
<struct>struct <name>Hint</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>		   <modifier>*</modifier></type><name>hint_str</name></decl>;</decl_stmt>		<comment type="block">/* must not do pfree */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>		   <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>		<comment type="block">/* must not do pfree */</comment>
	<decl_stmt><decl><type><name>HintKeyword</name></type>			<name>hint_keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintType</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintStatus</name></type>			<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintDeleteFunction</name></type>	<name>delete_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintDescFunction</name></type>	<name>desc_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintCmpFunction</name></type>		<name>cmp_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintParseFunction</name></type>	<name>parse_func</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* scan method hints */</comment>
<typedef>typedef <type><struct>struct <name>ScanMethodHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>			<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>indexnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>regexp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>enforce_mask</name></decl>;</decl_stmt>
}</block></struct></type> <name>ScanMethodHint</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParentIndexInfo</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>indisunique</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>method</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>column_names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>expression_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>opclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indpred_str</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParentIndexInfo</name>;</typedef>

<comment type="block">/* join method hints */</comment>
<typedef>typedef <type><struct>struct <name>JoinMethodHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>			<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>inner_nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>relnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>enforce_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>inner_joinrelids</name></decl>;</decl_stmt>
}</block></struct></type> <name>JoinMethodHint</name>;</typedef>

<comment type="block">/* join order hints */</comment>
<typedef>typedef <type><struct>struct <name>OuterInnerRels</name>
<block>{
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>outer_inner_pair</name></decl>;</decl_stmt>
}</block></struct></type> <name>OuterInnerRels</name>;</typedef>

<typedef>typedef <type><struct>struct <name>LeadingHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>			<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>relations</name></decl>;</decl_stmt>	<comment type="block">/* relation names specified in Leading hint */</comment>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl>;</decl_stmt>
}</block></struct></type> <name>LeadingHint</name>;</typedef>

<comment type="block">/* change a run-time parameter hints */</comment>
<typedef>typedef <type><struct>struct <name>SetHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>	<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>				<comment type="block">/* name of variable */</comment>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>words</name></decl>;</decl_stmt>
}</block></struct></type> <name>SetHint</name>;</typedef>

<comment type="block">/* rows hints */</comment>
<typedef>typedef <type><enum>enum <name>RowsValueType</name> <block>{
	<decl><name>RVT_ABSOLUTE</name></decl>,		<comment type="block">/* Rows(... #1000) */</comment>
	<decl><name>RVT_ADD</name></decl>,			<comment type="block">/* Rows(... +1000) */</comment>
	<decl><name>RVT_SUB</name></decl>,			<comment type="block">/* Rows(... -1000) */</comment>
	<decl><name>RVT_MULTI</name></decl>,			<comment type="block">/* Rows(... *1.2) */</comment>
}</block></enum></type> <name>RowsValueType</name>;</typedef>
<typedef>typedef <type><struct>struct <name>RowsHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>			<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>inner_nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>relnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>inner_joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>rows_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowsValueType</name></type>	<name>value_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>rows</name></decl>;</decl_stmt>
}</block></struct></type> <name>RowsHint</name>;</typedef>

<comment type="block">/* parallel hints */</comment>
<typedef>typedef <type><struct>struct <name>ParallelHint</name>
<block>{
	<decl_stmt><decl><type><name>Hint</name></type>			<name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>nworkers_str</name></decl>;</decl_stmt>	<comment type="block">/* original string of nworkers */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>nworkers</name></decl>;</decl_stmt>		<comment type="block">/* num of workers specified by Worker */</comment>
	<decl_stmt><decl><type><name>bool</name></type>			<name>force_parallel</name></decl>;</decl_stmt>	<comment type="block">/* force parallel scan */</comment>
}</block></struct></type> <name>ParallelHint</name>;</typedef>

<comment type="block">/*
 * Describes a context of hint processing.
 */</comment>
<struct>struct <name>HintState</name>
<block>{
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>hint_str</name></decl>;</decl_stmt>			<comment type="block">/* original hint string */</comment>

	<comment type="block">/* all hint */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>nall_hints</name></decl>;</decl_stmt>			<comment type="block">/* # of valid all hints */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>max_all_hints</name></decl>;</decl_stmt>		<comment type="block">/* # of slots for all hints */</comment>
	<decl_stmt><decl><type><name>Hint</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>all_hints</name></decl>;</decl_stmt>			<comment type="block">/* parsed all hints */</comment>

	<comment type="block">/* # of each hints */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name><name>num_hints</name><index>[<expr><name>NUM_HINT_TYPE</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* for scan method hints */</comment>
	<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>scan_hints</name></decl>;</decl_stmt>		<comment type="block">/* parsed scan hints */</comment>

	<comment type="block">/* Initial values of parameters  */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>init_scan_mask</name></decl>;</decl_stmt>		<comment type="block">/* enable_* mask */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>init_nworkers</name></decl>;</decl_stmt>		<comment type="block">/* max_parallel_workers_per_gather */</comment>
	<comment type="block">/* min_parallel_table_scan_size*/</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>init_min_para_tablescan_size</name></decl>;</decl_stmt>
	<comment type="block">/* min_parallel_index_scan_size*/</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>init_min_para_indexscan_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>init_paratup_cost</name></decl>;</decl_stmt>	<comment type="block">/* parallel_tuple_cost */</comment>
	<decl_stmt><decl><type><name>double</name></type>			<name>init_parasetup_cost</name></decl>;</decl_stmt><comment type="block">/* parallel_setup_cost */</comment>

	<decl_stmt><decl><type><name>PlannerInfo</name>	   <modifier>*</modifier></type><name>current_root</name></decl>;</decl_stmt>		<comment type="block">/* PlannerInfo for the followings */</comment>
	<decl_stmt><decl><type><name>Index</name></type>			<name>parent_relid</name></decl>;</decl_stmt>		<comment type="block">/* inherit parent of table relid */</comment>
	<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>parent_scan_hint</name></decl>;</decl_stmt>	<comment type="block">/* scan hint for the parent */</comment>
	<decl_stmt><decl><type><name>ParallelHint</name>   <modifier>*</modifier></type><name>parent_parallel_hint</name></decl>;</decl_stmt> <comment type="block">/* parallel hint for the parent */</comment>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>parent_index_infos</name></decl>;</decl_stmt> <comment type="block">/* list of parent table's index */</comment>

	<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>join_hints</name></decl>;</decl_stmt>		<comment type="block">/* parsed join hints */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>init_join_mask</name></decl>;</decl_stmt>		<comment type="block">/* initial value join parameter */</comment>
	<decl_stmt><decl><type><name>List</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>join_hint_level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LeadingHint</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>leading_hint</name></decl>;</decl_stmt>		<comment type="block">/* parsed Leading hints */</comment>
	<decl_stmt><decl><type><name>SetHint</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>set_hints</name></decl>;</decl_stmt>			<comment type="block">/* parsed Set hints */</comment>
	<decl_stmt><decl><type><name>GucContext</name></type>		<name>context</name></decl>;</decl_stmt>			<comment type="block">/* which GUC parameters can we set? */</comment>
	<decl_stmt><decl><type><name>RowsHint</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>rows_hints</name></decl>;</decl_stmt>			<comment type="block">/* parsed Rows hints */</comment>
	<decl_stmt><decl><type><name>ParallelHint</name>  <modifier>*</modifier><modifier>*</modifier></type><name>parallel_hints</name></decl>;</decl_stmt>		<comment type="block">/* parsed Parallel hints */</comment>
}</block>;</struct>

<comment type="block">/*
 * Describes a hint parser module which is bound with particular hint keyword.
 */</comment>
<typedef>typedef <type><struct>struct <name>HintParser</name>
<block>{
	<decl_stmt><decl><type><name>char</name>			   <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintCreateFunction</name></type>	<name>create_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintKeyword</name></type>			<name>hint_keyword</name></decl>;</decl_stmt>
}</block></struct></type> <name>HintParser</name>;</typedef>

<comment type="block">/* Module callbacks */</comment>
<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_hint</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_hint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_plan_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_plan_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type><name>pg_hint_plan_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
										 <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>pg_hint_plan_join_search</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>levels_needed</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Scan method hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>ScanMethodHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
								  <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ScanMethodHintDelete</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ScanMethodHintDesc</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ScanMethodHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ScanMethodHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScanMethodHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ScanMethodHintParse</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
									   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Join method hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>JoinMethodHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
								  <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JoinMethodHintDelete</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JoinMethodHintDesc</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>JoinMethodHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JoinMethodHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinMethodHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>JoinMethodHintParse</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
									   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Leading hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>LeadingHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
							   <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LeadingHintDelete</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LeadingHintDesc</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>LeadingHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LeadingHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LeadingHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>LeadingHintParse</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
									<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Set hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>SetHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
						   <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetHintDelete</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetHintDesc</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>SetHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SetHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SetHintParse</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Rows hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>RowsHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
							<parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RowsHintDelete</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RowsHintDesc</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>RowsHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RowsHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowsHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>RowsHintParse</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
								 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Parallel hint callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type><name>ParallelHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
								<parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelHintDelete</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelHintDesc</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ParallelHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParallelHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParallelHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ParallelHintParse</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>,
									 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>quote_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_quoted_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>word</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>truncate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>pg_hint_plan_standard_join_search</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>levels_needed</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>pg_hint_plan_join_search_one_level</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>pg_hint_plan_set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								   <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_plain_partial_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_rels_by_clause_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
									  <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_rels_by_clauseless_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>,
										  <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>other_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_join_restriction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_plain_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_append_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									<parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>pg_hint_plan_make_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>,
									   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_plan_plpgsql_stmt_beg</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
										  <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_plan_plpgsql_stmt_end</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
										  <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_query_erase_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
										 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_config_option_noerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						  <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>,
						  <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_scan_method_enforcement</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>scanhint</name></decl></parameter>,
										  <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_config_int32_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>value</name></decl></parameter>,
									<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_config_double_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>,
									<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>	<name>pg_hint_plan_enable_hint</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>debug_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_hint_plan_parse_message_level</name> <init>= <expr><name>INFO</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_hint_plan_debug_message_level</name> <init>= <expr><name>LOG</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Default is off, to keep backward compatibility. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>	<name>pg_hint_plan_enable_hint_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>plpgsql_recurse_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* PLpgSQL recursion level            */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recurse_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* recursion level incl. direct SPI calls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>hint_inhibit_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* Inhibit hinting if this is above 0 */</comment>
											<comment type="block">/* (This could not be above 1)        */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_hint_nworkers</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* Maximum nworkers of Workers hints */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>parse_messages_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<comment type="block">/*
	 * {"fatal", FATAL, true},
	 * {"panic", PANIC, true},
	 */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>parse_debug_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"detailed"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"2"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"3"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Saved hook values in case of unload */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>prev_post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>planner_hook_type</name></type> <name>prev_planner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>join_search_hook_type</name></type> <name>prev_join_search</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>set_rel_pathlist_hook_type</name></type> <name>prev_set_rel_pathlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorEnd_hook_type</name></type> <name>prev_ExecutorEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hold reference to currently active hint */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HintState</name> <modifier>*</modifier></type><name>current_hint_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of hint contexts.  We treat the head of the list as the Top of the
 * context stack, so current_hint_state always points the first element of this
 * list.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>HintStateStack</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>HintParser</name></type> <name><name>parsers</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>HINT_SEQSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_SEQSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_INDEXSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_INDEXSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_INDEXSCANREGEXP</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_INDEXSCANREGEXP</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_BITMAPSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_BITMAPSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_BITMAPSCANREGEXP</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>,
	 <expr><name>HINT_KEYWORD_BITMAPSCANREGEXP</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_TIDSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_TIDSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOSEQSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOSEQSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOINDEXSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOINDEXSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOBITMAPSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOBITMAPSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOTIDSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOTIDSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_INDEXONLYSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_INDEXONLYSCAN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_INDEXONLYSCANREGEXP</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>,
	 <expr><name>HINT_KEYWORD_INDEXONLYSCANREGEXP</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOINDEXONLYSCAN</name></expr>, <expr><name>ScanMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOINDEXONLYSCAN</name></expr>}</block></expr>,

	<expr><block>{<expr><name>HINT_NESTLOOP</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NESTLOOP</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_MERGEJOIN</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_MERGEJOIN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_HASHJOIN</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_HASHJOIN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NONESTLOOP</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NONESTLOOP</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOMERGEJOIN</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOMERGEJOIN</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_NOHASHJOIN</name></expr>, <expr><name>JoinMethodHintCreate</name></expr>, <expr><name>HINT_KEYWORD_NOHASHJOIN</name></expr>}</block></expr>,

	<expr><block>{<expr><name>HINT_LEADING</name></expr>, <expr><name>LeadingHintCreate</name></expr>, <expr><name>HINT_KEYWORD_LEADING</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_SET</name></expr>, <expr><name>SetHintCreate</name></expr>, <expr><name>HINT_KEYWORD_SET</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_ROWS</name></expr>, <expr><name>RowsHintCreate</name></expr>, <expr><name>HINT_KEYWORD_ROWS</name></expr>}</block></expr>,
	<expr><block>{<expr><name>HINT_PARALLEL</name></expr>, <expr><name>ParallelHintCreate</name></expr>, <expr><name>HINT_KEYWORD_PARALLEL</name></expr>}</block></expr>,

	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>HINT_KEYWORD_UNRECOGNIZED</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PLpgSQL_plugin</name></type>  <name>plugin_funcs</name> <init>= <expr><block>{
	<expr><name>NULL</name></expr>,
	<expr><name>NULL</name></expr>,
	<expr><name>NULL</name></expr>,
	<expr><name>pg_hint_plan_plpgsql_stmt_beg</name></expr>,
	<expr><name>pg_hint_plan_plpgsql_stmt_end</name></expr>,
	<expr><name>NULL</name></expr>,
	<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Module load callbacks
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_plugin</name>	<modifier>*</modifier><modifier>*</modifier></type><name>var_ptr</name></decl>;</decl_stmt>

	<comment type="block">/* Define custom GUC variables. */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan.enable_hint"</literal></expr></argument>,
			 <argument><expr><literal type="string">"Force planner to use plans specified in the hint comment preceding to the query."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>pg_hint_plan_enable_hint</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,
						     <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomEnumVariable</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan.debug_print"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Logs results of hint parsing."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>debug_level</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>parse_debug_level_options</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomEnumVariable</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan.parse_messages"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Message level of parse errors."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>pg_hint_plan_parse_message_level</name></expr></argument>,
							 <argument><expr><name>INFO</name></expr></argument>,
							 <argument><expr><name>parse_messages_level_options</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomEnumVariable</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan.message_level"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Message level of debug messages."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>pg_hint_plan_debug_message_level</name></expr></argument>,
							 <argument><expr><name>LOG</name></expr></argument>,
							 <argument><expr><name>parse_messages_level_options</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan.enable_hint_table"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Let pg_hint_plan look up the hint table."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>pg_hint_plan_enable_hint_table</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Install hooks. */</comment>
	<expr_stmt><expr><name>prev_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>pg_hint_plan_post_parse_analyze</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_planner</name> <operator>=</operator> <name>planner_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>pg_hint_plan_planner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_join_search</name> <operator>=</operator> <name>join_search_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>join_search_hook</name> <operator>=</operator> <name>pg_hint_plan_join_search</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_set_rel_pathlist</name> <operator>=</operator> <name>set_rel_pathlist_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_rel_pathlist_hook</name> <operator>=</operator> <name>pg_hint_plan_set_rel_pathlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ProcessUtility_hook</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>pg_hint_plan_ProcessUtility</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorEnd</name> <operator>=</operator> <name>ExecutorEnd_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> <operator>=</operator> <name>pg_hint_ExecutorEnd</name></expr>;</expr_stmt>

	<comment type="block">/* setup PL/pgSQL plugin hook */</comment>
	<expr_stmt><expr><name>var_ptr</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_plugin</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>find_rendezvous_variable</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL_plugin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>var_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>plugin_funcs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RegisterResourceReleaseCallback</name><argument_list>(<argument><expr><name>plpgsql_query_erase_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Module unload callback
 * XXX never called
 */</comment>
<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_plugin</name>	<modifier>*</modifier><modifier>*</modifier></type><name>var_ptr</name></decl>;</decl_stmt>

	<comment type="block">/* Uninstall hooks. */</comment>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>prev_post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>planner_hook</name> <operator>=</operator> <name>prev_planner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>join_search_hook</name> <operator>=</operator> <name>prev_join_search</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_rel_pathlist_hook</name> <operator>=</operator> <name>prev_set_rel_pathlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>prev_ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> <operator>=</operator> <name>prev_ExecutorEnd</name></expr>;</expr_stmt>

	<comment type="block">/* uninstall PL/pgSQL plugin hook */</comment>
	<expr_stmt><expr><name>var_ptr</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_plugin</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>find_rendezvous_variable</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL_plugin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>var_ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create and delete functions the hint object
 */</comment>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>ScanMethodHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
					 <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanMethodHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_SCAN_METHOD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator> <name>ScanMethodHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>ScanMethodHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>ScanMethodHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>ScanMethodHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>indexnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ScanMethodHintDelete</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>indexnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>JoinMethodHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
					 <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinMethodHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_JOIN_METHOD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator> <name>JoinMethodHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>JoinMethodHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>JoinMethodHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>JoinMethodHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>JoinMethodHintDelete</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>LeadingHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
				  <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LeadingHint</name>	   <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LeadingHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_LEADING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator><name>LeadingHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>LeadingHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>LeadingHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>LeadingHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LeadingHintDelete</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>SetHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
			  <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetHint</name>	   <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SetHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_SET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator> <name>SetHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>SetHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>SetHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>SetHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>words</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetHintDelete</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>words</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>words</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>RowsHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
			   <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RowsHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_ROWS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator> <name>RowsHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>RowsHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>RowsHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>RowsHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>rows_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>=</operator> <name>RVT_ABSOLUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RowsHintDelete</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hint</name> <modifier>*</modifier></type>
<name>ParallelHintCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
				  <parameter><decl><type><name>HintKeyword</name></type> <name>hint_keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelHint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name> <operator>=</operator> <name>hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name>keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name> <operator>=</operator> <name>hint_keyword</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>HINT_TYPE_PARALLEL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_NOTUSED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>delete_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDeleteFunction</name><operator>)</operator> <name>ParallelHintDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>desc_func</name></name> <operator>=</operator> <operator>(</operator><name>HintDescFunction</name><operator>)</operator> <name>ParallelHintDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cmp_func</name></name> <operator>=</operator> <operator>(</operator><name>HintCmpFunction</name><operator>)</operator> <name>ParallelHintCmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>parse_func</name></name> <operator>=</operator> <operator>(</operator><name>HintParseFunction</name><operator>)</operator> <name>ParallelHintParse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name> <operator>=</operator> <literal type="string">"0"</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Hint</name> <operator>*</operator><operator>)</operator> <name>hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelHintDelete</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>HintState</name> <modifier>*</modifier></type>
<name>HintStateCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HintState</name>   <modifier>*</modifier></type><name>hstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hstate</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HintState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>hint_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>scan_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_scan_mask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_nworkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_min_para_tablescan_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_min_para_indexscan_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_paratup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_parasetup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>current_root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_scan_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_parallel_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_index_infos</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>init_join_mask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>leading_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>set_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>rows_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parallel_hints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>hstate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>HintStateDelete</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hstate</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>hint_str</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>hint_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_SCAN_METHOD</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>delete_func</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_index_infos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>parent_index_infos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy given value into buf, with quoting with '"' if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>quote_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>str</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>str</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>str</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>str</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>need_quote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ScanMethodHintDesc</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>hint-&gt;indexnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>JoinMethodHintDesc</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>OuterInnerDesc</name><parameter_list>(<parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>outer_inner-&gt;outer_inner_pair</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>OuterInnerDesc</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LeadingHintDesc</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>HINT_LEADING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>hint-&gt;relations</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>OuterInnerDesc</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetHintDesc</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>HINT_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>hint-&gt;words</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RowsHintDesc</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>rows_str</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>rows_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelHintDesc</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* number of workers  */</comment>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* application mode of num of workers */</comment>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>hint</name><operator>-&gt;</operator><name>force_parallel</name></name></expr> ?</condition><then> <expr><literal type="string">"hard"</literal></expr> </then><else>: <expr><literal type="string">"soft"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append string which represents all hints in a given state to buf, with
 * preceding title with them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>desc_hint_in_state</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>,
				   <parameter><decl><type><name>HintStatus</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nolf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>, <decl><type ref="prev"/><name>nshown</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nolf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nshown</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>!=</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>desc_func</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nolf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nshown</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nolf</name> <operator>&amp;&amp;</operator> <name>nshown</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(none)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump contents of given hstate to server log with log level LOG.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HintStateDump</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hstate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>, <argument><expr><literal type="string">"pg_hint_plan:\nno hint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"pg_hint_plan:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"used hint"</literal></expr></argument>, <argument><expr><name>HINT_STATE_USED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"not used hint"</literal></expr></argument>, <argument><expr><name>HINT_STATE_NOTUSED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"duplication hint"</literal></expr></argument>, <argument><expr><name>HINT_STATE_DUPLICATION</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"error hint"</literal></expr></argument>, <argument><expr><name>HINT_STATE_ERROR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>HintStateDump2</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hstate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
			 <argument><expr><literal type="string">"pg_hint_plan%s: HintStateDump: no hint"</literal></expr></argument>, <argument><expr><name>qnostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"pg_hint_plan%s: HintStateDump: "</literal></expr></argument>, <argument><expr><name>qnostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"{used hints"</literal></expr></argument>, <argument><expr><name>HINT_STATE_USED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}, {not used hints"</literal></expr></argument>, <argument><expr><name>HINT_STATE_NOTUSED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}, {duplicate hints"</literal></expr></argument>, <argument><expr><name>HINT_STATE_DUPLICATION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>desc_hint_in_state</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}, {error hints"</literal></expr></argument>, <argument><expr><name>HINT_STATE_ERROR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * compare functions
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>RelnameCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relnamea</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relnameb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>relnamea</name></expr></argument>, <argument><expr><name>relnameb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ScanMethodHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ScanMethodHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScanMethodHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>JoinMethodHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JoinMethodHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinMethodHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nrels</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>nrels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>nrels</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>result</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LeadingHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LeadingHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LeadingHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SetHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SetHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>RowsHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RowsHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowsHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nrels</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>nrels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>nrels</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>result</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParallelHintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParallelHint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParallelHint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>HintCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>hinta</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>hintb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hinta</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>hintb</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>hinta</name><operator>-&gt;</operator><name>type</name></name> <operator>-</operator> <name><name>hintb</name><operator>-&gt;</operator><name>type</name></name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hinta</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hintb</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name><name>hinta</name><operator>-&gt;</operator><name>cmp_func</name></name><argument_list>(<argument><expr><name>hinta</name></expr></argument>, <argument><expr><name>hintb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns byte offset of hint b from hint a.  If hint a was specified before
 * b, positive value is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>HintCmpWithPos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>hinta</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Hint</name> <modifier>*</modifier></type><name>hintb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HintCmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>hinta</name><operator>-&gt;</operator><name>hint_str</name></name> <operator>-</operator> <name><name>hintb</name><operator>-&gt;</operator><name>hint_str</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse functions
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_keyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_parenthesis</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>parenthesis</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <name>parenthesis</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>parenthesis</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Opening parenthesis is necessary."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>parenthesis</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Closing parenthesis is necessary."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a token from str, and store malloc'd copy into word.  A token can be
 * quoted with '"'.  Return value is pointer to unparsed portion of original
 * string, or NULL if an error occurred.
 *
 * Parsed token is truncated within NAMEDATALEN-1 bytes, when truncate is true.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_quoted_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>truncate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>in_quote</name></decl>;</decl_stmt>

	<comment type="block">/* Skip leading spaces. */</comment>
	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>in_quote</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Double quotation must be closed. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Unterminated quoted string."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Skip escaped double quotation.
			 *
			 * We don't allow slash-asterisk and asterisk-slash (delimiters of
			 * block comments) to be an object name, so users must specify
			 * alias for such object names.
			 *
			 * Those special names can be allowed if we care escaped slashes
			 * and asterisks, but we don't.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator>
				 <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Zero-length delimited string."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Truncate name if it's too long */</comment>
	<if_stmt><if>if <condition>(<expr><name>truncate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>truncate_identifier</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>word</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OuterInnerRels</name> <modifier>*</modifier></type>
<name>OuterInnerRelsCreate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_inner_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>outer_inner</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OuterInnerRels</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>outer_inner_pair</name></name> <operator>=</operator> <name>outer_inner_list</name></expr>;</expr_stmt>

	<return>return <expr><name>outer_inner</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_parentheses_Leading_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_inner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>outer_inner_pair</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store words in parentheses into outer_inner_list. */</comment>
	<while>while<condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner_rels</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>parse_parentheses_Leading_in</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_inner_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_quoted_value</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>outer_inner_rels</name> <operator>=</operator> <call><name>OuterInnerRelsCreate</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>outer_inner_pair</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>outer_inner_pair</name></expr></argument>, <argument><expr><name>outer_inner_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>outer_inner_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>outer_inner</name> <operator>=</operator> <call><name>OuterInnerRelsCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>outer_inner_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_parentheses_Leading</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_list</name></decl></parameter>,
	<parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_inner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>truncate</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator><literal type="char">'('</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses_Leading_in</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>outer_inner</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Store words in parentheses into name_list. */</comment>
		<while>while<condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_quoted_value</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>truncate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>*</operator><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>name_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>name_list</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_parentheses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_list</name></decl></parameter>, <parameter><decl><type><name>HintKeyword</name></type> <name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>truncate</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store words in parentheses into name_list. */</comment>
	<while>while<condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_quoted_value</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>truncate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>*</operator><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>name_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>name_list</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>keyword</name> <operator>==</operator> <name>HINT_KEYWORD_INDEXSCANREGEXP</name> <operator>||</operator>
			<name>keyword</name> <operator>==</operator> <name>HINT_KEYWORD_INDEXONLYSCANREGEXP</name> <operator>||</operator>
			<name>keyword</name> <operator>==</operator> <name>HINT_KEYWORD_BITMAPSCANREGEXP</name> <operator>||</operator>
			<name>keyword</name> <operator>==</operator> <name>HINT_KEYWORD_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>truncate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>skip_parenthesis</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_hints</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>HintParser</name> <modifier>*</modifier></type><name>parser</name></decl>;</decl_stmt>

		<comment type="block">/* in error message, we output the comment including the keyword. */</comment>
		<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr>;</expr_stmt>

		<comment type="block">/* parse only the keyword of the hint. */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>parse_keyword</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>parser</name> <operator>=</operator> <name>parsers</name></expr>;</init> <condition><expr><name><name>parser</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>parser</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>keyword</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Hint</name>   <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>create_func</name></name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>hint_keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* parser of each hint does parse in a parenthesis. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name><name>hint</name><operator>-&gt;</operator><name>parse_func</name></name><argument_list>(<argument><expr><name>hint</name></expr></argument>, <argument><expr><name>hstate</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name><name>hint</name><operator>-&gt;</operator><name>delete_func</name></name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Add hint information into all_hints array.  If we don't have
			 * enough space, double the array.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name> <operator>=</operator> <name>HINT_ARRAY_DEFAULT_INITSIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name> <operator>=</operator> <operator>(</operator><name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Hint</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name> <operator>==</operator> <name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name> <operator>=</operator> <operator>(</operator><name>Hint</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Hint</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hstate</name><operator>-&gt;</operator><name>max_all_hints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name></expr>]</index></name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>keyword</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>head</name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"Unrecognized hint keyword \"%s\"."</literal><operator>,</operator> <name><name>buf</name><operator>.</operator><name>data</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* 
 * Get hints from table by client-supplied query string and application name.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_hints_from_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>client_query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>client_application</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>search_query</name> <init>=
		<expr><literal type="string">"SELECT hints "</literal>
		<literal type="string">"  FROM hint_plan.hints "</literal>
		<literal type="string">" WHERE norm_query_string = $1 "</literal>
		<literal type="string">"   AND ( application_name = $2 "</literal>
		<literal type="string">"    OR application_name = '' ) "</literal>
		<literal type="string">" ORDER BY application_name DESC"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>hints</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>		<name><name>argtypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>TEXTOID</name></expr>, <expr><name>TEXTOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>	<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> 	<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">' '</literal></expr>, <expr><literal type="char">' '</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>hint_inhibit_level</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	
		<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>p</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>search_query</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_saveplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	
		<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>client_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>app</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>client_application</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>app</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
		<expr_stmt><expr><call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
		<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	
			<expr_stmt><expr><name>hints</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * Here we use SPI_palloc to ensure that hints string is valid even
			 * after SPI_finish call.  We can't use simple palloc because it
			 * allocates memory in SPI's context and that context is deleted in
			 * SPI_finish.
			 */</comment>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>SPI_palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hints</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	
		<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>hint_inhibit_level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>hint_inhibit_level</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hints</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get client-supplied query string. Addtion to that the jumbled query is
 * supplied if the caller requested. From the restriction of JumbleQuery, some
 * kind of query needs special amendments. Reutrns NULL if this query doesn't
 * change the current hint. This function returns NULL also when something
 * wrong has happend and let the caller continue using the current hints.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_query_string</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier><modifier>*</modifier></type><name>jumblequery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>debug_query_string</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If debug_query_string is set, it is the top level statement. But in some
	 * cases we reach here with debug_query_string set NULL for example in the
	 * case of DESCRIBE message handling or EXECUTE command. We may still see a
	 * candidate top-level query in pstate in the case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't see a query string, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>jumblequery</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>jumblequery</name> <operator>=</operator> <name>query</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>target_query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Some CMD_UTILITY statements have a subquery that we can hint on.
		 * Since EXPLAIN can be placed before other kind of utility statements
		 * and EXECUTE can be contained other kind of utility statements, these
		 * conditions are not mutually exclusive and should be considered in
		 * this order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>target_query</name></expr></argument>, <argument><expr><name>ExplainStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator><name>target_query</name></expr></init></decl>;</decl_stmt>
			
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>target_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>

			<comment type="block">/* strip out the top-level query for further processing */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>target_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
				<name><name>target_query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>target_query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>target_query</name></expr></argument>, <argument><expr><name>DeclareCursorStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator><name>target_query</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* the target must be CMD_SELECT in this case */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>target_query</name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>target_query</name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateTableAsStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>target_query</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>target_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>

			<comment type="block">/* strip out the top-level query for further processing */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>target_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
				<name><name>target_query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>target_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>target_query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>target_query</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use the prepared query for EXECUTE. The Query for jumble
			 * also replaced with the corresponding one.
			 */</comment>
			<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator><name>target_query</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PreparedStatement</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>is_valid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>target_query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name> <argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* igonre the hint for EXECUTE if invalidated */</comment>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>target_query</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
			
		<comment type="block">/* JumbleQuery accespts only a non-utility Query */</comment>
		<if_stmt><if>if <condition>(<expr><name>target_query</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>target_query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>target_query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>target_query</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>jumblequery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>jumblequery</name> <operator>=</operator> <name>target_query</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * Return NULL if pstate is not of top-level query.  We don't need this
	 * when jumble info is not requested or cannot do this when pstate is NULL.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>jumblequery</name> <operator>&amp;&amp;</operator> <name>pstate</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>!=</operator> <name>p</name> <operator>&amp;&amp;</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get hints from the head block comment in client-supplied query string.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_hints_from_comment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* extract query head comment. */</comment>
	<expr_stmt><expr><name>hint_head</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HINT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hint_head</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init>;</init><condition><expr><name>p</name> <operator>&lt;</operator> <name>hint_head</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Allow these characters precedes hint comment:
		 *   - digits
		 *   - alphabets which are in ASCII range
		 *   - space, tabs and new-lines
		 *   - underscores, for identifier
		 *   - commas, for SELECT clause, EXPLAIN and PREPARE
		 *   - parentheses, for EXPLAIN and PREPARE
		 *
		 * Note that we don't use isalpha() nor isalnum() in ctype.h here to
		 * avoid behavior which depends on locale setting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator>
			<operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator>
			<operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>HINT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>skip_space</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find hint end keyword. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tail</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HINT_END</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Unterminated block comment."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't support nested block comments. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>head</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BLOCK_COMMENT_START</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>head</name> <operator>&lt;</operator> <name>tail</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Nested block comments are not supported."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make a copy of hint. */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>head</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse hints that got, create hint struct from parse tree and parse hints.
 */</comment>
<function><type><specifier>static</specifier> <name>HintState</name> <modifier>*</modifier></type>
<name>create_hintstate</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintState</name>   <modifier>*</modifier></type><name>hstate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hints</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* -1 means that no Parallel hint is specified. */</comment>
	<expr_stmt><expr><name>max_hint_nworkers</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>hints</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hstate</name> <operator>=</operator> <call><name>HintStateCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>hint_str</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>hints</name></expr>;</expr_stmt>

	<comment type="block">/* parse each hint. */</comment>
	<expr_stmt><expr><call><name>parse_hints</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* When nothing specified a hint, we free HintState and returns NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HintStateDelete</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sort hints in order of original position. */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name></expr></argument>, <argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Hint</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>HintCmpWithPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count number of hints per hint-type. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hint</name>   <modifier>*</modifier></type><name>cur_hint</name> <init>= <expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name><name>cur_hint</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If an object (or a set of objects) has multiple hints of same hint-type,
	 * only the last hint is valid and others are ignored in planning.
	 * Hints except the last are marked as 'duplicated' to remember the order.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>nall_hints</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hint</name>   <modifier>*</modifier></type><name>cur_hint</name> <init>= <expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Hint</name>   <modifier>*</modifier></type><name>next_hint</name> <init>= <expr><name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Leading hint is marked as 'duplicated' in transform_join_hints.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_hint</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>HINT_TYPE_LEADING</name> <operator>&amp;&amp;</operator>
			<name><name>next_hint</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>HINT_TYPE_LEADING</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note that we need to pass addresses of hint pointers, because
		 * HintCmp is designed to sort array of Hint* by qsort.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HintCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur_hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_hint</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>cur_hint</name><operator>-&gt;</operator><name>hint_str</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"Conflict %s hint."</literal><operator>,</operator> <name><name>HintTypeName</name><index>[<expr><name><name>cur_hint</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur_hint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_DUPLICATION</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Make sure that per-type array pointers point proper position in the
	 * array which consists of all hints.
	 */</comment>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>scan_hints</name></name> <operator>=</operator> <operator>(</operator><name>ScanMethodHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>hstate</name><operator>-&gt;</operator><name>all_hints</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hints</name></name> <operator>=</operator> <operator>(</operator><name>JoinMethodHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>hstate</name><operator>-&gt;</operator><name>scan_hints</name></name> <operator>+</operator>
		<name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_SCAN_METHOD</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>leading_hint</name></name> <operator>=</operator> <operator>(</operator><name>LeadingHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>hstate</name><operator>-&gt;</operator><name>join_hints</name></name> <operator>+</operator>
		<name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_JOIN_METHOD</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>set_hints</name></name> <operator>=</operator> <operator>(</operator><name>SetHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>hstate</name><operator>-&gt;</operator><name>leading_hint</name></name> <operator>+</operator>
		<name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_LEADING</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>rows_hints</name></name> <operator>=</operator> <operator>(</operator><name>RowsHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>hstate</name><operator>-&gt;</operator><name>set_hints</name></name> <operator>+</operator>
		<name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_SET</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>parallel_hints</name></name> <operator>=</operator> <operator>(</operator><name>ParallelHint</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>hstate</name><operator>-&gt;</operator><name>rows_hints</name></name> <operator>+</operator>
		<name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_ROWS</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>hstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse inside of parentheses of scan-method hints.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ScanMethodHintParse</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintKeyword</name></type>		<name>hint_keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>length</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><name>hint_keyword</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse relation name and index name(s) if given hint accepts. */</comment>
	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* at least twp parameters required */</comment>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires a relation."</literal><operator>,</operator>  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>indexnames</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check whether the hint accepts index name(s) */</comment>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCAN_HINT_ACCEPTS_INDEX_NAMES</name><argument_list>(<argument><expr><name>hint_keyword</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint accepts only one relation."</literal><operator>,</operator>
					  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set a bit for specified hint. */</comment>
	<switch>switch <condition>(<expr><name>hint_keyword</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HINT_KEYWORD_SEQSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_SEQSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_INDEXSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_INDEXSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_INDEXSCANREGEXP</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_INDEXSCAN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_BITMAPSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_BITMAPSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_BITMAPSCANREGEXP</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_BITMAPSCAN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_TIDSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_TIDSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOSEQSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_SCAN</name> <operator>^</operator> <name>ENABLE_SEQSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOINDEXSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_SCAN</name> <operator>^</operator> <name>ENABLE_INDEXSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOBITMAPSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_SCAN</name> <operator>^</operator> <name>ENABLE_BITMAPSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOTIDSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_SCAN</name> <operator>^</operator> <name>ENABLE_TIDSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_INDEXONLYSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_INDEXSCAN</name> <operator>|</operator> <name>ENABLE_INDEXONLYSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_INDEXONLYSCANREGEXP</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_INDEXSCAN</name> <operator>|</operator> <name>ENABLE_INDEXONLYSCAN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOINDEXONLYSCAN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_SCAN</name> <operator>^</operator> <name>ENABLE_INDEXONLYSCAN</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Unrecognized hint keyword \"%s\"."</literal><operator>,</operator> <name>keyword</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>JoinMethodHintParse</name><parameter_list>(<parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintKeyword</name></type>		<name>hint_keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><name>hint_keyword</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Transform relation names from list to array to sort them with qsort
		 * after.
		 */</comment>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>name_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A join hint requires at least two relations */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires at least two relations."</literal><operator>,</operator>
					  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sort hints in alphabetical order of relation names. */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>RelnameCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>hint_keyword</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HINT_KEYWORD_NESTLOOP</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_NESTLOOP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_MERGEJOIN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_MERGEJOIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_HASHJOIN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_HASHJOIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NONESTLOOP</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_JOIN</name> <operator>^</operator> <name>ENABLE_NESTLOOP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOMERGEJOIN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_JOIN</name> <operator>^</operator> <name>ENABLE_MERGEJOIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>HINT_KEYWORD_NOHASHJOIN</name></expr>:</case>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_JOIN</name> <operator>^</operator> <name>ENABLE_HASHJOIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Unrecognized hint keyword \"%s\"."</literal><operator>,</operator> <name>keyword</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>OuterInnerPairCheck</name><parameter_list>(<parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>outer_inner</name><operator>-&gt;</operator><name>outer_inner_pair</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>outer_inner_pair</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>outer_inner-&gt;outer_inner_pair</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OuterInnerPairCheck</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>OuterInnerList</name><parameter_list>(<parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>outer_inner_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner_rels</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>outer_inner-&gt;outer_inner_pair</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>outer_inner_rels</name> <operator>=</operator> <operator>(</operator><name>OuterInnerRels</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>outer_inner_rels</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>outer_inner_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>outer_inner_list</name></expr></argument>,
									   <argument><expr><name><name>outer_inner_rels</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>outer_inner_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>outer_inner_list</name></expr></argument>,
										   <argument><expr><call><name>OuterInnerList</name><argument_list>(<argument><expr><name>outer_inner_rels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>outer_inner_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>LeadingHintParse</name><parameter_list>(<parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses_Leading</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_inner</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator>
		<name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>outer_inner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name_list</name> <operator>=</operator> <call><name>OuterInnerList</name><argument_list>(<argument><expr><name>outer_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <name>name_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>=</operator> <name>outer_inner</name></expr>;</expr_stmt>

	<comment type="block">/* A Leading hint requires at least two relations */</comment>
	<if_stmt><if>if <condition>( <expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires at least two relations."</literal><operator>,</operator>
					  <name>HINT_LEADING</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>OuterInnerPairCheck</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>outer_inner</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires two sets of relations when parentheses nests."</literal><operator>,</operator>
					  <name>HINT_LEADING</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SetHintParse</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name></expr></argument>)</argument_list></call><operator>)</operator>
		<operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>words</name></name> <operator>=</operator> <name>name_list</name></expr>;</expr_stmt>

	<comment type="block">/* We need both name and value to set GUC parameter. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires name and value of GUC parameter."</literal><operator>,</operator>
					  <name>HINT_SET</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RowsHintParse</name><parameter_list>(<parameter><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HintKeyword</name></type>		<name>hint_keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>rows_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><name>hint_keyword</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Last element must be rows specification */</comment>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint needs at least one relation followed by one correction term."</literal><operator>,</operator>
					  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>

		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	

	<comment type="block">/*
	 * Transform relation names from list to array to sort them with qsort
	 * after.
	 */</comment>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>name_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Retieve rows estimation */</comment>
	<expr_stmt><expr><name>rows_str</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>rows_str</name></name> <operator>=</operator> <name>rows_str</name></expr>;</expr_stmt>		<comment type="block">/* store as-is for error logging */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rows_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>=</operator> <name>RVT_ABSOLUTE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rows_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>=</operator> <name>RVT_ADD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rows_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>=</operator> <name>RVT_SUB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rows_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>value_type</name></name> <operator>=</operator> <name>RVT_MULTI</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>rows_str</name></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Unrecognized rows value type notation."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>rows_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end_ptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>rows_str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires valid number as rows estimation."</literal><operator>,</operator>
					  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* A join hint requires at least two relations */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"%s hint requires at least two relations."</literal><operator>,</operator>
					  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort relnames in alphabetical order. */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>RelnameCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParallelHintParse</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HintKeyword</name></type>		<name>hint_keyword</name> <init>= <expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_keyword</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>name_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>nworkers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>force_parallel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>parse_parentheses</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_list</name></expr></argument>, <argument><expr><name>hint_keyword</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Parse relation name and index name(s) if given hint accepts. */</comment>
	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>length</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><literal type="string">"wrong number of arguments (%d): %s"</literal><operator>,</operator>
					  <name>length</name><operator>,</operator>  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<comment type="block">/* The second parameter is number of workers */</comment>
	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end_ptr</name> <operator>||</operator> <name><name>nworkers</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nworkers</name></expr></argument> &gt;</argument_list></name> <name>max_worker_processes</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"number of workers must be a number: %s"</literal><operator>,</operator>
						  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>nworkers</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"number of workers must be positive: %s"</literal><operator>,</operator>
						  <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>nworkers</name> <operator>&gt;</operator> <name>max_worker_processes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers_str</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"number of workers = %d is larger than max_worker_processes(%d): %s"</literal><operator>,</operator>
						  <name>nworkers</name><operator>,</operator> <name>max_worker_processes</name><operator>,</operator> <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>

	<comment type="block">/* optional third parameter is specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modeparam</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>modeparam</name></expr></argument>, <argument><expr><literal type="string">"hard"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>force_parallel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>modeparam</name></expr></argument>, <argument><expr><literal type="string">"soft"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>modeparam</name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"enforcement must be soft or hard: %s"</literal><operator>,</operator>
							 <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>force_parallel</name></name> <operator>=</operator> <name>force_parallel</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>HINT_STATE_ERROR</name> <operator>&amp;&amp;</operator>
		<name>nworkers</name> <operator>&gt;</operator> <name>max_hint_nworkers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_hint_nworkers</name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set GUC parameter functions
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_current_scan_mask</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_seqscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_SEQSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_indexscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_INDEXSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_bitmapscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_BITMAPSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_tidscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_TIDSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_indexonlyscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_INDEXONLYSCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_current_join_mask</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_nestloop</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_NESTLOOP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_mergejoin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_MERGEJOIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>enable_hashjoin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>ENABLE_HASHJOIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mask</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets GUC prameters without throwing exception. Reutrns false if something
 * wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_config_option_noerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						  <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>,
						  <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>ccxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
								   <argument><expr><name>action</name></expr></argument>, <argument><expr><name>changeVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>	   <modifier>*</modifier></type><name>errdata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ccxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name><name>errdata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errdata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name><name>errdata</name><operator>-&gt;</operator><name>detail</name></name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errdata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name><name>errdata</name><operator>-&gt;</operator><name>hint</name></name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errdata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>errdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets GUC parameter of int32 type without throwing exceptions. Returns false
 * if something wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_config_int32_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* enough for int32 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_parse_message_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"Failed to convert integer to string: %d"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return
		<expr><call><name>set_config_option_noerror</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>PGC_S_SESSION</name></expr></argument>, <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>pg_hint_plan_parse_message_level</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets GUC parameter of double type without throwing exceptions. Returns false
 * if something wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_config_double_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	  <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>set_config_option_noerror</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									   <argument><expr><name>PGC_S_SESSION</name></expr></argument>, <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									   <argument><expr><name>pg_hint_plan_parse_message_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* setup scan method enforcement according to given options */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_guc_enforcement</name><parameter_list>(<parameter><decl><type><name>SetHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noptions</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetHint</name>	   <modifier>*</modifier></type><name>hint</name> <init>= <expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>set_config_option_noerror</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
										   <argument><expr><name>PGC_S_SESSION</name></expr></argument>, <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>pg_hint_plan_parse_message_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setup parallel execution environment.
 *
 * If hint is not NULL, set up using it, elsewise reset to initial environment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_parallel_plan_enforcement</name><parameter_list>(<parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr></argument>,
								<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>init_nworkers</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* force means that enforce parallel as far as possible */</comment>
	<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>force_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_config_double_option</name><argument_list>(<argument><expr><literal type="string">"parallel_tuple_cost"</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_double_option</name><argument_list>(<argument><expr><literal type="string">"parallel_setup_cost"</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"min_parallel_table_scan_size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"min_parallel_index_scan_size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_config_double_option</name><argument_list>(<argument><expr><literal type="string">"parallel_tuple_cost"</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>init_paratup_cost</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_double_option</name><argument_list>(<argument><expr><literal type="string">"parallel_setup_cost"</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>init_parasetup_cost</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"min_parallel_table_scan_size"</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>init_min_para_tablescan_size</name></name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"min_parallel_index_scan_size"</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>init_min_para_indexscan_size</name></name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CONFIG_OPTION</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type_bits</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>set_config_option_noerror((name), \
		(mask &amp; (type_bits)) ? "true" : "false", \
		context, PGC_S_SESSION, GUC_ACTION_SAVE, true, ERROR)</cpp:value></cpp:define>


<comment type="block">/*
 * Setup GUC environment to enforce scan methods. If scanhint is NULL, reset
 * GUCs to the saved state in state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_scan_method_enforcement</name><parameter_list>(<parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>scanhint</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>enforce_mask</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>init_scan_mask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucContext</name></type>		<name>context</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>mask</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>scanhint</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>enforce_mask</name> <operator>=</operator> <name><name>scanhint</name><operator>-&gt;</operator><name>enforce_mask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanhint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enforce_mask</name> <operator>==</operator> <name>ENABLE_SEQSCAN</name> <operator>||</operator> <name>enforce_mask</name> <operator>==</operator> <name>ENABLE_INDEXSCAN</name> <operator>||</operator>
		<name>enforce_mask</name> <operator>==</operator> <name>ENABLE_BITMAPSCAN</name> <operator>||</operator> <name>enforce_mask</name> <operator>==</operator> <name>ENABLE_TIDSCAN</name>
		<operator>||</operator> <name>enforce_mask</name> <operator>==</operator> <operator>(</operator><name>ENABLE_INDEXSCAN</name> <operator>|</operator> <name>ENABLE_INDEXONLYSCAN</name><operator>)</operator></expr>
		)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>enforce_mask</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>enforce_mask</name> <operator>&amp;</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>init_scan_mask</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_seqscan"</literal></expr></argument>, <argument><expr><name>ENABLE_SEQSCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_indexscan"</literal></expr></argument>, <argument><expr><name>ENABLE_INDEXSCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_bitmapscan"</literal></expr></argument>, <argument><expr><name>ENABLE_BITMAPSCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_tidscan"</literal></expr></argument>, <argument><expr><name>ENABLE_TIDSCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_indexonlyscan"</literal></expr></argument>, <argument><expr><name>ENABLE_INDEXONLYSCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_join_config_options</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>enforce_mask</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>	<name>mask</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enforce_mask</name> <operator>==</operator> <name>ENABLE_NESTLOOP</name> <operator>||</operator> <name>enforce_mask</name> <operator>==</operator> <name>ENABLE_MERGEJOIN</name> <operator>||</operator>
		<name>enforce_mask</name> <operator>==</operator> <name>ENABLE_HASHJOIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>enforce_mask</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>enforce_mask</name> <operator>&amp;</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>init_join_mask</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_nestloop"</literal></expr></argument>, <argument><expr><name>ENABLE_NESTLOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_mergejoin"</literal></expr></argument>, <argument><expr><name>ENABLE_MERGEJOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_CONFIG_OPTION</name><argument_list>(<argument><expr><literal type="string">"enable_hashjoin"</literal></expr></argument>, <argument><expr><name>ENABLE_HASHJOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hash join may be rejected for the reason of estimated memory usage. Try
	 * getting rid of that limitation. This change on work_mem is reverted just
	 * after searching join path so no suginificant side-effects are expected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enforce_mask</name> <operator>==</operator> <name>ENABLE_HASHJOIN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>			<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* See final_cost_hashjoin(). */</comment>
		<if_stmt><if>if <condition>(<expr><name>work_mem</name> <operator>&lt;</operator> <name>MAX_KILOBYTES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name>MAX_KILOBYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_config_option_noerror</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
									  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>, <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push a hint into hint stack which is implemented with List struct.  Head of
 * list is top of stack.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_hint</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Prepend new hint to the list means pushing to stack. */</comment>
	<expr_stmt><expr><name>HintStateStack</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>, <argument><expr><name>HintStateStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pushed hint is the one which should be used hereafter. */</comment>
	<expr_stmt><expr><name>current_hint_state</name> <operator>=</operator> <name>hstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Pop a hint from hint stack.  Popped hint is automatically discarded. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_hint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Hint stack must not be empty. */</comment>
	<if_stmt><if>if<condition>(<expr><name>HintStateStack</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hint stack is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Take a hint at the head from the list, and free it.  Switch
	 * current_hint_state to point new head (NULL if the list is empty).
	 */</comment>
	<expr_stmt><expr><name>HintStateStack</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>HintStateStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HintStateDelete</name><argument_list>(<argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>HintStateStack</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_hint_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_hint_state</name> <operator>=</operator> <operator>(</operator><name>HintState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>HintStateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve and store hint string from given query or from the hint table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_hint_string</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing under hint table search */</comment>
	<if_stmt><if>if <condition>(<expr><name>hint_inhibit_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We alredy have one, don't parse it again. */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_hint_retrieved</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't parse the current query hereafter */</comment>
	<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pg_hint_plan_enable_hint</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>current_hint_str</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_hint_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* increment the query number */</comment>
	<expr_stmt><expr><name><name>qnostr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>qnostr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>qnostr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[qno=0x%x]"</literal></expr></argument>, <argument><expr><name>qno</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>qno</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* search the hint table for a hint if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>pg_hint_plan_enable_hint_table</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>				<name>query_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgssJumbleState</name></type>	<name>jstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>		   <modifier>*</modifier></type><name>jumblequery</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>normalized_query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>query_str</name> <operator>=</operator> <call><name>get_query_string</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jumblequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this query is not for hint, just return */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>query_str</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* clear the previous hint string */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_hint_str</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_hint_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>jumblequery</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * XXX: normalization code is copied from pg_stat_statements.c.
			 * Make sure to keep up-to-date with it.
			 */</comment>
			<expr_stmt><expr><name><name>jstate</name><operator>.</operator><name>jumble</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>JUMBLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>.</operator><name>jumble_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>.</operator><name>clocations_buf_size</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>.</operator><name>clocations</name></name> <operator>=</operator> <operator>(</operator><name>pgssLocationLen</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name><name>jstate</name><operator>.</operator><name>clocations_buf_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>.</operator><name>clocations_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jstate</name></expr></argument>, <argument><expr><name>jumblequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Normalize the query string by replacing constants with '?'
			 */</comment>
			<comment type="block">/*
			 * Search hint string which is stored keyed by query string
			 * and application name.  The query string is normalized to allow
			 * fuzzy matching.
			 *
			 * Adding 1 byte to query_len ensures that the returned string has
			 * a terminating NULL.
			 */</comment>
			<expr_stmt><expr><name>query_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query_str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>normalized_query</name> <operator>=</operator>
				<call><name>generate_normalized_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jstate</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>query_len</name></expr></argument>,
										  <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * find a hint for the normalized query. the result should be in
			 * TopMemoryContext
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator>
				<call><name>get_hints_from_table</name><argument_list>(<argument><expr><name>normalized_query</name></expr></argument>, <argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>current_hint_str</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan[qno=0x%x]: "</literal>
									<literal type="string">"post_parse_analyze_hook: "</literal>
									<literal type="string">"hints from table: \"%s\": "</literal>
									<literal type="string">"normalized_query=\"%s\", "</literal>
									<literal type="string">"application name =\"%s\""</literal></expr></argument>,
									<argument><expr><name>qno</name></expr></argument>, <argument><expr><name>current_hint_str</name></expr></argument>,
									<argument><expr><name>normalized_query</name></expr></argument>, <argument><expr><name>application_name</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan[qno=0x%x]: "</literal>
									<literal type="string">"no match found in table:  "</literal>
									<literal type="string">"application name = \"%s\", "</literal>
									<literal type="string">"normalized_query=\"%s\""</literal></expr></argument>,
									<argument><expr><name>qno</name></expr></argument>, <argument><expr><name>application_name</name></expr></argument>,
									<argument><expr><name>normalized_query</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* retrun if we have hint here */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_hint_str</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_str</name> <operator>=</operator> <call><name>get_query_string</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>query_str</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * get hints from the comment. However we may have the same query
		 * string with the previous call, but the extra comparison seems no
		 * use..
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_hint_str</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_hint_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <call><name>get_hints_from_comment</name><argument_list>(<argument><expr><name>query_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Failed to get query. We would be in fetching invalidated
		 * plancache. Try the next chance.
		 */</comment>
		<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>query_str</name> <operator>&amp;&amp;</operator> <name>debug_query_string</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>query_str</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hints in comment=\"%s\""</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name>current_hint_str</name></expr> ?</condition><then> <expr><name>current_hint_str</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hints in comment=\"%s\", query=\"%s\", debug_query_string=\"%s\""</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name>current_hint_str</name></expr> ?</condition><then> <expr><name>current_hint_str</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><name>query_str</name></expr> ?</condition><then> <expr><name>query_str</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><name>debug_query_string</name></expr> ?</condition><then> <expr><name>debug_query_string</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve hint string from the current query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_hint_plan_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* always retrieve hint from the top-level query string */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_recurse_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_current_hint_string</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We need to reset current_hint_retrieved flag always when a command execution
 * is finished. This is true even for a pure utility command that doesn't
 * involve planning phase.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_hint_plan_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ProcessUtility_hook</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
								 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
								 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>plpgsql_recurse_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read and set up hint information
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pg_hint_plan_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HintState</name>	   <modifier>*</modifier></type><name>hstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> 	   <modifier>*</modifier></type><name>prev_hint_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use standard planner if pg_hint_plan is disabled or current nesting 
	 * depth is nesting depth of SPI calls. Other hook functions try to change
	 * plan with current_hint_state if any, so set it to NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pg_hint_plan_enable_hint</name> <operator>||</operator> <name>hint_inhibit_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: planner: enable_hint=%d,"</literal>
							 <literal type="string">" hint_inhibit_level=%d"</literal></expr></argument>,
							 <argument><expr><name>qnostr</name></expr></argument>, <argument><expr><name>pg_hint_plan_enable_hint</name></expr></argument>,
							 <argument><expr><name>hint_inhibit_level</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>

		<goto>goto <name>standard_planner_proc</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Support for nested plpgsql functions. This is quite ugly but this is the
	 * only point I could find where I can get the query string.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_recurse_level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>error_context_stack</name> <operator>&amp;&amp;</operator> <name><name>error_context_stack</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator>
			<call><name>get_hints_from_comment</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>error_context_stack</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Query execution in extended protocol can be started without the analyze
	 * phase. In the case retrieve hint string here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_hint_str</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_current_hint_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No hint, go the normal way */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_hint_str</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>standard_planner_proc</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* parse the hint into hint state struct */</comment>
	<expr_stmt><expr><name>hstate</name> <operator>=</operator> <call><name>create_hintstate</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>current_hint_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* run standard planner if the statement has not valid hint */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hstate</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>standard_planner_proc</name>;</goto></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * Push new hint struct to the hint stack to disable previous hint context.
	 */</comment>
	<expr_stmt><expr><call><name>push_hint</name><argument_list>(<argument><expr><name>hstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*  Set scan enforcement here. */</comment>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply Set hints, then save it as the initial state  */</comment>
	<expr_stmt><expr><call><name>setup_guc_enforcement</name><argument_list>(<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>set_hints</name></name></expr></argument>,
						   <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_SET</name></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_scan_mask</name></name> <operator>=</operator> <call><name>get_current_scan_mask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_join_mask</name></name> <operator>=</operator> <call><name>get_current_join_mask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_min_para_tablescan_size</name></name> <operator>=</operator>
		<name>min_parallel_table_scan_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_min_para_indexscan_size</name></name> <operator>=</operator>
		<name>min_parallel_index_scan_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_paratup_cost</name></name> <operator>=</operator> <name>parallel_tuple_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_parasetup_cost</name></name> <operator>=</operator> <name>parallel_setup_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * max_parallel_workers_per_gather should be non-zero here if Workers hint
	 * is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_hint_nworkers</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max_parallel_workers_per_gather</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_config_int32_option</name><argument_list>(<argument><expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr></argument>,
								<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_nworkers</name></name> <operator>=</operator> <name>max_parallel_workers_per_gather</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: planner"</literal></expr></argument>, <argument><expr><name>qnostr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The planner call below may replace current_hint_str. Store and restore
	 * it so that the subsequent planning in the upper level doesn't get
	 * confused.
	 */</comment>
	<expr_stmt><expr><name>recurse_level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_hint_str</name> <operator>=</operator> <name>current_hint_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * Use PG_TRY mechanism to recover GUC parameters and current_hint_state to
	 * the state when this planner started when error occurred in planner.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_planner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>prev_planner</name>) <argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>prev_hint_str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recurse_level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Rollback changes of GUC parameters, and pop current hint context
		 * from hint stack to rewind the state.
		 */</comment>
		<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>prev_hint_str</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recurse_level</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pop_hint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * current_hint_str is useless after planning of the top-level query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse_level</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>current_hint_str</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>current_hint_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>current_hint_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print hint in debug mode. */</comment>
	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HintStateDump</name><argument_list>(<argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HintStateDump2</name><argument_list>(<argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Rollback changes of GUC parameters, and pop current hint context from
	 * hint stack to rewind the state.
	 */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pop_hint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>

<label><name>standard_planner_proc</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>msgqno</name> <operator>!=</operator> <name>qno</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: planner: no valid hint"</literal></expr></argument>,
						<argument><expr><name>qnostr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>msgqno</name> <operator>=</operator> <name>qno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>current_hint_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev_planner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator>  <call>(<modifier>*</modifier><name>prev_planner</name>) <argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* The upper-level planner still needs the current hint state */</comment>
	<if_stmt><if>if <condition>(<expr><name>HintStateStack</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_hint_state</name> <operator>=</operator> <operator>(</operator><name>HintState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>HintStateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find scan method hint to be applied to the given relation
 *
 */</comment>
<function><type><specifier>static</specifier> <name>ScanMethodHint</name> <modifier>*</modifier></type>
<name>find_scan_hint</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name>	   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name>  <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanMethodHint</name>	<modifier>*</modifier></type><name>real_name_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanMethodHint</name>	<modifier>*</modifier></type><name>alias_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* This should not be a join rel */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function is called for any RelOptInfo or its inheritance parent if
	 * any. If we are called from inheritance planner, the RelOptInfo for the
	 * parent of target child relation is not set in the planner info.
	 *
	 * Otherwise we should check that the reloptinfo is base relation or
	 * inheritance children.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This is baserel or appendrel children. We can refer to RangeTblEntry.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't hint on other than relation and foreign tables */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Find scan method hint, which matches given names, from the list. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_SCAN_METHOD</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>scan_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We ignore disabled hints. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alias_hint</name> <operator>&amp;&amp;</operator>
			<call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alias_hint</name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check the real name for appendrel children */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>real_name_hint</name> <operator>&amp;&amp;</operator>
			<name>rel</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>realname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>realname</name> <operator>&amp;&amp;</operator> <call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>real_name_hint</name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No more match expected, break  */</comment>
		<if_stmt><if>if<condition>(<expr><name>alias_hint</name> <operator>&amp;&amp;</operator> <name>real_name_hint</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* real name match precedes alias match */</comment>
	<if_stmt><if>if <condition>(<expr><name>real_name_hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>real_name_hint</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>alias_hint</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParallelHint</name> <modifier>*</modifier></type>
<name>find_parallel_hint</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name>	   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name>  <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHint</name>	<modifier>*</modifier></type><name>real_name_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHint</name>	<modifier>*</modifier></type><name>alias_hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* This should not be a join rel */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parallel planning is appliable only on base relation, which has
	 * RelOptInfo. 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We have set root-&gt;glob-&gt;parallelModeOK if needed. What we should do here
	 * is just following the decision of planner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This is baserel or appendrel children. We can refer to RangeTblEntry.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find parallel method hint, which matches given names, from the list. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_PARALLEL</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParallelHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parallel_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We ignore disabled hints. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alias_hint</name> <operator>&amp;&amp;</operator>
			<call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alias_hint</name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check the real name for appendrel children */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>real_name_hint</name> <operator>&amp;&amp;</operator>
			<name>rel</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>realname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>realname</name> <operator>&amp;&amp;</operator> <call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>realname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>real_name_hint</name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No more match expected, break  */</comment>
		<if_stmt><if>if<condition>(<expr><name>alias_hint</name> <operator>&amp;&amp;</operator> <name>real_name_hint</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* real name match precedes alias match */</comment>
	<if_stmt><if>if <condition>(<expr><name>real_name_hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>real_name_hint</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>alias_hint</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * regexeq
 *
 * Returns TRUE on match, FALSE on no match.
 *
 *   s1 --- the data to match against
 *   s2 --- the pattern
 *
 * Because we copy s1 to NameData, make the size of s1 less than NAMEDATALEN.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>regexpeq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>regexp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>regexp</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2Coll</name><argument_list>(<argument><expr><name>nameregexeq</name></expr></argument>,
									 <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
									 <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Remove indexes instructed not to use by hint. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restrict_indexes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>using_parent_hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name>  <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>relationObjectId</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We delete all the IndexOptInfo list and prevent you from being usable by
	 * a scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>==</operator> <name>ENABLE_SEQSCAN</name> <operator>||</operator>
		<name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>==</operator> <name>ENABLE_TIDSCAN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When a list of indexes is not specified, we just use all indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>indexnames</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Leaving only an specified index, we delete it from a IndexOptInfo list
	 * other than it.
	 */</comment>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOptInfo</name>   <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>			<name>use_index</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>hint-&gt;indexnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>hintname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>	<name>result</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>regexp</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>regexpeq</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>, <argument><expr><name>hintname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>use_index</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Apply index restriction of parent hint to children. Since index
		 * inheritance is not explicitly described we should search for an
		 * children's index with the same definition to that of the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>using_parent_hint</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_index</name></expr>)</condition>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>current_hint_state-&gt;parent_index_infos</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>ht_idx</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParentIndexInfo</name>	   <modifier>*</modifier></type><name>p_info</name> <init>= <expr><operator>(</operator><name>ParentIndexInfo</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * we check the 'same' index by comparing uniqueness, access
				 * method and index key columns.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>p_info</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator>
					<name><name>p_info</name><operator>-&gt;</operator><name>method</name></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>relam</name></name> <operator>||</operator>
					<call><name>list_length</name><argument_list>(<argument><expr><name><name>p_info</name><operator>-&gt;</operator><name>column_names</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Check if index key columns match */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>c_attname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p_attname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>p_attname</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>p_info</name><operator>-&gt;</operator><name>column_names</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if both of the key of the same position are expressions,
					 * ignore them for now and check later.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>p_attname</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* deny if one is expression while another is not */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>p_attname</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>c_attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>,
											<argument><expr><name><name>info</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* deny if any of column attributes don't match */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p_attname</name></expr></argument>, <argument><expr><name>c_attname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
						<name><name>p_info</name><operator>-&gt;</operator><name>indcollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
						<name><name>p_info</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name><operator>||</operator>
						<operator>(</operator><operator>(</operator><name><name>p_info</name><operator>-&gt;</operator><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator>
						<operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
						<operator>(</operator><operator>(</operator><name><name>p_info</name><operator>-&gt;</operator><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator>
						<operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* deny this if any difference found */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* check on key expressions  */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>indpred</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fetch the index of this child */</comment>
					<expr_stmt><expr><name>ht_idx</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
											 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* check expressions if both expressions are available */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Datum</name></type>       <name>exprsDatum</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Datum</name></type>       <name>result</name></decl>;</decl_stmt>

						<comment type="block">/*
						 * to change the expression's parameter of child's
						 * index to strings
						 */</comment>
						<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
													 <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>,
													 <argument><expr><name>exprsDatum</name></expr></argument>,
													 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
														 <argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* deny if expressions don't match */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name></expr></argument>,
								   <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Clean up */</comment>
							<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* compare index predicates  */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Datum</name></type>       <name>predDatum</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Datum</name></type>       <name>result</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
													 <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>,
													 <argument><expr><name>predDatum</name></expr></argument>,
													 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
														 <argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name></expr></argument>,
								   <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Clean up */</comment>
							<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Clean up */</comment>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name> <operator>||</operator> <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if>
				<if type="elseif">else if	<condition>(<expr><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name> <operator>||</operator> <operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>indpred</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>use_index</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* to log the candidate of index */</comment>
				<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_index</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type>  <name>rel_buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>disprelname</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this hint targetted the parent, use the real name of this
		 * child. Otherwise use hint specification.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>using_parent_hint</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>disprelname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>disprelname</name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quote_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_buf</name></expr></argument>, <argument><expr><name>disprelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"available indexes for %s(%s):%s"</literal></expr></argument>,
					 <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>keyword</name></name></expr></argument>,
					 <argument><expr><name><name>rel_buf</name><operator>.</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rel_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * Return information of index definition.
 */</comment>
<function><type><specifier>static</specifier> <name>ParentIndexInfo</name> <modifier>*</modifier></type>
<name>get_parent_index_info</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParentIndexInfo</name>	<modifier>*</modifier></type><name>p_info</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParentIndexInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	    <name>indexRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type>	<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>method</name></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>column_names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indoption</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect relation attribute names of index columns for index
	 * identification, not index attribute names. NULL means expression index
	 * columns.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>column_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>p_info</name><operator>-&gt;</operator><name>column_names</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indcollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>opclass</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * to check to match the expression's parameter of index with child indexes
 	 */</comment>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>       <name>exprsDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
									 <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>,
									 <argument><expr><name>exprsDatum</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>expression_str</name></name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * to check to match the predicate's parameter of index with child indexes
 	 */</comment>
	<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>       <name>predDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
									 <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>,
									 <argument><expr><name>predDatum</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>p_info</name><operator>-&gt;</operator><name>indpred_str</name></name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cancel hint enforcement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_hint_enforcement</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>setup_scan_method_enforcement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setup_parallel_plan_enforcement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set planner guc parameters according to corresponding scan hints.  Returns
 * bitmap of HintTypeBitmap. If shint or phint is not NULL, set used hint
 * there respectively.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setup_hint_enforcement</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>ScanMethodHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>rshint</name></decl></parameter>, <parameter><decl><type><name>ParallelHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>rphint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>	<name>new_parent_relid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type><name>shint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelHint</name>   <modifier>*</modifier></type><name>phint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>inhparent</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name><operator>-&gt;</operator><name>inh</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>relationObjectId</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reset returns if requested  */</comment>
	<if_stmt><if>if <condition>(<expr><name>rshint</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>rshint</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rphint</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>rphint</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We could register the parent relation of the following children here
	 * when inhparent == true but inheritnce planner doesn't call this function
	 * for parents. Since we cannot distinguish who called this function we
	 * cannot do other than always seeking the parent regardless of who called
	 * this function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhparent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set up only parallel hints for parent relation */</comment>
		<expr_stmt><expr><name>phint</name> <operator>=</operator> <call><name>find_parallel_hint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>phint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>setup_parallel_plan_enforcement</name><argument_list>(<argument><expr><name>phint</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rphint</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>rphint</name> <operator>=</operator> <name>phint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name>HINT_BM_PARALLEL</name></expr>;</expr_stmt>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: setup_hint_enforcement"</literal>
							 <literal type="string">" skipping inh parent: relation=%u(%s), inhparent=%d,"</literal>
							 <literal type="string">" current_hint_state=%p, hint_inhibit_level=%d"</literal></expr></argument>,
							 <argument><expr><name>qnostr</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>, <argument><expr><name>hint_inhibit_level</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Forget about the parent of another subquery */</comment>
	<if_stmt><if>if <condition>(<expr><name>root</name> <operator>!=</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>current_root</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find the parent for this relation other than the registered parent */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_parent_relid</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>current_root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>l</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This relation doesn't have a parent. Cancel current_hint_state. */</comment>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_parallel_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_parent_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Here we found a new parent for the current relation. Scan continues
		 * hint to other childrens of this parent so remember it to avoid
		 * redundant setup cost.
		 */</comment>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>new_parent_relid</name></expr>;</expr_stmt>
				
		<comment type="block">/* Find hints for the parent */</comment>
		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name> <operator>=</operator>
			<call><name>find_scan_hint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_parallel_hint</name></name> <operator>=</operator>
			<call><name>find_parallel_hint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If hint is found for the parent, apply it for this child instead
		 * of its own.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanMethodHint</name> <modifier>*</modifier></type> <name>pshint</name> <init>= <expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>pshint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>

			<comment type="block">/* Apply index mask in the same manner to the parent. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pshint</name><operator>-&gt;</operator><name>indexnames</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>parentrel_oid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parentrel_oid</name> <operator>=</operator>
					<name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentrel_oid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Search the parent relation for indexes match the hint spec */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>RelationGetIndexList(parent_rel)</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>         <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ParentIndexInfo</name> <modifier>*</modifier></type><name>parent_index_info</name></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pshint-&gt;indexnames</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexname</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>parent_index_info</name> <operator>=</operator>
						<call><name>get_parent_index_info</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>parentrel_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_index_infos</name></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_index_infos</name></name></expr></argument>,
								<argument><expr><name>parent_index_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>shint</name> <operator>=</operator> <call><name>find_scan_hint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>shint</name> <operator>=</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>using_parent_hint</name> <init>=
			<expr><operator>(</operator><name>shint</name> <operator>==</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name>HINT_BM_SCAN_METHOD</name></expr>;</expr_stmt>

		<comment type="block">/* Setup scan enforcement environment */</comment>
		<expr_stmt><expr><call><name>setup_scan_method_enforcement</name><argument_list>(<argument><expr><name>shint</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* restrict unwanted inexes */</comment>
		<expr_stmt><expr><call><name>restrict_indexes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>shint</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>using_parent_hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>additional_message</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>shint</name> <operator>==</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_scan_hint</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>additional_message</name> <operator>=</operator> <literal type="string">" by parent hint"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: setup_hint_enforcement"</literal>
							 <literal type="string">" index deletion%s:"</literal>
							 <literal type="string">" relation=%u(%s), inhparent=%d, "</literal>
							 <literal type="string">"current_hint_state=%p,"</literal>
							 <literal type="string">" hint_inhibit_level=%d, scanmask=0x%x"</literal></expr></argument>,
							 <argument><expr><name>qnostr</name></expr></argument>, <argument><expr><name>additional_message</name></expr></argument>,
							 <argument><expr><name>relationObjectId</name></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>,
							 <argument><expr><name>hint_inhibit_level</name></expr></argument>,
							 <argument><expr><name><name>shint</name><operator>-&gt;</operator><name>enforce_mask</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do the same for parallel plan enforcement */</comment>
	<expr_stmt><expr><name>phint</name> <operator>=</operator> <call><name>find_parallel_hint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>phint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>phint</name> <operator>=</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>parent_parallel_hint</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>setup_parallel_plan_enforcement</name><argument_list>(<argument><expr><name>phint</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>phint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name>HINT_BM_PARALLEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Nothing to apply. Reset the scan mask to intial state */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shint</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>phint</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>pg_hint_plan_debug_message_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errhidestmt</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name> <argument_list>(<argument><expr><literal type="string">"pg_hint_plan%s: setup_hint_enforcement"</literal>
							 <literal type="string">" no hint applied:"</literal>
							 <literal type="string">" relation=%u(%s), inhparent=%d, current_hint=%p,"</literal>
							 <literal type="string">" hint_inhibit_level=%d, scanmask=0x%x"</literal></expr></argument>,
							 <argument><expr><name>qnostr</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>current_hint_state</name></expr></argument>, <argument><expr><name>hint_inhibit_level</name></expr></argument>,
							 <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_scan_mask</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>setup_scan_method_enforcement</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<argument><expr><name>current_hint_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rshint</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>rshint</name> <operator>=</operator> <name>shint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rphint</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>rphint</name> <operator>=</operator> <name>phint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return index of relation which matches given aliasname, or 0 if not found.
 * If same aliasname was used multiple times in a query, return -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_relid_aliasname</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>	<name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelnameCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aliasname</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>initial_rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
							 <argument><expr><operator>(</operator><literal type="string">"Relation name \"%s\" is ambiguous."</literal><operator>,</operator>
							  <name>aliasname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

	</block_content>}</block></for>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return join hint which matches given joinrelids.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinMethodHint</name> <modifier>*</modifier></type>
<name>find_join_hint</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>join_hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>join_hint</name> <operator>=</operator> <name><name>current_hint_state</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>join_hint</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><operator>(</operator><name>JoinMethodHint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>hint</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>OuterInnerJoinCreate</name><parameter_list>(<parameter><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_inner</name></decl></parameter>, <parameter><decl><type><name>LeadingHint</name> <modifier>*</modifier></type><name>leading_hint</name></decl></parameter>,
	<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>, <parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbaserel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>outer_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OuterInnerRels</name> <modifier>*</modifier></type><name>inner_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>outer_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>inner_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>join_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>bms_make_singleton</name><argument_list>(
					<argument><expr><call><name>find_relid_aliasname</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										 <argument><expr><name>initial_rels</name></expr></argument>,
										 <argument><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>outer_rels</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>outer_inner_pair</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_rels</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>outer_inner</name><operator>-&gt;</operator><name>outer_inner_pair</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outer_relids</name> <operator>=</operator> <call><name>OuterInnerJoinCreate</name><argument_list>(<argument><expr><name>outer_rels</name></expr></argument>,
										<argument><expr><name>leading_hint</name></expr></argument>,
										<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>initial_rels</name></expr></argument>,
										<argument><expr><name>hstate</name></expr></argument>,
										<argument><expr><name>nbaserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_relids</name> <operator>=</operator> <call><name>OuterInnerJoinCreate</name><argument_list>(<argument><expr><name>inner_rels</name></expr></argument>,
										<argument><expr><name>leading_hint</name></expr></argument>,
										<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>initial_rels</name></expr></argument>,
										<argument><expr><name>hstate</name></expr></argument>,
										<argument><expr><name>nbaserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>, <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>join_relids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>nbaserel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>join_relids</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we don't have join method hint, create new one for the
	 * join combination with all join methods are enabled.
	 */</comment>
	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>find_join_hint</name><argument_list>(<argument><expr><name>join_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Here relnames is not set, since Relids bitmap is sufficient to
		 * control paths of this query afterward.
		 */</comment>
		<expr_stmt><expr><name>hint</name> <operator>=</operator> <operator>(</operator><name>JoinMethodHint</name> <operator>*</operator><operator>)</operator> <call><name>JoinMethodHintCreate</name><argument_list>(
					<argument><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
					<argument><expr><name>HINT_LEADING</name></expr></argument>,
					<argument><expr><name>HINT_KEYWORD_LEADING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>join_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_JOIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>join_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>]</index></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>join_relids</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>create_bms_of_relids</name><parameter_list>(<parameter><decl><type><name>Hint</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>	<name>relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <name><name>relnames</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>find_relid_aliasname</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>,
									 <argument><expr><name><name>base</name><operator>-&gt;</operator><name>hint_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * the aliasname is not found(relid == 0) or same aliasname was used
		 * multiple times in a query(relid == -1)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>base</name><operator>-&gt;</operator><name>hint_str</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><literal type="string">"Relation name \"%s\" is duplicated."</literal><operator>,</operator> <name>relname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>base</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>relids</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Transform join method hint into handy form.
 *
 *   - create bitmap of relids from alias names, to make it easier to check
 *     whether a join path matches a join method hint.
 *   - add join method hints which are necessary to enforce join order
 *     specified by Leading hint
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>transform_join_hints</name><parameter_list>(<parameter><decl><type><name>HintState</name> <modifier>*</modifier></type><name>hstate</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbaserel</name></decl></parameter>,
		<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>, <parameter><decl><type><name>JoinMethodHint</name> <modifier>*</modifier><modifier>*</modifier></type><name>join_method_hints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>njoinrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LeadingHint</name>	   <modifier>*</modifier></type><name>lhint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create bitmap of relids from alias names for each join method hint.
	 * Bitmaps are more handy than strings in join searching.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_JOIN_METHOD</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&gt;</operator> <name>nbaserel</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <call><name>create_bms_of_relids</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hint</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></argument>, <argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name>initial_rels</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>]</index></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Create bitmap of relids from alias names for each rows hint.
	 * Bitmaps are more handy than strings in join searching.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_ROWS</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowsHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name><name>hstate</name><operator>-&gt;</operator><name>rows_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&gt;</operator> <name>nbaserel</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <call><name>create_bms_of_relids</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>hint</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></argument>, <argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name>initial_rels</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>relnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Do nothing if no Leading hint was supplied. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_LEADING</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether to use Leading hint
 	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hstate</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_LEADING</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LeadingHint</name>	   <modifier>*</modifier></type><name>leading_hint</name> <init>= <expr><operator>(</operator><name>LeadingHint</name> <operator>*</operator><operator>)</operator><name><name>hstate</name><operator>-&gt;</operator><name>leading_hint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>			<name>relids</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>leading_hint-&gt;relations</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>relname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>find_relid_aliasname</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>,
										 <argument><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><literal type="string">"Relation name \"%s\" is duplicated."</literal><operator>,</operator> <name>relname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_ERROR</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>HINT_STATE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>lhint</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hint_ereport</name><argument_list>(<argument><expr><name><name>lhint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><literal type="string">"Conflict %s hint."</literal><operator>,</operator> <name><name>HintTypeName</name><index>[<expr><name><name>lhint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lhint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_DUPLICATION</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>leading_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lhint</name> <operator>=</operator> <name>leading_hint</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* check to exist Leading hint marked with 'used'. */</comment>
	<if_stmt><if>if <condition>(<expr><name>lhint</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need join method hints which fit specified join order in every join
	 * level.  For example, Leading(A B C) virtually requires following join
	 * method hints, if no join method hint supplied:
	 *   - level 1: none
	 *   - level 2: NestLoop(A B), MergeJoin(A B), HashJoin(A B)
	 *   - level 3: NestLoop(A B C), MergeJoin(A B C), HashJoin(A B C)
	 *
	 * If we already have join method hint which fits specified join order in
	 * that join level, we leave it as-is and don't add new hints.
	 */</comment>
	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>njoinrels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lhint</name><operator>-&gt;</operator><name>outer_inner</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lhint-&gt;relations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>relname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Find relid of the relation which has given name.  If we have the
			 * name given in Leading hint multiple times in the join, nothing to
			 * do.
			 */</comment>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>find_relid_aliasname</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>,
										 <argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>hint_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create bitmap of relids for current join level. */</comment>
			<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>njoinrels</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* We never have join method hint for single relation. */</comment>
			<if_stmt><if>if <condition>(<expr><name>njoinrels</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we don't have join method hint, create new one for the
			 * join combination with all join methods are enabled.
			 */</comment>
			<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>find_join_hint</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Here relnames is not set, since Relids bitmap is sufficient
				 * to control paths of this query afterward.
				 */</comment>
				<expr_stmt><expr><name>hint</name> <operator>=</operator> <operator>(</operator><name>JoinMethodHint</name> <operator>*</operator><operator>)</operator> <call><name>JoinMethodHintCreate</name><argument_list>(
											<argument><expr><name><name>lhint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>hint_str</name></name></expr></argument>,
											<argument><expr><name>HINT_LEADING</name></expr></argument>,
											<argument><expr><name>HINT_KEYWORD_LEADING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <name>njoinrels</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name> <operator>=</operator> <name>ENABLE_ALL_JOIN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>join_method_hints</name><index>[<expr><name>njoinrels</name></expr>]</index></name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>njoinrels</name> <operator>&gt;=</operator> <name>nbaserel</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>njoinrels</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Delete all join hints which have different combination from Leading
		 * hint.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>njoinrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>join_method_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>OuterInnerJoinCreate</name><argument_list>(<argument><expr><name><name>lhint</name><operator>-&gt;</operator><name>outer_inner</name></name></expr></argument>,
										  <argument><expr><name>lhint</name></expr></argument>,
                                          <argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name>initial_rels</name></expr></argument>,
										  <argument><expr><name>hstate</name></expr></argument>,
										  <argument><expr><name>nbaserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>njoinrels</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>njoinrels</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Delete all join hints which have different combination from Leading
		 * hint.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init><condition><expr><name>i</name> <operator>&lt;=</operator> <name>njoinrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<for>for<control>(<init><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
				<block>{<block_content>

					<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><operator>(</operator><name>JoinMethodHint</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<operator>!</operator><operator>(</operator><call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						  <call><name>bms_equal</name><argument_list>(<argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>joinrelids</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
							<call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>hstate</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>l</name></expr></argument>,
											 <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hint_state_enabled</name><argument_list>(<argument><expr><name>lhint</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_join_config_options</name><argument_list>(<argument><expr><name>DISABLE_ALL_JOIN</name></expr></argument>, <argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * wrapper of make_join_rel()
 *
 * call make_join_rel() after changing enable_* parameters according to given
 * hints.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_join_rel_wrapper</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name>	   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>save_nestlevel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>find_join_hint</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pg_hint_plan_make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_join_config_options</name><argument_list>(<argument><expr><name><name>hint</name><operator>-&gt;</operator><name>enforce_mask</name></name></expr></argument>,
								<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>pg_hint_plan_make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restore the GUC variables we set above.
		 */</comment>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>pg_hint_plan_make_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel1</name></expr></argument>, <argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TODO : comment
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_paths_to_joinrel_wrapper</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>			<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinMethodHint</name> <modifier>*</modifier></type><name>join_hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>save_nestlevel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>join_hint</name> <operator>=</operator> <call><name>find_join_hint</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>join_hint</name> <operator>&amp;&amp;</operator> <name><name>join_hint</name><operator>-&gt;</operator><name>inner_nrels</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>join_hint</name><operator>-&gt;</operator><name>inner_joinrelids</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>

			<expr_stmt><expr><call><name>set_join_config_options</name><argument_list>(<argument><expr><name><name>join_hint</name><operator>-&gt;</operator><name>enforce_mask</name></name></expr></argument>,
									<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
								 <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>join_hint</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>HINT_STATE_USED</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_join_config_options</name><argument_list>(<argument><expr><name>DISABLE_ALL_JOIN</name></expr></argument>,
									<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
								 <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Restore the GUC variables we set above.
		 */</comment>
		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_paths_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
							 <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_num_baserels</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbaserel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>initial_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nbaserel</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator><name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nbaserel</name><operator>+=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized reloptkind type: %d"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>nbaserel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>pg_hint_plan_join_search</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levels_needed</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinMethodHint</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>join_method_hints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>nbaserel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name>		   <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>leading_hint_enable</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use standard planner (or geqo planner) if pg_hint_plan is disabled or no
	 * valid hint is supplied or current nesting depth is nesting depth of SPI
	 * calls.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_hint_state</name> <operator>||</operator> <name>hint_inhibit_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_join_search</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call>(<modifier>*</modifier><name>prev_join_search</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>enable_geqo</name> <operator>&amp;&amp;</operator> <name>levels_needed</name> <operator>&gt;=</operator> <name>geqo_threshold</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>geqo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>standard_join_search</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In the case using GEQO, only scan method hints and Set hints have
	 * effect.  Join method and join order is not controllable by hints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_geqo</name> <operator>&amp;&amp;</operator> <name>levels_needed</name> <operator>&gt;=</operator> <name>geqo_threshold</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>geqo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nbaserel</name> <operator>=</operator> <call><name>get_num_baserels</name><argument_list>(<argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>join_hint_level</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nbaserel</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>join_method_hints</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinMethodHint</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nbaserel</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leading_hint_enable</name> <operator>=</operator> <call><name>transform_join_hints</name><argument_list>(<argument><expr><name>current_hint_state</name></expr></argument>,
											   <argument><expr><name>root</name></expr></argument>, <argument><expr><name>nbaserel</name></expr></argument>,
											   <argument><expr><name>initial_rels</name></expr></argument>, <argument><expr><name>join_method_hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>pg_hint_plan_standard_join_search</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>levels_needed</name></expr></argument>, <argument><expr><name>initial_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust number of parallel workers of the result rel to the largest
	 * number of the component paths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>num_hints</name><index>[<expr><name>HINT_TYPE_PARALLEL</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 		<name>nworkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>initial_rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lcp</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>nworkers</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator> <name>parallel_workers</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator> <name>parallel_workers</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>&lt;</operator> <name>nworkers</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nbaserel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>join_hint_level</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* free Leading hint only */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>join_method_hints</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>join_method_hints</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>enforce_mask</name> <operator>==</operator> <name>ENABLE_ALL_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>JoinMethodHintDelete</name><argument_list>(<argument><expr><name><name>join_method_hints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>join_hint_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>join_method_hints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>leading_hint_enable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_join_config_options</name><argument_list>(<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>init_join_mask</name></name></expr></argument>,
								<argument><expr><name><name>current_hint_state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Force number of wokers if instructed by hint
 */</comment>
<function><type><name>void</name></type>
<name>pg_hint_plan_set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelHint</name>   <modifier>*</modifier></type><name>phint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>found_hints</name></decl>;</decl_stmt>

	<comment type="block">/* call the previous hook */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_set_rel_pathlist</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_set_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Nothing to do if no hint available */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_hint_state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't touch dummy rels. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can accept only plain relations, foreign tables and table saples are
	 * also unacceptable. See set_rel_pathlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name><operator>)</operator><operator>||</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		<name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Even though UNION ALL node doesn't have particular name so usually it is
	 * unhintable, turn on parallel when it contains parallel nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>	<name>inhibit_nonparallel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>		<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>apath</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lcp</argument>, <argument>apath-&gt;subpaths</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>spath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spath</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>&amp;&amp;</operator>
					<name>parallel_workers</name> <operator>&lt;</operator> <name><name>spath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <name><name>spath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>inhibit_nonparallel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>inhibit_nonparallel</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name>disable_cost</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We cannot handle if this requires an outer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Return if this relation gets no enfocement */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>found_hints</name> <operator>=</operator> <call><name>setup_hint_enforcement</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phint</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Here, we regenerate paths with the current hint restriction */</comment>
	<if_stmt><if>if <condition>(<expr><name>found_hints</name> <operator>&amp;</operator> <name>HINT_BM_SCAN_METHOD</name> <operator>||</operator> <name>found_hints</name> <operator>&amp;</operator> <name>HINT_BM_PARALLEL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When hint is specified on non-parent relations, discard existing
		 * paths and regenerate based on the hint considered. Otherwise we
		 * already have hinted child paths then just adjust the number of
		 * planned number of workers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name><operator>-&gt;</operator><name>inh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* enforce number of workers if requested */</comment>
			<if_stmt><if>if <condition>(<expr><name>phint</name> <operator>&amp;&amp;</operator> <name><name>phint</name><operator>-&gt;</operator><name>force_parallel</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>phint</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* prioritize partial paths */</comment>
					<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>ppath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>ppath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>parallel_workers</name></name>	<operator>=</operator> <name><name>phint</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

					<comment type="block">/* disable non-partial paths */</comment>
					<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>ppath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>ppath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name>disable_cost</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Just discard all the paths considered so far */</comment>
			<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

			<comment type="block">/* Regenerate paths with the current enforcement */</comment>
			<expr_stmt><expr><call><name>set_plain_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Additional work to enforce parallel query execution */</comment>
			<if_stmt><if>if <condition>(<expr><name>phint</name> <operator>&amp;&amp;</operator> <name><name>phint</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * For Parallel Append to be planned properly, we shouldn't set
				 * the costs of non-partial paths to disable-value.  Lower the
				 * priority of non-parallel paths by setting partial path costs
				 * to 0 instead.
				 */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* enforce number of workers if requested */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>phint</name><operator>-&gt;</operator><name>force_parallel</name></name></expr>)</condition>
				<block>{<block_content>
					<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>ppath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>ppath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>parallel_workers</name></name>	<operator>=</operator> <name><name>phint</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Generate gather paths */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>&amp;&amp;</operator>
					<call><name>bms_membership</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>reset_hint_enforcement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_rel_pathlist
 *	  Build access paths for a base relation
 *
 * This function was copied and edited from set_rel_pathlist() in
 * src/backend/optimizer/path/allpaths.c in order not to copy other static
 * functions not required here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rel_pathlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We already proved the relation empty, so nothing more to do */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's an "append relation", process accordingly */</comment>
		<expr_stmt><expr><call><name>set_append_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"sampled relation is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Plain relation */</comment>
				<expr_stmt><expr><call><name>set_plain_rel_pathlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind: %c"</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rtekind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allow a plugin to editorialize on the set of Paths for this base
	 * relation.  It could add new paths (such as CustomPaths) by calling
	 * add_path(), or delete or modify paths added by the core code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>set_rel_pathlist_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>set_rel_pathlist_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now find the cheapest of the paths for this rel */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * stmt_beg callback is called when each query in PL/pgSQL function is about
 * to be executed.  At that timing, we save query string in the global variable
 * plpgsql_query_string to use it in planner hook.  It's safe to use one global
 * variable for the purpose, because its content is only necessary until
 * planner hook is called for the query, so recursive PL/pgSQL function calls
 * don't harm this mechanism.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_hint_plan_plpgsql_stmt_beg</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>plpgsql_recurse_level</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * stmt_end callback is called then each query in PL/pgSQL function has
 * finished.  At that timing, we clear plpgsql_query_string to tell planner
 * hook that next call is not for a query written in PL/pgSQL block.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_hint_plan_plpgsql_stmt_end</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>plpgsql_recurse_level</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>plpgsql_query_erase_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
								  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isTopLevel</name> <operator>||</operator> <name>phase</name> <operator>!=</operator> <name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Cancel plpgsql nest level*/</comment>
	<expr_stmt><expr><name>plpgsql_recurse_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pg_hint_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_recurse_level</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>current_hint_retrieved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>standard_join_search</name></cpp:macro> <cpp:value>pg_hint_plan_standard_join_search</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>join_search_one_level</name></cpp:macro> <cpp:value>pg_hint_plan_join_search_one_level</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>make_join_rel</name></cpp:macro> <cpp:value>make_join_rel_wrapper</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"core.c"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>make_join_rel</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>make_join_rel</name></cpp:macro> <cpp:value>pg_hint_plan_make_join_rel</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>add_paths_to_joinrel</name></cpp:macro> <cpp:value>add_paths_to_joinrel_wrapper</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"make_join_rel.c"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_stat_statements.c"</cpp:file></cpp:include>
</unit>
