<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/pg_hint_plan/pg_stat_statements.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_stat_statements.c
 * 
 * Part of pg_stat_statements.c in PostgreSQL 10.
 *
 * Copyright (c) 2008-2020, PostgreSQL Global Development Group
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scanner.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendJumble</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleQuery</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleRangeTable</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JumbleExpr</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordConstLocation</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_normalized_query</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>query_len_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_in_constant_lengths</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>comp_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * AppendJumble: Append a value that is substantive in a given query to
 * the current jumble.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendJumble</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>jumble</name> <init>= <expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>jumble_len</name> <init>= <expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Whenever the jumble buffer is full, we hash the current contents and
	 * reset the buffer to contain just that hash value, thus relying on the
	 * hash to summarize everything so far.
	 */</comment>
	<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>part_size</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>jumble_len</name> <operator>&gt;=</operator> <name>JUMBLE_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>start_hash</name> <init>= <expr><call><name>hash_any</name><argument_list>(<argument><expr><name>jumble</name></expr></argument>, <argument><expr><name>JUMBLE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jumble</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>start_hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>jumble_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>start_hash</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>part_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>JUMBLE_SIZE</name> <operator>-</operator> <name>jumble_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jumble</name> <operator>+</operator> <name>jumble_len</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>part_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jumble_len</name> <operator>+=</operator> <name>part_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>+=</operator> <name>part_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>part_size</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>jumble_len</name></name> <operator>=</operator> <name>jumble_len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrappers around AppendJumble to encapsulate details of serialization
 * of individual local variable elements.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APP_JUMB</name><parameter_list>(<parameter><type><name>item</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>AppendJumble(jstate, (const unsigned char *) &amp;(item), sizeof(item))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APP_JUMB_STRING</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>AppendJumble(jstate, (const unsigned char *) (str), strlen(str) + 1)</cpp:value></cpp:define>

<comment type="block">/*
 * JumbleQuery: Selectively serialize the query tree, appending significant
 * data to the "query jumble" while ignoring nonsignificant data.
 *
 * Rule of thumb for what to include is that we should ignore anything not
 * semantically significant (such as alias names) as well as anything that can
 * be deduced from child nodes (else we'd just be double-hashing that piece
 * of information).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleQuery</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* resultRelation is usually predictable from commandType */</comment>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleRangeTable</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we ignore rowMarks */</comment>
	<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Jumble a range table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleRangeTable</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>

				<comment type="block">/*
				 * Depending on the CTE name here isn't ideal, but it's the
				 * only info we have to identify the referenced WITH item.
				 */</comment>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Jumble an expression tree
 *
 * In general this function should handle all the same node types that
 * expression_tree_walker() does, and therefore it's coded to be as parallel
 * to that function as possible.  However, since we are only invoked on
 * queries immediately post-parse-analysis, we need not handle node types
 * that only appear in planning.
 *
 * Note: the reason we don't simply use expression_tree_walker() is that the
 * point of that function is to support tree walkers that don't care about
 * most tree node types, but here we care about all types.  We should complain
 * about any unrecognized node type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>JumbleExpr</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always emit the node's NodeTag, then any additional fields that are
	 * considered significant, and then we recurse to any child nodes.
	 */</comment>
	<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* We jumble only the constant's type, not its value */</comment>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Also, record its parse location for query normalization */</comment>
				<expr_stmt><expr><call><name>RecordConstLocation</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Also, track the highest external Param id */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
					<name><name>p</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>highest_extern_param_id</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grpnode</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grpnode</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>nae</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nae</name><operator>-&gt;</operator><name>argnumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nae</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>cio</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cio</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cio</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acexpr</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>acexpr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>crexpr</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>crexpr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>crexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>(</operator><name>CaseTestExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>mmexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>mmexpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mmexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* type is fully determined by op */</comment>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nt</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cd</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>cdv</name> <init>= <expr><operator>(</operator><name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>cdv</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>sd</name> <init>= <expr><operator>(</operator><name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sd</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cvarno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>ie</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ie</name><operator>-&gt;</operator><name>infercollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>ie</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>ie</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>isNatural</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>from</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>from</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>conf</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IntList</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gsnode</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gsnode</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we store the string name because RTE_CTE RTEs need it */</comment>
				<expr_stmt><expr><call><name>APP_JUMB_STRING</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleQuery</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>all</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tablefunc</name> <init>= <expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>tablefunc</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name><name>tablefunc</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tablefunc</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>APP_JUMB</name><argument_list>(<argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JumbleExpr</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Only a warning, since we can stumble along anyway */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Record location of constant within query string of query tree
 * that is currently being walked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordConstLocation</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* -1 indicates unknown or undefined location */</comment>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* enlarge array if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>&gt;=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name> <operator>=</operator> <operator>(</operator><name>pgssLocationLen</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr></argument>,
						 <argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_buf_size</name></name> <operator>*</operator>
						 <sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>]</index></name><operator>.</operator><name>location</name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<comment type="block">/* initialize lengths to -1 to simplify fill_in_constant_lengths */</comment>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a normalized version of the query string that will be used to
 * represent all similar queries.
 *
 * Note that the normalized representation may well vary depending on
 * just which "equivalent" query is used to create the hashtable entry.
 * We assume this is OK.
 *
 * If query_loc &gt; 0, then "query" has been advanced by that much compared to
 * the original string start, so we need to translate the provided locations
 * to compensate.  (This lets us avoid re-scanning statements before the one
 * of interest, so it's worth doing.)
 *
 * *query_len_p contains the input string length, and is updated with
 * the result string length on exit.  The resulting string might be longer
 * or shorter depending on what happens with replacement of constants.
 *
 * Returns a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_normalized_query</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>query_len_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>norm_query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_len</name> <init>= <expr><operator>*</operator><name>query_len_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>norm_query_buflen</name></decl>,	<comment type="block">/* Space allowed for norm_query */</comment>
				<decl><type ref="prev"/><name>len_to_wrt</name></decl>,		<comment type="block">/* Length (in bytes) to write */</comment>
				<decl><type ref="prev"/><name>quer_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/* Source query byte location */</comment>
				<decl><type ref="prev"/><name>n_quer_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <comment type="block">/* Normalized query byte location */</comment>
				<decl><type ref="prev"/><name>last_off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/* Offset from start for previous tok */</comment>
				<decl><type ref="prev"/><name>last_tok_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* Length (in bytes) of that tok */</comment>

	<comment type="block">/*
	 * Get constants' lengths (core system only gives us locations).  Note
	 * this also ensures the items are sorted by location.
	 */</comment>
	<expr_stmt><expr><call><name>fill_in_constant_lengths</name><argument_list>(<argument><expr><name>jstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow for $n symbols to be longer than the constants they replace.
	 * Constants must take at least one byte in text form, while a $n symbol
	 * certainly isn't more than 11 bytes, even if n reaches INT_MAX.  We
	 * could refine that limit based on the max value of n for the current
	 * query, but it hardly seems worth any extra effort to do so.
	 */</comment>
	<expr_stmt><expr><name>norm_query_buflen</name> <operator>=</operator> <name>query_len</name> <operator>+</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<comment type="block">/* Allocate result buffer */</comment>
	<expr_stmt><expr><name>norm_query</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>norm_query_buflen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,		<comment type="block">/* Offset from start for cur tok */</comment>
					<decl><type ref="prev"/><name>tok_len</name></decl>;</decl_stmt>	<comment type="block">/* Length (in bytes) of that tok */</comment>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>location</name></expr>;</expr_stmt>
		<comment type="block">/* Adjust recorded location if we're dealing with partial string */</comment>
		<expr_stmt><expr><name>off</name> <operator>-=</operator> <name>query_loc</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tok_len</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore any duplicates */</comment>

		<comment type="block">/* Copy next chunk (what precedes the next constant) */</comment>
		<expr_stmt><expr><name>len_to_wrt</name> <operator>=</operator> <name>off</name> <operator>-</operator> <name>last_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len_to_wrt</name> <operator>-=</operator> <name>last_tok_len</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len_to_wrt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>norm_query</name> <operator>+</operator> <name>n_quer_loc</name></expr></argument>, <argument><expr><name>query</name> <operator>+</operator> <name>quer_loc</name></expr></argument>, <argument><expr><name>len_to_wrt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_quer_loc</name> <operator>+=</operator> <name>len_to_wrt</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * PG_HINT_PLAN: DON'T TAKE IN a6f22e8356 so that the designed behavior
		 * is kept stable.
		 */</comment>
		<comment type="block">/* And insert a '?' in place of the constant token */</comment>
		<expr_stmt><expr><name><name>norm_query</name><index>[<expr><name>n_quer_loc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>quer_loc</name> <operator>=</operator> <name>off</name> <operator>+</operator> <name>tok_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_off</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_tok_len</name> <operator>=</operator> <name>tok_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We've copied up until the last ignorable constant.  Copy over the
	 * remaining bytes of the original query string.
	 */</comment>
	<expr_stmt><expr><name>len_to_wrt</name> <operator>=</operator> <name>query_len</name> <operator>-</operator> <name>quer_loc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len_to_wrt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>norm_query</name> <operator>+</operator> <name>n_quer_loc</name></expr></argument>, <argument><expr><name>query</name> <operator>+</operator> <name>quer_loc</name></expr></argument>, <argument><expr><name>len_to_wrt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_quer_loc</name> <operator>+=</operator> <name>len_to_wrt</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_quer_loc</name> <operator>&lt;=</operator> <name>norm_query_buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_query</name><index>[<expr><name>n_quer_loc</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>query_len_p</name> <operator>=</operator> <name>n_quer_loc</name></expr>;</expr_stmt>
	<return>return <expr><name>norm_query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a valid SQL string and an array of constant-location records,
 * fill in the textual lengths of those constants.
 *
 * The constants may use any allowed constant syntax, such as float literals,
 * bit-strings, single-quoted strings and dollar-quoted strings.  This is
 * accomplished by using the public API for the core scanner.
 *
 * It is the caller's job to ensure that the string is a valid SQL statement
 * with constants at the indicated locations.  Since in practice the string
 * has already been parsed, and the locations that the caller provides will
 * have originated from within the authoritative parser, this should not be
 * a problem.
 *
 * Duplicate constant pointers are possible, and will have their lengths
 * marked as '-1', so that they are later ignored.  (Actually, we assume the
 * lengths were initialized as -1 to start with, and don't change them here.)
 *
 * If query_loc &gt; 0, then "query" has been advanced by that much compared to
 * the original string start, so we need to translate the provided locations
 * to compensate.  (This lets us avoid re-scanning statements before the one
 * of interest, so it's worth doing.)
 *
 * N.B. There is an assumption that a '-' character at a Const location begins
 * a negative numeric constant.  This precludes there ever being another
 * reason for a constant to start with a '-'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_in_constant_lengths</name><parameter_list>(<parameter><decl><type><name>pgssJumbleState</name> <modifier>*</modifier></type><name>jstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssLocationLen</name> <modifier>*</modifier></type><name>locs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_yyscan_t</name></type> <name>yyscanner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_yy_extra_type</name></type> <name>yyextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>core_YYSTYPE</name></type> <name>yylval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YYLTYPE</name></type>		<name>yylloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_loc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sort the records by location so that we can process them in order while
	 * scanning the query text.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr></argument>, <argument><expr><name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssLocationLen</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comp_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>locs</name> <operator>=</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialize the flex scanner --- should match raw_parser() */</comment>
	<expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <call><name>scanner_init</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>yyextra</name></expr></argument>,
							 <argument><expr><name>ScanKeywords</name></expr></argument>,
							 <argument><expr><name>NumScanKeywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't want to re-emit any escape string warnings */</comment>
	<expr_stmt><expr><name><name>yyextra</name><operator>.</operator><name>escape_string_warning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Search for each constant, in sequence */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jstate</name><operator>-&gt;</operator><name>clocations_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>loc</name> <init>= <expr><name><name>locs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>location</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tok</name></decl>;</decl_stmt>

		<comment type="block">/* Adjust recorded location if we're dealing with partial string */</comment>
		<expr_stmt><expr><name>loc</name> <operator>-=</operator> <name>query_loc</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>loc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;=</operator> <name>last_loc</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* Duplicate constant, ignore */</comment>

		<comment type="block">/* Lex tokens until we find the desired constant */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>core_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We should not hit end-of-string, but if we do, behave sanely */</comment>
			<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* out of inner for-loop */</comment>

			<comment type="block">/*
			 * We should find the token position exactly, but if we somehow
			 * run past it, work with that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>yylloc</name> <operator>&gt;=</operator> <name>loc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * It's a negative value - this is the one and only case
					 * where we replace more than a single token.
					 *
					 * Do not compensate for the core system's special-case
					 * adjustment of location to that of the leading '-'
					 * operator in the event of a negative constant.  It is
					 * also useful for our purposes to start from the minus
					 * symbol.  In this way, queries like "select * from foo
					 * where bar = 1" and "select * from foo where bar = -2"
					 * will have identical normalized query strings.
					 */</comment>
					<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>core_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* out of inner for-loop */</comment>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We now rely on the assumption that flex has placed a zero
				 * byte after the text of the current token in scanbuf.
				 */</comment>
				<expr_stmt><expr><name><name>locs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>yyextra</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* out of inner for-loop */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If we hit end-of-string, give up, leaving remaining lengths -1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>last_loc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>scanner_finish</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * comp_location: comparator for qsorting pgssLocationLen structs by location
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>comp_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>pgssLocationLen</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>pgssLocationLen</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
