<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/third-party-extensions/orafce/plvstr.c"><comment type="block">/*
  This code implements one part of functonality of
  free available library PL/Vision. Please look www.quest.com

  Original author: Steven Feuerstein, 1996 - 2002
  PostgreSQL implementation author: Pavel Stehule, 2006-2018

  This module is under BSD Licence

  History:
    1.0. first public version 13. March 2006
*/</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orafce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtins.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_rvrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_normalize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_is_prefix_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_is_prefix_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_is_prefix_int64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_lpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_rpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_lstrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_rstrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_substr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_substr3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_instr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_instr3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_instr4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_betwn_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_betwn_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvstr_swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_is_kind_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_is_kind_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plvchr_char_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>oracle_substr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>oracle_substr3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>ora_substr</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ora_substr_text</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ora_substr(PointerGetDatum((str)), (start), (len))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>char_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"NULL"</literal></expr>,<expr><literal type="string">"SOH"</literal></expr>,<expr><literal type="string">"STX"</literal></expr>,<expr><literal type="string">"ETX"</literal></expr>,<expr><literal type="string">"EOT"</literal></expr>,<expr><literal type="string">"ENQ"</literal></expr>,<expr><literal type="string">"ACK"</literal></expr>,<expr><literal type="string">"DEL"</literal></expr>,
	<expr><literal type="string">"BS"</literal></expr>,  <expr><literal type="string">"HT"</literal></expr>, <expr><literal type="string">"NL"</literal></expr>, <expr><literal type="string">"VT"</literal></expr>, <expr><literal type="string">"NP"</literal></expr>, <expr><literal type="string">"CR"</literal></expr>, <expr><literal type="string">"SO"</literal></expr>, <expr><literal type="string">"SI"</literal></expr>,
	<expr><literal type="string">"DLE"</literal></expr>, <expr><literal type="string">"DC1"</literal></expr>,<expr><literal type="string">"DC2"</literal></expr>,<expr><literal type="string">"DC3"</literal></expr>,<expr><literal type="string">"DC4"</literal></expr>,<expr><literal type="string">"NAK"</literal></expr>,<expr><literal type="string">"SYN"</literal></expr>,<expr><literal type="string">"ETB"</literal></expr>,
	<expr><literal type="string">"CAN"</literal></expr>, <expr><literal type="string">"EM"</literal></expr>,<expr><literal type="string">"SUB"</literal></expr>,<expr><literal type="string">"ESC"</literal></expr>,<expr><literal type="string">"FS"</literal></expr>,<expr><literal type="string">"GS"</literal></expr>,<expr><literal type="string">"RS"</literal></expr>,<expr><literal type="string">"US"</literal></expr>,<expr><literal type="string">"SP"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NON_EMPTY_CHECK</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>if (VARSIZE_ANY_EXHDR(str) == 0) \
	ereport(ERROR, \
			(errcode(ERRCODE_INVALID_PARAMETER_VALUE), \
			 errmsg("invalid parameter"), \
		 errdetail("Not allowed empty string.")));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMETER_ERROR</name><parameter_list>(<parameter><type><name>detail</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ereport(ERROR, \
		(errcode(ERRCODE_INVALID_PARAMETER_VALUE), \
		 errmsg("invalid parameter"), \
		 errdetail(detail)));</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_pg_mblen</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_pg_mblen</name></cpp:macro>	<cpp:value>pg_mblen</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>POSITION</name></decl>,
	<decl><name>FIRST</name></decl>,
	<decl><name>LAST</name></decl>
}</block></enum></type>  <name>position_mode</name>;</typedef>

<comment type="block">/*
 * Make substring, can handle negative start
 *
 */</comment>
<function><type><name>int</name></type>
<name>ora_mb_strlen</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sizes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>positions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>r_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cur_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>sizes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sizes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>r_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>positions</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>positions</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>r_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>cur</name> <operator>&lt;</operator> <name>r_len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>_pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sizes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sizes</name><operator>)</operator><index>[<expr><name>cur_size</name></expr>]</index> <operator>=</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>positions</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>positions</name><operator>)</operator><index>[<expr><name>cur_size</name></expr>]</index> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cur</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>cur_size</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>ora_mb_strlen1</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>r_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>r_len</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>r_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>_pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>r_len</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * len &lt; 0 means "length is not specified".
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>ora_substr</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* 0 is interpreted as 1 */</comment>
	<if type="elseif">else if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>	<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* save detoasted text */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>text_substr_no_len</name></expr></argument>,
			<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>text_substr</name></expr></argument>,
			<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* simply search algorhitm - can be better */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ora_instr_mb</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c_len_txt</name></decl>, <decl><type ref="prev"/><name>c_len_pat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>b_len_pat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>pos_txt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_txt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str_pat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>beg</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>dx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str_txt</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c_len_txt</name> <operator>=</operator> <call><name>ora_mb_strlen</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos_txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str_pat</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b_len_pat</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c_len_pat</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>str_pat</name></expr></argument>, <argument><expr><name>b_len_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <name>c_len_txt</name> <operator>-</operator> <name>c_len_pat</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of range */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>c_len_txt</name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>c_len_txt</name> <operator>-</operator> <name>c_len_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of range */</comment>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>dx</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>str_txt</name> <operator>+</operator> <name><name>pos_txt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>str_pat</name></expr></argument>, <argument><expr><name>b_len_pat</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>ora_instr</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len_txt</name></decl>, <decl><type ref="prev"/><name>len_pat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_txt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str_pat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>beg</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>dx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PARAMETER_ERROR</name><argument_list>(<argument><expr><literal type="string">"Four parameter isn't positive."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Forward for multibyte strings */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ora_instr_mb</name><argument_list>(<argument><expr><name>txt</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str_txt</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_txt</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str_pat</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_pat</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <name>len_txt</name> <operator>-</operator> <name>len_pat</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of range */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>len_txt</name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>len_txt</name> <operator>-</operator> <name>len_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of range */</comment>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>dx</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>str_txt</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>str_pat</name></expr></argument>, <argument><expr><name>len_pat</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.normalize
 *
 * Syntax:
 *   FUNCTION plvstr.normalize (string_in IN VARCHAR)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Normalize string - replace white chars by space, replace
 * spaces by space
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_normalize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aux</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aux_cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

	<decl_stmt><decl><type><name>__int64</name></type>			<name>l</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<decl_stmt><decl><type><name>int</name></type>				<name>l</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>write_spc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ignore_stsp</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>mb_encode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mb_encode</name> <operator>=</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aux_cur</name> <operator>=</operator> <name>aux</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>write_spc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>cur</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
			<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
			<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
			<case>case <expr><literal type="char">' '</literal></expr>:</case>
				<expr_stmt><expr><name>write_spc</name> <operator>=</operator> <ternary><condition><expr><name>ignore_stsp</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* ignore all other unvisible chars */</comment>

				<if_stmt><if>if <condition>(<expr><name>mb_encode</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>_pg_mblen</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>sz</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>write_spc</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>aux_cur</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>write_spc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

						</block_content>}</block></if></if_stmt>
						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>aux_cur</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>cur</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><name>ignore_stsp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>sz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<continue>continue;</continue>

				</block_content>}</block></if>
				<if type="elseif">else
					if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>write_spc</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>aux_cur</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>write_spc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>aux_cur</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>ignore_stsp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

		</block_content>}</block></switch>
		<expr_stmt><expr><name>cur</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>aux_cur</name> <operator>-</operator> <name>aux</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>l</name><operator>+</operator><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aux</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.instr
 *
 * Syntax:
 *   FUNCTION plvstr.instr (string_in VARCHAR, pattern VARCHAR)
 *   FUNCTION plvstr.instr (string_in VARCHAR, pattern VARCHAR,
 *            start_in INTEGER)
 *   FUNCTION plvstr.instr (string_in VARCHAR, pattern VARCHAR,
 *            start_in INTEGER, nth INTEGER)
 *            RETURN INT;
 *
 * Purpouse:
 *   Search pattern in string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_instr2</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ora_instr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvstr_instr3</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg3</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ora_instr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvstr_instr4</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg3</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arg4</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ora_instr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>arg4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.is_prefix
 *
 * Syntax:
 *   FUNCTION plvstr.is_prefix (string_in IN VARCHAR,
 *                    prefix_in VARCHAR,
 *                    case_sensitive BOOL := true)
 *      RETURN bool;
 *   FUNCTION plvstr.is_prefix (num_in IN NUMERIC,
 *                    prefix_in NUMERIC) RETURN bool;
 *   FUNCTION plvstr.is_prefix (int_in IN INT,
 *                    prefix_in INT)  RETURN bool;
 *
 * Purpouse:
 *   Returns true, if prefix_in is prefix of string_in
 *
 ****************************************************************/</comment>


<function><type><name>Datum</name></type>
<name>plvstr_is_prefix_text</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>case_sens</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>mb_encode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>str_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pref_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ap</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>


	<expr_stmt><expr><name>mb_encode</name> <operator>=</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mb_encode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>case_sens</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>lower</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pref_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>str_len</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>case_sens</name> <operator>||</operator> <name>mb_encode</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ap</name><operator>++</operator> <operator>!=</operator> <operator>*</operator><name>bp</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>mb_encode</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ap</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>bp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>pref_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvstr_is_prefix_int</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>prefix</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>prefix</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	</block_content>}</block> while <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>prefix</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvstr_is_prefix_int64</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>n</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>prefix</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>prefix</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	</block_content>}</block> while <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>prefix</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.rvrs
 *
 * Syntax:
 *   FUNCTION plvstr.rvrs (string_in IN VARCHAR,
 *					  start_in IN INTEGER := 1,
 *					  end_in IN INTEGER := NULL)
 *  	RETURN VARCHAR2;
 *
 * Purpouse:
 *   Reverse string or part of string
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_rvrs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>new_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>mb_encode</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mb_encode</name> <operator>=</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mb_encode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ora_mb_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>positions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>len</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>start</name> <operator>&gt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>start</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>start</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>start</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PARAMETER_ERROR</name><argument_list>(<argument><expr><literal type="string">"Second parameter is bigger than third."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>new_start</name></decl>, <decl><type ref="prev"/><name>new_end</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_start</name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_end</name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>new_end</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <name>new_start</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><name>start</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>start</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>end</name> <operator>&lt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>end</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_len</name> <operator>=</operator> <ternary><condition><expr><name>new_len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>new_len</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mb_encode</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>max_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cur_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>fz_size</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fz_size</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>max_size</name> <operator>=</operator> <operator>(</operator><name>new_len</name><operator>*</operator><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <name>fz_size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>fz_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>max_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cur_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>end</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&gt;=</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>data</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><name>j</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name>cur_size</name> <operator>+=</operator> <name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cur_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>new_len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>end</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>data</name><operator>++</operator> <operator>=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.lpart
 *
 * Syntax:
 *   FUNCTION PLVstr.lpart (string_in IN VARCHAR,
 *					   divider_in IN VARCHAR,
 *					   start_in IN INTEGER := 1,
 *					   nth_in IN INTEGER := 1,
 *					   all_if_notfound_in IN BOOLEAN := FALSE)
 *	RETURN VARCHAR2;
 *
 * Purpouse:
 *   Call this function to return the left part of a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_lpart</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>div</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nth</name>   <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>all_if_notfound</name>  <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>ora_instr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>div</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>all_if_notfound</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>TextPCopy</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>loc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.rpart
 *
 * Syntax:
 *   FUNCTION PLVstr.rpart (string_in IN VARCHAR,
 *					   divider_in IN VARCHAR,
 *					   start_in IN INTEGER := 1,
 *					   nth_in IN INTEGER := 1,
 *					   all_if_notfound_in IN BOOLEAN := FALSE)
 *	RETURN VARCHAR2;
 *
 * Purpouse:
 *   Call this function to return the right part of a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_rpart</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>div</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nth</name>   <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>all_if_notfound</name>  <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>loc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>ora_instr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>div</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>all_if_notfound</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>TextPCopy</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.lstrip
 *
 * Syntax:
 *   FUNCTION plvstr.lstrip (string_in IN VARCHAR,
 *							substring_in IN VARCHAR,
 *							num_in IN INTEGER := 1)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to remove characters from the beginning
 * (left) of a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_lstrip</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len_p</name></decl>, <decl><type ref="prev"/><name>len_s</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aux_str_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pat_p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>len_p</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_s</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>str_p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pat_p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aux_str_p</name> <operator>=</operator> <name>str_p</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len_s</name> <operator>&lt;</operator> <name>len_p</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_p</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>aux_str_p</name><operator>++</operator> <operator>!=</operator> <operator>*</operator><name>pat_p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>len_p</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* found */</comment>
			<expr_stmt><expr><name>str_p</name> <operator>=</operator> <name>aux_str_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len_s</name> <operator>-=</operator> <name>len_p</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>str_p</name></expr></argument>,<argument><expr><name>len_s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.rstrip
 *
 * Syntax:
 *   FUNCTION plvstr.rstrip (string_in IN VARCHAR,
 *							substring_in IN VARCHAR,
 *							num_in IN INTEGER := 1)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to remove characters from the end
 * (right) of a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_rstrip</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len_p</name></decl>, <decl><type ref="prev"/><name>len_s</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aux_str_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pat_p</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>len_p</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_s</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>str_p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len_s</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pat_p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len_p</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>aux_str_p</name> <operator>=</operator> <name>str_p</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len_s</name> <operator>&lt;</operator> <name>len_p</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_p</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>aux_str_p</name><operator>--</operator> <operator>!=</operator> <operator>*</operator><name>pat_p</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>len_p</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* found */</comment>
			<expr_stmt><expr><name>str_p</name> <operator>=</operator> <name>aux_str_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len_s</name> <operator>-=</operator> <name>len_p</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>len_s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.left
 *
 * Syntax:
 *   FUNCTION plvstr.left (string_in IN VARCHAR,
 *							num_in INTEGER)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns firs num_in charaters. You can use negative num_in
 *   left('abcde', -2) -&gt; abc
 *
 ****************************************************************/</comment>


<function><type><name>Datum</name></type>
<name>plvstr_left</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.right
 *
 * Syntax:
 *   FUNCTION plvstr.right (string_in IN VARCHAR,
 *							num_in INTEGER)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns last (right) num_in characters.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_right</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><name>n</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.substr2
 *
 * Syntax:
 *   FUNCTION plvstr.substr (string_in IN VARCHAR,
 *							start INTEGER)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns substring started on start_in to end
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_substr2</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>oracle_substr2</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVstr.substr3
 *
 * Syntax:
 *   FUNCTION plvstr.substr (string_in IN VARCHAR,
 *							start INTEGER, len INTEGER)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns len chars from start_in position
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_substr3</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>oracle_substr3</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.nth
 *
 * Syntax:
 *   FUNCTION plvchr.nth (string_in IN VARCHAR,
 * 					 nth_in IN INTEGER)
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to return the Nth character in a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvchr_nth</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.first
 *
 * Syntax:
 *   FUNCTION plvchr.first (string_in IN VARCHAR,
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to return the first character in a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvchr_first</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.last
 *
 * Syntax:
 *   FUNCTION plvchr.last (string_in IN VARCHAR,
 *  	RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to return the last character in a string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvchr_last</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.is_blank, plvchr.is_digit, ...
 *
 * Syntax:
 *   FUNCTION plvchr.is_kind (string_in IN VARCHAR,
 *      kind INT)
 *          RETURN VARCHAR;
 *
 * Purpouse:
 *   Call this function to see if a character is blank, ...
 *   1 blank, 2 digit, 3 quote, 4 other, 5 letter
 *
 ****************************************************************/</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_kind</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</return>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<return>return <expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</return>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>;</return>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<return>return
				<expr><operator>(</operator><literal type="number">32</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">47</literal><operator>)</operator> <operator>||</operator>
				<operator>(</operator><literal type="number">58</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">64</literal><operator>)</operator> <operator>||</operator>
				<operator>(</operator><literal type="number">91</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">96</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="number">123</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">126</literal><operator>)</operator></expr>;</return>
		<case>case <expr><literal type="number">5</literal></expr>:</case>
			<return>return <expr><operator>(</operator><literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="char">'a'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>PARAMETER_ERROR</name><argument_list>(<argument><expr><literal type="string">"Second parametr isn't in enum {1,2,3,4,5}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvchr_is_kind_i</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>k</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>is_kind</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>plvchr_is_kind_a</name> <parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>k</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NON_EMPTY_CHECK</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>_pg_mblen</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>( <argument><expr><operator>(</operator><name>k</name> <operator>==</operator> <literal type="number">5</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>is_kind</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.char_name
 *
 * Syntax:
 *   FUNCTION plvchr.char_name (letter_in IN VARCHAR)
 *   	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns the name of the character to ascii code as a VARCHAR.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvchr_char_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NON_EMPTY_CHECK</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>(</operator><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>char_names</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ora_substr_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>char_names</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * substr
 *
 * Syntax:
 *   FUNCTION substr (string, start_position, [length])
 *   	RETURN VARCHAR;
 *
 * Purpouse:
 *   Returns len chars from start_in position, compatible with Oracle
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>oracle_substr3</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>	<name>len</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>oracle_substr2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>text</name><modifier>*</modifier></type>
<name>ora_concat2</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>l1</name><operator>+</operator><name>l2</name><operator>+</operator><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>l1</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l1</name> <operator>+</operator> <name>l2</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>text</name><modifier>*</modifier></type>
<name>ora_concat3</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str2</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>str3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l3</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>l1</name><operator>+</operator><name>l2</name><operator>+</operator><name>l3</name><operator>+</operator><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>l1</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>l1</name><operator>+</operator><name>l2</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>l1</name> <operator>+</operator> <name>l2</name> <operator>+</operator> <name>l3</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.swap
 *
 * Syntax:
 *    FUNCTION swap
 *      (string_in IN VARCHAR2,
 *       replace_in IN VARCHAR2,
 *       start_in IN INTEGER := 1,
 *       oldlen_in IN INTEGER := NULL)
 *  RETURN VARCHAR2
 *
 * Purpouse:
 *   Replace a substring in a string with a specified string.
 *
 ****************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>plvstr_swap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>string_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>replace_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start_in</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>oldlen_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>v_len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>string_in</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>replace_in</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_in</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldlen_in</name> <operator>=</operator> <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>replace_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldlen_in</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>v_len</name> <operator>=</operator>  <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_in</name> <operator>=</operator> <ternary><condition><expr><name>start_in</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>start_in</name></expr> </then><else>: <expr><name>v_len</name> <operator>+</operator> <name>start_in</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>start_in</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>start_in</name> <operator>&gt;</operator> <name>v_len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>TextPCopy</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>start_in</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_concat2</name><argument_list>(
			<argument><expr><name>replace_in</name></expr></argument>, <argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><name>oldlen_in</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_concat3</name><argument_list>(
			<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>start_in</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>replace_in</name></expr></argument>,
			<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><name>start_in</name> <operator>+</operator> <name>oldlen_in</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************
 * PLVchr.betwn
 *
 * Find the Substring Between Start and End Locations
 *
 * Syntax:
 *     FUNCTION plvstr.betwn (string_in IN VARCHAR2,
 *       start_in IN INTEGER,
 *       end_in IN INTEGER,
 *       inclusive IN BOOLEAN := TRUE)
 *      RETURN VARCHAR2;
 *
 *     FUNCTION plvstr.betwn (string_in IN VARCHAR2,
 *       start_in IN VARCHAR2,
 *       end_in IN VARCHAR2 := NULL,
 *       startnth_in IN INTEGER := 1,
 *       endnth_in IN INTEGER := 1,
 *       inclusive IN BOOLEAN := TRUE,
 *       gotoend IN BOOLEAN := FALSE)
 *      RETURN VARCHAR2;
 *
 * Purpouse:
 *   Call this function to extract a sub-string from a string. This
 * function is overloaded. You can either provide the start and end
 * locations or you can provide start and end substrings.
 *
 ****************************************************************/</comment>


<function><type><name>Datum</name></type>
<name>plvstr_betwn_i</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>string_in</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start_in</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>end_in</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>inclusive</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>start_in</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>end_in</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>start_in</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>end_in</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>start_in</name> <operator>&gt;</operator> <name>end_in</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PARAMETER_ERROR</name><argument_list>(<argument><expr><literal type="string">"Wrong positions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>start_in</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>v_len</name> <init>=  <expr><call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>start_in</name> <operator>=</operator> <name>v_len</name> <operator>+</operator> <name>start_in</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_in</name> <operator>=</operator> <name>v_len</name> <operator>+</operator> <name>start_in</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inclusive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start_in</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_in</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>start_in</name> <operator>&gt;</operator> <name>end_in</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>,
									 <argument><expr><name>start_in</name></expr></argument>,
									 <argument><expr><name>end_in</name> <operator>-</operator> <name>start_in</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>plvstr_betwn_c</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>string_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>start_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>end_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>startnth_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>endnth_in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>inclusive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>gotoend</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>v_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>v_end</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><name>string_in</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_in</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_in</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>start_in</name></expr> </then><else>: <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>startnth_in</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endnth_in</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gotoend</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>startnth_in</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>v_start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_end</name> <operator>=</operator> <call><name>ora_instr</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><name>end_in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>endnth_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>v_start</name> <operator>=</operator> <call><name>ora_instr</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><name>start_in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>startnth_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_end</name> <operator>=</operator> <call><name>ora_instr</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>, <argument><expr><name>end_in</name></expr></argument>, <argument><expr><name>v_start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>endnth_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>v_start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inclusive</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>startnth_in</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>v_start</name> <operator>+=</operator> <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>start_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>v_end</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>v_end</name> <operator>+=</operator> <operator>(</operator><call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>end_in</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>v_start</name> <operator>&gt;</operator> <name>v_end</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>v_end</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>v_end</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>gotoend</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>v_end</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>v_end</name> <operator>=</operator> <call><name>ora_mb_strlen1</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>ora_substr_text</name><argument_list>(<argument><expr><name>string_in</name></expr></argument>,
									 <argument><expr><name>v_start</name></expr></argument>,
									 <argument><expr><name>v_end</name> <operator>-</operator> <name>v_start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
