<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/psql/copy.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 *
 * src/bin/psql/copy.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"copy.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>				<comment type="block">/* for isatty */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>					<comment type="block">/* I think */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prompt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * parse_slash_copy
 * -- parses \copy command line
 *
 * The documented syntax is:
 *	\copy tablename [(columnlist)] from|to filename [options]
 *	\copy ( query stmt ) to filename [options]
 *
 * where 'filename' can be one of the following:
 *	'&lt;file path&gt;' | PROGRAM '&lt;command&gt;' | stdin | stdout | pstdout | pstdout
 * and 'query' can be one of the following:
 *	SELECT | UPDATE | INSERT | DELETE
 *
 * An undocumented fact is that you can still write BINARY before the
 * tablename; this is a hangover from the pre-7.3 syntax.  The options
 * syntax varies across backend versions, but we avoid all that mess
 * by just transmitting the stuff after the filename literally.
 *
 * table name can be double-quoted and can have a schema part.
 * column names can be double-quoted.
 * filename can be single-quoted like SQL literals.
 * command must be single-quoted like SQL literals.
 *
 * returns a malloc'ed structure with the options, or NULL on parsing error
 */</comment>

<struct>struct <name>copy_options</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>before_tofrom</name></decl>;</decl_stmt>	<comment type="block">/* COPY string before TO/FROM */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>after_tofrom</name></decl>;</decl_stmt>	<comment type="block">/* COPY string after TO/FROM filename */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>			<comment type="block">/* NULL = stdin/stdout */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>program</name></decl>;</decl_stmt>		<comment type="block">/* is 'file' a program to popen? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>psql_inout</name></decl>;</decl_stmt>		<comment type="block">/* true = use psql stdin/stdout */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>from</name></decl>;</decl_stmt>			<comment type="block">/* true = FROM, false = TO */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_copy_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>copy_options</name></name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>after_tofrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* concatenate "more" onto "var", freeing the original value of *var */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xstrcat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>var</name></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>var</name> <operator>=</operator> <name>newvar</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>copy_options</name></name> <modifier>*</modifier></type>
<name>parse_slash_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>copy_options</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>whitespace</name> <init>= <expr><literal type="string">" \t\n\r"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>nonstd_backslash</name> <init>= <expr><ternary><condition><expr><call><name>standard_strings</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="char">'\\'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>args</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\copy: arguments required\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>copy_options</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* initialize for appending */</comment>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* The following can be removed when we drop 7.3 syntax support */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle COPY (query) case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>parens</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>parens</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">"()"</literal></expr></argument>, <argument><expr><literal type="string">"\"'"</literal></expr></argument>,
							<argument><expr><name>nonstd_backslash</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>parens</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>parens</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * strtokx() will not have returned a multi-character token starting with
	 * '.', so we don't need strcmp() here.  Likewise for '(', etc, below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handle schema . table */</comment>
		<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handle parenthesized column list */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">"()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">".,()"</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"to"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></else></if_stmt>

	<comment type="block">/* { 'filename' | PROGRAM 'command' | STDIN | STDOUT | PSTDIN | PSTDOUT } */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The shell command must be quoted. This isn't fool-proof, but
		 * catches most quoting errors.
		 */</comment>
		<expr_stmt><expr><name>toklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\''</literal> <operator>||</operator> <name>toklen</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>token</name><index>[<expr><name>toklen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>strip_quotes</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>program</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"pstdin"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"pstdout"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>psql_inout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* filename can be optionally quoted */</comment>
		<expr_stmt><expr><call><name>strip_quotes</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>expand_tilde</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Collect the rest of the line (COPY options) */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtokx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>token</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>after_tofrom</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>

<label><name>error</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>token</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\copy: parse error at \"%s\"\n"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\copy: parse error at end of line\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>free_copy_options</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Execute a \copy command (frontend copy). We have to open a file (or execute
 * a command), then submit a COPY query to the backend and either feed it data
 * from the file or route its response into the file.
 */</comment>
<function><type><name>bool</name></type>
<name>do_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>copystream</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>copy_options</name></name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

	<comment type="block">/* parse options */</comment>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>parse_slash_copy</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* prepare to read or write the target file */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>from</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>copystream</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>copystream</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>psql_inout</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>copystream</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>cur_cmd_source</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>copystream</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disable_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>copystream</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>copystream</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>psql_inout</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>copystream</name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>copystream</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copystream</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %s\n"</literal></expr></argument>,
					   <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>,
					   <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>free_copy_options</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<comment type="block">/* make sure the specified file is not a directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %s\n"</literal></expr></argument>,
					   <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s: cannot copy from/to a directory\n"</literal></expr></argument>,
					   <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_copy_options</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build the command we will send to the backend */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">"COPY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>before_tofrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>from</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM STDIN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><literal type="string">" TO STDOUT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>after_tofrom</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>after_tofrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* run it like a user command, but with copystream as data source/sink */</comment>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>copyStream</name></name> <operator>=</operator> <name>copystream</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>SendQuery</name><argument_list>(<argument><expr><name><name>query</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>copyStream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>program</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>pclose_rc</name> <init>= <expr><call><name>pclose</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>pclose_rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>pclose_rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not close pipe to external command: %s\n"</literal></expr></argument>,
							   <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reason</name> <init>= <expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>pclose_rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>reason</name></expr> ?</condition><then> <expr><name>reason</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>reason</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>restore_sigpipe_trap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>free_copy_options</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Functions for handling COPY IN/OUT data transfer.
 *
 * If you want to use COPY TO STDOUT/FROM STDIN in your application,
 * this is the code to steal ;)
 */</comment>

<comment type="block">/*
 * handleCopyOut
 * receives data as a result of a COPY ... TO STDOUT command
 *
 * conn should be a database connection that you just issued COPY TO on
 * and got back a PGRES_COPY_OUT result.
 *
 * copystream is the file stream for the data to go to.
 * copystream can be NULL to eat the data without writing it anywhere.
 *
 * The final status for the COPY is returned into *res (but note
 * we already reported the error, if it's not a success result).
 *
 * result is true if successful, false if not.
 */</comment>
<function><type><name>bool</name></type>
<name>handleCopyOut</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>copystream</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>OK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* done or server/connection error */</comment>

		<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>OK</name> <operator>&amp;&amp;</operator> <name>copystream</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>copystream</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ret</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not write COPY data: %s\n"</literal></expr></argument>,
						   <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* complain only once, keep reading data from server */</comment>
				<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>OK</name> <operator>&amp;&amp;</operator> <name>copystream</name> <operator>&amp;&amp;</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not write COPY data: %s\n"</literal></expr></argument>,
				   <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"COPY data transfer failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check command status and return to normal libpq state.
	 *
	 * If for some reason libpq is still reporting PGRES_COPY_OUT state, we
	 * would like to forcibly exit that state, since our caller would be
	 * unable to distinguish that situation from reaching the next COPY in a
	 * command string that happened to contain two consecutive COPY TO STDOUT
	 * commands.  However, libpq provides no API for doing that, and in
	 * principle it's a libpq bug anyway if PQgetCopyData() returns -1 or -2
	 * but hasn't exited COPY_OUT state internally.  So we ignore the
	 * possibility here.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * handleCopyIn
 * sends data to complete a COPY ... FROM STDIN command
 *
 * conn should be a database connection that you just issued COPY FROM on
 * and got back a PGRES_COPY_IN result.
 * copystream is the file stream to read the data from.
 * isbinary can be set from PQbinaryTuples().
 * The final status for the COPY is returned into *res (but note
 * we already reported the error, if it's not a success result).
 *
 * result is true if successful, false if not.
 */</comment>

<comment type="block">/* read chunk size for COPY IN - size is not critical */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYBUFSIZ</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<function><type><name>bool</name></type>
<name>handleCopyIn</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>copystream</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isbinary</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>OK</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>COPYBUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showprompt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Establish longjmp destination for exiting from wait-for-input. (This is
	 * only effective while sigint_interrupt_enabled is TRUE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>sigint_interrupt_jmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* got here with longjmp */</comment>

		<comment type="block">/* Terminate data transfer */</comment>
		<expr_stmt><expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>PQprotocolVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
					 <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"canceled by user"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>copyin_cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prompt if interactive input */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>showprompt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Enter data to be copied followed by a newline.\n"</literal>
				   <literal type="string">"End with a backslash and a period on a line by itself, or an EOF signal."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>showprompt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isbinary</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* interactive input probably silly, but give one prompt anyway */</comment>
		<if_stmt><if>if <condition>(<expr><name>showprompt</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name> <init>= <expr><call><name>get_prompt</name><argument_list>(<argument><expr><name>PROMPT_COPY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name></decl>;</decl_stmt>

			<comment type="block">/* enable longjmp while waiting for input */</comment>
			<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>COPYBUFSIZ</name></expr></argument>, <argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>copydone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>!</operator><name>copydone</name></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* for each input line ... */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>firstload</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>linedone</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>showprompt</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name> <init>= <expr><call><name>get_prompt</name><argument_list>(<argument><expr><name>PROMPT_COPY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>firstload</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>linedone</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>!</operator><name>linedone</name></expr>)</condition>
			<block>{<block_content>					<comment type="block">/* for each bufferload in line ... */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>linelen</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fgresult</name></decl>;</decl_stmt>

				<comment type="block">/* enable longjmp while waiting for input */</comment>
				<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>fgresult</name> <operator>=</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fgresult</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>copydone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>linelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* current line is done? */</comment>
				<if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>linelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>linedone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* check for EOF marker, but not on a partial line */</comment>
				<if_stmt><if>if <condition>(<expr><name>firstload</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * This code erroneously assumes '\.' on a line alone
					 * inside a quoted CSV string terminates the \copy.
					 * http://www.postgresql.org/message-id/E1TdNVQ-0001ju-GO@wrigleys.postgresql.org
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\.\n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						<call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\.\r\n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>copydone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>firstload</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>copydone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>copystream</name> <operator>==</operator> <name><name>pset</name><operator>.</operator><name>cur_cmd_source</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>lineno</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>stmt_lineno</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check for read error */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Terminate data transfer.  We can't send an error message if we're using
	 * protocol version 2.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name>OK</name> <operator>||</operator> <call><name>PQprotocolVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
					 <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"aborted because of read failure"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>copyin_cleanup</name>:</label>

	<comment type="block">/*
	 * Clear the EOF flag on the stream, in case copying ended due to an EOF
	 * signal.  This allows an interactive TTY session to perform another COPY
	 * FROM STDIN later.  (In non-STDIN cases, we're about to close the file
	 * anyway, so it doesn't matter.)  Although we don't ever test the flag
	 * with feof(), some fread() implementations won't read more data if it's
	 * set.  This also clears the error flag, but we already checked that.
	 */</comment>
	<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>copystream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check command status and return to normal libpq state.
	 *
	 * We do not want to return with the status still PGRES_COPY_IN: our
	 * caller would be unable to distinguish that situation from reaching the
	 * next COPY in a command string that happened to contain two consecutive
	 * COPY FROM STDIN commands.  We keep trying PQputCopyEnd() in the hope
	 * it'll work eventually.  (What's actually likely to happen is that in
	 * attempting to flush the data, libpq will eventually realize that the
	 * connection is lost.  But that's fine; it will get us out of COPY_IN
	 * state, which is what we need.)
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We can't send an error message if we're using protocol version 2 */</comment>
		<expr_stmt><expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>PQprotocolVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
					 <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"trying to exit copy mode"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><operator>*</operator><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>OK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>
</unit>
