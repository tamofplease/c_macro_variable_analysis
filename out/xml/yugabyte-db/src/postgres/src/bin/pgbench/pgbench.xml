<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/pgbench/pgbench.c"><comment type="block">/*
 * pgbench.c
 *
 * A simple benchmark program for PostgreSQL
 * Originally written by Tatsuo Ishii and enhanced by many contributors.
 *
 * src/bin/pgbench/pgbench.c
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 * ALL RIGHTS RESERVED;
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHOR OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR AND DISTRIBUTORS SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_SETSIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>			<comment type="block">/* set before winsock2.h is included */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ! WIN32 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/conditional.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>		<comment type="block">/* for getrlimit */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgbench.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></cpp:macro>  <cpp:value>"25P02"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></cpp:macro>  <cpp:value>"40001"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_T_R_DEADLOCK_DETECTED</name></cpp:macro>  <cpp:value>"40P01"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_UNDEFINED_TABLE</name></cpp:macro>  <cpp:value>"42P01"</cpp:value></cpp:define>

<comment type="block">/*
 * Hashing constants
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNV_PRIME</name></cpp:macro>			<cpp:value>UINT64CONST(0x100000001b3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNV_OFFSET_BASIS</name></cpp:macro>	<cpp:value>UINT64CONST(0xcbf29ce484222325)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MM2_MUL</name></cpp:macro>				<cpp:value>UINT64CONST(0xc6a4a7935bd1e995)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MM2_MUL_TIMES_8</name></cpp:macro>		<cpp:value>UINT64CONST(0x35253c9ade8f4ca8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MM2_ROT</name></cpp:macro>				<cpp:value>47</cpp:value></cpp:define>

<comment type="block">/*
 * Multi-platform pthread implementations
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* Use native win32 threads on Windows */</comment>
<typedef>typedef <type><name><name>struct</name> <name>win32_pthread</name></name> <modifier>*</modifier></type><name>pthread_t</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>pthread_attr_t</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pthread_create</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pthread_join</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>thread_return</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* Use platform-dependent pthread capability */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* No threads implementation, use none (-j 1) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pthread_t</name></cpp:macro> <cpp:value>void *</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/********************************************************************
 * some configurable parameters */</comment>

<comment type="block">/* max number of clients allowed */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_SETSIZE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCLIENTS</name></cpp:macro>	<cpp:value>(FD_SETSIZE - 10)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCLIENTS</name></cpp:macro>	<cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_INIT_STEPS</name></cpp:macro> <cpp:value>"dtgp"</cpp:value></cpp:define>	<comment type="block">/* default -I setting */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_STEP_SECONDS</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>	<comment type="block">/* seconds between log messages */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_NXACTS</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>		<comment type="block">/* default nxacts */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPF_CACHE_SIZE</name></cpp:macro>	<cpp:value>15</cpp:value></cpp:define>		<comment type="block">/* cache cells number */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_GAUSSIAN_PARAM</name></cpp:macro>		<cpp:value>2.0</cpp:value></cpp:define> <comment type="block">/* minimum parameter for gauss */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ZIPFIAN_PARAM</name></cpp:macro>		<cpp:value>1000</cpp:value></cpp:define>	<comment type="block">/* maximum parameter for zipfian */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>nxacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* number of transactions per client */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>duration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* duration in seconds */</comment>
<decl_stmt><decl><type><name>int64</name></type>		<name>end_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* when to stop in micro seconds, under -T */</comment>

<comment type="block">/*
 * scaling factor. for example, scale = 10 will make 1000000 tuples in
 * ysql_bench_accounts table.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>scale</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * fillfactor. for example, fillfactor = 90 will use only 90 percent
 * space during inserts and leave 10 percent free.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>fillfactor</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>			<name>set_fillfactor</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * use unlogged tables?
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>unlogged_tables</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * log sampling rate (1.0 = log everything, 0.0 = option not given)
 */</comment>
<decl_stmt><decl><type><name>double</name></type>		<name>sample_rate</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * When threads are throttled to a given rate limit, this is the target delay
 * to reach that rate in usec.  0 is the default and means no throttling.
 */</comment>
<decl_stmt><decl><type><name>int64</name></type>		<name>throttle_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Transactions which take longer than this limit (in usec) are counted as
 * late, and reported as such, although they are completed anyway. When
 * throttling is enabled, execution time slots that are more than this late
 * are skipped altogether, and counted separately.
 */</comment>
<decl_stmt><decl><type><name>int64</name></type>		<name>latency_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * tablespace selection
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>index_tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* random seed used to initialize base_random_sequence */</comment>
<decl_stmt><decl><type><name>int64</name></type>		<name>random_seed</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * end of configurable parameters
 *********************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nbranches</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>			<comment type="block">/* Makes little sense to change this.  Change
								 * -s instead */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ntellers</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>naccounts</name></cpp:macro>	<cpp:value>100000</cpp:value></cpp:define>

<comment type="block">/*
 * The scale factor at/beyond which 32bit integers are incapable of storing
 * 64bit values.
 *
 * Although the actual threshold is 21474, we use 20000 because it is easier to
 * document and remember, and isn't that far away from the real threshold.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCALE_32BIT_THRESHOLD</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type>		<name>use_log</name></decl>;</decl_stmt>			<comment type="block">/* log transaction latencies to a file */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>use_quiet</name></decl>;</decl_stmt>			<comment type="block">/* quiet logging onto stderr */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>agg_interval</name></decl>;</decl_stmt>		<comment type="block">/* log aggregates instead of individual
								 * transactions */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>per_script_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* whether to collect stats per script */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>progress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* thread progress report every this seconds */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>progress_timestamp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* progress report with Unix time */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>nclients</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* number of clients */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>nthreads</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* number of threads */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>is_connect</name></decl>;</decl_stmt>			<comment type="block">/* establish connection for each transaction */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>report_per_command</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* report per-command latencies, retries
										 * after the failures and errors
										 * (failures without retrying) */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>main_pid</name></decl>;</decl_stmt>			<comment type="block">/* main process id used in log filename */</comment>
<decl_stmt><decl><type><name>uint32</name></type>		<name>batch_size</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* Batch size used for a transaction */</comment>

<comment type="block">/*
 * There're different types of restrictions for deciding that the current failed
 * transaction can no longer be retried and should be reported as failed:
 * - max_tries can be used to limit the number of tries;
 * - latency_limit can be used to limit the total time of tries.
 *
 * They can be combined together, and you need to use at least one of them to
 * retry the failed transactions. By default, failed transactions are not
 * retried at all.
 */</comment>
<decl_stmt><decl><type><name>uint32</name></type>		<name>max_tries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* we cannot retry a failed transaction if its
								 * number of tries reaches this maximum; if its
								 * value is zero, it is not used */</comment>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pghost</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pgport</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>login</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>logfile_prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WSEP</name></cpp:macro> <cpp:value>'@'</cpp:value></cpp:define>				<comment type="block">/* weight separator */</comment>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>timer_exceeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* flag from signal handler */</comment>

<comment type="block">/*
 * Variable definitions.
 *
 * If a variable only has a string value, "svalue" is that value, and value is
 * "not set".  If the value is known, "value" contains the value (in any
 * variant).
 *
 * In this case "svalue" contains the string equivalent of the value, if we've
 * had occasion to compute that, or NULL if we haven't.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* variable's name */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>svalue</name></decl>;</decl_stmt>			<comment type="block">/* its value in string form, if known */</comment>
	<decl_stmt><decl><type><name>PgBenchValue</name></type> <name>value</name></decl>;</decl_stmt>			<comment type="block">/* actual variable's value */</comment>
}</block></struct></type> <name>Variable</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SCRIPTS</name></cpp:macro>		<cpp:value>128</cpp:value></cpp:define>		<comment type="block">/* max number of SQL scripts allowed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHELL_COMMAND_SIZE</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define> <comment type="block">/* maximum size allowed for shell command */</comment>

<comment type="block">/*
 * Simple data structure to keep stats about something.
 *
 * XXX probably the first value should be kept and used as an offset for
 * better numerical stability...
 */</comment>
<typedef>typedef <type><struct>struct <name>SimpleStats</name>
<block>{
	<decl_stmt><decl><type><name>int64</name></type>		<name>count</name></decl>;</decl_stmt>			<comment type="block">/* how many values were encountered */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>min</name></decl>;</decl_stmt>			<comment type="block">/* the minimum seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>max</name></decl>;</decl_stmt>			<comment type="block">/* the maximum seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>sum</name></decl>;</decl_stmt>			<comment type="block">/* sum of values */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>sum2</name></decl>;</decl_stmt>			<comment type="block">/* sum of squared values */</comment>
}</block></struct></type> <name>SimpleStats</name>;</typedef>

<comment type="block">/*
 * Data structure to hold various statistics: per-thread and per-script stats
 * are maintained and merged together.
 */</comment>
<typedef>typedef <type><struct>struct <name>StatsData</name>
<block>{
	<decl_stmt><decl><type><name>time_t</name></type>		<name>start_time</name></decl>;</decl_stmt>		<comment type="block">/* interval start time, for aggregates */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>cnt</name></decl>;</decl_stmt>			<comment type="block">/* number of sucessfull transactions, including
								 * skipped */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>skipped</name></decl>;</decl_stmt>		<comment type="block">/* number of transactions skipped under --rate
								 * and --latency-limit */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>retries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>retried</name></decl>;</decl_stmt>		<comment type="block">/* number of transactions that were retried
								 * after a serialization or a deadlock
								 * failure */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>errors</name></decl>;</decl_stmt>			<comment type="block">/* number of transactions that were not retried
								 * after a serialization or a deadlock
								 * failure or had another error (including meta
								 * commands errors) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>errors_in_failed_tx</name></decl>;</decl_stmt>	<comment type="block">/* number of transactions that failed in
										 * a error
										 * ERRCODE_IN_FAILED_SQL_TRANSACTION */</comment>
	<decl_stmt><decl><type><name>SimpleStats</name></type> <name>latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStats</name></type> <name>lag</name></decl>;</decl_stmt>
}</block></struct></type> <name>StatsData</name>;</typedef>

<comment type="block">/* Various random sequences are initialized from this one. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name><name>base_random_sequence</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * Data structure for client variables.
 */</comment>
<typedef>typedef <type><struct>struct <name>Variables</name>
<block>{
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>			<comment type="block">/* array of variable definitions */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvariables</name></decl>;</decl_stmt>		<comment type="block">/* number of variables */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>vars_sorted</name></decl>;</decl_stmt>	<comment type="block">/* are variables sorted by name? */</comment>
}</block></struct></type> <name>Variables</name>;</typedef>

<comment type="block">/*
 * Data structure for thread/client random seed.
 */</comment>
<typedef>typedef <type><struct>struct <name>RandomState</name>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RandomState</name>;</typedef>

<comment type="block">/*
 * Data structure for repeating a transaction from the beginnning with the same
 * parameters.
 */</comment>
<typedef>typedef <type><struct>struct <name>RetryState</name>
<block>{
	<decl_stmt><decl><type><name>RandomState</name></type> <name>random_state</name></decl>;</decl_stmt>	<comment type="block">/* random seed */</comment>
	<decl_stmt><decl><type><name>Variables</name></type>   <name>variables</name></decl>;</decl_stmt>		<comment type="block">/* client variables */</comment>
}</block></struct></type> <name>RetryState</name>;</typedef>

<comment type="block">/*
 * For the failures during script execution.
 */</comment>
<typedef>typedef <type><enum>enum <name>FailureStatus</name>
<block>{
	<decl><name>NO_FAILURE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>ANOTHER_FAILURE</name></decl>,			<comment type="block">/* other failures that are not listed by
								 * themselves below */</comment>
	<decl><name>SERIALIZATION_FAILURE</name></decl>,
	<decl><name>DEADLOCK_FAILURE</name></decl>,
	<decl><name>IN_FAILED_SQL_TRANSACTION</name></decl>
}</block></enum></type> <name>FailureStatus</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Failure</name>
<block>{
	<decl_stmt><decl><type><name>FailureStatus</name></type> <name>status</name></decl>;</decl_stmt>		<comment type="block">/* type of the failure */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>command</name></decl>;</decl_stmt>		<comment type="block">/* command number in script where the failure
								 * occurred */</comment>
}</block></struct></type> <name>Failure</name>;</typedef>

<comment type="block">/*
 * Connection state machine states.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<comment type="block">/*
	 * The client must first choose a script to execute.  Once chosen, it can
	 * either be throttled (state CSTATE_START_THROTTLE under --rate) or start
	 * right away (state CSTATE_START_TX).
	 */</comment>
	<decl><name>CSTATE_CHOOSE_SCRIPT</name></decl>,

	<comment type="block">/*
	 * In CSTATE_START_THROTTLE state, we calculate when to begin the next
	 * transaction, and advance to CSTATE_THROTTLE.  CSTATE_THROTTLE state
	 * sleeps until that moment.  (If throttling is not enabled, doCustom()
	 * falls directly through from CSTATE_START_THROTTLE to CSTATE_START_TX.)
	 */</comment>
	<decl><name>CSTATE_START_THROTTLE</name></decl>,
	<decl><name>CSTATE_THROTTLE</name></decl>,

	<comment type="block">/*
	 * CSTATE_START_TX performs start-of-transaction processing.  Establishes
	 * a new connection for the transaction, in --connect mode, and records
	 * the transaction start time.
	 */</comment>
	<decl><name>CSTATE_START_TX</name></decl>,

	<comment type="block">/*
	 * We loop through these states, to process each command in the script:
	 *
	 * CSTATE_START_COMMAND starts the execution of a command.  On a SQL
	 * command, the command is sent to the server, and we move to
	 * CSTATE_WAIT_RESULT state.  On a \sleep meta-command, the timer is set,
	 * and we enter the CSTATE_SLEEP state to wait for it to expire. Other
	 * meta-commands are executed immediately.
	 *
	 * CSTATE_SKIP_COMMAND for conditional branches which are not executed,
	 * quickly skip commands that do not need any evaluation.
	 *
	 * CSTATE_WAIT_RESULT waits until we get a result set back from the server
	 * for the current command.
	 *
	 * CSTATE_SLEEP waits until the end of \sleep.
	 *
	 * CSTATE_END_COMMAND records the end-of-command timestamp, increments the
	 * command counter, and loops back to CSTATE_START_COMMAND state.
	 */</comment>
	<decl><name>CSTATE_START_COMMAND</name></decl>,
	<decl><name>CSTATE_SKIP_COMMAND</name></decl>,
	<decl><name>CSTATE_WAIT_RESULT</name></decl>,
	<decl><name>CSTATE_SLEEP</name></decl>,
	<decl><name>CSTATE_END_COMMAND</name></decl>,

	<comment type="block">/*
	 * States for transactions with serialization or deadlock failures.
	 *
	 * First, remember the failure in CSTATE_FAILURE. Then process other
	 * commands of the failed transaction if any and go to CSTATE_RETRY. If we
	 * can re-execute the transaction from the very beginning, report this as a
	 * failure, set the same parameters for the transaction execution as in the
	 * previous tries and process the first transaction command in
	 * CSTATE_START_COMMAND. Otherwise, report this as an error, set the
	 * parameters for the transaction execution as they were before the first
	 * run of this transaction (except for a random state) and go to
	 * CSTATE_END_TX to complete this transaction.
	 */</comment>
	<decl><name>CSTATE_FAILURE</name></decl>,
	<decl><name>CSTATE_RETRY</name></decl>,

	<comment type="block">/*
	 * CSTATE_END_TX performs end-of-transaction processing.  Calculates
	 * latency, and logs the transaction.  In --connect mode, closes the
	 * current connection.  Chooses the next script to execute and starts over
	 * in CSTATE_START_THROTTLE state, or enters CSTATE_FINISHED if we have no
	 * more work to do.
	 */</comment>
	<decl><name>CSTATE_END_TX</name></decl>,

	<comment type="block">/*
	 * Final states.  CSTATE_ABORTED means that the script execution was
	 * aborted because a command failed, CSTATE_FINISHED means success.
	 */</comment>
	<decl><name>CSTATE_ABORTED</name></decl>,
	<decl><name>CSTATE_FINISHED</name></decl>
}</block></enum></type> <name>ConnectionStateEnum</name>;</typedef>

<comment type="block">/*
 * Connection state.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>			<comment type="block">/* connection handle to DB */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>id</name></decl>;</decl_stmt>				<comment type="block">/* client No. */</comment>
	<decl_stmt><decl><type><name>ConnectionStateEnum</name></type> <name>state</name></decl>;</decl_stmt>	<comment type="block">/* state machine's current state. */</comment>
	<decl_stmt><decl><type><name>ConditionalStack</name></type> <name>cstack</name></decl>;</decl_stmt>	<comment type="block">/* enclosing conditionals state */</comment>
	<decl_stmt><decl><type><name>RandomState</name></type> <name>random_state</name></decl>;</decl_stmt>	<comment type="block">/* separate randomness for each client */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>use_file</name></decl>;</decl_stmt>		<comment type="block">/* index in sql_script for this client */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>command</name></decl>;</decl_stmt>		<comment type="block">/* command number in script */</comment>

	<comment type="block">/* client variables */</comment>
	<decl_stmt><decl><type><name>Variables</name></type>   <name>variables</name></decl>;</decl_stmt>

	<comment type="block">/* various times about current transaction */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>txn_scheduled</name></decl>;</decl_stmt>	<comment type="block">/* scheduled start time of transaction (usec) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>sleep_until</name></decl>;</decl_stmt>	<comment type="block">/* scheduled start time of next cmd (usec) */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>txn_begin</name></decl>;</decl_stmt>		<comment type="block">/* used for measuring schedule lag times */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>stmt_begin</name></decl>;</decl_stmt>		<comment type="block">/* used for measuring statement latencies */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name><name>prepared</name><index>[<expr><name>MAX_SCRIPTS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* whether client prepared the script */</comment>

	<comment type="block">/*
	 * For processing errors and repeating transactions with serialization or
	 * deadlock failures:
	 */</comment>
	<decl_stmt><decl><type><name>Failure</name></type>		<name>first_failure</name></decl>;</decl_stmt>	<comment type="block">/* status and command number of the first
								 * failure in the current transaction execution;
								 * status NO_FAILURE if there were no failures
								 * or errors */</comment>
	<decl_stmt><decl><type><name>RetryState</name></type>  <name>retry_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>retries</name></decl>;</decl_stmt>	<comment type="block">/* how many times have we already retried the
								 * current transaction? */</comment>

	<comment type="block">/* per client collected stats */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>cnt</name></decl>;</decl_stmt>			<comment type="block">/* client transaction count, for -t */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ecnt</name></decl>;</decl_stmt>			<comment type="block">/* error count */</comment>
}</block></struct></type> <name>CState</name>;</typedef>

<comment type="block">/*
 * Cache cell for random_zipfian call
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* cell keys */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>s</name></decl>;</decl_stmt>				<comment type="block">/* s - parameter of random_zipfian function */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>n</name></decl>;</decl_stmt>				<comment type="block">/* number of elements in range (max - min + 1) */</comment>

	<decl_stmt><decl><type><name>double</name></type>		<name>harmonicn</name></decl>;</decl_stmt>		<comment type="block">/* generalizedHarmonicNumber(n, s) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>alpha</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>beta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>eta</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>last_used</name></decl>;</decl_stmt>		<comment type="block">/* last used logical time */</comment>
}</block></struct></type> <name>ZipfCell</name>;</typedef>

<comment type="block">/*
 * Zipf cache for zeta values
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>current</name></decl>;</decl_stmt>		<comment type="block">/* counter for LRU cache replacement algorithm */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>nb_cells</name></decl>;</decl_stmt>		<comment type="block">/* number of filled cells */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>overflowCount</name></decl>;</decl_stmt>	<comment type="block">/* number of cache overflows */</comment>
	<decl_stmt><decl><type><name>ZipfCell</name></type>	<name><name>cells</name><index>[<expr><name>ZIPF_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ZipfCache</name>;</typedef>

<comment type="block">/*
 * Thread state
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>tid</name></decl>;</decl_stmt>			<comment type="block">/* thread id */</comment>
	<decl_stmt><decl><type><name>pthread_t</name></type>	<name>thread</name></decl>;</decl_stmt>			<comment type="block">/* thread handle */</comment>
	<decl_stmt><decl><type><name>CState</name>	   <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>			<comment type="block">/* array of CState */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nstate</name></decl>;</decl_stmt>			<comment type="block">/* length of state[] */</comment>
	<decl_stmt><decl><type><name>RandomState</name></type> <name>random_state</name></decl>;</decl_stmt> 	<comment type="block">/* separate randomness for each thread */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>throttle_trigger</name></decl>;</decl_stmt>	<comment type="block">/* previous/next throttling (us) */</comment>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>logfile</name></decl>;</decl_stmt>		<comment type="block">/* where to log, or NULL */</comment>
	<decl_stmt><decl><type><name>ZipfCache</name></type>	<name>zipf_cache</name></decl>;</decl_stmt>		<comment type="block">/* for thread-safe  zipfian random number
								 * generation */</comment>

	<comment type="block">/* per thread collected stats */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>start_time</name></decl>;</decl_stmt>		<comment type="block">/* thread start time */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>conn_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatsData</name></type>	<name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>latency_late</name></decl>;</decl_stmt>	<comment type="block">/* executed but late transactions (including
								 * errors) */</comment>
}</block></struct></type> <name>TState</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_THREAD</name></cpp:macro>		<cpp:value>((pthread_t) 0)</cpp:value></cpp:define>

<comment type="block">/*
 * queries read from files
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_COMMAND</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COMMAND</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ARGS</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>MetaCommand</name>
<block>{
	<decl><name>META_NONE</name></decl>,					<comment type="block">/* not a known meta-command */</comment>
	<decl><name>META_SET</name></decl>,					<comment type="block">/* \set */</comment>
	<decl><name>META_SETSHELL</name></decl>,				<comment type="block">/* \setshell */</comment>
	<decl><name>META_SHELL</name></decl>,					<comment type="block">/* \shell */</comment>
	<decl><name>META_SLEEP</name></decl>,					<comment type="block">/* \sleep */</comment>
	<decl><name>META_IF</name></decl>,					<comment type="block">/* \if */</comment>
	<decl><name>META_ELIF</name></decl>,					<comment type="block">/* \elif */</comment>
	<decl><name>META_ELSE</name></decl>,					<comment type="block">/* \else */</comment>
	<decl><name>META_ENDIF</name></decl>					<comment type="block">/* \endif */</comment>
}</block></enum></type> <name>MetaCommand</name>;</typedef>

<typedef>typedef <type><enum>enum <name>QueryMode</name>
<block>{
	<decl><name>QUERY_SIMPLE</name></decl>,				<comment type="block">/* simple query */</comment>
	<decl><name>QUERY_EXTENDED</name></decl>,				<comment type="block">/* extended query */</comment>
	<decl><name>QUERY_PREPARED</name></decl>,				<comment type="block">/* extended query with prepared statements */</comment>
	<decl><name>NUM_QUERYMODE</name></decl>
}</block></enum></type> <name>QueryMode</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>QueryMode</name></type> <name>querymode</name> <init>= <expr><name>QUERY_SIMPLE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>QUERYMODE</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"simple"</literal></expr>, <expr><literal type="string">"extended"</literal></expr>, <expr><literal type="string">"prepared"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>			<comment type="block">/* text of command line */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>command_num</name></decl>;</decl_stmt>	<comment type="block">/* unique index of this Command struct */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>;</decl_stmt>			<comment type="block">/* command type (SQL_COMMAND or META_COMMAND) */</comment>
	<decl_stmt><decl><type><name>MetaCommand</name></type> <name>meta</name></decl>;</decl_stmt>			<comment type="block">/* meta command identifier, or META_NONE */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>argc</name></decl>;</decl_stmt>			<comment type="block">/* number of command words */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>argv</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* command word list */</comment>
	<decl_stmt><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* parsed expression, if needed */</comment>
	<decl_stmt><decl><type><name>SimpleStats</name></type> <name>stats</name></decl>;</decl_stmt>			<comment type="block">/* time spent in this command */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>retries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>errors</name></decl>;</decl_stmt>			<comment type="block">/* number of failures that were not retried */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>errors_in_failed_tx</name></decl>;</decl_stmt>	<comment type="block">/* number of errors
										 * ERRCODE_IN_FAILED_SQL_TRANSACTION */</comment>
}</block></struct></type> <name>Command</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParsedScript</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>			<comment type="block">/* script descriptor (eg, file name) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>			<comment type="block">/* selection weight */</comment>
	<decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name></decl>;</decl_stmt>		<comment type="block">/* NULL-terminated array of Commands */</comment>
	<decl_stmt><decl><type><name>StatsData</name></type>	<name>stats</name></decl>;</decl_stmt>			<comment type="block">/* total time spent in script */</comment>
}</block></struct></type> <name>ParsedScript</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ParsedScript</name></type> <name><name>sql_script</name><index>[<expr><name>MAX_SCRIPTS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* SQL script files */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_scripts</name></decl>;</decl_stmt>		<comment type="block">/* number of scripts in sql_script[] */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_commands</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* total number of Command structs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>total_weight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <name>DebugLevel</name>
<block>{
	<decl><name>NO_DEBUG</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,				<comment type="block">/* no debugging output (except PGBENCH_DEBUG) */</comment>
	<decl><name>DEBUG_FAILS</name></decl>,				<comment type="block">/* print only failure messages, errors and
								 * retries */</comment>
	<decl><name>DEBUG_ALL</name></decl>,					<comment type="block">/* print all debugging output (throttling,
								 * executed/sent/received commands etc.) */</comment>
	<decl><name>NUM_DEBUGLEVEL</name></decl>
}</block></enum></type> <name>DebugLevel</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>DebugLevel</name></type> <name>debug_level</name> <init>= <expr><name>NO_DEBUG</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* debug flag */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>DEBUGLEVEL</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><literal type="string">"fails"</literal></expr>, <expr><literal type="string">"all"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Builtin test scripts */</comment>
<typedef>typedef <type><struct>struct <name>BuiltinScript</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* very short name for -b ... */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>			<comment type="block">/* short description */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>script</name></decl>;</decl_stmt>			<comment type="block">/* actual pgbench script */</comment>
}</block></struct></type> <name>BuiltinScript</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BuiltinScript</name></type> <name><name>builtin_script</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><literal type="string">"tpcb-like"</literal></expr>,
		<expr><literal type="string">"&lt;builtin: TPC-B (sort of)&gt;"</literal></expr>,
		<expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
		<literal type="string">"BEGIN;\n"</literal>
		<literal type="string">"UPDATE ysql_bench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\n"</literal>
		<literal type="string">"SELECT abalance FROM ysql_bench_accounts WHERE aid = :aid;\n"</literal>
		<literal type="string">"UPDATE ysql_bench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;\n"</literal>
		<literal type="string">"UPDATE ysql_bench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;\n"</literal>
		<literal type="string">"INSERT INTO ysql_bench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
		<literal type="string">"END;\n"</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"simple-update"</literal></expr>,
		<expr><literal type="string">"&lt;builtin: simple update&gt;"</literal></expr>,
		<expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set bid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>nbranches</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set tid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>ntellers</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"\\set delta random(-5000, 5000)\n"</literal>
		<literal type="string">"BEGIN;\n"</literal>
		<literal type="string">"UPDATE ysql_bench_accounts SET abalance = abalance + :delta WHERE aid = :aid;\n"</literal>
		<literal type="string">"SELECT abalance FROM ysql_bench_accounts WHERE aid = :aid;\n"</literal>
		<literal type="string">"INSERT INTO ysql_bench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);\n"</literal>
		<literal type="string">"END;\n"</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"select-only"</literal></expr>,
		<expr><literal type="string">"&lt;builtin: select only&gt;"</literal></expr>,
		<expr><literal type="string">"\\set aid random(1, "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>naccounts</name></expr></argument>)</argument_list></call> <literal type="string">" * :scale)\n"</literal>
		<literal type="string">"SELECT abalance FROM ysql_bench_accounts WHERE aid = :aid;\n"</literal></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <name>ErrorLevel</name>
<block>{
	<comment type="block">/*
	 * To report throttling, executed/sent/received commands etc.
	 */</comment>
	<decl><name>ELEVEL_DEBUG</name></decl>,

	<comment type="block">/*
	 * Normal failure of the SQL/meta command, or processing of the failed
	 * transaction (its end/retry).
	 */</comment>
	<decl><name>ELEVEL_LOG_CLIENT_FAIL</name></decl>,

	<comment type="block">/*
	 * Something serious e.g. connection with the backend was lost.. therefore
	 * abort the client.
	 */</comment>
	<decl><name>ELEVEL_LOG_CLIENT_ABORTED</name></decl>,

	<comment type="block">/*
	 * To report the error/log messages of the main program and/or
	 * PGBENCH_DEBUG.
	 */</comment>
	<decl><name>ELEVEL_LOG_MAIN</name></decl>,

	<comment type="block">/*
	 * To report the error messages of the main program and to exit immediately.
	 */</comment>
	<decl><name>ELEVEL_FATAL</name></decl>
}</block></enum></type> <name>ErrorLevel</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ErrorData</name>
<block>{
	<decl_stmt><decl><type><name>ErrorLevel</name></type>	<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>message</name></decl>;</decl_stmt>
}</block></struct></type> <name>ErrorData</name>;</typedef>

<typedef>typedef <type><name>ErrorData</name> <modifier>*</modifier></type><name>Error</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* use the local ErrorData in ereport */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ERROR_DATA</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>ErrorData edata;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errstart</name><parameter_list>(<parameter><type><name>elevel</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>errstartImpl(&amp;edata, elevel)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errmsg</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>errmsgImpl(&amp;edata, __VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errfinish</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>errfinishImpl(&amp;edata, __VA_ARGS__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !(ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS) */</comment>
<comment type="block">/* use the global ErrorData in ereport... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ERROR_DATA</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Error</name></type> <name>error</name> <init>= <expr><operator>&amp;</operator><name>edata</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ...and protect it with a mutex if necessary */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>error_mutex</name> <init>= <expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errstart</name></cpp:macro>	<cpp:value>errstartImpl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errmsg</name></cpp:macro>		<cpp:value>errmsgImpl</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errfinish</name></cpp:macro>	<cpp:value>errfinishImpl</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS */</comment>

<comment type="block">/*
 * Error reporting API: to be used in this way:
 *		ereport(ELEVEL_LOG,
 *				(errmsg("connection to database \"%s\" failed\n", dbName),
 *				... other errxxx() fields as needed ...));
 *
 * The error level is required, and so is a primary error message. All else is
 * optional.
 *
 * If elevel &gt;= ELEVEL_FATAL, the call will not return; we try to inform the
 * compiler of that via abort(). However, no useful optimization effect is
 * obtained unless the compiler sees elevel as a compile-time constant, else
 * we're just adding code bloat. So, if __builtin_constant_p is available, use
 * that to cause the second if() to vanish completely for non-constant cases. We
 * avoid using a local variable because it's not necessary and prevents gcc from
 * making the unreachability deduction at optlevel -O0.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE__BUILTIN_CONSTANT_P</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ereport</name><parameter_list>(<parameter><type><name>elevel</name></type></parameter>, <parameter><type><name>rest</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		LOCAL_ERROR_DATA() \
		if (errstart(elevel)) \
			errfinish rest; \
		if (__builtin_constant_p(elevel) &amp;&amp; (elevel) &gt;= ELEVEL_FATAL) \
			abort(); \
	} while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE__BUILTIN_CONSTANT_P */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ereport</name><parameter_list>(<parameter><type><name>elevel</name></type></parameter>, <parameter><type><name>rest</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		const int elevel_ = (elevel); \
		LOCAL_ERROR_DATA() \
		if (errstart(elevel_)) \
			errfinish rest; \
		if (elevel_ &gt;= ELEVEL_FATAL) \
			abort(); \
	} while(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE__BUILTIN_CONSTANT_P */</comment>


<comment type="block">/* Function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setNullValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setBoolValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setIntValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ival</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setDoubleValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>evaluateExpr</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doLog</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
	  <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>latency</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processXactStats</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgbench_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addScript</name><parameter_list>(<parameter><decl><type><name>ParsedScript</name></type> <name>script</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>threadRun</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finishCon</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>errstartImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>ErrorLevel</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>errmsgImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>errfinishImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !(ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS) */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>errstartImpl</name><parameter_list>(<parameter><decl><type><name>ErrorLevel</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>errmsgImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>errfinishImpl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS */</comment>

<comment type="block">/* callback functions for our flex lexer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PsqlScanCallbacks</name></type> <name>pgbench_callbacks</name> <init>= <expr><block>{
	<expr><name>NULL</name></expr>,						<comment type="block">/* don't need get_variable functionality */</comment>
	<expr><name>pgbench_error</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s is a benchmarking tool for YSQL.\n\n"</literal>
		   <literal type="string">"Usage:\n"</literal>
		   <literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal>
		   <literal type="string">"\nInitialization options:\n"</literal>
		   <literal type="string">"  -i, --initialize         invokes initialization mode\n"</literal>
		   <literal type="string">"  -I, --init-steps=[dtgvpf]+ (default \"dtgp\")\n"</literal>
		   <literal type="string">"                           run selected initialization steps\n"</literal>
		   <literal type="string">"  -F, --fillfactor=NUM     set fill factor\n"</literal>
		   <literal type="string">"  -n, --no-vacuum          do not run VACUUM during initialization\n"</literal>
		   <literal type="string">"  -q, --quiet              quiet logging (one message each 5 seconds)\n"</literal>
		   <literal type="string">"  -s, --scale=NUM          scaling factor\n"</literal>
		   <literal type="string">"  --foreign-keys           create foreign key constraints between tables\n"</literal>
		   <literal type="string">"  --index-tablespace=TABLESPACE\n"</literal>
		   <literal type="string">"                           create indexes in the specified tablespace\n"</literal>
		   <literal type="string">"  --tablespace=TABLESPACE  create tables in the specified tablespace\n"</literal>
		   <literal type="string">"  --unlogged-tables        create tables as unlogged tables\n"</literal>
		   <literal type="string">"\nOptions to select what to run:\n"</literal>
		   <literal type="string">"  -b, --builtin=NAME[@W]   add builtin script NAME weighted at W (default: 1)\n"</literal>
		   <literal type="string">"                           (use \"-b list\" to list available scripts)\n"</literal>
		   <literal type="string">"  -f, --file=FILENAME[@W]  add script FILENAME weighted at W (default: 1)\n"</literal>
		   <literal type="string">"  -N, --skip-some-updates  skip updates of ysql_bench_tellers and ysql_bench_branches\n"</literal>
		   <literal type="string">"                           (same as \"-b simple-update\")\n"</literal>
		   <literal type="string">"  -S, --select-only        perform SELECT-only transactions\n"</literal>
		   <literal type="string">"                           (same as \"-b select-only\")\n"</literal>
		   <literal type="string">"\nBenchmarking options:\n"</literal>
		   <literal type="string">"  -c, --client=NUM         number of concurrent database clients (default: 1)\n"</literal>
		   <literal type="string">"  -C, --connect            establish new connection for each transaction\n"</literal>
		   <literal type="string">"  -D, --define=VARNAME=VALUE\n"</literal>
		   <literal type="string">"                           define variable for use by custom script\n"</literal>
		   <literal type="string">"  -j, --jobs=NUM           number of threads (default: 1)\n"</literal>
		   <literal type="string">"  -l, --log                write transaction times to log file\n"</literal>
		   <literal type="string">"  -L, --latency-limit=NUM  count transactions lasting more than NUM ms as late\n"</literal>
		   <literal type="string">"  -M, --protocol=simple|extended|prepared\n"</literal>
		   <literal type="string">"                           protocol for submitting queries (default: simple)\n"</literal>
		   <literal type="string">"  -n, --no-vacuum          do not run VACUUM before tests\n"</literal>
		   <literal type="string">"  -P, --progress=NUM       show thread progress report every NUM seconds\n"</literal>
		   <literal type="string">"  -r, --report-per-command report latencies, errors and retries per command\n"</literal>
		   <literal type="string">"  -R, --rate=NUM           target rate in transactions per second\n"</literal>
		   <literal type="string">"  -s, --scale=NUM          report this scale factor in output\n"</literal>
		   <literal type="string">"  -t, --transactions=NUM   number of transactions each client runs (default: 10)\n"</literal>
		   <literal type="string">"  -T, --time=NUM           duration of benchmark test in seconds\n"</literal>
		   <literal type="string">"  -v, --vacuum-all         vacuum all four standard tables before tests\n"</literal>
		   <literal type="string">"  --aggregate-interval=NUM aggregate data over NUM seconds\n"</literal>
		   <literal type="string">"  --log-prefix=PREFIX      prefix for transaction time log file\n"</literal>
		   <literal type="string">"                           (default: \"ysql_bench_log\")\n"</literal>
		   <literal type="string">"  --max-tries=NUM          max number of tries to run transaction\n"</literal>
		   <literal type="string">"  --progress-timestamp     use Unix epoch timestamps for progress\n"</literal>
		   <literal type="string">"  --random-seed=SEED       set random seed (\"time\", \"rand\", integer)\n"</literal>
		   <literal type="string">"  --sampling-rate=NUM      fraction of transactions to log (e.g., 0.01 for 1%%)\n"</literal>
		   <literal type="string">"  --batch-size=NUM         batch size for a transaction\n"</literal>
		   <literal type="string">"\nCommon options:\n"</literal>
		   <literal type="string">"  -d, --debug=no|fails|all print debugging output (default: no)\n"</literal>
		   <literal type="string">"  -h, --host=HOSTNAME      database server host or socket directory\n"</literal>
		   <literal type="string">"  -p, --port=PORT          database server port number\n"</literal>
		   <literal type="string">"  -U, --username=USERNAME  connect as specified database user\n"</literal>
		   <literal type="string">"  -V, --version            output version information, then exit\n"</literal>
		   <literal type="string">"  -?, --help               show this help, then exit\n"</literal>
		   <literal type="string">"\n"</literal>
		   <literal type="string">"Report bugs on https://github.com/YugaByte/yugabyte-db/issues/new.\n"</literal></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return whether str matches "^\s*[-+]?[0-9]+$" */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_an_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* skip leading spaces; cast is consistent with strtoint64 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* skip sign */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* at least one digit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* eat all digits */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* must have reached end of string */</comment>
	<return>return <expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * strtoint64 -- convert a string to 64-bit integer
 *
 * This function is a modified version of scanint8() from
 * src/backend/utils/adt/int8.c.
 */</comment>
<function><type><name>int64</name></type>
<name>strtoint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do our own scan, rather than relying on sscanf which might be broken
	 * for long long.
	 */</comment>

	<comment type="block">/* skip leading spaces */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* handle sign */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do an explicit check for INT64_MIN.  Ugly though this is, it's
		 * cleaner than trying to get the loop below to handle it portably.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"9223372036854775808"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>PG_INT64_MIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">19</literal></expr>;</expr_stmt>
			<goto>goto <name>gotdigits</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* require at least one digit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for integer: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* process digits */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>tmp</name> <init>= <expr><name>result</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator> <operator>!=</operator> <name>result</name></expr>)</condition>	<comment type="block">/* overflow? */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value \"%s\" is out of range for type bigint\n"</literal></expr></argument>,
							<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></while>

<label><name>gotdigits</name>:</label>

	<comment type="block">/* allow trailing whitespace, but not other trailing chars */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for integer: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>result</name></expr> </then><else>: <expr><name>result</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Random number generator: uniform distribution from min to max inclusive.
 *
 * Although the limits are expressed as int64, you can't generate the full
 * int64 range in one call, because the difference of the limits mustn't
 * overflow int64.  In practice it's unwise to ask for more than an int32
 * range, because of the limited precision of pg_erand48().
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getrand</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Odd coding is so that min and max have approximately the same chance of
	 * being selected as do numbers between them.
	 *
	 * pg_erand48() is thread-safe and concurrent, which is why we use it
	 * rather than random(), which in glibc is non-reentrant, and therefore
	 * protected by a mutex, and therefore a bottleneck on machines with many
	 * CPUs.
	 */</comment>
	<return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * random number generator: exponential distribution from min to max inclusive.
 * the parameter is so that the density of probability for the last cut-off max
 * value is exp(-parameter).
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getExponentialRand</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>,
				   <parameter><decl><type><name>double</name></type> <name>parameter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>cut</name></decl>,
				<decl><type ref="prev"/><name>uniform</name></decl>,
				<decl><type ref="prev"/><name>rand</name></decl>;</decl_stmt>

	<comment type="block">/* abort if wrong parameter, but must really be checked beforehand */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parameter</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cut</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* erand in [0, 1), uniform in (0, 1] */</comment>
	<expr_stmt><expr><name>uniform</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * inner expression in (cut, 1] (if parameter &gt; 0), rand in [0, 1)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cut</name><operator>)</operator> <operator>!=</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rand</name> <operator>=</operator> <operator>-</operator><call><name>log</name><argument_list>(<argument><expr><name>cut</name> <operator>+</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>cut</name><operator>)</operator> <operator>*</operator> <name>uniform</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>parameter</name></expr>;</expr_stmt>
	<comment type="block">/* return int64 random number within between min and max */</comment>
	<return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>rand</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* random number generator: gaussian distribution from min to max inclusive */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getGaussianRand</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>,
				<parameter><decl><type><name>double</name></type> <name>parameter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>stdev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rand</name></decl>;</decl_stmt>

	<comment type="block">/* abort if parameter is too low, but must really be checked beforehand */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parameter</name> <operator>&gt;=</operator> <name>MIN_GAUSSIAN_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get user specified random number from this loop, with -parameter &lt;
	 * stdev &lt;= parameter
	 *
	 * This loop is executed until the number is in the expected range.
	 *
	 * As the minimum parameter is 2.0, the probability of looping is low:
	 * sqrt(-2 ln(r)) &lt;= 2 =&gt; r &gt;= e^{-2} ~ 0.135, then when taking the
	 * average sinus multiplier as 2/pi, we have a 8.6% looping probability in
	 * the worst case. For a parameter value of 5.0, the looping probability
	 * is about e^{-5} * 2 / pi ~ 0.43%.
	 */</comment>
	<do>do
	<block>{<block_content>
		<comment type="block">/*
		 * pg_erand48 generates [0,1), but for the basic version of the
		 * Box-Muller transform the two uniformly distributed random numbers
		 * are expected in (0, 1] (see
		 * https://en.wikipedia.org/wiki/Box-Muller_transform)
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>rand1</name> <init>= <expr><literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>rand2</name> <init>= <expr><literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Box-Muller basic form transform */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>var_sqrt</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2.0</literal> <operator>*</operator> <call><name>log</name><argument_list>(<argument><expr><name>rand1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>stdev</name> <operator>=</operator> <name>var_sqrt</name> <operator>*</operator> <call><name>sin</name><argument_list>(<argument><expr><literal type="number">2.0</literal> <operator>*</operator> <name>M_PI</name> <operator>*</operator> <name>rand2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we may try with cos, but there may be a bias induced if the
		 * previous value fails the test. To be on the safe side, let us try
		 * over.
		 */</comment>
	</block_content>}</block>
	while <condition>(<expr><name>stdev</name> <operator>&lt;</operator> <operator>-</operator><name>parameter</name> <operator>||</operator> <name>stdev</name> <operator>&gt;=</operator> <name>parameter</name></expr>)</condition>;</do>

	<comment type="block">/* stdev is in [-parameter, parameter), normalization to [0,1) */</comment>
	<expr_stmt><expr><name>rand</name> <operator>=</operator> <operator>(</operator><name>stdev</name> <operator>+</operator> <name>parameter</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>parameter</name> <operator>*</operator> <literal type="number">2.0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* return int64 random number within between min and max */</comment>
	<return>return <expr><name>min</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>rand</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * random number generator: generate a value, such that the series of values
 * will approximate a Poisson distribution centered on the given value.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getPoissonRand</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>center</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Use inverse transform sampling to generate a value &gt; 0, such that the
	 * expected (i.e. average) value is the given argument.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>uniform</name></decl>;</decl_stmt>

	<comment type="block">/* erand in [0, 1), uniform in (0, 1] */</comment>
	<expr_stmt><expr><name>uniform</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>-</operator><call><name>log</name><argument_list>(<argument><expr><name>uniform</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>center</name><operator>)</operator> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function for getZipfianRand */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>generalizedHarmonicNumber</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ans</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ans</name> <operator>+=</operator> <call><name>pow</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>ans</name> <operator>+</operator> <literal type="number">1.0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set harmonicn and other parameters to cache cell */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>zipfSetCacheCell</name><parameter_list>(<parameter><decl><type><name>ZipfCell</name> <modifier>*</modifier></type><name>cell</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>harmonic2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>harmonic2</name> <operator>=</operator> <call><name>generalizedHarmonicNumber</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>harmonicn</name></name> <operator>=</operator> <call><name>generalizedHarmonicNumber</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>alpha</name></name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>s</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>beta</name></name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">0.5</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>eta</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">2.0</literal> <operator>/</operator> <name>n</name></expr></argument>, <argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>harmonic2</name> <operator>/</operator> <name><name>cell</name><operator>-&gt;</operator><name>harmonicn</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * search for cache cell with keys (n, s)
 * and create new cell if it does not exist
 */</comment>
<function><type><specifier>static</specifier> <name>ZipfCell</name> <modifier>*</modifier></type>
<name>zipfFindOrCreateCacheCell</name><parameter_list>(<parameter><decl><type><name>ZipfCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>least_recently_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ZipfCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* search cached cell for given parameters */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>nb_cells</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cell</name> <operator>=</operator> <operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>n</name></name> <operator>==</operator> <name>n</name> <operator>&amp;&amp;</operator> <name><name>cell</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>last_used</name></name> <operator>&lt;</operator> <name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>least_recently_used</name></expr>]</index></name><operator>.</operator><name>last_used</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>least_recently_used</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* create new one if it does not exist */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>nb_cells</name></name> <operator>&lt;</operator> <name>ZIPF_CACHE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>nb_cells</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* replace LRU cell if cache is full */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>least_recently_used</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>overflowCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>zipfSetCacheCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_used</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Computing zipfian using rejection method, based on
 * "Non-Uniform Random Variate Generation",
 * Luc Devroye, p. 550-551, Springer 1986.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>computeIterativeZipfian</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>b</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>, <argument><expr><name>s</name> <operator>-</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>x</name></decl>,
				<decl><type ref="prev"/><name>t</name></decl>,
				<decl><type ref="prev"/><name>u</name></decl>,
				<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* random variates */</comment>
		<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>s</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>+</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>x</name></expr></argument>, <argument><expr><name>s</name> <operator>-</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* reject if too large or out of bound */</comment>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>*</operator> <name>x</name> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>b</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>&lt;=</operator> <name>t</name> <operator>/</operator> <name>b</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Computing zipfian using harmonic numbers, based on algorithm described in
 * "Quickly Generating Billion-Record Synthetic Databases",
 * Jim Gray et al, SIGMOD 1994
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>computeHarmonicZipfian</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>n</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ZipfCell</name>   <modifier>*</modifier></type><name>cell</name> <init>= <expr><call><name>zipfFindOrCreateCacheCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>zipf_cache</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>uniform</name> <init>= <expr><call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>uz</name> <init>= <expr><name>uniform</name> <operator>*</operator> <name><name>cell</name><operator>-&gt;</operator><name>harmonicn</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>uz</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>uz</name> <operator>&lt;</operator> <literal type="number">1.0</literal> <operator>+</operator> <name><name>cell</name><operator>-&gt;</operator><name>beta</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name><name>cell</name><operator>-&gt;</operator><name>n</name></name> <operator>*</operator> <call><name>pow</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>eta</name></name> <operator>*</operator> <name>uniform</name> <operator>-</operator> <name><name>cell</name><operator>-&gt;</operator><name>eta</name></name> <operator>+</operator> <literal type="number">1.0</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>alpha</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* random number generator: zipfian distribution from min to max inclusive */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getZipfianRand</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>min</name></decl></parameter>,
			   <parameter><decl><type><name>int64</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>n</name> <init>= <expr><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* abort if parameter is invalid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>s</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>s</name> <operator>!=</operator> <literal type="number">1.0</literal> <operator>&amp;&amp;</operator> <name>s</name> <operator>&lt;=</operator> <name>MAX_ZIPFIAN_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<return>return <expr><name>min</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>s</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>
					  ?</condition><then> <expr><call><name>computeIterativeZipfian</name><argument_list>(<argument><expr><name>random_state</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>
					  </then><else>: <expr><call><name>computeHarmonicZipfian</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>random_state</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FNV-1a hash function
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getHashFnv1a</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FNV_OFFSET_BASIS</name> <operator>^</operator> <name>seed</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>octet</name> <init>= <expr><name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>^</operator> <name>octet</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>*</operator> <name>FNV_PRIME</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Murmur2 hash function
 *
 * Based on original work of Austin Appleby
 * https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getHashMurmur2</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name> <init>= <expr><name>seed</name> <operator>^</operator> <name>MM2_MUL_TIMES_8</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* sizeof(int64) */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>k</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>val</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>MM2_MUL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>^=</operator> <name>k</name> <operator>&gt;&gt;</operator> <name>MM2_ROT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>MM2_MUL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>*=</operator> <name>MM2_MUL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>result</name> <operator>&gt;&gt;</operator> <name>MM2_ROT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>*=</operator> <name>MM2_MUL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>^=</operator> <name>result</name> <operator>&gt;&gt;</operator> <name>MM2_ROT</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the given SimpleStats struct to all zeroes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate one value into a SimpleStats struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addToSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>val</name> <operator>&gt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name> <operator>+=</operator> <name>val</name> <operator>*</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Merge two SimpleStats objects
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mergeSimpleStats</name><parameter_list>(<parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>, <parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name> <operator>&lt;</operator> <name><name>acc</name><operator>-&gt;</operator><name>min</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>min</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name> <operator>&gt;</operator> <name><name>acc</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>sum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>sum2</name></name> <operator>+=</operator> <name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a StatsData struct to mostly zeroes, with its start time set to
 * the given value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initStats</name><parameter_list>(<parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>start_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>start_time</name></name> <operator>=</operator> <name>start_time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>skipped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>retries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>retried</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sd</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate one additional item into the given stats object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accumStats</name><parameter_list>(<parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>,
		   <parameter><decl><type><name>FailureStatus</name></type> <name>first_error</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>retries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Record the number of retries regardless of whether the transaction was
	 * successful or failed.
	 */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>retries</name></name> <operator>+=</operator> <name>retries</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>retries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>retried</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Record the failed transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name>first_error</name> <operator>!=</operator> <name>NO_FAILURE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>errors</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_error</name> <operator>==</operator> <name>IN_FAILED_SQL_TRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Record the successful transaction */</comment>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>skipped</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no latency to record on skipped transactions */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>skipped</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>, <argument><expr><name>lat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and possibly the same for schedule lag */</comment>
		<if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>lag</name></name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* call PQexec() and exit() on failure */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>executeStatement</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* call PQexec() and complain, but without exiting, on failure */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tryExecuteStatement</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s(ignoring this error and continuing anyway)\n"</literal></expr></argument>,
						<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* set up a connection to the backend */</comment>
<function><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type>
<name>doConnect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_password</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>password</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start the connection.  Loop until we have a password if requested by
	 * backend.
	 */</comment>
	<do>do
	<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMS_ARRAY_SIZE</name></cpp:macro>	<cpp:value>7</cpp:value></cpp:define>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keywords</name><index>[<expr><name>PARAMS_ARRAY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>values</name><index>[<expr><name>PARAMS_ARRAY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pghost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pgport</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>login</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>have_password</name></expr> ?</condition><then> <expr><name>password</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>dbName</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>progname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to database \"%s\" failed\n"</literal></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>&amp;&amp;</operator>
			<call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>have_password</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>new_pass</name></expr>)</condition>;</do>

	<comment type="block">/* check to see that the backend connection was successfully made */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to database \"%s\" failed:\n%s"</literal></expr></argument>,
						<argument><expr><name>dbName</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* throw away response from backend */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>discard_response</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>res</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* qsort comparator for Variable array */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compareVariableNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Variable</name> <operator>*</operator><operator>)</operator> <name>v1</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>,
				  <argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Variable</name> <operator>*</operator><operator>)</operator> <name>v2</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Locate a variable by name; returns NULL if unknown */</comment>
<function><type><specifier>static</specifier> <name>Variable</name> <modifier>*</modifier></type>
<name>lookupVariable</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name></type>	<name>key</name></decl>;</decl_stmt>

	<comment type="block">/* On some versions of Solaris, bsearch of zero items dumps core */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Sort if we have to */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>variables</name><operator>-&gt;</operator><name>vars_sorted</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>variables</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compareVariableNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>variables</name><operator>-&gt;</operator><name>vars_sorted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we can search */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>variables</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,
								<argument><expr><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name></expr></argument>,
								<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								<argument><expr><name>compareVariableNames</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the value of a variable, in string form; returns NULL if unknown */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getVariable</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>stringform</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not found */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* we have it in string form */</comment>

	<comment type="block">/* We need to produce a string equivalent of the value */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>PGBT_NO_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_BOOLEAN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>u</name><operator>.</operator><name>bval</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* internal error, unexpected type */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>stringform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Try to convert variable to a value; return false on failure */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>makeVariableValue</name><parameter_list>(<parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>slen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>PGBT_NO_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no work */</comment>

	<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* what should it do on ""? */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * accept prefixes such as y, ye, n, no... but not for "o". 0/1 are
	 * recognized later as an int, which is converted to bool if needed.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"of"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_an_int</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><call><name>strtoint64</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* type should be double */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>dv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>xs</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>, <argument><expr><literal type="string">"%lf%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed variable \"%s\" value: \"%s\"\n"</literal></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether a variable's name is allowed.
 *
 * We allow any non-ASCII character, as well as ASCII letters, digits, and
 * underscore.
 *
 * Keep this in sync with the definitions of variable name characters in
 * "src/fe_utils/psqlscan.l", "src/bin/psql/psqlscanslash.l" and
 * "src/bin/pgbench/exprscan.l".  Also see parseVariable(), below.
 *
 * Note: this static function is copied from "src/bin/psql/variables.c"
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valid_variable_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>name</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Mustn't be zero-length */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal> <literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
				   <literal type="string">"_0123456789"</literal></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup a variable by name, creating it if need be.
 * Caller is expected to assign a value to the variable.
 * On failure (bad name): if this is a client run returns NULL; exits the
 * program otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>Variable</name> <modifier>*</modifier></type>
<name>lookupCreateVariable</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>newvars</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for the name only when declaring a new variable to avoid
		 * overhead.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_variable_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * About the error level used: if we process client commands, it a
			 * normal failure; otherwise it is not and we exit the program.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>client</name></expr> ?</condition><then> <expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr> </then><else>: <expr><name>ELEVEL_FATAL</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: invalid variable name: \"%s\"\n"</literal></expr></argument>,
							<argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Create variable at the end of the array */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>variables</name><operator>-&gt;</operator><name>array</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newvars</name> <operator>=</operator> <operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>variables</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newvars</name> <operator>=</operator> <operator>(</operator><name>Variable</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>variables</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <name>newvars</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>&amp;</operator><name><name>newvars</name><index>[<expr><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* caller is expected to initialize remaining fields */</comment>

		<expr_stmt><expr><name><name>variables</name><operator>-&gt;</operator><name>nvariables</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* we don't re-sort the array till we have to */</comment>
		<expr_stmt><expr><name><name>variables</name><operator>-&gt;</operator><name>vars_sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assign a string value to a variable, creating it if need be */</comment>
<comment type="block">/* Exits on failure (bad name) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>putVariable</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupCreateVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dup then free, in case value is pointing at this variable */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PGBT_NO_VALUE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a value to a variable, creating it if need be.
 * On failure (bad name): if this is a client run returns false; exits the
 * program otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>putVariableValue</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>PgBenchValue</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lookupCreateVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assign an integer value to a variable, creating it if need be.
 * On failure (bad name): if this is a client run returns false; exits the
 * program otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>putVariableInt</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			   <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgBenchValue</name></type> <name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>putVariableValue</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a possible variable reference (:varname).
 *
 * "sql" points at a colon.  If what follows it looks like a valid
 * variable name, return a malloc'd string containing the variable name,
 * and set *eaten to the number of characters consumed.
 * Otherwise, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parseVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>eaten</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name><name>sql</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal> <literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
					<literal type="string">"_0123456789"</literal></expr></argument>, <argument><expr><name><name>sql</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no valid variable name chars */</comment>

	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sql</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>name</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>eaten</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>replaceVariable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>valueln</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>valueln</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>offset</name> <init>= <expr><name>param</name> <operator>-</operator> <operator>*</operator><name>sql</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>sql</name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>sql</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>sql</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name> <operator>+</operator> <name>valueln</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>param</name> <operator>=</operator> <operator>*</operator><name>sql</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>valueln</name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>param</name> <operator>+</operator> <name>valueln</name></expr></argument>, <argument><expr><name>param</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>param</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>param</name> <operator>+</operator> <name>valueln</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>assignVariables</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>name</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>eaten</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>parseVariable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>replaceVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>eaten</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>sql</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getQueryParams</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Command</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>valueTypeName</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NO_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"none"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"null"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"int"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"double"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_BOOLEAN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"boolean"</literal></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* internal error, should never get there */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* get a value as a boolean, or tell if there is a problem */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>coerceToBool</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>bval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_BOOLEAN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bval</name> <operator>=</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bval</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* NULL, INT or DOUBLE */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot coerce %s to boolean\n"</literal></expr></argument>, <argument><expr><call><name>valueTypeName</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* suppress uninitialized-variable warnings */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return true or false from an expression for conditional purposes.
 * Non zero numerical values are true, zero and NULL are false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valueTruth</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGBT_NULL</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>PGBT_BOOLEAN</name></expr>:</case>
			<return>return <expr><name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bval</name></name></expr>;</return>
		<case>case <expr><name>PGBT_INT</name></expr>:</case>
			<return>return <expr><name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>PGBT_DOUBLE</name></expr>:</case>
			<return>return <expr><name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name> <operator>!=</operator> <literal type="number">0.0</literal></expr>;</return>
		<default>default:</default>
			<comment type="block">/* internal error, unexpected type */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* get a value as an int, tell if there is a problem */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>coerceToInt</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>ival</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ival</name> <operator>=</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>dval</name> <init>= <expr><name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Cast to avoid -Wimplicit-int-float-conversion */</comment>
		<if_stmt><if>if <condition>(<expr><name>dval</name> <operator>&lt;</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>PG_INT64_MIN</name> <operator>||</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>PG_INT64_MAX</name> <operator>&lt;</operator> <name>dval</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"double to int overflow for %f\n"</literal></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>ival</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>dval</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* BOOLEAN or NULL */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot coerce %s to int\n"</literal></expr></argument>, <argument><expr><call><name>valueTypeName</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* get a value as a double, or tell if there is a problem */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>coerceToDouble</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>dval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dval</name> <operator>=</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dval</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>pval</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* BOOLEAN or NULL */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot coerce %s to double\n"</literal></expr></argument>, <argument><expr><call><name>valueTypeName</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* assign a null value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setNullValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* assign a boolean value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setBoolValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_BOOLEAN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bval</name></name> <operator>=</operator> <name>bval</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* assign an integer value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setIntValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ival</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_INT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name>ival</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* assign a double value */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setDoubleValue</name><parameter_list>(<parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>pv</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>PGBT_DOUBLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name> <operator>=</operator> <name>dval</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isLazyFunc</name><parameter_list>(<parameter><decl><type><name>PgBenchFunction</name></type> <name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>func</name> <operator>==</operator> <name>PGBENCH_AND</name> <operator>||</operator> <name>func</name> <operator>==</operator> <name>PGBENCH_OR</name> <operator>||</operator> <name>func</name> <operator>==</operator> <name>PGBENCH_CASE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* lazy evaluation of some functions */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evalLazyFunc</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
			 <parameter><decl><type><name>PgBenchFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgBenchValue</name></type> <name>a1</name></decl>,
				<decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ba1</name></decl>,
				<decl><type ref="prev"/><name>ba2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>isLazyFunc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>args</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* args points to first condition */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* second condition for AND/OR and corresponding branch for CASE */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>func</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGBENCH_AND</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToBool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ba1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ba1</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>a2</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>coerceToBool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ba2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ba2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>PGBENCH_OR</name></expr>:</case>

			<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToBool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ba1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ba1</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>a2</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>coerceToBool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ba2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ba2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

		<case>case <expr><name>PGBENCH_CASE</name></expr>:</case>
			<comment type="block">/* when true, execute branch */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>valueTruth</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* now args contains next condition or final else expression */</comment>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

			<comment type="block">/* final else case? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* no, another when, proceed */</comment>
			<return>return <expr><call><name>evalLazyFunc</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>PGBENCH_CASE</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<comment type="block">/* internal error, cannot get here */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* maximum number of function arguments */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FARGS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
 * Recursive evaluation of standard functions,
 * which do not require lazy evaluation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evalStandardFunc</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
				 <parameter><decl><type><name>PgBenchFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				 <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* evaluate all function arguments */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgBenchValue</name></type> <name><name>vargs</name><index>[<expr><name>MAX_FARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>args</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nargs</name> <operator>&lt;</operator> <name>MAX_FARGS</name> <operator>&amp;&amp;</operator> <name>l</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>nargs</name><operator>++</operator></expr><operator>,</operator> <expr><name>l</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>nargs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>has_null</name> <operator>|=</operator> <name><name>vargs</name><index>[<expr><name>nargs</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>PGBT_NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many function arguments, maximum is %d\n"</literal></expr></argument>,
					   <argument><expr><name>MAX_FARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* NULL arguments */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_null</name> <operator>&amp;&amp;</operator> <name>func</name> <operator>!=</operator> <name>PGBENCH_IS</name> <operator>&amp;&amp;</operator> <name>func</name> <operator>!=</operator> <name>PGBENCH_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setNullValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* then evaluate function */</comment>
	<switch>switch <condition>(<expr><name>func</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* overloaded operators */</comment>
		<case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
		<case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
		<case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
		<case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
		<case>case <expr><name>PGBENCH_MOD</name></expr>:</case>
		<case>case <expr><name>PGBENCH_EQ</name></expr>:</case>
		<case>case <expr><name>PGBENCH_NE</name></expr>:</case>
		<case>case <expr><name>PGBENCH_LE</name></expr>:</case>
		<case>case <expr><name>PGBENCH_LT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>lval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>rval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* overloaded type management, double if some double */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name> <operator>||</operator>
					 <name><name>rval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>func</name> <operator>!=</operator> <name>PGBENCH_MOD</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>ld</name></decl>,
								<decl><type ref="prev"/><name>rd</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ld</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<switch>switch <condition>(<expr><name>func</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
							<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>+</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
							<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>-</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
							<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>*</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
							<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>/</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_EQ</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>==</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_NE</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>!=</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_LE</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>&lt;=</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_LT</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ld</name> <operator>&lt;</operator> <name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<default>default:</default>
							<comment type="block">/* cannot get here */</comment>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if>
				<else>else			<comment type="block">/* we have integer operands, or % */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int64</name></type>		<name>li</name></decl>,
								<decl><type ref="prev"/><name>ri</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<switch>switch <condition>(<expr><name>func</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>PGBENCH_ADD</name></expr>:</case>
							<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>+</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_SUB</name></expr>:</case>
							<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>-</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_MUL</name></expr>:</case>
							<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>*</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_EQ</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>==</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_NE</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>!=</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_LE</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>&lt;=</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_LT</name></expr>:</case>
							<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>&lt;</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>true</name></expr>;</return>

						<case>case <expr><name>PGBENCH_DIV</name></expr>:</case>
						<case>case <expr><name>PGBENCH_MOD</name></expr>:</case>
							<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<return>return <expr><name>false</name></expr>;</return>
							</block_content>}</block></if></if_stmt>
							<comment type="block">/* special handling of -1 divisor */</comment>
							<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_DIV</name></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/* overflow check (needed for INT64_MIN) */</comment>
									<if_stmt><if>if <condition>(<expr><name>li</name> <operator>==</operator> <name>PG_INT64_MIN</name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><call><name>ereport</name><argument_list>(
											<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
											<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bigint out of range\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<return>return <expr><name>false</name></expr>;</return>
									</block_content>}</block></if>
									<else>else<block type="pseudo"><block_content>
										<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><operator>-</operator><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
								</block_content>}</block></if>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
								<return>return <expr><name>true</name></expr>;</return>
							</block_content>}</block></if></if_stmt>
							<comment type="block">/* else divisor is not -1 */</comment>
							<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_DIV</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>/</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>	<comment type="block">/* func == PGBENCH_MOD */</comment>
								<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>%</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<return>return <expr><name>true</name></expr>;</return>

						<default>default:</default>
							<comment type="block">/* cannot get here */</comment>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* NOTREACHED */</comment>
			</block_content>}</block>

			<comment type="block">/* integer bitwise operators */</comment>
		<case>case <expr><name>PGBENCH_BITAND</name></expr>:</case>
		<case>case <expr><name>PGBENCH_BITOR</name></expr>:</case>
		<case>case <expr><name>PGBENCH_BITXOR</name></expr>:</case>
		<case>case <expr><name>PGBENCH_LSHIFT</name></expr>:</case>
		<case>case <expr><name>PGBENCH_RSHIFT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int64</name></type>		<name>li</name></decl>,
							<decl><type ref="prev"/><name>ri</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_BITAND</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>&amp;</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_BITOR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>|</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_BITXOR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>^</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LSHIFT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>&lt;&lt;</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RSHIFT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>li</name> <operator>&gt;&gt;</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>			<comment type="block">/* cannot get here */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* logical operators */</comment>
		<case>case <expr><name>PGBENCH_NOT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>b</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToBool</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><operator>!</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* no arguments */</comment>
		<case>case <expr><name>PGBENCH_PI</name></expr>:</case>
			<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>M_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>

			<comment type="block">/* 1 overloaded argument */</comment>
		<case>case <expr><name>PGBENCH_ABS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>varg</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int64</name></type>		<name>i</name> <init>= <expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>i</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>d</name> <init>= <expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><ternary><condition><expr><name>d</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>d</name></expr> </then><else>: <expr><name>d</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>PGBENCH_DEBUG</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>varg</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errormsg_buf</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>,
								  <argument><expr><literal type="string">"debug(script=%d,command=%d): "</literal></expr></argument>,
								  <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>, <argument><expr><literal type="string">"null\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_BOOLEAN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>,
									  <argument><expr><literal type="string">"boolean %s\n"</literal></expr></argument>,
									  <argument><expr><ternary><condition><expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bval</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_INT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>,
									  <argument><expr><literal type="string">"int "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>varg</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>,
									  <argument><expr><literal type="string">"double %.*g\n"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name><name>varg</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>dval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else			<comment type="block">/* internal error, unexpected type */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errormsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errormsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <operator>*</operator><name>varg</name></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* 1 double argument */</comment>
		<case>case <expr><name>PGBENCH_DOUBLE</name></expr>:</case>
		<case>case <expr><name>PGBENCH_SQRT</name></expr>:</case>
		<case>case <expr><name>PGBENCH_LN</name></expr>:</case>
		<case>case <expr><name>PGBENCH_EXP</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>double</name></type>		<name>dval</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_SQRT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dval</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dval</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_EXP</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dval</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* else is cast: do nothing */</comment>

				<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* 1 int argument */</comment>
		<case>case <expr><name>PGBENCH_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int64</name></type>		<name>ival</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* variable number of arguments */</comment>
		<case>case <expr><name>PGBENCH_LEAST</name></expr>:</case>
		<case>case <expr><name>PGBENCH_GREATEST</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>havedouble</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* need double result if any input is double */</comment>
				<expr_stmt><expr><name>havedouble</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>PGBT_DOUBLE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>havedouble</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>havedouble</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>extremum</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extremum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>double</name></type>		<name>dval</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LEAST</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>extremum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int64</name></type>		<name>extremum</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extremum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int64</name></type>		<name>ival</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_LEAST</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>extremum</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>extremum</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>extremum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* random functions */</comment>
		<case>case <expr><name>PGBENCH_RANDOM</name></expr>:</case>
		<case>case <expr><name>PGBENCH_RANDOM_EXPONENTIAL</name></expr>:</case>
		<case>case <expr><name>PGBENCH_RANDOM_GAUSSIAN</name></expr>:</case>
		<case>case <expr><name>PGBENCH_RANDOM_ZIPFIAN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int64</name></type>		<name>imin</name></decl>,
							<decl><type ref="prev"/><name>imax</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imin</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>imax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* check random range */</comment>
				<if_stmt><if>if <condition>(<expr><name>imin</name> <operator>&gt;</operator> <name>imax</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty range given to random\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>imax</name> <operator>-</operator> <name>imin</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>imax</name> <operator>-</operator> <name>imin</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* prevent int overflows in random functions */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"random range is too large\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RANDOM</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><call><name>getrand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>, <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else			<comment type="block">/* gaussian &amp; exponential */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>param</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RANDOM_GAUSSIAN</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>param</name> <operator>&lt;</operator> <name>MIN_GAUSSIAN_PARAM</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"gaussian parameter must be at least %f (not %f)\n"</literal></expr></argument>,
											<argument><expr><name>MIN_GAUSSIAN_PARAM</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>false</name></expr>;</return>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
									<argument><expr><call><name>getGaussianRand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>, <argument><expr><name>imin</name></expr></argument>,
													<argument><expr><name>imax</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_RANDOM_ZIPFIAN</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>param</name> <operator>&lt;=</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>param</name> <operator>==</operator> <literal type="number">1.0</literal> <operator>||</operator> <name>param</name> <operator>&gt;</operator> <name>MAX_ZIPFIAN_PARAM</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"zipfian parameter must be in range (0, 1) U (1, %d] (got %f)\n"</literal></expr></argument>,
											<argument><expr><name>MAX_ZIPFIAN_PARAM</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>false</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
									<argument><expr><call><name>getZipfianRand</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>,
												   <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else		<comment type="block">/* exponential */</comment>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>param</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exponential parameter must be greater than zero (got %f)\n"</literal></expr></argument>,
											<argument><expr><name>param</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr><name>false</name></expr>;</return>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
									<argument><expr><call><name>getExponentialRand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>, <argument><expr><name>imin</name></expr></argument>,
													   <argument><expr><name>imax</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>PGBENCH_POW</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>lval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>rval</name> <init>= <expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>ld</name></decl>,
							<decl><type ref="prev"/><name>rd</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ld</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>coerceToDouble</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>setDoubleValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><call><name>pow</name><argument_list>(<argument><expr><name>ld</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>PGBENCH_IS</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * note: this simple implementation is more permissive than
				 * SQL
				 */</comment>
				<expr_stmt><expr><call><name>setBoolValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>,
							 <argument><expr><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>&amp;&amp;</operator>
							 <name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>bval</name></name> <operator>==</operator> <name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>bval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/* hashing */</comment>
		<case>case <expr><name>PGBENCH_HASH_FNV1A</name></expr>:</case>
		<case>case <expr><name>PGBENCH_HASH_MURMUR2</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int64</name></type>		<name>val</name></decl>,
							<decl><type ref="prev"/><name>seed</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>coerceToInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seed</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_HASH_MURMUR2</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><call><name>getHashMurmur2</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>func</name> <operator>==</operator> <name>PGBENCH_HASH_FNV1A</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><call><name>getHashFnv1a</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/* cannot get here */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<default>default:</default>
			<comment type="block">/* cannot get here */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* dead code to avoid a compiler warning */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* evaluate some function */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evalFunc</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
		 <parameter><decl><type><name>PgBenchFunction</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>PgBenchExprLink</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isLazyFunc</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>evalLazyFunc</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>evalStandardFunc</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive evaluation of an expression in a pgbench script
 * using the current state of variables.
 * Returns whether the evaluation was ok,
 * the value itself is returned through the retval pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evaluateExpr</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>PgBenchValue</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>etype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENODE_CONSTANT</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>constant</name></name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>ENODE_VARIABLE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>var</name> <operator>=</operator> <call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>variable</name><operator>.</operator><name>varname</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"undefined variable \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>variable</name><operator>.</operator><name>varname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>makeVariableValue</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>ENODE_FUNCTION</name></expr>:</case>
			<return>return <expr><call><name>evalFunc</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>,
							<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>function</name></name></expr></argument>,
							<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>args</name></name></expr></argument>,
							<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<comment type="block">/* internal error which should never occur */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected enode type in evaluation: %d\n"</literal></expr></argument>,
							<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>etype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Convert command name to meta-command enum identifier
 */</comment>
<function><type><specifier>static</specifier> <name>MetaCommand</name></type>
<name>getMetaCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MetaCommand</name></type> <name>mc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_SET</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_SETSHELL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"shell"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_SHELL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_SLEEP</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"if"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_IF</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"elif"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_ELIF</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_ELSE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"endif"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_ENDIF</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>mc</name> <operator>=</operator> <name>META_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>mc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Run a shell command. The result is assigned to the variable if not NULL.
 * Return true if succeeded, or false on error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>runShellCommand</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>command</name><index>[<expr><name>SHELL_COMMAND_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>res</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * Join arguments with whitespace separators. Arguments starting with
	 * exactly one colon are treated as variables:
	 *	name - append a string "name"
	 *	:var - append a variable named 'var'
	 *	::name - append a string ":name"
	 *----------
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>arglen</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>		<comment type="block">/* a string literal */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* a string literal starting with colons */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>arg</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: undefined variable \"%s\"\n"</literal></expr></argument>,
							<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>arglen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>arglen</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>&gt;=</operator> <name>SHELL_COMMAND_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: shell command is too long\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>command</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>command</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>arglen</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>command</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Fast path for non-assignment case */</comment>
	<if_stmt><if>if <condition>(<expr><name>variable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>timer_exceeded</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: could not launch shell command\n"</literal></expr></argument>,
								<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Execute the command with pipe and read the standard output. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: could not launch shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>timer_exceeded</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: could not read result of shell command\n"</literal></expr></argument>,
							<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: could not close shell command\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check whether the result is an integer and assign it to the variable */</comment>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>res</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: shell command must return an integer (not \"%s\")\n"</literal></expr></argument>,
						<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableInt</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"shell parameter name: \"%s\", value: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PREPARE_NAME</name></cpp:macro>		<cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preparedStatementName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"P%d_%d"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>commandFailed</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
			  <parameter><decl><type><name>ErrorLevel</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This is the first failure during the execution of the current
				 * script.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d got a failure in command %d (%s) of script %d; %s\n"</literal></expr></argument>,
								<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
								<argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This is not the first failure during the execution of the
				 * current script.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d continues a failed transaction in command %d (%s) of script %d; %s\n"</literal></expr></argument>,
								<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
								<argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d aborted in command %d (%s) of script %d; %s\n"</literal></expr></argument>,
							<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ELEVEL_DEBUG</name></expr>:</case>
		<case>case <expr><name>ELEVEL_LOG_MAIN</name></expr>:</case>
		<case>case <expr><name>ELEVEL_FATAL</name></expr>:</case>
		<default>default:</default>
			<comment type="block">/* internal error which should never occur */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected error level when the command failed: %d\n"</literal></expr></argument>,
							<argument><expr><name>elevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* return a script number with a weighted choice. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chooseScript</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>w</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>getrand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_weight</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>-=</operator> <name><name>sql_script</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>w</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Send a SQL command, using the chosen querymode */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendCommand</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>Command</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_SIMPLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>assignVariables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_EXTENDED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getQueryParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>querymode</name> <operator>==</operator> <name>QUERY_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>MAX_PREPARE_NAME</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>st</name><operator>-&gt;</operator><name>prepared</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name> <init>= <expr><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>commands</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>MAX_PREPARE_NAME</name></expr>]</index></name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>SQL_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>preparedStatementName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQprepare</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
								<argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>getQueryParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>preparedStatementName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d sending %s\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
								<argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* unknown sql mode */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d could not send %s\n"</literal></expr></argument>,
						<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the argument to a \sleep command, and return the requested amount
 * of delay, in microseconds.  Returns true on success, false on error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>evaluateSleep</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>variables</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>usecs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>var</name> <operator>=</operator> <call><name>getVariable</name><argument_list>(<argument><expr><name>variables</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: undefined variable \"%s\"\n"</literal></expr></argument>,
							<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>usec</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>usec</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>usec</name> <operator>*=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>usecs</name> <operator>=</operator> <name>usec</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the number of all processed transactions including skipped ones and
 * errors.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getTotalCnt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name> <operator>+</operator> <name><name>st</name><operator>-&gt;</operator><name>ecnt</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy an array of random state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copyRandomState</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RandomState</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>destination</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>source</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make a deep copy of variables array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copyVariables</name><parameter_list>(<parameter><decl><type><name>Variables</name> <modifier>*</modifier></type><name>destination_vars</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variables</name> <modifier>*</modifier></type><name>source_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>destination</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>current_destination</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>current_source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvariables</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destination_vars</name> <operator>||</operator> <operator>!</operator><name>source_vars</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>destination</name> <operator>=</operator> <name><name>destination_vars</name><operator>-&gt;</operator><name>array</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>source_vars</name><operator>-&gt;</operator><name>array</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nvariables</name> <operator>=</operator> <name><name>source_vars</name><operator>-&gt;</operator><name>nvariables</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>current_destination</name> <operator>=</operator> <name>destination</name></expr>;</init>
		 <condition><expr><name>current_destination</name> <operator>-</operator> <name>destination</name> <operator>&lt;</operator> <name><name>destination_vars</name><operator>-&gt;</operator><name>nvariables</name></name></expr>;</condition>
		 <incr><expr><operator>++</operator><name>current_destination</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>current_destination</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>current_destination</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>destination_vars</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>destination_vars</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,
										 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Variable</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nvariables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destination</name> <operator>=</operator> <name><name>destination_vars</name><operator>-&gt;</operator><name>array</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>current_source</name> <operator>=</operator> <name>source</name></expr><operator>,</operator> <expr><name>current_destination</name> <operator>=</operator> <name>destination</name></expr>;</init>
		 <condition><expr><name>current_source</name> <operator>-</operator> <name>source</name> <operator>&lt;</operator> <name>nvariables</name></expr>;</condition>
		 <incr><expr><operator>++</operator><name>current_source</name></expr><operator>,</operator> <expr><operator>++</operator><name>current_destination</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>current_destination</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>current_source</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>current_source</name><operator>-&gt;</operator><name>svalue</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>current_destination</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>current_source</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>current_destination</name><operator>-&gt;</operator><name>svalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>current_destination</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>current_source</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>destination_vars</name><operator>-&gt;</operator><name>nvariables</name></name> <operator>=</operator> <name>nvariables</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>destination_vars</name><operator>-&gt;</operator><name>vars_sorted</name></name> <operator>=</operator> <name><name>source_vars</name><operator>-&gt;</operator><name>vars_sorted</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if this type of failure can be retried.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>canRetryFailure</name><parameter_list>(<parameter><decl><type><name>FailureStatus</name></type> <name>failure_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>failure_status</name> <operator>==</operator> <name>SERIALIZATION_FAILURE</name> <operator>||</operator>
			<name>failure_status</name> <operator>==</operator> <name>DEADLOCK_FAILURE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the failure can be retried.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>canRetry</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FailureStatus</name></type> <name>failure_status</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>failure_status</name> <operator>!=</operator> <name>NO_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can only retry serialization or deadlock failures. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>canRetryFailure</name><argument_list>(<argument><expr><name>failure_status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must have at least one option to limit the retrying of failed
	 * transactions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max_tries</name> <operator>||</operator> <name>latency_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot retry the failure if we have reached the maximum number of
	 * tries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_tries</name> <operator>&amp;&amp;</operator> <name><name>st</name><operator>-&gt;</operator><name>retries</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>max_tries</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We cannot retry the failure if we spent too much time on this
	 * transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>&gt;=</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the conditional stack depending on the condition value; is used for
 * the meta commands \if and \elif.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>executeCondition</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>condition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* execute or not depending on evaluated condition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>conditional_stack_push</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>condition</name></expr> ?</condition><then> <expr><name>IFSTATE_TRUE</name></expr> </then><else>: <expr><name>IFSTATE_FALSE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we should get here only if the "elif" needed evaluation */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IFSTATE_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>conditional_stack_poke</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>condition</name></expr> ?</condition><then> <expr><name>IFSTATE_TRUE</name></expr> </then><else>: <expr><name>IFSTATE_FALSE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the failure status from the error code.
 */</comment>
<function><type><specifier>static</specifier> <name>FailureStatus</name></type>
<name>getFailureStatus</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>sqlState</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SERIALIZATION_FAILURE</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_T_R_DEADLOCK_DETECTED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>DEADLOCK_FAILURE</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>IN_FAILED_SQL_TRANSACTION</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ANOTHER_FAILURE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the latency limit is used, return a percentage of the current transaction
 * latency from the latency limit. Otherwise return zero.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>getLatencyUsed</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><literal type="number">100.0</literal> <operator>*</operator> <operator>(</operator><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name><operator>)</operator> <operator>/</operator>
			<name>latency_limit</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the state machine of a connection, if possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doCustom</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>end_tx_processed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>wait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FailureStatus</name></type> <name>failure_status</name> <init>= <expr><name>NO_FAILURE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * gettimeofday() isn't free, so we get the current timestamp lazily the
	 * first time it's needed, and reuse the same value throughout this
	 * function after that.  This also ensures that e.g. the calculated
	 * latency reported in the log file and in the totals are the same. Zero
	 * means "not set yet".  Reset "now" when we execute shell commands or
	 * expressions, which might take a non-negligible amount of time, though.
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop in the state machine, until we have to wait for a result from the
	 * server (or have to sleep, for throttling or for \sleep).
	 *
	 * Note: In the switch-statement below, 'break' will loop back here,
	 * meaning "continue in the state machine".  Return is used to return to
	 * the caller.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * Select transaction to run.
				 */</comment>
			<case>case <expr><name>CSTATE_CHOOSE_SCRIPT</name></expr>:</case>

				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name> <operator>=</operator> <call><name>chooseScript</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d executing script \"%s\"\n"</literal></expr></argument>,
								<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_THROTTLE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_TX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* check consistency */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset transaction variables to default values */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>NO_FAILURE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<break>break;</break>

				<comment type="block">/*
				 * Handle throttling once per transaction by sleeping.
				 */</comment>
			<case>case <expr><name>CSTATE_START_THROTTLE</name></expr>:</case>

				<comment type="block">/*
				 * Generate a delay such that the series of delays will
				 * approximate a Poisson distribution centered on the
				 * throttle_delay time.
				 *
				 * If transactions are too slow or a given wait is shorter
				 * than a transaction, the next transaction will start right
				 * away.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>throttle_delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>getPoissonRand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>, <argument><expr><name>throttle_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>+=</operator> <name>wait</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * stop client if next transaction is beyond pgbench end of
				 * execution
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>&gt;</operator> <name>end_time</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If --latency-limit is used, and this slot is already late
				 * so that the transaction will miss the latency limit even if
				 * it completed immediately, we skip this time slot and
				 * iterate till the next slot that isn't late yet.  But don't
				 * iterate beyond the -t limit, if one is given.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int64</name></type>		<name>now_us</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>now_us</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<while>while <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>&lt;</operator> <name>now_us</name> <operator>-</operator> <name>latency_limit</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name>nxacts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nxacts</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>processXactStats</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* next rendez-vous */</comment>
						<expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>getPoissonRand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>,
											  <argument><expr><name>throttle_delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>+=</operator> <name>wait</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name></expr>;</expr_stmt>
					</block_content>}</block></while>
					<comment type="block">/* stop client if -t exceeded */</comment>
					<if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nxacts</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_THROTTLE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d throttling "</literal> <name>INT64_FORMAT</name> <literal type="string">" us\n"</literal></expr></argument>,
								<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Wait until it's time to start next transaction.
				 */</comment>
			<case>case <expr><name>CSTATE_THROTTLE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>		<comment type="block">/* Still sleeping, nothing to do here */</comment>

				<comment type="block">/* Else done sleeping, start the transaction */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_TX</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* Start new transaction */</comment>
			<case>case <expr><name>CSTATE_START_TX</name></expr>:</case>

				<comment type="block">/*
				 * Establish connection on first call, or if is_connect is
				 * true.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>instr_time</name></type>	<name>start</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>start</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d aborted while establishing connection\n"</literal></expr></argument>,
										<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Reset session-local state */</comment>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>prepared</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * It is the first try to run this transaction. Remember its
				 * parameters just in case if it fails or we should repeat it in
				 * future.
				 */</comment>
				<expr_stmt><expr><call><name>copyRandomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>retry_state</name><operator>.</operator><name>random_state</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copyVariables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>retry_state</name><operator>.</operator><name>variables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Record transaction start time under logging, progress or
				 * throttling.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>use_log</name> <operator>||</operator> <name>progress</name> <operator>||</operator> <name>throttle_delay</name> <operator>||</operator> <name>latency_limit</name> <operator>||</operator>
					<name>per_script_stats</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_begin</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * When not throttling, this is also the transaction's
					 * scheduled start time.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Begin with the first command */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Send a command to server (or execute a meta-command)
				 */</comment>
			<case>case <expr><name>CSTATE_START_COMMAND</name></expr>:</case>
				<expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we reached the end of the script, move to end-of-xact
				 * processing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>command</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_TX</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* check if we can retry the failure */</comment>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_RETRY</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Record statement start time if per-command latencies are
				 * requested
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>report_per_command</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>stmt_begin</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SQL_COMMAND</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendCommand</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>, <argument><expr><literal type="string">"SQL command send failed"</literal></expr></argument>,
									  <argument><expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_WAIT_RESULT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>META_COMMAND</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>argc</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>,
								<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>argv</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"client %d executing \\%s"</literal></expr></argument>,
									  <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* change it if the meta command fails */</comment>
					<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>NO_FAILURE</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SLEEP</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * A \sleep doesn't execute anything, we just get the
						 * delay from the argument, and enter the CSTATE_SLEEP
						 * state.  (The per-command latency will be recorded
						 * in CSTATE_SLEEP state, not here, after the delay
						 * has elapsed.)
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>usec</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usec</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>,
										  <argument><expr><literal type="string">"execution of meta-command failed"</literal></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>ANOTHER_FAILURE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>usec</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_SLEEP</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SET</name> <operator>||</operator>
							 <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name> <operator>||</operator>
							 <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* backslash commands with an expression to evaluate */</comment>
						<decl_stmt><decl><type><name>PgBenchExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PgBenchValue</name></type> <name>result</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name> <operator>&amp;&amp;</operator>
							<call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IFSTATE_TRUE</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * elif after executed block, skip eval and wait
							 * for endif
							 */</comment>
							<expr_stmt><expr><call><name>conditional_stack_poke</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>, <argument><expr><name>IFSTATE_IGNORED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>move_to_end_command</name>;</goto>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>evaluateExpr</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										  <argument><expr><literal type="string">"evaluation of meta-command failed"</literal></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Do not ruin the following conditional commands,
							 * if any.
							 */</comment>
							<expr_stmt><expr><call><name>executeCondition</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>ANOTHER_FAILURE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SET</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>putVariableValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>,  <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												  <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>,
											  <argument><expr><literal type="string">"assignment of meta-command failed"</literal></expr></argument>,
											  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>ANOTHER_FAILURE</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if>
						<else>else	<comment type="block">/* if and elif evaluated cases */</comment>
						<block>{<block_content>
							<expr_stmt><expr><call><name>executeCondition</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><call><name>valueTruth</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELSE</name></expr>)</condition>
					<block>{<block_content>
						<switch>switch <condition>(<expr><call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>IFSTATE_TRUE</name></expr>:</case>
								<expr_stmt><expr><call><name>conditional_stack_poke</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>, <argument><expr><name>IFSTATE_ELSE_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>IFSTATE_FALSE</name></expr>:</case> <comment type="block">/* inconsistent if active */</comment>
							<case>case <expr><name>IFSTATE_IGNORED</name></expr>:</case>	<comment type="block">/* inconsistent if active */</comment>
							<case>case <expr><name>IFSTATE_NONE</name></expr>:</case>	<comment type="block">/* else without if */</comment>
							<case>case <expr><name>IFSTATE_ELSE_TRUE</name></expr>:</case> <comment type="block">/* else after else */</comment>
							<case>case <expr><name>IFSTATE_ELSE_FALSE</name></expr>:</case>	<comment type="block">/* else after else */</comment>
							<default>default:</default>
								<comment type="block">/* dead code if conditional check is ok */</comment>
								<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></switch>
						<goto>goto <name>move_to_end_command</name>;</goto>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ENDIF</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>conditional_stack_pop</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>move_to_end_command</name>;</goto>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SETSHELL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><call><name>runShellCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>,
														  <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,
														  <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>timer_exceeded</name></expr>)</condition> <comment type="block">/* timeout */</comment>
						<block>{<block_content>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>	<comment type="block">/* on error */</comment>
						<block>{<block_content>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"setshell"</literal></expr></argument>,
										  <argument><expr><literal type="string">"execution of meta-command failed"</literal></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>ANOTHER_FAILURE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* succeeded */</comment>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SHELL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><call><name>runShellCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
														  <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>timer_exceeded</name></expr>)</condition> <comment type="block">/* timeout */</comment>
						<block>{<block_content>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>	<comment type="block">/* on error */</comment>
						<block>{<block_content>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"shell"</literal></expr></argument>,
										  <argument><expr><literal type="string">"execution of meta-command failed"</literal></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>ANOTHER_FAILURE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* succeeded */</comment>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>

			<label><name>move_to_end_command</name>:</label>

					<comment type="block">/*
					 * executing the expression or shell command might take a
					 * non-negligible amount of time, so reset 'now'
					 */</comment>
					<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * non executed conditional branch
				 */</comment>
			<case>case <expr><name>CSTATE_SKIP_COMMAND</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>conditional_active</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* quickly skip commands until something to do... */</comment>
				<while>while <condition>(<expr><name>true</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>

					<comment type="block">/* cannot reach end of script in that state */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if this is conditional related, update conditional
					 * state
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>META_COMMAND</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELSE</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ENDIF</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<switch>switch <condition>(<expr><call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>IFSTATE_FALSE</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name> <operator>||</operator> <name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/* we must evaluate the condition */</comment>
									<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
								</block_content>}</block></if>
								<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELSE</name></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/* we must execute next command */</comment>
									<expr_stmt><expr><call><name>conditional_stack_poke</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>, <argument><expr><name>IFSTATE_ELSE_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
									<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
								</block_content>}</block></if>
								<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ENDIF</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>conditional_stack_pop</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<if_stmt><if>if <condition>(<expr><call><name>conditional_active</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

									<comment type="block">/*
									 * else state remains in
									 * CSTATE_SKIP_COMMAND
									 */</comment>
									<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
								<break>break;</break>

							<case>case <expr><name>IFSTATE_IGNORED</name></expr>:</case>
							<case>case <expr><name>IFSTATE_ELSE_FALSE</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>conditional_stack_push</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>, <argument><expr><name>IFSTATE_IGNORED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ENDIF</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>conditional_stack_pop</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<if_stmt><if>if <condition>(<expr><call><name>conditional_active</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
								</block_content>}</block></if></if_stmt>
								<comment type="block">/* could detect "else" &amp; "elif" after "else" */</comment>
								<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>IFSTATE_NONE</name></expr>:</case>
							<case>case <expr><name>IFSTATE_TRUE</name></expr>:</case>
							<case>case <expr><name>IFSTATE_ELSE_TRUE</name></expr>:</case>
							<default>default:</default>

								<comment type="block">/*
								 * inconsistent if inactive, unreachable dead
								 * code
								 */</comment>
								<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></switch>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* skip and consider next */</comment>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CSTATE_SKIP_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></while>
				<break>break;</break>

				<comment type="block">/*
				 * Wait for the current SQL command to complete
				 */</comment>
			<case>case <expr><name>CSTATE_WAIT_RESULT</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlState</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client %d receiving\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>				<comment type="block">/* there's something wrong */</comment>
						<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>,
									  <argument><expr><literal type="string">"perhaps the backend died while processing"</literal></expr></argument>,
									  <argument><expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>		<comment type="block">/* don't have the whole result yet */</comment>

					<comment type="block">/*
					 * Read and discard the query result;
					 */</comment>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sqlState</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
						<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
						<case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
							<comment type="block">/* OK */</comment>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>discard_response</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <name>NO_FAILURE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
						<case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
							<expr_stmt><expr><name>failure_status</name> <operator>=</operator> <call><name>getFailureStatus</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>discard_response</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FAILURE</name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>commandFailed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_ABORTED</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

				<comment type="block">/*
				 * Wait until sleep is done. This state is entered after a
				 * \sleep metacommand. The behavior is similar to
				 * CSTATE_THROTTLE, but proceeds to CSTATE_START_COMMAND
				 * instead of CSTATE_START_TX.
				 */</comment>
			<case>case <expr><name>CSTATE_SLEEP</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>		<comment type="block">/* Still sleeping, nothing to do here */</comment>
				<comment type="block">/* Else done sleeping. */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_COMMAND</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * End of command: record stats and proceed to next command.
				 */</comment>
			<case>case <expr><name>CSTATE_END_COMMAND</name></expr>:</case>

				<comment type="block">/*
				 * command completed: accumulate per-command execution times
				 * in thread-local data structure, if per-command latencies
				 * are requested.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>report_per_command</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* XXX could use a mutex here, but we choose not to */</comment>
					<expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>addToSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
									 <argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator>
									 <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>stmt_begin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Go ahead with next command, to be executed or skipped */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><call><name>conditional_active</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
					<expr><name>CSTATE_START_COMMAND</name></expr> </then><else>: <expr><name>CSTATE_SKIP_COMMAND</name></expr></else></ternary></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Remember the failure and go ahead with next command.
				 */</comment>
			<case>case <expr><name>CSTATE_FAILURE</name></expr>:</case>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>failure_status</name> <operator>!=</operator> <name>NO_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * All subsequent failures will be "retried"/"failed" if the
				 * first failure of this transaction can be/cannot be retried.
				 * Therefore remember only the first failure.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>failure_status</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>command</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>command</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Go ahead with next command, to be executed or skipped */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><call><name>conditional_active</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
					<expr><name>CSTATE_START_COMMAND</name></expr> </then><else>: <expr><name>CSTATE_SKIP_COMMAND</name></expr></else></ternary></expr>;</expr_stmt>
				<break>break;</break>

			<comment type="block">/*
			 * Retry the failed transaction if possible.
			 */</comment>
			<case>case <expr><name>CSTATE_RETRY</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>command</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name><name>commands</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>command</name></name></expr>]</index></name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>canRetry</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The failed transaction will be retried. So accumulate
						 * the retry.
						 */</comment>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>retries</name></name><operator>++</operator></expr>;</expr_stmt>

						<comment type="block">/*
						 * Report this with failures to indicate that the failed
						 * transaction will be retried.
						 */</comment>
						<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>,
										  <argument><expr><literal type="string">"client %d repeats the failed transaction (try %d"</literal></expr></argument>,
										  <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>max_tries</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"/%d"</literal></expr></argument>, <argument><expr><name>max_tries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>,
											  <argument><expr><literal type="string">", %.3f%% of the maximum time of tries was used"</literal></expr></argument>,
											  <argument><expr><call><name>getLatencyUsed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Reset the execution parameters as they were at the
						 * beginning of the transaction.
						 */</comment>
						<expr_stmt><expr><call><name>copyRandomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>retry_state</name><operator>.</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>copyVariables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>retry_state</name><operator>.</operator><name>variables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Process the first transaction command */</comment>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>NO_FAILURE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_START_COMMAND</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * We will not be able to retry this failed transaction.
						 * So accumulate the error.
						 */</comment>
						<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>errors</name></name><operator>++</operator></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator>
							<name>IN_FAILED_SQL_TRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * Report this with failures to indicate that the failed
						 * transaction will not be retried.
						 */</comment>
						<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>,
										  <argument><expr><literal type="string">"client %d ends the failed transaction (try %d"</literal></expr></argument>,
										  <argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Report the actual number and/or time of tries. We do
						 * not need this information if this type of failure can
						 * be never retried.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>canRetryFailure</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>max_tries</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"/%d"</literal></expr></argument>,
												  <argument><expr><name>max_tries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>,
												  <argument><expr><literal type="string">", %.3f%% of the maximum time of tries was used"</literal></expr></argument>,
												  <argument><expr><call><name>getLatencyUsed</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Reset the execution parameters as they were at the
						 * beginning of the transaction except for a random
						 * state.
						 */</comment>
						<expr_stmt><expr><call><name>copyVariables</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>retry_state</name><operator>.</operator><name>variables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* End the failed transaction */</comment>
						<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_END_TX</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>

				<comment type="block">/*
				 * End of transaction.
				 */</comment>
			<case>case <expr><name>CSTATE_END_TX</name></expr>:</case>

				<comment type="block">/* transaction finished: calculate latency and do log */</comment>
				<expr_stmt><expr><call><name>processXactStats</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* conditional stack must be empty */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>cstack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end of script reached within a conditional, missing \\endif\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>is_connect</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>finishCon</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>nxacts</name> <operator>&amp;&amp;</operator> <name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
					<name>timer_exceeded</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* exit success */</comment>
					<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * No transaction is underway anymore.
				 */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_CHOOSE_SCRIPT</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we paced through all commands in the script in this
				 * loop, without returning to the caller even once, do it now.
				 * This gives the thread a chance to process other
				 * connections, and to do progress reporting.  This can
				 * currently only happen if the script consists entirely of
				 * meta-commands.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>end_tx_processed</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>end_tx_processed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Final states.  Close the connection if it's still open.
				 */</comment>
			<case>case <expr><name>CSTATE_ABORTED</name></expr>:</case>
			<case>case <expr><name>CSTATE_FINISHED</name></expr>:</case>
				<expr_stmt><expr><call><name>finishCon</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Print log entry after completing one transaction.
 *
 * We print Unix-epoch timestamps in the log, so that entries can be
 * correlated against other logs.  On some platforms this could be obtained
 * from the instr_time reading the caller has, but rather than get entangled
 * with that, we just eat the cost of an extra syscall in all cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doLog</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>,
	  <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>latency</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>logfile</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>use_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Skip the log entry if sampling is enabled and this row doesn't belong
	 * to the random sample.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>!=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator>
		<call><name>pg_erand48</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>random_state</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>sample_rate</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* should we aggregate the results or not? */</comment>
	<if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Loop until we reach the interval of the current moment, and print
		 * any empty intervals in between (this may happen with very low tps,
		 * e.g. --rate=0.1).
		 */</comment>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name> <operator>+</operator> <name>agg_interval</name> <operator>&lt;=</operator> <name>now</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* print aggregated report to logfile */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%ld "</literal> <name>INT64_FORMAT</name> <literal type="string">" %.0f %.0f %.0f %.0f "</literal> <name>INT64_FORMAT</name> <literal type="string">" "</literal> <name>INT64_FORMAT</name></expr></argument>,
					<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>sum</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>sum2</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>min</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>latency</name><operator>.</operator><name>max</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>,
					<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" %.0f %.0f %.0f %.0f"</literal></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum</name></name></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum2</name></name></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>min</name></name></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>skipped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>max_tries</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal> <name>INT64_FORMAT</name> <literal type="string">" "</literal> <name>INT64_FORMAT</name></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>retried</name></name></expr></argument>,
						<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* reset data and move to next interval */</comment>
			<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><name>agg</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>start_time</name></name> <operator>+</operator> <name>agg_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* accumulate the current transaction */</comment>
		<expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><name>agg</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></argument>,
				   <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no, print raw transactions */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>skipped</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" skipped %d %ld %ld"</literal></expr></argument>,
					<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" %.0f %d %ld %ld"</literal></expr></argument>,
					<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>IN_FAILED_SQL_TRANSACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" in_failed_tx %d %ld %ld"</literal></expr></argument>,
					<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal> <name>INT64_FORMAT</name> <literal type="string">" failed %d %ld %ld"</literal></expr></argument>,
					<argument><expr><name><name>st</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getTotalCnt</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" %.0f"</literal></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>max_tries</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate and report statistics at end of a transaction.
 *
 * (This is also called when a transaction is late and thus skipped.
 * Note that even skipped transactions are counted in the "cnt" fields.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processXactStats</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>, <parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>now</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>skipped</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>latency</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>lag</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>thread_details</name> <init>= <expr><name>progress</name> <operator>||</operator> <name>throttle_delay</name> <operator>||</operator> <name>latency_limit</name></expr></init></decl>,
				<decl><type ref="prev"/><name>detailed</name> <init>= <expr><name>thread_details</name> <operator>||</operator> <name>use_log</name> <operator>||</operator> <name>per_script_stats</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>detailed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>skipped</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name> <operator>||</operator> <name>latency_limit</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* compute latency &amp; lag */</comment>
		<expr_stmt><expr><name>latency</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><operator>*</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lag</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>txn_begin</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>thread_details</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* keep detailed thread stats */</comment>
		<expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>,
				   <argument><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* count transactions over the latency limit, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>latency_limit</name> <operator>&amp;&amp;</operator> <name>latency</name> <operator>&gt;</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no detailed stats */</comment>
		<expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></argument>,
				   <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* client stat is just counting */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name> <operator>==</operator> <name>NO_FAILURE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>ecnt</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_log</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>doLog</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* XXX could use a mutex here, but we choose not to */</comment>
	<if_stmt><if>if <condition>(<expr><name>per_script_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>accumStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sql_script</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>use_file</name></name></expr>]</index></name><operator>.</operator><name>stats</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>,
				   <argument><expr><name><name>st</name><operator>-&gt;</operator><name>first_failure</name><operator>.</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* discard connections */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_all</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>finishCon</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Remove old pgbench tables, if any exist
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initDropTables</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping old tables...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We drop all the tables in one command, so that whether there are
	 * foreign key dependencies or not doesn't matter.
	 */</comment>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"drop table if exists "</literal>
					 <literal type="string">"ysql_bench_accounts, "</literal>
					 <literal type="string">"ysql_bench_branches, "</literal>
					 <literal type="string">"ysql_bench_history, "</literal>
					 <literal type="string">"ysql_bench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create pgbench's standard tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initCreateTables</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_primary_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The scale factor at/beyond which 32-bit integers are insufficient for
	 * storing TPC-B account IDs.
	 *
	 * Although the actual threshold is 21474, we use 20000 because it is
	 * easier to document and remember, and isn't that far away from the real
	 * threshold.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCALE_32BIT_THRESHOLD</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>

	<comment type="block">/*
	 * Note: TPC-B requires at least 100 bytes per row, and the "filler"
	 * fields in these table declarations were intended to comply with that.
	 * The ysql_bench_accounts table complies with that because the "filler"
	 * column is set to blank-padded empty string. But for all other tables
	 * the columns default to NULL and so don't actually take any space.  We
	 * could fix that by giving them non-null default values.  However, that
	 * would completely break comparability of pgbench results with prior
	 * versions. Since pgbench has never pretended to be fully TPC-B compliant
	 * anyway, we stick with the historical behavior.
	 */</comment>
	<struct>struct <name>ddlinfo</name>
	<block>{
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>		<comment type="block">/* table name */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>smcols</name></decl>;</decl_stmt>		<comment type="block">/* column decls if accountIDs are 32 bits */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bigcols</name></decl>;</decl_stmt>	<comment type="block">/* column decls if accountIDs are 64 bits */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pkey</name></decl>;</decl_stmt>     <comment type="block">/* optional use primary key for the table */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>declare_fillfactor</name></decl>;</decl_stmt>
	}</block>;</struct>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ddlinfo</name></name></type> <name><name>DDLs</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{
			<expr><literal type="string">"ysql_bench_history"</literal></expr>,
			<expr><literal type="string">"tid int,bid int,aid    int,delta int,mtime timestamp,filler char(22)"</literal></expr>,
			<expr><literal type="string">"tid int,bid int,aid bigint,delta int,mtime timestamp,filler char(22)"</literal></expr>,
			<expr><literal type="string">""</literal></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><block>{
			<expr><literal type="string">"ysql_bench_tellers"</literal></expr>,
			<expr><literal type="string">"tid int not null,bid int,tbalance int,filler char(84)"</literal></expr>,
			<expr><literal type="string">"tid int not null,bid int,tbalance int,filler char(84)"</literal></expr>,
      <expr><literal type="string">",PRIMARY KEY(tid)"</literal></expr>,
			<expr><literal type="number">1</literal></expr>
		}</block></expr>,
		<expr><block>{
			<expr><literal type="string">"ysql_bench_accounts"</literal></expr>,
			<expr><literal type="string">"aid    int not null,bid int,abalance int,filler char(84)"</literal></expr>,
			<expr><literal type="string">"aid bigint not null,bid int,abalance int,filler char(84)"</literal></expr>,
      <expr><literal type="string">",PRIMARY KEY(aid)"</literal></expr>,
			<expr><literal type="number">1</literal></expr>
		}</block></expr>,
		<expr><block>{
			<expr><literal type="string">"ysql_bench_branches"</literal></expr>,
			<expr><literal type="string">"bid int not null,bbalance int,filler char(88)"</literal></expr>,
			<expr><literal type="string">"bid int not null,bbalance int,filler char(88)"</literal></expr>,
      <expr><literal type="string">",PRIMARY KEY(bid)"</literal></expr>,
			<expr><literal type="number">1</literal></expr>
		}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_primary_key</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating tables (with primary keys)...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating tables...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>opts</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ddlinfo</name></name> <modifier>*</modifier></type><name>ddl</name> <init>= <expr><operator>&amp;</operator><name><name>DDLs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cols</name></decl>;</decl_stmt>

		<comment type="block">/* Construct new create table statement. */</comment>
		<expr_stmt><expr><name><name>opts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ddl</name><operator>-&gt;</operator><name>declare_fillfactor</name></name> <operator>&amp;&amp;</operator> <name>set_fillfactor</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>opts</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">" with (fillfactor=%d)"</literal></expr></argument>, <argument><expr><name>fillfactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>escape_tablespace</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>escape_tablespace</name> <operator>=</operator> <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>,
												   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>opts</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">" tablespace %s"</literal></expr></argument>, <argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>escape_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cols</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>scale</name> <operator>&gt;=</operator> <name>SCALE_32BIT_THRESHOLD</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>ddl</name><operator>-&gt;</operator><name>bigcols</name></name></expr> </then><else>: <expr><name><name>ddl</name><operator>-&gt;</operator><name>smcols</name></name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"create%s table %s(%s%s)%s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>unlogged_tables</name></expr> ?</condition><then> <expr><literal type="string">" unlogged"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name><name>ddl</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>cols</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>use_primary_key</name></expr> ?</condition><then> <expr><name><name>ddl</name><operator>-&gt;</operator><name>pkey</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Fill the standard tables with some data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initGenerateData</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>k</name></decl>;</decl_stmt>

	<comment type="block">/* used to track elapsed time and estimate of the remaining time */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>start</name></decl>,
				<decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>elapsed_sec</name></decl>,
				<decl><type ref="prev"/><name>remaining_sec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>log_interval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generating data...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * truncate away any old data, in one command in case there are foreign
	 * keys
	 */</comment>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"truncate table "</literal>
					 <literal type="string">"ysql_bench_accounts, "</literal>
					 <literal type="string">"ysql_bench_branches, "</literal>
					 <literal type="string">"ysql_bench_history, "</literal>
					 <literal type="string">"ysql_bench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fill branches, tellers, accounts in that order in case foreign keys
	 * already exist
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbranches</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* "filler" column defaults to NULL */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"insert into ysql_bench_branches(bid,bbalance) values(%d,0)"</literal></expr></argument>,
				 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntellers</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* "filler" column defaults to NULL */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"insert into ysql_bench_tellers(tid,bid,tbalance) values (%d,%d,0)"</literal></expr></argument>,
				 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name> <operator>/</operator> <name>ntellers</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * we do all of this in one transaction to enable the backend's
	 * data-loading optimizations
	 */</comment>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * accounts is big enough to be worth using COPY and tracking runtime
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"copy ysql_bench_accounts from stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>j</name> <init>= <expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* "filler" column defaults to blank padded empty string */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><name>INT64_FORMAT</name> <literal type="string">"\t"</literal> <name>INT64_FORMAT</name> <literal type="string">"\t%d\t\n"</literal></expr></argument>,
				 <argument><expr><name>j</name></expr></argument>, <argument><expr><name>k</name> <operator>/</operator> <name>naccounts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQputline</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PQputline failed\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we want to stick with the original logging, print a message each
		 * 100k inserted rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>use_quiet</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">100000</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elapsed_sec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining_sec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>elapsed_sec</name> <operator>/</operator> <name>j</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>INT64_FORMAT</name> <literal type="string">" of "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples (%d%%) done (elapsed %.2f s, remaining %.2f s)\n"</literal></expr></argument>,
							<argument><expr><name>j</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>j</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>/</operator>
								   <operator>(</operator><name>naccounts</name> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>scale</name><operator>)</operator><operator>)</operator></expr></argument>,
							<argument><expr><name>elapsed_sec</name></expr></argument>, <argument><expr><name>remaining_sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* let's not call the timing for each row, but only each 100 rows */</comment>
		<if type="elseif">else if <condition>(<expr><name>use_quiet</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>%</operator> <literal type="number">100</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elapsed_sec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining_sec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>*</operator> <name>elapsed_sec</name> <operator>/</operator> <name>j</name></expr>;</expr_stmt>

			<comment type="block">/* have we reached the next interval (or end)? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>==</operator> <name>scale</name> <operator>*</operator> <name>naccounts</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>elapsed_sec</name> <operator>&gt;=</operator> <name>log_interval</name> <operator>*</operator> <name>LOG_STEP_SECONDS</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>INT64_FORMAT</name> <literal type="string">" of "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples (%d%%) done (elapsed %.2f s, remaining %.2f s)\n"</literal></expr></argument>,
								<argument><expr><name>j</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name>j</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>/</operator>
									   <operator>(</operator><name>naccounts</name> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>scale</name><operator>)</operator><operator>)</operator></expr></argument>,
								<argument><expr><name>elapsed_sec</name></expr></argument>, <argument><expr><name>remaining_sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* skip to the next interval */</comment>
				<expr_stmt><expr><name>log_interval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>elapsed_sec</name> <operator>/</operator> <name>LOG_STEP_SECONDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>%</operator> <name>batch_size</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>==</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We have submitted the batch. Commit the transaction. */</comment>
			 <if_stmt><if>if <condition>(<expr><call><name>PQputline</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"\\.\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"very last PQputline failed\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQendcopy</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PQendcopy failed\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"commit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>naccounts</name> <operator>*</operator> <name>scale</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We would need to begin a new transaction if we have more
				* records to be pushed to the database.
				*/</comment>
				<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"copy ysql_bench_accounts from stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke vacuum on the standard tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initVacuum</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vacuuming...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze ysql_bench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze ysql_bench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze ysql_bench_accounts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze ysql_bench_history"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create foreign key constraints between the standard tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initCreateFKeys</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>DDLKEYs</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"alter table ysql_bench_tellers add constraint ysql_bench_tellers_bid_fkey foreign key (bid) references ysql_bench_branches"</literal></expr>,
		<expr><literal type="string">"alter table ysql_bench_accounts add constraint ysql_bench_accounts_bid_fkey foreign key (bid) references ysql_bench_branches"</literal></expr>,
		<expr><literal type="string">"alter table ysql_bench_history add constraint ysql_bench_history_bid_fkey foreign key (bid) references ysql_bench_branches"</literal></expr>,
		<expr><literal type="string">"alter table ysql_bench_history add constraint ysql_bench_history_tid_fkey foreign key (tid) references ysql_bench_tellers"</literal></expr>,
		<expr><literal type="string">"alter table ysql_bench_history add constraint ysql_bench_history_aid_fkey foreign key (aid) references ysql_bench_accounts"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating foreign keys...\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>DDLKEYs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>executeStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name><name>DDLKEYs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Validate an initialization-steps string
 *
 * (We could just leave it to runInitSteps() to fail if there are wrong
 * characters, but since initialization can take awhile, it seems friendlier
 * to check during option parsing.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkInitSteps</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initialize_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>initialize_steps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no initialization steps specified\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>step</name> <operator>=</operator> <name>initialize_steps</name></expr>;</init> <condition><expr><operator>*</operator><name>step</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>step</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"dtgvpf "</literal></expr></argument>, <argument><expr><operator>*</operator><name>step</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized initialization step \"%c\"\n"</literal>
							<literal type="string">"allowed steps are: \"d\", \"t\", \"g\", \"v\", \"p\", \"f\"\n"</literal></expr></argument>,
							<argument><expr><operator>*</operator><name>step</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke each initialization step in the given string
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>runInitSteps</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initialize_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>use_primary_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>step</name> <operator>=</operator> <name>initialize_steps</name></expr>;</init> <condition><expr><operator>*</operator><name>step</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>step</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><name>use_primary_key</name> <operator>|=</operator> <operator>(</operator><operator>*</operator><name>step</name> <operator>==</operator> <literal type="char">'p'</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
	<for>for <control>(<init><expr><name>step</name> <operator>=</operator> <name>initialize_steps</name></expr>;</init> <condition><expr><operator>*</operator><name>step</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>step</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>step</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><call><name>initDropTables</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<expr_stmt><expr><call><name>initCreateTables</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>use_primary_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'g'</literal></expr>:</case>
				<expr_stmt><expr><call><name>initGenerateData</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><call><name>initVacuum</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
          <comment type="line">// handled via 'use_primary_key' in conjunction with 't'</comment>
          <break>break;</break>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><call><name>initCreateFKeys</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">' '</literal></expr>:</case>
				<break>break;</break>			<comment type="block">/* ignore */</comment>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized initialization step \"%c\"\n"</literal></expr></argument>,
								<argument><expr><operator>*</operator><name>step</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"done.\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replace :param with $n throughout the command's SQL text, which
 * is a modifiable string in cmd-&gt;argv[0].
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parseQuery</name><parameter_list>(<parameter><decl><type><name>Command</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/* We don't want to scribble on cmd-&gt;argv[0] until done */</comment>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>var</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>eaten</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>parseVariable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eaten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <name>MAX_ARGS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement has too many arguments (maximum is %d): %s\n"</literal></expr></argument>,
							<argument><expr><name>MAX_ARGS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>replaceVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>eaten</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name></expr>]</index></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Simple error-printing function, might be needed by lexer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgbench_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop in case we have to retry after enlarging the buffer. */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>appendPQExpBufferVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syntax error while parsing a script (in practice, while parsing a
 * backslash command, because we don't detect syntax errors in SQL)
 *
 * source: source of script (filename or builtin-script ID)
 * lineno: line number within script (count from 1)
 * line: whole line of backslash command, if available
 * command: backslash command name, if available
 * msg: the actual error message
 * more: optional extra message
 * column: zero-based column number, or -1 if unknown
 */</comment>
<function><type><name>void</name></type>
<name>syntax_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>more</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: %s"</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>more</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>column</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">" at column %d"</literal></expr></argument>, <argument><expr><name>column</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">" in command \"%s\""</literal></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>column</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>column</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"^ error found here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a SQL command; return a Command struct, or NULL if it's a comment
 *
 * On entry, psqlscan.l has collected the command into "buf", so we don't
 * really need to do much here except check for comment and set up a
 * Command struct.
 */</comment>
<function><type><specifier>static</specifier> <name>Command</name> <modifier>*</modifier></type>
<name>process_sql_command</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>my_command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nlpos</name></decl>;</decl_stmt>

	<comment type="block">/* Skip any leading whitespace, as well as "--" style comments */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If there's nothing but whitespace and comments, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate and initialize Command structure */</comment>
	<expr_stmt><expr><name>my_command</name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>command_num</name></name> <operator>=</operator> <name>num_commands</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SQL_COMMAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>=</operator> <name>META_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Install query text as the sole argv string.  If we are using a
	 * non-simple query mode, we'll extract parameters from it later.
	 */</comment>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If SQL command is multi-line, we only want to save the first line as
	 * the "line" label.
	 */</comment>
	<expr_stmt><expr><name>nlpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nlpos</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nlpos</name> <operator>-</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nlpos</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name><index>[<expr><name>nlpos</name> <operator>-</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>my_command</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a backslash command; return a Command struct, or NULL if comment
 *
 * At call, we have scanned only the initial backslash.
 */</comment>
<function><type><specifier>static</specifier> <name>Command</name> <modifier>*</modifier></type>
<name>process_backslash_command</name><parameter_list>(<parameter><decl><type><name>PsqlScanState</name></type> <name>sstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>my_command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>word_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>word_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>offsets</name><index>[<expr><name>MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* offsets of argument words */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember location of the backslash */</comment>
	<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>expr_scanner_get_lineno</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect first word of command */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate and initialize Command structure */</comment>
	<expr_stmt><expr><name>my_command</name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>command_num</name></name> <operator>=</operator> <name>num_commands</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>META_COMMAND</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_command</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save first word (command name) */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* ... and convert it to enum form */</comment>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>=</operator> <call><name>getMetaCommand</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SET</name> <operator>||</operator>
		<name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_IF</name> <operator>||</operator>
		<name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELIF</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>yyscan_t</name></type>	<name>yyscanner</name></decl>;</decl_stmt>

		<comment type="block">/* For \set, collect var name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SET</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							 <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* then for all parse the expression */</comment>
		<expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <call><name>expr_scanner_init</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>,
									  <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>expr_yyparse</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* dead code: exit done from syntax_error called by yyerror */</comment>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr_parse_result</name></expr>;</expr_stmt>

		<comment type="block">/* Save line, trimming any trailing newline */</comment>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>expr_scanner_get_substring</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>,
													  <argument><expr><name>start_offset</name></expr></argument>,
													  <argument><expr><call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>expr_scanner_finish</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>my_command</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* For all other commands, collect remaining words. */</comment>
	<while>while <condition>(<expr><call><name>expr_lex_one_word</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_offset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>word_offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>word_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Save line, trimming any trailing newline */</comment>
	<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>expr_scanner_get_substring</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>,
												  <argument><expr><name>start_offset</name></expr></argument>,
												  <argument><expr><call><name>expr_scanner_offset</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SLEEP</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Split argument into number and unit to allow "sleep 1ms" etc. We
		 * don't have to terminate the number argument with null because it
		 * will be parsed with atoi, which ignores trailing non-digit
		 * characters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"us"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							 <argument><expr><literal type="string">"unrecognized time unit, must be us, ms or s"</literal></expr></argument>,
							 <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SETSHELL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"missing argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_SHELL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"missing command"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ELSE</name> <operator>||</operator> <name><name>my_command</name><operator>-&gt;</operator><name>meta</name></name> <operator>==</operator> <name>META_ENDIF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>my_command</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><literal type="string">"unexpected argument"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* my_command-&gt;meta == META_NONE */</comment>
		<expr_stmt><expr><call><name>syntax_error</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name><name>my_command</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					 <argument><expr><literal type="string">"invalid command"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>word_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>my_command</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConditionError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cmdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"condition error in script \"%s\" command %d: %s\n"</literal></expr></argument>,
					<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>cmdn</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Partial evaluation of conditionals before recording and running the script.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckConditional</name><parameter_list>(<parameter><decl><type><name>ParsedScript</name></type> <name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* statically check conditional structure */</comment>
	<decl_stmt><decl><type><name>ConditionalStack</name></type> <name>cs</name> <init>= <expr><call><name>conditional_stack_create</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>META_COMMAND</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>meta</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>META_IF</name></expr>:</case>
					<expr_stmt><expr><call><name>conditional_stack_push</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>IFSTATE_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>META_ELIF</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\elif without matching \\if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IFSTATE_ELSE_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\elif after \\else"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>META_ELSE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\else without matching \\if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>conditional_stack_peek</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IFSTATE_ELSE_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\else after \\else"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>conditional_stack_poke</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>IFSTATE_ELSE_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>META_ENDIF</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conditional_stack_pop</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\endif without matching \\if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* ignore anything else... */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>conditional_stack_empty</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ConditionError</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\\if without matching \\endif"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>conditional_stack_destroy</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a script (either the contents of a file, or a built-in script)
 * and add it to the list of scripts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseScript</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>script</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParsedScript</name></type> <name>ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PsqlScanState</name></type> <name>sstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>line_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>alloc_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMANDS_ALLOC_NUM</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
	<expr_stmt><expr><name>alloc_num</name> <operator>=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize all fields of ps */</comment>
	<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><operator>.</operator><name>stats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to parse script */</comment>
	<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>psql_scan_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgbench_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ideally, we'd scan scripts using the encoding and stdstrings settings
	 * we get from a DB connection.  However, without major rearrangement of
	 * pgbench's argument parsing, we can't have a DB connection at the time
	 * we parse scripts.  Using SQL_ASCII (encoding 0) should work well enough
	 * with any backend-safe encoding, though conceivably we could be fooled
	 * if a script file uses a client-only encoding.  We also assume that
	 * stdstrings should be true, which is a bit riskier.
	 */</comment>
	<expr_stmt><expr><call><name>psql_scan_setup</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PsqlScanResult</name></type> <name>sr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>promptStatus_t</name></type> <name>prompt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Command</name>    <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sr</name> <operator>=</operator> <call><name>psql_scan</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we collected a SQL command, process that */</comment>
		<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>process_sql_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>alloc_num</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>alloc_num</name> <operator>+=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>commands</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we reached a backslash, process that */</comment>
		<if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>PSCAN_BACKSLASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>process_backslash_command</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>command</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>alloc_num</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>alloc_num</name> <operator>+=</operator> <name>COMMANDS_ALLOC_NUM</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name></name> <operator>=</operator> <operator>(</operator><name>Command</name> <operator>*</operator><operator>*</operator><operator>)</operator>
						<call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>commands</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Command</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>alloc_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Done if we reached EOF */</comment>
		<if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>PSCAN_INCOMPLETE</name> <operator>||</operator> <name>sr</name> <operator>==</operator> <name>PSCAN_EOL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>ps</name><operator>.</operator><name>commands</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>addScript</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>psql_scan_finish</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>psql_scan_destroy</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the entire contents of file fd, and return it in a malloc'd buffer.
 *
 * The buffer will typically be larger than necessary, but we don't care
 * in this program, because we'll free it as soon as we've parsed the script.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_file_contents</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>buflen</name> <init>= <expr><name>BUFSIZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>used</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>used</name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
		<comment type="block">/* If fread() read less than requested, must be EOF or error */</comment>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <name>BUFSIZ</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/* Enlarge buf so we can read some more */</comment>
		<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <name>BUFSIZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* There is surely room for a terminator */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>used</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a file name, read it and add its script to the list.
 * "-" means to read stdin.
 * NB: filename must be storage that won't disappear.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<comment type="block">/* Slurp the file contents into "buf" */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>read_file_contents</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %s\n"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ParseScript</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse the given builtin script and add it to the list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_builtin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type><name>bi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ParseScript</name><argument_list>(<argument><expr><name><name>bi</name><operator>-&gt;</operator><name>script</name></name></expr></argument>, <argument><expr><name><name>bi</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* show available builtin scripts */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>listAvailableScripts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"Available builtin scripts:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>builtin_script</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"\t%s\n"</literal></expr></argument>, <argument><expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return builtin script "name" if unambiguous, fails if not found */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type>
<name>findBuiltin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>BuiltinScript</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>builtin_script</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>builtin_script</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ok, unambiguous result */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* error cases */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no builtin script found for name \"%s\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>						<comment type="block">/* found &gt; 1 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ambiguous builtin name: %d builtin scripts found for prefix \"%s\"\n"</literal></expr></argument>,
						<argument><expr><name>found</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>listAvailableScripts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the weight specification from a script option (-b, -f), if any,
 * and return it as an integer (1 is returned if there's no weight).  The
 * script name is returned in *script as a malloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parseScriptWeight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>script</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sep</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>WSEP</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>namelen</name> <init>= <expr><name>sep</name> <operator>-</operator> <name>option</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>wtmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>badp</name></decl>;</decl_stmt>

		<comment type="block">/* generate the script name */</comment>
		<expr_stmt><expr><operator>*</operator><name>script</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>namelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>*</operator><name>script</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>script</name><operator>)</operator><index>[<expr><name>namelen</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* process digits of the weight spec */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>wtmp</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>badp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>badp</name> <operator>==</operator> <name>sep</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>badp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid weight specification: %s\n"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>wtmp</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>wtmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"weight specification out of range (0 .. %u): "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
							<argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>wtmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>weight</name> <operator>=</operator> <name>wtmp</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>script</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>weight</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* append a script to the list of scripts to process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addScript</name><parameter_list>(<parameter><decl><type><name>ParsedScript</name></type> <name>script</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>script</name><operator>.</operator><name>commands</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>script</name><operator>.</operator><name>commands</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty command list for script \"%s\"\n"</literal></expr></argument>,
						<argument><expr><name><name>script</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;=</operator> <name>MAX_SCRIPTS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at most %d SQL scripts are allowed\n"</literal></expr></argument>, <argument><expr><name>MAX_SCRIPTS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckConditional</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sql_script</name><index>[<expr><name>num_scripts</name></expr>]</index></name> <operator>=</operator> <name>script</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_scripts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printSimpleStats</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>latency</name> <init>= <expr><name><name>ss</name><operator>-&gt;</operator><name>sum</name></name> <operator>/</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>stddev</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>sum2</name></name> <operator>/</operator> <name><name>ss</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>latency</name> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s average = %.3f ms\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s stddev = %.3f ms\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name>stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* print out results */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printResults</name><parameter_list>(<parameter><decl><type><name>TState</name> <modifier>*</modifier></type><name>threads</name></decl></parameter>, <parameter><decl><type><name>StatsData</name> <modifier>*</modifier></type><name>total</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>total_time</name></decl></parameter>,
			 <parameter><decl><type><name>instr_time</name></type> <name>conn_total_time</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>latency_late</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>time_include</name></decl>,
				<decl><type ref="prev"/><name>tps_include</name></decl>,
				<decl><type ref="prev"/><name>tps_exclude</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>ntx</name> <init>= <expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>-</operator> <name><name>total</name><operator>-&gt;</operator><name>skipped</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>total_ntx</name> <init>= <expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>+</operator> <name><name>total</name><operator>-&gt;</operator><name>errors</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>totalCacheOverflows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>time_include</name> <operator>=</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tps is about actually executed transactions */</comment>
	<expr_stmt><expr><name>tps_include</name> <operator>=</operator> <name>ntx</name> <operator>/</operator> <name>time_include</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tps_exclude</name> <operator>=</operator> <name>ntx</name> <operator>/</operator>
		<operator>(</operator><name>time_include</name> <operator>-</operator> <operator>(</operator><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>nclients</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Report test parameters. */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"transaction type: %s\n"</literal></expr></argument>,
		   <argument><expr><ternary><condition><expr><name>num_scripts</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>sql_script</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>desc</name></expr> </then><else>: <expr><literal type="string">"multiple scripts"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"scaling factor: %d\n"</literal></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"query mode: %s\n"</literal></expr></argument>, <argument><expr><name><name>QUERYMODE</name><index>[<expr><name>querymode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of clients: %d\n"</literal></expr></argument>, <argument><expr><name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of threads: %d\n"</literal></expr></argument>, <argument><expr><name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"batch size: %d\n"</literal></expr></argument>, <argument><expr><name>batch_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions per client: %d\n"</literal></expr></argument>, <argument><expr><name>nxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions actually processed: "</literal> <name>INT64_FORMAT</name> <literal type="string">"/"</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
			   <argument><expr><name>ntx</name></expr></argument>, <argument><expr><name>total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"duration: %d s\n"</literal></expr></argument>, <argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions actually processed: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
			   <argument><expr><name>ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of errors: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
			   <argument><expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>/</operator> <name>total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of errors \"in failed SQL transaction\": "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
			   <argument><expr><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name></expr></argument>,
			   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>/</operator> <name>total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It can be non-zero only if max_tries is greater than one or
	 * latency_limit is used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of retried: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
			   <argument><expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name></expr></argument>, <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>/</operator> <name>total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of retries: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>total</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_tries</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"maximum number of tries: %d\n"</literal></expr></argument>, <argument><expr><name>max_tries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions above the %.1f ms latency limit: "</literal> <name>INT64_FORMAT</name> <literal type="string">"/"</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f %%)"</literal></expr></argument>,
			   <argument><expr><name>latency_limit</name> <operator>/</operator> <literal type="number">1000.0</literal></expr></argument>, <argument><expr><name>latency_late</name></expr></argument>, <argument><expr><name>total_ntx</name></expr></argument>,
			   <argument><expr><ternary><condition><expr><operator>(</operator><name>total_ntx</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">100.0</literal> <operator>*</operator> <name>latency_late</name> <operator>/</operator> <name>total_ntx</name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this statistics includes both successful and failed transactions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (including errors)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Report zipfian cache overflow */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>totalCacheOverflows</name> <operator>+=</operator> <name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>zipf_cache</name><operator>.</operator><name>overflowCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>totalCacheOverflows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"zipfian cache array overflowed %d time(s)\n"</literal></expr></argument>, <argument><expr><name>totalCacheOverflows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Remaining stats are nonsensical if we failed to execute any xacts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>cnt</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>&amp;&amp;</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"number of transactions skipped: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f %%)\n"</literal></expr></argument>,
			   <argument><expr><name><name>total</name><operator>-&gt;</operator><name>skipped</name></name></expr></argument>,
			   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>skipped</name></name> <operator>/</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>||</operator> <name>progress</name> <operator>||</operator> <name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printSimpleStats</name><argument_list>(<argument><expr><literal type="string">"latency"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>total</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no measurement, show average latency computed from run time */</comment>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"latency average = %.3f ms"</literal></expr></argument>,
			   <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>time_include</name> <operator>*</operator> <name>nclients</name> <operator>/</operator> <name>total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this statistics includes both successful and failed transactions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (including errors)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Report average transaction lag under rate limit throttling.  This
		 * is the delay between scheduled and actual start times for the
		 * transaction.  The measured lag may be caused by thread/client load,
		 * the database load, or the Poisson throttling process.
		 */</comment>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rate limit schedule lag: avg %.3f (max %.3f) ms\n"</literal></expr></argument>,
			   <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>sum</name></name> <operator>/</operator> <name><name>total</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>, <argument><expr><literal type="number">0.001</literal> <operator>*</operator> <name><name>total</name><operator>-&gt;</operator><name>lag</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"tps = %f (including connections establishing)\n"</literal></expr></argument>, <argument><expr><name>tps_include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"tps = %f (excluding connections establishing)\n"</literal></expr></argument>, <argument><expr><name>tps_exclude</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report per-script/command statistics */</comment>
	<if_stmt><if>if <condition>(<expr><name>per_script_stats</name> <operator>||</operator> <name>report_per_command</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>per_script_stats</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StatsData</name>  <modifier>*</modifier></type><name>sstats</name> <init>= <expr><operator>&amp;</operator><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stats</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int64</name></type>		<name>script_total_ntx</name> <init>= <expr><name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name> <operator>+</operator> <name><name>sstats</name><operator>-&gt;</operator><name>errors</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SQL script %d: %s\n"</literal>
					   <literal type="string">" - weight: %d (targets %.1f%% of total)\n"</literal>
					   <literal type="string">" - "</literal> <name>INT64_FORMAT</name> <literal type="string">" transactions (%.1f%% of total, tps = %f)\n"</literal></expr></argument>,
					   <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>,
					   <argument><expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr></argument>,
					   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>/</operator> <name>total_weight</name></expr></argument>,
					   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>,
					   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name> <operator>/</operator> <name>script_total_ntx</name></expr></argument>,
					   <argument><expr><operator>(</operator><name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name> <operator>-</operator> <name><name>sstats</name><operator>-&gt;</operator><name>skipped</name></name><operator>)</operator> <operator>/</operator> <name>time_include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of errors: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
						   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>,
						   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sstats</name><operator>-&gt;</operator><name>errors</name></name> <operator>/</operator> <name>script_total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of errors \"in failed SQL transaction\": "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
						   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><literal type="number">100.0</literal> <operator>*</operator> <name><name>sstats</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>/</operator>
							<name>script_total_ntx</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * It can be non-zero only if max_tries is greater than one or
				 * latency_limit is used.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of retried: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
						   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>retried</name></name></expr></argument>,
						   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sstats</name><operator>-&gt;</operator><name>retried</name></name> <operator>/</operator> <name>script_total_ntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of retries: "</literal> <name>INT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
						   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>throttle_delay</name> <operator>&amp;&amp;</operator> <name>latency_limit</name> <operator>&amp;&amp;</operator> <name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - number of transactions skipped: "</literal> <name>INT64_FORMAT</name> <literal type="string">" (%.3f%%)\n"</literal></expr></argument>,
						   <argument><expr><name><name>sstats</name><operator>-&gt;</operator><name>skipped</name></name></expr></argument>,
						   <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <name><name>sstats</name><operator>-&gt;</operator><name>skipped</name></name> <operator>/</operator> <name><name>sstats</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>printSimpleStats</name><argument_list>(<argument><expr><literal type="string">" - latency"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sstats</name><operator>-&gt;</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Report per-command latencies and errors */</comment>
			<if_stmt><if>if <condition>(<expr><name>report_per_command</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>per_script_stats</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - statement latencies in milliseconds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"statement latencies in milliseconds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s errors"</literal></expr></argument>,
						   <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
							<expr><literal type="string">" and"</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s errors \"in failed SQL transaction\""</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">" and"</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" and retries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">":\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>commands</name> <operator>=</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commands</name></expr>;</init>
					 <condition><expr><operator>*</operator><name>commands</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
					 <incr><expr><name>commands</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SimpleStats</name> <modifier>*</modifier></type><name>cstats</name> <init>= <expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>stats</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"   %11.3f"</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><operator>(</operator><name><name>cstats</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
						   <expr><literal type="number">1000.0</literal> <operator>*</operator> <name><name>cstats</name><operator>-&gt;</operator><name>sum</name></name> <operator>/</operator> <name><name>cstats</name><operator>-&gt;</operator><name>count</name></name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"d"</literal></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>errors_in_failed_tx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"d"</literal></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>errors_in_failed_tx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>total</name><operator>-&gt;</operator><name>retried</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"d"</literal></expr></argument>,
							   <argument><expr><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s\n"</literal></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>commands</name><operator>)</operator><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up a random seed according to seed parameter (NULL means default),
 * and initialize base_random_sequence for use in initializing other sequences.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>set_random_seed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>iseed</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>seed</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="string">"time"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* rely on current time */</comment>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>now</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iseed</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="string">"rand"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use some "strong" random source */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRONG_RANDOM</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_strong_random</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iseed</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iseed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot seed random from a strong source, none available: use \"time\" or an unsigned integer value.\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* parse seed unsigned int value */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name>garbage</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name> <literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>garbage</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
                                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized random seed option \"%s\": expecting an unsigned integer, \"time\" or \"rand\"\n"</literal></expr></argument>,
                                                        <argument><expr><name>seed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>seed</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setting random seed to "</literal> <name>UINT64_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>iseed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>random_seed</name> <operator>=</operator> <name>iseed</name></expr>;</expr_stmt>

	<comment type="block">/* Fill base_random_sequence with low-order bits of seed */</comment>
	<expr_stmt><expr><name><name>base_random_sequence</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>iseed</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>base_random_sequence</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iseed</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>base_random_sequence</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>iseed</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the random state of the client/thread.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initRandomState</name><parameter_list>(<parameter><decl><type><name>RandomState</name> <modifier>*</modifier></type><name>random_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator>
                <operator>(</operator><call><name>pg_jrand48</name><argument_list>(<argument><expr><name>base_random_sequence</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator><operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator>
                <operator>(</operator><call><name>pg_jrand48</name><argument_list>(<argument><expr><name>base_random_sequence</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>random_state</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator>
                <operator>(</operator><call><name>pg_jrand48</name><argument_list>(<argument><expr><name>base_random_sequence</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<comment type="block">/* systematic long/short named options */</comment>
		<expr><block>{<expr><literal type="string">"builtin"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"client"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"connect"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"define"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"fillfactor"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"initialize"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'i'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"init-steps"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'I'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"jobs"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"latency-limit"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'L'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-vacuum"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"progress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"protocol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'M'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quiet"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'q'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"report-per-command"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"scale"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"select-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"skip-some-updates"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"time"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"transactions"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"vacuum-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<comment type="block">/* long-named only options */</comment>
		<expr><block>{<expr><literal type="string">"unlogged-tables"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"tablespace"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"index-tablespace"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"sampling-rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"aggregate-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"progress-timestamp"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"log-prefix"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"foreign-keys"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"random-seed"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"max-tries"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"batch-size"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_init_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* initialize mode? */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initialize_steps</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foreign_keys</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_no_vacuum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>do_vacuum_accounts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* vacuum accounts table? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scale_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>benchmarking_option_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>initialization_option_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>internal_script_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CState</name>	   <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>			<comment type="block">/* status of clients */</comment>
	<decl_stmt><decl><type><name>TState</name>	   <modifier>*</modifier></type><name>threads</name></decl>;</decl_stmt>		<comment type="block">/* array of thread */</comment>

	<decl_stmt><decl><type><name>instr_time</name></type>	<name>start_time</name></decl>;</decl_stmt>		<comment type="block">/* start up time */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>total_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>conn_total_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>latency_late</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatsData</name></type>	<name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nclients_dealt</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"ysql_bench (YSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* stderr is buffered on Win32. */</comment>
	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pghost</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgport</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>login</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>CState</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set random seed early, because it may be used while parsing scripts. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_random_seed</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGBENCH_RANDOM_SEED"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while setting random seed from PGBENCH_RANDOM_SEED environment variable\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"iI:h:nvp:d:qb:SNc:j:Crs:t:T:U:lf:D:F:M:P:R:L:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>script</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><name>is_init_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'I'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>initialize_steps</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>initialize_steps</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>checkInitSteps</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name>pghost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>is_no_vacuum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>do_vacuum_accounts</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name>pgport</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<block>{<block_content>
					<for>for <control>(<init><expr><name>debug_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
						 <condition><expr><name>debug_level</name> <operator>&lt;</operator> <name>NUM_DEBUGLEVEL</name></expr>;</condition>
						 <incr><expr><name>debug_level</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>DEBUGLEVEL</name><index>[<expr><name>debug_level</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></for>
					<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;=</operator> <name>NUM_DEBUGLEVEL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid debug level (-d): \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nclients</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nclients</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nclients</name> <operator>&gt;</operator> <name>MAXCLIENTS</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of clients: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETRLIMIT</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RLIMIT_NOFILE</name></cpp:ifdef>			<comment type="block">/* most platforms use RLIMIT_NOFILE */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* but BSD doesn't ... */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_OFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* RLIMIT_NOFILE */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"getrlimit failed: %s\n"</literal></expr></argument>,
									<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <name>nclients</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"need at least %d open files, but system limit is %ld\n"</literal>
									<literal type="string">"Reduce number of clients, or use limit/ulimit to increase the system limit.\n"</literal></expr></argument>,
									<argument><expr><name>nclients</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_GETRLIMIT */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'j'</literal></expr>:</case>			<comment type="block">/* jobs */</comment>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nthreads</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of threads: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifndef>
				<if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"threads are not supported on this platform; use -j1\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !ENABLE_THREAD_SAFETY */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>is_connect</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>report_per_command</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><name>scale_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid scaling factor: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nxacts</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of transactions: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid duration: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name>login</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>use_log</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>use_quiet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>listAvailableScripts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>parseScriptWeight</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><literal type="string">"select-only"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><literal type="string">"simple-update"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>parseScriptWeight</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>process_file</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid variable definition: \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>putVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"option"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fillfactor</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>set_fillfactor</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>fillfactor</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">10</literal> <operator>||</operator> <name>fillfactor</name></expr></argument> &gt;</argument_list></name> <literal type="number">100</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid fillfactor: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'M'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>querymode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>querymode</name> <operator>&lt;</operator> <name>NUM_QUERYMODE</name></expr>;</condition> <incr><expr><name>querymode</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>QUERYMODE</name><index>[<expr><name>querymode</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
				<if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>&gt;=</operator> <name>NUM_QUERYMODE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid query mode (-M): \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>progress</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid thread progress delay: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* get a double from the beginning of option value */</comment>
					<decl_stmt><decl><type><name>double</name></type>		<name>throttle_value</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>throttle_value</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid rate limit: \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* Invert rate limit into a time offset */</comment>
					<expr_stmt><expr><name>throttle_delay</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><literal type="number">1000000.0</literal> <operator>/</operator> <name>throttle_value</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>limit_ms</name> <init>= <expr><call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>limit_ms</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid latency limit: \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>latency_limit</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name>limit_ms</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>				<comment type="block">/* unlogged-tables */</comment>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>unlogged_tables</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>				<comment type="block">/* tablespace */</comment>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>				<comment type="block">/* index-tablespace */</comment>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>index_tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>				<comment type="block">/* sampling-rate */</comment>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>sample_rate</name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&lt;=</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>sample_rate</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid sampling rate: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr>:</case>				<comment type="block">/* aggregate-interval */</comment>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>agg_interval</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of seconds for aggregation: \"%s\"\n"</literal></expr></argument>,
									<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr>:</case>				<comment type="block">/* progress-timestamp */</comment>
				<expr_stmt><expr><name>progress_timestamp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">7</literal></expr>:</case>				<comment type="block">/* log-prefix */</comment>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>logfile_prefix</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">8</literal></expr>:</case>				<comment type="block">/* foreign-keys */</comment>
				<expr_stmt><expr><name>initialization_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>foreign_keys</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">9</literal></expr>:</case>				<comment type="block">/* random-seed */</comment>
				<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_random_seed</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while setting random seed from --random-seed option\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">10</literal></expr>:</case>			<comment type="block">/* max-tries */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int32</name></type>		<name>max_tries_arg</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>max_tries_arg</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of maximum tries: \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>max_tries</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>max_tries_arg</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="number">11</literal></expr>:</case>			<comment type="block">/* batch-size */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int32</name></type>		<name>batch_size_arg</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>batch_size_arg</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid number of batch_size: \"%s\"\n"</literal></expr></argument>,
										<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>batch_size</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>batch_size_arg</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/* set default script if none */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_init_mode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>process_builtin</name><argument_list>(<argument><expr><call><name>findBuiltin</name><argument_list>(<argument><expr><literal type="string">"tpcb-like"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>benchmarking_option_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>internal_script_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if not simple query mode, parse the script(s) to find parameters */</comment>
	<if_stmt><if>if <condition>(<expr><name>querymode</name> <operator>!=</operator> <name>QUERY_SIMPLE</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Command</name>   <modifier>*</modifier><modifier>*</modifier></type><name>commands</name> <init>= <expr><name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>commands</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>type</name> <operator>!=</operator> <name>SQL_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseQuery</name><argument_list>(<argument><expr><name><name>commands</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* compute total_weight */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_scripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<comment type="block">/* cannot overflow: weight is 32b, total_weight 64b */</comment>
		<expr_stmt><expr><name>total_weight</name> <operator>+=</operator> <name><name>sql_script</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>total_weight</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_init_mode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"total script weight must not be zero\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* show per script stats if several scripts are used */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_scripts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>per_script_stats</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't need more threads than there are clients.  (This is not merely an
	 * optimization; throttle_delay is calculated incorrectly below if some
	 * threads have no clients assigned to them.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nthreads</name> <operator>&gt;</operator> <name>nclients</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nthreads</name> <operator>=</operator> <name>nclients</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* compute a per thread delay */</comment>
	<expr_stmt><expr><name>throttle_delay</name> <operator>*=</operator> <name>nthreads</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <name>optind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbName</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>env</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dbName</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>login</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>login</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dbName</name> <operator>=</operator> <name>login</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dbName</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_init_mode</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>benchmarking_option_set</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"some of the specified options cannot be used in initialization (-i) mode\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>initialize_steps</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initialize_steps</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>DEFAULT_INIT_STEPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_no_vacuum</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remove any vacuum step in initialize_steps */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>foreign_keys</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add 'f' to end of initialize_steps, if not already there */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>initialize_steps</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
					<call><name>pg_realloc</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>,
							   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>runInitSteps</name><argument_list>(<argument><expr><name>initialize_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>initialization_option_set</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"some of the specified options cannot be used in benchmarking mode\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specify either a number of transactions (-t) or a duration (-T), not both\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use DEFAULT_NXACTS if neither nxacts nor duration is specified. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nxacts</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nxacts</name> <operator>=</operator> <name>DEFAULT_NXACTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* --sampling-rate may be used only with -l */</comment>
	<if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_log</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log sampling (--sampling-rate) is allowed only when logging transactions (-l)\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* --sampling-rate may not be used with --aggregate-interval */</comment>
	<if_stmt><if>if <condition>(<expr><name>sample_rate</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log sampling (--sampling-rate) and aggregation (--aggregate-interval) cannot be used at the same time\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_log</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log aggregation is allowed only when actually logging transactions\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_log</name> <operator>&amp;&amp;</operator> <name>logfile_prefix</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log file prefix (--log-prefix) is allowed only when logging transactions (-l)\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <name>duration</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of seconds for aggregation (%d) must not be higher than test duration (%d)\n"</literal></expr></argument>,
						<argument><expr><name>agg_interval</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>duration</name> <operator>%</operator> <name>agg_interval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration (%d) must be a multiple of aggregation interval (%d)\n"</literal></expr></argument>,
						<argument><expr><name>duration</name></expr></argument>, <argument><expr><name>agg_interval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>progress_timestamp</name> <operator>&amp;&amp;</operator> <name>progress</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--progress-timestamp is allowed only under --progress\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If necessary set the default tries limit  */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_tries</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_tries</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * save main process id in the global variable because process id will be
	 * changed after fork.
	 */</comment>
	<expr_stmt><expr><name>main_pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nclients</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>CState</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nclients</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy any -D switch values to all clients */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>variables</name><operator>.</operator><name>nvariables</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Variable</name>   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>variables</name><operator>.</operator><name>array</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>PGBT_NO_VALUE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>putVariableValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>putVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								<argument><expr><name><name>var</name><operator>-&gt;</operator><name>svalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* other CState initializations */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cstack</name> <operator>=</operator> <call><name>conditional_stack_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initRandomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>random_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pghost: %s pgport: %s nclients: %d nxacts: %d dbName: %s\n"</literal></expr></argument>,
						<argument><expr><name>pghost</name></expr></argument>, <argument><expr><name>pgport</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>, <argument><expr><name>nxacts</name></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_DEBUG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pghost: %s pgport: %s nclients: %d duration: %d dbName: %s\n"</literal></expr></argument>,
						<argument><expr><name>pghost</name></expr></argument>, <argument><expr><name>pgport</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>dbName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* opening connection... */</comment>
	<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>con</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to database \"%s\" failed\n%s"</literal></expr></argument>,
						<argument><expr><name>dbName</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>internal_script_used</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * get the scaling factor that should be same as count(*) from
		 * ysql_bench_branches if this is not a custom query
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"select count(*) from ysql_bench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlState</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>errmsg_buf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sqlState</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>,
								  <argument><expr><literal type="string">"Perhaps you need to do initialization (\"ysql_bench -i\") in database \"%s\"\n"</literal></expr></argument>,
								  <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errmsg_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errmsg_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid count(*) from ysql_bench_branches: \"%s\"\n"</literal></expr></argument>,
							<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* warn if we override user-given -s switch */</comment>
		<if_stmt><if>if <condition>(<expr><name>scale_given</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"scale option ignored, using count from ysql_bench_branches table (%d)\n"</literal></expr></argument>,
							<argument><expr><name>scale</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * :scale variables normally get -s or database scale, but don't override
	 * an explicit -D switch
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"scale"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"scale"</literal></expr></argument>, <argument><expr><name>scale</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Define a :client_id variable that is unique per connection. But don't
	 * override an explicit -D switch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"client_id"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"client_id"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set default seed for hash functions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"default_seed"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>seed</name> <init>=
		<expr><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>pg_jrand48</name><argument_list>(<argument><expr><name>base_random_sequence</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator> <operator>|</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>pg_jrand48</name><argument_list>(<argument><expr><name>base_random_sequence</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"default_seed"</literal></expr></argument>,
						   <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>seed</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set random seed unless overwritten */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lookupVariable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"random_seed"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nclients</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>putVariableInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>variables</name></expr></argument>, <argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><literal type="string">"random_seed"</literal></expr></argument>,
						   <argument><expr><name>random_seed</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_vacuum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting vacuum..."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum ysql_bench_branches"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum ysql_bench_tellers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"truncate ysql_bench_history"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end.\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>do_vacuum_accounts</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"starting vacuum ysql_bench_accounts..."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>tryExecuteStatement</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><literal type="string">"vacuum analyze ysql_bench_accounts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end.\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up thread data structures */</comment>
	<expr_stmt><expr><name>threads</name> <operator>=</operator> <operator>(</operator><name>TState</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nclients_dealt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TState</name>	   <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><index>[<expr><name>nclients_dealt</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name> <operator>=</operator>
			<operator>(</operator><name>nclients</name> <operator>-</operator> <name>nclients_dealt</name> <operator>+</operator> <name>nthreads</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>nthreads</name> <operator>-</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initRandomState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>random_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled in later */</comment>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>zipf_cache</name><operator>.</operator><name>nb_cells</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>zipf_cache</name><operator>.</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>zipf_cache</name><operator>.</operator><name>overflowCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nclients_dealt</name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* all clients must be assigned to a thread */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nclients_dealt</name> <operator>==</operator> <name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get start up time */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set alarm if duration is specified. */</comment>
	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setalarm</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* start threads */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TState</name>	   <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* compute when to stop */</comment>
		<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
				<operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000000</literal> <operator>*</operator> <name>duration</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* the first thread (i = 0) is executed by main thread */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>threadRun</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>thread</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <name>INVALID_THREAD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create thread: %s\n"</literal></expr></argument>,
								<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name> <operator>=</operator> <name>INVALID_THREAD</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* compute when to stop */</comment>
	<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_time</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>start_time</name></expr></argument>)</argument_list></call> <operator>+</operator>
			<operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000000</literal> <operator>*</operator> <name>duration</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>threads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>thread</name> <operator>=</operator> <name>INVALID_THREAD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

	<comment type="block">/* wait for threads and accumulate results */</comment>
	<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TState</name>	   <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread</name> <operator>==</operator> <name>INVALID_THREAD</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* actually run this thread directly in the main thread */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>threadRun</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* wait of other threads. should check that 0 is returned? */</comment>
			<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>threadRun</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>

		<comment type="block">/* aggregate thread level stats */</comment>
		<expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>cnt</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>cnt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>skipped</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>skipped</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>retries</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>retries</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>retried</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>retried</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>errors</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>errors</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>errors_in_failed_tx</name></name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>errors_in_failed_tx</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>latency_late</name> <operator>+=</operator> <name><name>thread</name><operator>-&gt;</operator><name>latency_late</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>conn_total_time</name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>disconnect_all</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nclients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX We compute results as though every client of every thread started
	 * and finished at the same time.  That model can diverge noticeably from
	 * reality for a short benchmark run involving relatively many threads.
	 * The first thread may process notably many transactions before the last
	 * thread begins.  Improving the model alone would bring limited benefit,
	 * because performance during those periods of partial thread count can
	 * easily exceed steady state performance.  This is one of the many ways
	 * short runs convey deceptive performance figures.
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printResults</name><argument_list>(<argument><expr><name>threads</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><name>total_time</name></expr></argument>, <argument><expr><name>conn_total_time</name></expr></argument>, <argument><expr><name>latency_late</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>threadRun</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TState</name>	   <modifier>*</modifier></type><name>thread</name> <init>= <expr><operator>(</operator><name>TState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CState</name>	   <modifier>*</modifier></type><name>state</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>start</name></decl>,
				<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nstate</name> <init>= <expr><name><name>thread</name><operator>-&gt;</operator><name>nstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remains</name> <init>= <expr><name>nstate</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* number of remaining clients */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* for reporting progress: */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>thread_start</name> <init>= <expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>last_report</name> <init>= <expr><name>thread_start</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>next_report</name> <init>= <expr><name>last_report</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>progress</name> <operator>*</operator> <literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatsData</name></type>	<name>last</name></decl>,
				<decl><type ref="prev"/><name>aggs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize throttling rate target for all of the thread's clients.  It
	 * might be a little more accurate to reset thread-&gt;start_time here too.
	 * The possible drift seems too small relative to typical throttle delay
	 * times to worry about it.
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>throttle_trigger</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last</name> <operator>=</operator> <name>aggs</name></expr>;</expr_stmt>

	<comment type="block">/* open log file if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_log</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>logpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><ternary><condition><expr><name>logfile_prefix</name></expr> ?</condition><then> <expr><name>logfile_prefix</name></expr> </then><else>: <expr><literal type="string">"ysql_bench_log"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>main_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%d.%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>main_pid</name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>logpath</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open logfile \"%s\": %s\n"</literal></expr></argument>,
							<argument><expr><name>logpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_connect</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make connections to the database */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>con</name> <operator>=</operator> <call><name>doConnect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* time after thread and connections set up */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* explicitly initialize the state machines */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>CSTATE_CHOOSE_SCRIPT</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* loop till all clients have terminated */</comment>
	<while>while <condition>(<expr><name>remains</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>fd_set</name></type>		<name>input_mask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>maxsock</name></decl>;</decl_stmt>	<comment type="block">/* max socket number to be waited for */</comment>
		<decl_stmt><decl><type><name>int64</name></type>		<name>min_usec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>now_usec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* set this only if needed */</comment>

		<comment type="block">/* identify which client sockets should be checked for input */</comment>
		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>PG_INT64_MAX</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CState</name>	   <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_THROTTLE</name> <operator>&amp;&amp;</operator> <name>timer_exceeded</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* interrupt client that has not started a transaction */</comment>
				<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>CSTATE_FINISHED</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finishCon</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>remains</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_SLEEP</name> <operator>||</operator> <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_THROTTLE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* a nap from the script, or under throttling */</comment>
				<decl_stmt><decl><type><name>int64</name></type>		<name>this_usec</name></decl>;</decl_stmt>

				<comment type="block">/* get current time if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>instr_time</name></type>	<name>now</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>now_usec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* min_usec should be the minimum delay across all clients */</comment>
				<expr_stmt><expr><name>this_usec</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_SLEEP</name></expr> ?</condition><then>
							 <expr><name><name>st</name><operator>-&gt;</operator><name>sleep_until</name></name></expr> </then><else>: <expr><name><name>st</name><operator>-&gt;</operator><name>txn_scheduled</name></name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>now_usec</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>&gt;</operator> <name>this_usec</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>this_usec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_WAIT_RESULT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * waiting for result from server - nothing to do unless the
				 * socket is readable
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>,
									<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>done</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>&lt;</operator> <name>sock</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CSTATE_ABORTED</name> <operator>&amp;&amp;</operator>
					 <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>CSTATE_FINISHED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This client thread is ready to do something, so we don't
				 * want to wait.  No need to examine additional clients.
				 */</comment>
				<expr_stmt><expr><name>min_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* also wake up to print the next progress report on time */</comment>
		<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>min_usec</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* get current time if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>instr_time</name></type>	<name>now</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>now_usec</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>now_usec</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>min_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>next_report</name> <operator>-</operator> <name>now_usec</name><operator>)</operator> <operator>&lt;</operator> <name>min_usec</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>min_usec</name> <operator>=</operator> <name>next_report</name> <operator>-</operator> <name>now_usec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If no clients are ready to execute actions, sleep until we receive
		 * data from the server, or a nap-time specified in the script ends,
		 * or it's time to print a progress report.  Update input_mask to show
		 * which client(s) received data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nsocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* return from select(2) if called */</comment>

			<if_stmt><if>if <condition>(<expr><name>min_usec</name> <operator>!=</operator> <name>PG_INT64_MAX</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>min_usec</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>min_usec</name> <operator>%</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>nsocks</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else			<comment type="block">/* nothing active, simple sleep */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>min_usec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else				<comment type="block">/* no explicit delay, select without timeout */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>nsocks</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>nsocks</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* On EINTR, go back to top of loop */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* must be something wrong */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select() failed: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>done</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* min_usec == 0, i.e. something needs to be executed */</comment>

			<comment type="block">/* If we didn't call select(), don't try to read any data */</comment>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* ok, advance the state machine of each connection */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CState</name>	   <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_WAIT_RESULT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* don't call doCustom unless data is available */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid socket: %s"</literal></expr></argument>,
									<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>done</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_FINISHED</name> <operator>||</operator>
					 <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_ABORTED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this client is done, no need to consider it anymore */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>doCustom</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If doCustom changed client to finished state, reduce remains */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_FINISHED</name> <operator>||</operator> <name><name>st</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CSTATE_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remains</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* progress report is made by thread 0 for all threads */</comment>
		<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name><name>thread</name><operator>-&gt;</operator><name>tid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>instr_time</name></type>	<name>now_time</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>now</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>now_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* generate and show report */</comment>
				<decl_stmt><decl><type><name>StatsData</name></type>	<name>cur</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int64</name></type>		<name>run</name> <init>= <expr><name>now</name> <operator>-</operator> <name>last_report</name></expr></init></decl>,
							<decl><type ref="prev"/><name>ntx</name></decl>,
							<decl><type ref="prev"/><name>retries</name></decl>,
							<decl><type ref="prev"/><name>retried</name></decl>,
							<decl><type ref="prev"/><name>errors</name></decl>,
							<decl><type ref="prev"/><name>errors_in_failed_tx</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>tps</name></decl>,
							<decl><type ref="prev"/><name>total_run</name></decl>,
							<decl><type ref="prev"/><name>latency</name></decl>,
							<decl><type ref="prev"/><name>sqlat</name></decl>,
							<decl><type ref="prev"/><name>lag</name></decl>,
							<decl><type ref="prev"/><name>stdev</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>tbuf</name><index>[<expr><literal type="number">315</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>progress_buf</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Add up the statistics of all threads.
				 *
				 * XXX: No locking. There is no guarantee that we get an
				 * atomic snapshot of the transaction count and latencies, so
				 * these figures can well be off by a small amount. The
				 * progress report's purpose is to give a quick overview of
				 * how the test is going, so that shouldn't matter too much.
				 * (If a read from a 64-bit integer is not atomic, you might
				 * get a "torn" read and completely bogus latencies though!)
				 */</comment>
				<expr_stmt><expr><call><name>initStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>.</operator><name>latency</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>mergeSimpleStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>.</operator><name>lag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>lag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>cnt</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>skipped</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>skipped</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>retries</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>retries</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>retried</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>retried</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>errors</name></name> <operator>+=</operator> <name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>errors</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cur</name><operator>.</operator><name>errors_in_failed_tx</name></name> <operator>+=</operator>
						<name><name>thread</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>stats</name><operator>.</operator><name>errors_in_failed_tx</name></name></expr>;</expr_stmt>
				</block_content>}</block></for>

				<comment type="block">/* we count only actually executed transactions */</comment>
				<expr_stmt><expr><name>ntx</name> <operator>=</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>cur</name><operator>.</operator><name>skipped</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>last</name><operator>.</operator><name>cnt</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>skipped</name></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>total_run</name> <operator>=</operator> <operator>(</operator><name>now</name> <operator>-</operator> <name>thread_start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>tps</name> <operator>=</operator> <literal type="number">1000000.0</literal> <operator>*</operator> <name>ntx</name> <operator>/</operator> <name>run</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ntx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>latency</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum</name></name><operator>)</operator> <operator>/</operator> <name>ntx</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>sqlat</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum2</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>latency</name><operator>.</operator><name>sum2</name></name><operator>)</operator> <operator>/</operator> <name>ntx</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>stdev</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>sqlat</name> <operator>-</operator> <literal type="number">1000000.0</literal> <operator>*</operator> <name>latency</name> <operator>*</operator> <name>latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>lag</name> <operator>=</operator> <literal type="number">0.001</literal> <operator>*</operator> <operator>(</operator><name><name>cur</name><operator>.</operator><name>lag</name><operator>.</operator><name>sum</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>lag</name><operator>.</operator><name>sum</name></name><operator>)</operator> <operator>/</operator> <name>ntx</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>latency</name> <operator>=</operator> <name>sqlat</name> <operator>=</operator> <name>stdev</name> <operator>=</operator> <name>lag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>retries</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>retries</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>retries</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>retried</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>retried</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>retried</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errors</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>errors</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>errors</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errors_in_failed_tx</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>errors_in_failed_tx</name></name> <operator>-</operator>
					<name><name>last</name><operator>.</operator><name>errors_in_failed_tx</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>progress_timestamp</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * On some platforms the current system timestamp is
					 * available in now_time, but rather than get entangled
					 * with that, we just eat the cost of an extra syscall in
					 * all cases.
					 */</comment>
					<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld.%03ld s"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* round seconds are expected, but the thread may be late */</comment>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.1f s"</literal></expr></argument>, <argument><expr><name>total_run</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>,
								  <argument><expr><literal type="string">"progress: %s, %.1f tps, lat %.3f ms stddev %.3f"</literal></expr></argument>,
								  <argument><expr><name>tbuf</name></expr></argument>, <argument><expr><name>tps</name></expr></argument>, <argument><expr><name>latency</name></expr></argument>, <argument><expr><name>stdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>errors</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>,
									  <argument><expr><literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">" failed"</literal></expr></argument> , <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>errors_in_failed_tx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>,
										  <argument><expr><literal type="string">" ("</literal> <name>INT64_FORMAT</name> <literal type="string">" in failed tx)"</literal></expr></argument>,
										  <argument><expr><name>errors_in_failed_tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>throttle_delay</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>, <argument><expr><literal type="string">", lag %.3f ms"</literal></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>latency_limit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>,
										  <argument><expr><literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">" skipped"</literal></expr></argument>,
										  <argument><expr><name><name>cur</name><operator>.</operator><name>skipped</name></name> <operator>-</operator> <name><name>last</name><operator>.</operator><name>skipped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * It can be non-zero only if max_tries is greater than one or
				 * latency_limit is used.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>retried</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>,
									  <argument><expr><literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">" retried, "</literal> <name>INT64_FORMAT</name> <literal type="string">" retries"</literal></expr></argument>,
									  <argument><expr><name>retried</name></expr></argument>, <argument><expr><name>retries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_LOG_MAIN</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>progress_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>progress_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>last</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>last_report</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Ensure that the next report is in the future, in case
				 * pgbench/postgres got stuck somewhere.
				 */</comment>
				<do>do
				<block>{<block_content>
					<expr_stmt><expr><name>next_report</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>progress</name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
				</block_content>}</block> while <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_report</name></expr>)</condition>;</do>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>disconnect_all</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>conn_time</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>agg_interval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* log aggregated but not yet reported transactions */</comment>
			<expr_stmt><expr><call><name>doLog</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>logfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>finishCon</name><parameter_list>(<parameter><decl><type><name>CState</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for duration option: set timer_exceeded after so many seconds.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sig_alarm</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>timer_exceeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>handle_sig_alarm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

<function><type><specifier>static</specifier> <name>VOID</name> <name>CALLBACK</name></type>
<name>win32_timer_callback</name><parameter_list>(<parameter><decl><type><name>PVOID</name></type> <name>lpParameter</name></decl></parameter>, <parameter><decl><type><name>BOOLEAN</name></type> <name>TimerOrWaitFired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>timer_exceeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setalarm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>timer</name></decl>;</decl_stmt>

	<comment type="block">/* This function will be called at most once, so we can cheat a bit. */</comment>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>CreateTimerQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>seconds</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal> <operator>||</operator>
		<operator>!</operator><call><name>CreateTimerQueueTimer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timer</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>,
							   <argument><expr><name>win32_timer_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>seconds</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>WT_EXECUTEINTIMERTHREAD</name> <operator>|</operator> <name>WT_EXECUTEONLYONCE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to set timer\n"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* partial pthread implementation for Windows */</comment>

<typedef>typedef <type><struct>struct <name>win32_pthread</name>
<block>{
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>handle</name></decl>;</decl_stmt>
	<function_decl><type><name>void</name>	   <modifier>*</modifier></type>(<modifier>*</modifier><name>routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>win32_pthread</name>;</typedef>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>__stdcall</name></type>
<name>win32_pthread_run</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>win32_pthread</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><operator>(</operator><name>win32_pthread</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name><name>th</name><operator>-&gt;</operator><name>routine</name></name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pthread_create</name><parameter_list>(<parameter><decl><type><name>pthread_t</name> <modifier>*</modifier></type><name>thread</name></decl></parameter>,
			   <parameter><decl><type><name>pthread_attr_t</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
			   <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>start_routine</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
			   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>win32_pthread</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>th</name> <operator>=</operator> <operator>(</operator><name>win32_pthread</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>win32_pthread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>routine</name></name> <operator>=</operator> <name>start_routine</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>win32_pthread_run</name></expr></argument>, <argument><expr><name>th</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>save_errno</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>thread</name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pthread_join</name><parameter_list>(<parameter><decl><type><name>pthread_t</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>thread_return</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>th</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>th</name><operator>-&gt;</operator><name>handle</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>WAIT_OBJECT_0</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>errno</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>thread_return</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>thread_return</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * errstartImpl --- begin an error-reporting cycle
 *
 * Initialize the error data and store the given parameters in it.
 * Subsequently, errmsg() and perhaps other routines will be called to further
 * populate the error data.  Finally, errfinish() will be called to actually
 * process the error report.  If multiple threads can use the same error data,
 * the error mutex is locked before the error data is initialized and will be
 * unlocked in the end of the errfinish() call.
 *
 * Returns true in normal case.  Returns false to short-circuit the error
 * report (if the debugging level does not resolve this error/logging level).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>errstartImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>ErrorLevel</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !(ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS) */</comment>
errstartImpl<parameter_list>(<parameter><decl><type><name>ErrorLevel</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>start_error_reporting</name></decl>;</decl_stmt>

	<comment type="block">/* Check if we have the appropriate debugging level */</comment>
	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ELEVEL_DEBUG</name></expr>:</case>
			<comment type="block">/*
			 * Print the message only if there's a debugging mode for all types
			 * of messages.
			 */</comment>
			<expr_stmt><expr><name>start_error_reporting</name> <operator>=</operator> <name>debug_level</name> <operator>&gt;=</operator> <name>DEBUG_ALL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ELEVEL_LOG_CLIENT_FAIL</name></expr>:</case>
			<comment type="block">/*
			 * Print a failure message only if there's at least a debugging mode
			 * for fails.
			 */</comment>
			<expr_stmt><expr><name>start_error_reporting</name> <operator>=</operator> <name>debug_level</name> <operator>&gt;=</operator> <name>DEBUG_FAILS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ELEVEL_LOG_CLIENT_ABORTED</name></expr>:</case>
		<case>case <expr><name>ELEVEL_LOG_MAIN</name></expr>:</case>
		<case>case <expr><name>ELEVEL_FATAL</name></expr>:</case>
			<comment type="block">/*
			 * Always print an error message if the client is aborted or this is
			 * the main program error/log message.
			 */</comment>
			<expr_stmt><expr><name>start_error_reporting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* internal error which should never occur */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ELEVEL_FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected error level: %d\n"</literal></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Initialize the error data */</comment>
	<if_stmt><if>if <condition>(<expr><name>start_error_reporting</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>error_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; !HAVE__VA_ARGS */</comment>

		<expr_stmt><expr><name><name>error</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>start_error_reporting</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errmsgImpl --- add a primary error message text to the current error
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>errmsgImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !(ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS) */</comment>
errmsgImpl<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Already failed. */</comment>
		<comment type="block">/* Return value does not matter. */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Loop in case we have to retry after enlarging the buffer. */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>appendPQExpBufferVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<comment type="block">/* Return value does not matter. */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errfinishImpl --- end an error-reporting cycle
 *
 * Print the appropriate error report to stderr.
 *
 * If elevel is ELEVEL_FATAL or worse, control does not return to the caller.
 * See ErrorLevel enumeration for the error level definitions.
 *
 * If the error message buffer is empty or broken, prints a corresponding error
 * message and exits the program.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>errfinishImpl</name><parameter_list>(<parameter><decl><type><name>Error</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !(ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS) */</comment>
errfinishImpl<parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; HAVE__VA_ARGS */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>error_during_reporting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorLevel</name></type>  <name>elevel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name><name>error</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Immediately print the message to stderr so as not to get an endless cycle
	 * of errors...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>error_during_reporting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>error</name><operator>-&gt;</operator><name>message</name><operator>.</operator><name>data</name></name><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* internal error which should never occur */</comment>
		<expr_stmt><expr><name>error_during_reporting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"empty error message cannot be reported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>error</name><operator>-&gt;</operator><name>message</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Release the error data and exit if needed */</comment>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>error</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__VA_ARGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>error_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; !HAVE__VA_ARGS */</comment>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>ELEVEL_FATAL</name> <operator>||</operator> <name>error_during_reporting</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
